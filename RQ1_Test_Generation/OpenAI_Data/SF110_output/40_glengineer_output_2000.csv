ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
b0937db6-83df-4d5e-bf1c-4564b876364b,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11508 tokens (9508 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {
"
e46b7972-f1d1-43b3-b6e7-fdb2493c8dc1,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11510 tokens (9510 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {
"
eba924be-8026-4258-b69e-78f55318e816,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11512 tokens (9512 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {
"
57fef879-3426-4e69-88eb-5fb383757cb1,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11512 tokens (9512 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {
"
fbd5a5fc-34b8-491f-b5d1-dedcad985110,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 11509 tokens (9509 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {
"
cmpl-6u4DnPxuHtyMTj9mVI6qRGZqnyHef,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgent_3Test.java,57.895418643951416,length,"// ComponentAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnComponent;
import glengineer.agents.settings.ComponentSettings;
import glengineer.agents.settings.Sizes;
import javax.swing.GroupLayout.Group;

/**
 * The agent representing a component.
 */
public class ComponentAgent extends Agent {

    private String componentName;

    public ComponentAgent(String componentName) {
        this.componentName = componentName;
        settings = new ComponentSettings();
    }

    public String getFirstName() {
        return componentName;
    }

    public String getLastName() {
        return componentName;
    }

    public boolean isComponent(String componentName) {
        return this.componentName.equals(componentName);
    }

    public boolean isGroup(String firstName, String lastName) {
        return false;
    }

    public boolean isGap() {
        return false;
    }

    public boolean equals(Agent agent) {
        return agent.isComponent(componentName);
    }

    private ComponentSettings getSettings() {
        return (ComponentSettings) settings;
    }

    /**
     * Returns this component agent if its name equals the specified one
     * or null if it is not the case.
     */
    public ComponentAgent findDependingComponentByName(String componentName) {
        if (isComponent(componentName))
            return this;
        else
            return null;
    }

    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {
        return null;
    }

    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {
        return null;
    }

    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {
        return null;
    }

    /**
     *     , 
     *     .
     *        
     *    {@code ComponentAdder}.
     * <p>
     *  -.
     *
     * @param targetGroup		,   
     * 							
     * @param creatorAndAdder	   
     * 							    
     */
    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {
        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());
    }

    /**
     * Returns a class implementing the interface {@code FunctionsOnComponent}
     * which allows the user to control the sizes of this component.
     */
    public FunctionsOnComponent getFunctionsOnComponentImplementation() {
        return new FunctionsOnComponent() {

            public void setSize(int size) {
                ComponentAgent.this.getSettings().sizes = new Sizes(size);
            }

            public void setSize(int min, int pref, int max) {
                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);
            }
        };
    }

    public String toString() {
        return ""component "" + componentName;
    }
}
","// ComponentAgent_3Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnComponent;
import glengineer.agents.settings.ComponentSettings;
import glengineer.agents.settings.Sizes;
import javax.swing.GroupLayout.Group;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentAgent}.
* It contains ten unit test cases for the {@link ComponentAgent#findDependingComponentByName(String)} method.
*/
class ComponentAgent_3Test {","// ComponentAgent_3Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnComponent;
import glengineer.agents.settings.ComponentSettings;
import glengineer.agents.settings.Sizes;
import javax.swing.GroupLayout.Group;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentAgent}.
* It contains ten unit test cases for the {@link ComponentAgent#findDependingComponentByName(String)} method.
*/
class ComponentAgent_3Test {

	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns the component agent itself
	 * if its name equals the specified one.
	 */
	@Test
	void testFindDependingComponentByName_1() {
		ComponentAgent componentAgent = new ComponentAgent(""component"");
		assertEquals(componentAgent, componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent does not equal the specified one.
	 */
	@Test
	void testFindDependingComponentByName_2() {
		ComponentAgent componentAgent = new ComponentAgent(""component"");
		assertNull(componentAgent.findDependingComponentByName(""another component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is null.
	 */
	@Test
	void testFindDependingComponentByName_3() {
		ComponentAgent componentAgent = new ComponentAgent(null);
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is empty.
	 */
	@Test
	void testFindDependingComponentByName_4() {
		ComponentAgent componentAgent = new ComponentAgent("""");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_5() {
		ComponentAgent componentAgent = new ComponentAgent("" "");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_6() {
		ComponentAgent componentAgent = new ComponentAgent(""\t"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_7() {
		ComponentAgent componentAgent = new ComponentAgent(""\n"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_8() {
		ComponentAgent componentAgent = new ComponentAgent(""\r"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_9() {
		ComponentAgent componentAgent = new ComponentAgent(""\f"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_10() {
		ComponentAgent componentAgent = new ComponentAgent(""\b"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
}</code></pre>
</div>
</div>

</div>
<div class=""cell border-box-sizing code_cell rendered"">
<div class=""input"">
<div class=""prompt input_prompt"">In&nbsp;[&nbsp;]:</div>
<div class=""inner_cell"">
    <div class=""input_area"">
<div class="" highlight hl-ipython3""><pre><span></span><span class=""kn"">import</span> <span class=""nn"">glengineer.agents</span>
<span class=""kn"">import</span> <span class=""nn"">glengineer.agents.setters</span>
<span class=""kn"">import</span> <span class=""nn"">glengineer.agents.settings</span>
<span class=""kn"">import</span> <span class=""nn"">javax.swing.GroupLayout.Group</span>
<span class=""kn"">import</span> <span class=""nn"">org.junit.jupiter.api.Test</span>
<span class=""kn"">import</span> <span class=""nn"">static</span> <span class=""nn"">org.junit.jupiter.api.Assertions.*</span>

<span class=""c1"">/**
* Test class of {@link ComponentAgent}.
* It contains ten unit test cases for the {@link ComponentAgent#findDependingComponentByName(String)} method.
*/</span>
<span class=""k"">class</span> <span class=""nc"">ComponentAgent_3Test</span> <span class=""p"">{</span>
		
	<span class=""c1"">/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * &lt;p&gt;
	 * The test case checks that the method returns the component agent itself
	 * if its name equals the specified one.
	 */</span>
	<span class=""k"">@Test</span>
	<span class=""kd"">void</span> <span class=""nf"">testFindDependingComponentByName_1</span><span class=""p"">()</span> <span class=""p"">{</span>
		<span class=""n"">ComponentAgent</span> <span class=""n"">componentAgent</span> <span class=""o"">=</span> <span class=""k"">new</span> <span class=""n"">ComponentAgent</span><span class=""p"">(</span><span class=""s"">""component""</span><span class=""p"">);</span>
		<span class=""n"">assertEquals</span><span class=""p"">(</span><span class=""n"">componentAgent</span><span class=""p"">,</span> <span class=""n"">componentAgent</span><span class=""o"">.</span><span class=""na"">findDependingComponentByName</span><span class=""p"">(</span><span class=""s"">""component""</span><span class=""p"">));</span>
	<span class=""p"">}</span>
	
	<span class=""c1"">/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * &lt;p&gt;
	 * The test case checks that the method returns null
	 * if the name of the component agent does not equal the specified one.
	 */</span>
	<span class=""k"">@Test</span>
	<span class=""kd"">void</span> <span class=""nf"">testFindDependingComponentByName_2</span><span class=""p"
cmpl-6u4EqN2i5aGURdIoQerbiSMfVHnUv,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_0Test.java,56.10820508003235,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
        settings = new ParallelGroupSettings();
    }

    public ParallelGroupSettings getSettings() {
        return (ParallelGroupSettings) settings;
    }

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps() {
        Iterator<Agent> i = childrenAgents.iterator();
        while (i.hasNext()) if (i.next().isGap())
            i.remove();
    }

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType() {
        Iterator<Agent> i = childrenAgents.iterator();
        Agent firstGapFound = null;
        Agent next;
        while (i.hasNext()) {
            next = i.next();
            if (!next.isGap())
                continue;
            if (firstGapFound == null)
                firstGapFound = next;
            else //the first gap has been already found.
            if (next != firstGapFound)
                throw new IllegalArgumentException(""A parallel group consists of gaps only "" + ""but the gaps have different types."");
        }
        return firstGapFound;
    }

    /**
     *       
     *   .
     *
     * @param creatorAndAdder	   
     * 							    
     * @return					,   
     * 							.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnParallelGroupImplemenation();
    }

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {
        return new FunctionsOnParallelGroupImplemenation();
    }

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         *      .
         *
         * @param alignment	 
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         *   "" ""  
         *    .
         * <p>
         *   {@code FunctionsOnParallelGroupAndElement}
         *      .
         *
         * @param componentName	  
         * @return				
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						  
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         *   "" ""  
         *        .
         * <p>
         *   {@code FunctionsOnParallelGroupAndElement}
         *      .
         *
         * @param firstName	    
         * @param lastName	    
         * @return			
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					  
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString() {
        return ""parallel group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {

	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
"
cmpl-6u4FtgSO1NecJZcp50zXhLAuBJk3s,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_1Test.java,55.017169713974,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * ,   .
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
        settings = new ParallelGroupSettings();
    }

    public ParallelGroupSettings getSettings() {
        return (ParallelGroupSettings) settings;
    }

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps() {
        Iterator<Agent> i = childrenAgents.iterator();
        while (i.hasNext()) if (i.next().isGap())
            i.remove();
    }

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType() {
        Iterator<Agent> i = childrenAgents.iterator();
        Agent firstGapFound = null;
        Agent next;
        while (i.hasNext()) {
            next = i.next();
            if (!next.isGap())
                continue;
            if (firstGapFound == null)
                firstGapFound = next;
            else //the first gap has been already found.
            if (next != firstGapFound)
                throw new IllegalArgumentException(""A parallel group consists of gaps only "" + ""but the gaps have different types."");
        }
        return firstGapFound;
    }

    /**
     *       
     *   .
     *
     * @param creatorAndAdder	   
     * 							    
     * @return					,   
     * 							.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnParallelGroupImplemenation();
    }

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {
        return new FunctionsOnParallelGroupImplemenation();
    }

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         *      .
         *
         * @param alignment	 
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         *   "" ""  
         *    .
         * <p>
         *   {@code FunctionsOnParallelGroupAndElement}
         *      .
         *
         * @param componentName	  
         * @return				
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						  
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         *   "" ""  
         *        .
         * <p>
         *   {@code FunctionsOnParallelGroupAndElement}
         *      .
         *
         * @param firstName	    
         * @param lastName	    
         * @return			
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					  
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString() {
        return ""parallel group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {

	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 */
	@Test
	void testGroupContent_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getComponentCount());
		assertEquals(10, parallelGroup.getComponent(0).getPreferredSize().width);
	}
	
	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains a single component.
	 * <p>
	 * The component is added to the parallel group.
	 */
	@Test
	void testGroupContent_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addComponent(""component"", 10, 20);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getComponentCount());
		assertEquals(10, parallelGroup.getComponent(0).getPreferredSize().width);
	}
	
	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains a single group.
	 * <p>
	 * The group is added to the parallel group.
	 */
	@Test
	void testGroupContent_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGroup(""group"", new FunctionsOnGroup() {
			public void setContentAlignment(Alignment alignment) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void setResizable(boolean resizable) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public FunctionsOnParallelGroup getParallelGroup() {
				return new FunctionsOnParallelGroup() {
					public void setContentAlignment(Alignment alignment) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
					public void setResizable(boolean resizable) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
					public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
					public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
				};
			}
			public FunctionsOnParallelGroup getSequentialGroup() {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				group.addGroup(groupAgent.groupContent(this));
			}
		});
		
		assertEquals(1, parallelGroup.getComponentCount());
	}
	
	/**
	 * Test case #4.
	 * <p>
	 * The parallel group contains a single gap and a single component.
	 * <p>
	 * The gap and the component are added to the parallel group.
	 */
	@Test
	void testGroupContent_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addComponent(""component"", 10, 20);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(2, parallelGroup.getComponentCount());
		assertEquals(10, parallelGroup.getComponent(0).getPreferredSize().width);
		assertEquals(10, parallelGroup.getComponent(1).getPreferredSize().width);
	}
	
	/**
	 * Test case #5.
	 * <p>
	 * The parallel group contains a single gap and a single group.
	 * <p>
	 * The gap and the group are added to the parallel group.
	 */
	@Test
	void testGroupContent_5() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.addGroup(""group"", new FunctionsOnGroup() {
			public void setContentAlignment(Alignment alignment) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void setResizable(boolean resizable) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public FunctionsOnParallelGroup getParallelGroup() {
				return new FunctionsOnParallelGroup() {
					public void setContentAlignment(Alignment alignment) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
					public void setResizable(boolean resizable) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
					public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
					public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
						throw new UnsupportedOperationException(""Not supported yet."");
					}
"
cmpl-6u4GwINPYx6s1X6drWv4WRJfLdLXL,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,48.62757968902588,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * ,   .
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     *       
     *   .
     *
     * @param creatorAndAdder	   
     * 							    
     * @return					,   
     * 							.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnSequentialGroupImplemenation();
    }

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {
        return new FunctionsOnSequentialGroupImplemenation();
    }

    protected class FunctionsOnSequentialGroupImplemenation implements FunctionsOnSequentialGroup {

        public FunctionsOnSequentialGroupAndElement getComponent(String name) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getComponent(name));
        }

        public FunctionsOnSequentialGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnSequentialGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnSequentialGroupAndElement {

        public FunctionsOnSequentialGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        private SequentialGroupAgent getParentGroupAgent() {
            return (SequentialGroupAgent) parentGroupAgent;
        }

        /**
         *     
         *  """" .
         */
        public void addPrecedingRelatedGap() {
            addPrecedingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         *     
         *  """" .
         */
        public void addPrecedingUnrelatedGap() {
            addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         *     
         *  """" .
         */
        public void addFollowingRelatedGap() {
            addFollowingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         *     
         *  """" .
         */
        public void addFollowingUnrelatedGap() {
            addFollowingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         *       
         *  """"      
         *     .
         */
        public void addPrecedingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         *       
         *  """"      
         *     .
         */
        public void addPrecedingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }

        /**
         *       
         *  """"      
         *     .
         */
        public void addFollowingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         *       
         *  """"      
         *     .
         */
        public void addFollowingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list before that element.
     */
    public void addPreferredGapBefore(PreferredGapAgent gap, Agent element) {
        if (childrenAgents.isEmpty()) {
            childrenAgents.add(gap);
            return;
        }
        ListIterator<Agent> iter = childrenAgents.listIterator();
        while (iter.hasNext()) if (iter.next().equals(element)) {
            iter.previous();
            iter.add(gap);
            return;
        }
        throw new IllegalArgumentException(""the "" + element.toString() + "" in the "" + toString() + "" not found"");
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list after that element.
     */
    public void addPreferredGapAfter(PreferredGapAgent gap, Agent element) {
        if (childrenAgents.isEmpty()) {
            childrenAgents.add(gap);
            return;
        }
        ListIterator<Agent> iter = childrenAgents.listIterator();
        while (iter.hasNext()) if (iter.next().equals(element)) {
            iter.add(gap);
            return;
        }
        throw new IllegalArgumentException(""the "" + element.toString() + "" in the "" + toString() + "" not found"");
    }

    public String toString() {
        return ""sequential group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has no children.
	 */
	@Test
	void testGroupContent_NoChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(0, result.getComponents().length);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one child.
	 */
	@Test
	void testGroupContent_OneChild() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(1, result.getComponents().length);
		assertEquals(""component"", result.getComponents()[0].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has two children.
	 */
	@Test
	void testGroupContent_TwoChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(2, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has three children.
	 */
	@Test
	void testGroupContent_ThreeChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		group.addComponent(new ComponentAgent(""component3""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(3, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""component2"", result.getComponents()[1].getName());
		assertEquals(""component3"", result.getComponents()[2].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one child and one preferred gap.
	 */
	@Test
	void testGroupContent_OneChildAndOnePreferredGap() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(2, result.getComponents().length);
		assertEquals(""component"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has two children and one preferred gap.
	 */
	@Test
	void testGroupContent_TwoChildrenAndOnePreferredGap() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component1""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(3, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
		assertEquals(""component2"", result.getComponents()[2].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has three children and one preferred gap.
	 */
	@Test
	void testGroupContent_ThreeChildrenAndOnePreferredGap() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component1""));
		group.addComponent(new ComponentAgent(""component2""));
		group.addComponent(new ComponentAgent(""component3""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component1""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(4, result.getComponents().length);
		assertEquals(""component1"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
		assertEquals(""component2"", result.getComponents()[2].getName());
		assertEquals(""component3"", result.getComponents()[3].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one child and two preferred gaps.
	 */
	@Test
	void testGroupContent_OneChildAndTwoPreferredGaps() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent(""component""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component""));
		group.addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE), group.getComponent(""component""));
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(3, result.getComponents().length);
		assertEquals(""component"", result.getComponents()[0].getName());
		assertEquals(""preferred gap"", result.getComponents()[1].getName());
		assertEquals(""preferred gap"", result.getComponents()[2].getName());
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has two children and two preferred gaps.
	 */
	@Test
	void testGroupContent_TwoChildrenAndTwoPreferredGaps() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		group.addComponent(new ComponentAgent"
cmpl-6u4HzYb413TtPY1chQDonv3ZHgotj,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,58.25972890853882,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * ,     .
 * <p>
 *   {@code FunctionsOnTopSequentialGroup}
 *    
 *         .
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    /**
     * ,      .
     */
    private ContainerGapAgent precedingContainerGap;

    /**
     * ,      .
     */
    private ContainerGapAgent followingContainerGap;

    /**
     *       ,
     * ,  ,       ,
     *    .
     * <p>
     *   {@code TopSequentialGroupAgent.groupContent()},
     *     .
     *
     * @param creatorAndAdder	   
     * 							    
     * @return					,   
     * 							.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        if (precedingContainerGap != null)
            precedingContainerGap.addOneselfToGroup(result);
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        if (followingContainerGap != null)
            followingContainerGap.addOneselfToGroup(result);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnTopSequentialGroupImplemenation();
    }

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {
        return getFunctionsOnTopSequentialGroupImplemenation();
    }

    public FunctionsOnTopSequentialGroup getFunctionsOnTopSequentialGroupImplemenation() {
        return new FunctionsOnTopSequentialGroupImplemenation();
    }

    private class FunctionsOnTopSequentialGroupImplemenation extends SequentialGroupAgent.FunctionsOnSequentialGroupImplemenation implements FunctionsOnTopSequentialGroup {

        /**
         *   
         *      .
         */
        public void addPrecedingContainerGap() {
            precedingContainerGap = new ContainerGapAgent();
        }

        /**
         *       
         *      .
         */
        public void addPrecedingContainerGap(int pref, int max) {
            precedingContainerGap = new ContainerGapAgent(pref, max);
        }

        /**
         *   
         *      .
         */
        public void addFollowingContainerGap() {
            followingContainerGap = new ContainerGapAgent();
        }

        /**
         *       
         *      .
         */
        public void addFollowingContainerGap(int pref, int max) {
            followingContainerGap = new ContainerGapAgent(pref, max);
        }

        public void addBothContainerGaps() {
            addPrecedingContainerGap();
            addFollowingContainerGap();
        }

        public void addBothContainerGaps(int pref, int max) {
            addPrecedingContainerGap(pref, max);
            addFollowingContainerGap(pref, max);
        }
    }
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(2, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a preceding container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents_PrecedingContainerGap() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addPrecedingContainerGap();
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(3, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a following container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents_FollowingContainerGap() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addFollowingContainerGap();
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(3, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a preceding container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a following container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link SequentialGroup} object is created by the {@link GroupCreatorAndElementAdder} object.
	 * <p>
	 * The {@link GroupCreatorAndElementAdder} object is created by the {@link GroupCreatorAndElementAdderTest#createGroupCreatorAndElementAdder()} method.
	 */
	@Test
	void testGroupContent_TwoComponents_BothContainerGaps() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.addComponent(new ComponentAgent());
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addBothContainerGaps();
		GroupCreatorAndElementAdder creatorAndAdder = GroupCreatorAndElementAdderTest.createGroupCreatorAndElementAdder();
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(creatorAndAdder);
		assertEquals(4, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a preceding container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a following container gap,
	 * which is added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a {@link ParallelGroupAgent} object,
	 * which contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 *"
cmpl-6u4J2PLByeB2jaNxfIHAg6lKeUwp1,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_2Test.java,60.74730372428894,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public HorizontalBlock(Scheme scheme) {
        super(scheme);
    }

    public HorizontalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public Block subblock(int x1, int y1, int x2, int y2) {
        return new HorizontalBlock(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock cloneWith(CharPosition1 p1) {
        return new HorizontalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components, gaps , or horizontal lines
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component, gap, or horizontal line)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstSequentialSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of an entity.
     * @return	the position of the entity found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain entities.
     */
    private CharPosition firstEntity() {
        int y = firstEntityBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstEntityBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstEntityBelow(int x, int y) {
        for (; y < y2; y++) if (entityAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a horizontal line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '|';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !entityAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Returns the set of all horizontal lines intersecting this block.
     */
    private Set<HWordPosition> getIntersectingHLines() {
        Set<HWordPosition> source = scheme.getHLinesPositions();
        Set<HWordPosition> result = new HashSet<HWordPosition>();
        for (HWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long horizontal lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {
        removeSmallHLinesFrom(hLines);
        List<Integer> separators = sortedYsOf(hLines);
        return extractParallelSubblocksSeparatedBy(separators);
    }

    /**
     * Finds the longest lines in the specified set of horizontal lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (HWordPosition line : hLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        HWordPosition line;
        Iterator<HWordPosition> i = hLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    /**
     * Returns a list of the specified horizontal lines' vertical coordinates.
     */
    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {
        LinkedList<Integer> linesY = new LinkedList<Integer>();
        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));
        Collections.sort(linesY);
        return linesY;
    }

    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {
        List<Block> blocksList = new LinkedList<Block>();
        Block subBlock;
        //upper bound of a subblock
        int upperY = y1;
        for (int lowerY : ySeparators) {
            if (lowerY > upperY) {
                //there is a (non-trivial?) block between two lines.
                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    blocksList.add(subBlock);
            }
            upperY = lowerY + 1;
        }
        //below the last line:
        if (upperY < y2) {
            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                blocksList.add(subBlock);
        }
        return blocksList;
    }

    /**
     * Divides the current block without horizontal lines
     * into a set of parallel subblocks, optimizes these subblocks
     * and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block block;
        for (int y = y1; y < y2; y++) {
            block = subblock(x1, y, x2, y + 1);
            block.optimize();
            if (!block.isTrivial())
                result.add(block);
        }
        return result;
    }
}
","// HorizontalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlock_2Test {","// HorizontalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractSequentialSubblocks()} method.
*/
class HorizontalBlock_2Test {

	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing a single word.
	 */
	@Test
	void testExtractSequentialSubblocks_1() {
		Scheme scheme = new Scheme(""a"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 1, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(1, result.size());
		assertEquals(block, result.get(0));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words.
	 */
	@Test
	void testExtractSequentialSubblocks_2() {
		Scheme scheme = new Scheme(""ab"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 2, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 1, 0, 2, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing three words.
	 */
	@Test
	void testExtractSequentialSubblocks_3() {
		Scheme scheme = new Scheme(""abc"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 3, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 1, 0, 2, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(2));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words separated by a space.
	 */
	@Test
	void testExtractSequentialSubblocks_4() {
		Scheme scheme = new Scheme(""a b"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 3, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words separated by a space.
	 */
	@Test
	void testExtractSequentialSubblocks_5() {
		Scheme scheme = new Scheme(""a  b"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 4, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 4, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words separated by a space.
	 */
	@Test
	void testExtractSequentialSubblocks_6() {
		Scheme scheme = new Scheme(""a   b"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 4, 0, 5, 1), result.get(1));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words separated by a space.
	 */
	@Test
	void testExtractSequentialSubblocks_7() {
		Scheme scheme = new Scheme(""a b c"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 4, 0, 5, 1), result.get(2));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words separated by a space.
	 */
	@Test
	void testExtractSequentialSubblocks_8() {
		Scheme scheme = new Scheme(""a  b  c"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 7, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 4, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 6, 0, 7, 1), result.get(2));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words separated by a space.
	 */
	@Test
	void testExtractSequentialSubblocks_9() {
		Scheme scheme = new Scheme(""a   b   c"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 9, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 4, 0, 5, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 8, 0, 9, 1), result.get(2));
	}
	
	/**
	 * Tests the {@link HorizontalBlock#extractSequentialSubblocks()} method
	 * on a block containing two words separated by a space.
	 */
	@Test
	void testExtractSequentialSubblocks_10() {
		Scheme scheme = new Scheme(""a b c d"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 7, 1);
		List<Block> result = block.extractSequentialSubblocks();
		assertEquals(4, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 1, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 2, 0, 3, 1), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 4, 0, 5, 1), result.get(2));
		assertEquals"
cmpl-6u4K1Fnyq7gFEe8fWKKCboR5W31QU,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/HorizontalBlock_3Test.java,62.82425618171692,length,"// HorizontalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for horizontal layouting.
 */
public class HorizontalBlock extends Block {

    public HorizontalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public HorizontalBlock(Scheme scheme) {
        super(scheme);
    }

    public HorizontalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public HorizontalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public Block subblock(int x1, int y1, int x2, int y2) {
        return new HorizontalBlock(scheme, x1, y1, x2, y2);
    }

    public HorizontalBlock cloneWith(CharPosition1 p1) {
        return new HorizontalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        HorizontalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components, gaps , or horizontal lines
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component, gap, or horizontal line)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstSequentialSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstEntity());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of an entity.
     * @return	the position of the entity found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain entities.
     */
    private CharPosition firstEntity() {
        int y = firstEntityBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstEntityBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstEntityBelow(int x, int y) {
        for (; y < y2; y++) if (entityAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a horizontal line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '|';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !entityAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has horizontal lines,
     * this method divides the block by the maximal horizontal lines only.
     * <p>
     * If there are no horizontal lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<HWordPosition> hLines = getIntersectingHLines();
        if (hLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(hLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Returns the set of all horizontal lines intersecting this block.
     */
    private Set<HWordPosition> getIntersectingHLines() {
        Set<HWordPosition> source = scheme.getHLinesPositions();
        Set<HWordPosition> result = new HashSet<HWordPosition>();
        for (HWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long horizontal lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<HWordPosition> hLines) {
        removeSmallHLinesFrom(hLines);
        List<Integer> separators = sortedYsOf(hLines);
        return extractParallelSubblocksSeparatedBy(separators);
    }

    /**
     * Finds the longest lines in the specified set of horizontal lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallHLinesFrom(Set<HWordPosition> hLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (HWordPosition line : hLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        HWordPosition line;
        Iterator<HWordPosition> i = hLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    /**
     * Returns a list of the specified horizontal lines' vertical coordinates.
     */
    private List<Integer> sortedYsOf(Set<HWordPosition> hLines) {
        LinkedList<Integer> linesY = new LinkedList<Integer>();
        for (HWordPosition line : hLines) linesY.add(new Integer(line.y));
        Collections.sort(linesY);
        return linesY;
    }

    private List<Block> extractParallelSubblocksSeparatedBy(List<Integer> ySeparators) {
        List<Block> blocksList = new LinkedList<Block>();
        Block subBlock;
        //upper bound of a subblock
        int upperY = y1;
        for (int lowerY : ySeparators) {
            if (lowerY > upperY) {
                //there is a (non-trivial?) block between two lines.
                subBlock = new HorizontalBlock(this, x1, upperY, x2, lowerY);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    blocksList.add(subBlock);
            }
            upperY = lowerY + 1;
        }
        //below the last line:
        if (upperY < y2) {
            subBlock = new HorizontalBlock(this, x1, upperY, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                blocksList.add(subBlock);
        }
        return blocksList;
    }

    /**
     * Divides the current block without horizontal lines
     * into a set of parallel subblocks, optimizes these subblocks
     * and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block block;
        for (int y = y1; y < y2; y++) {
            block = subblock(x1, y, x2, y + 1);
            block.optimize();
            if (!block.isTrivial())
                result.add(block);
        }
        return result;
    }
}
","// HorizontalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlock_3Test {","// HorizontalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HorizontalBlock}.
* It contains ten unit test cases for the {@link HorizontalBlock#extractParallelSubblocks()} method.
*/
class HorizontalBlock_3Test {

	/**
	 * Test case 1.
	 * <p>
	 * The block contains a single horizontal line.
	 * <p>
	 * The block is divided into two subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_1() {
		Scheme scheme = new Scheme(""|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 1);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(2, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 1), result.get(1));
	}
	
	/**
	 * Test case 2.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_2() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 3.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_3() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 4.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_4() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 5.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_5() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 6.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_6() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 7.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_7() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 8.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_8() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0, 1, 3, 2), result.get(1));
		assertEquals(new HorizontalBlock(scheme, 3, 0, 5, 2), result.get(2));
	}
	
	/**
	 * Test case 9.
	 * <p>
	 * The block contains two horizontal lines.
	 * <p>
	 * The block is divided into three subblocks.
	 */
	@Test
	void testExtractParallelSubblocks_9() {
		Scheme scheme = new Scheme(""|---|\n|---|"");
		HorizontalBlock block = new HorizontalBlock(scheme, 0, 0, 5, 2);
		List<Block> result = block.extractParallelSubblocks();
		assertEquals(3, result.size());
		assertEquals(new HorizontalBlock(scheme, 0, 0, 3, 1), result.get(0));
		assertEquals(new HorizontalBlock(scheme, 0,"
069aaab8-656d-4464-8b97-1939287197ec,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8957 tokens (6957 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_0Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#containsComponentName(String)} method.
*/
class Scheme_0Test {","// Scheme_0Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#containsComponentName(String)} method.
*/
class Scheme_0Test {
"
f442eca9-421b-4027-80b7-d247fdccc618,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_10Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8957 tokens (6957 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_10Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#gapAtLine(WordPosition)} method.
*/
class Scheme_10Test {","// Scheme_10Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#gapAtLine(WordPosition)} method.
*/
class Scheme_10Test {
"
7ee58984-8765-4236-87d0-b679db509703,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8958 tokens (6958 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#containsGapName(String)} method.
*/
class Scheme_1Test {","// Scheme_1Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#containsGapName(String)} method.
*/
class Scheme_1Test {
"
19891beb-327a-48d3-890d-9c6bd0c68bbd,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8957 tokens (6957 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#charAt(int, int)} method.
*/
class Scheme_2Test {","// Scheme_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#charAt(int, int)} method.
*/
class Scheme_2Test {
"
46f26d1c-cf2a-4a26-8a16-bb82f8206eff,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8959 tokens (6959 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#textAt(int, int, int)} method.
*/
class Scheme_3Test {","// Scheme_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#textAt(int, int, int)} method.
*/
class Scheme_3Test {
"
7dc16f34-0f89-450b-8d05-d1bc49b3db09,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8959 tokens (6959 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_4Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#anyHElementAt(int, int)} method.
*/
class Scheme_4Test {","// Scheme_4Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#anyHElementAt(int, int)} method.
*/
class Scheme_4Test {
"
065408c3-bbb5-40b5-8416-e7f37d6f89cf,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8957 tokens (6957 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_6Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#gapAt(int, int)} method.
*/
class Scheme_6Test {","// Scheme_6Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#gapAt(int, int)} method.
*/
class Scheme_6Test {
"
a6554970-539f-4e28-b8c9-f200368f7268,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/Scheme_8Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8959 tokens (6959 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// Scheme.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * Represents the layout scheme which is specified by the end user
 * as a sequence of strings.
 */
public class Scheme extends CharTable {

    protected final String[] lines;

    /**
     * Encapsulates the sets of positions of all components, lines and gaps
     * present on the scheme.
     */
    private static class Positions {

        HashSet<HWordPosition> components = new HashSet<HWordPosition>();

        HashSet<HWordPosition> hLines = new HashSet<HWordPosition>();

        HashSet<VWordPosition> vLines = new HashSet<VWordPosition>();

        HashSet<HWordPosition> gaps = new HashSet<HWordPosition>();
    }

    private Positions positions;

    /**
     * Encapsulates the sets of names of all components and of all gaps
     * present on the scheme.
     */
    private static class Names {

        HashSet<String> components = new HashSet<String>();

        HashSet<String> gaps = new HashSet<String>();
    }

    private Names names;

    /**
     * Maps components and gaps positions to the corresponding names.
     */
    private HashMap<HWordPosition, String> positionsToNames;

    /**
     * Maps the y-coordinates on the scheme
     * to sets of horizontal words having these coordinates.
     * This map is used in the horizontal words and lines search methods.
     */
    private Map<Integer, HashSet<HWordPosition>> hWordsAtYs;

    /**
     * Maps the x-coordinates on the scheme
     * to sets of vertical words having these coordinates.
     * This map is used in the vertical line search method.
     */
    private Map<Integer, HashSet<VWordPosition>> vWordsAtXs;

    /**
     * Represents the correspondence between the lines on the scheme
     * and the gaps which belong to those lines (intersect them).
     * Both lines and gaps are represented by their positions on the scheme.
     * <p>
     * Note that each line may contain (may be intersected by) only one gap.
     */
    private Map<WordPosition, HWordPosition> gapsAtLines;

    public Scheme(String... strings) {
        lines = strings;
        calculateAndCheckSize();
        recognizeContent();
        extractNamesFromPositions();
        organizeFastElementsSearch();
        recognizeGapsAtLines();
    }

    protected void calculateAndCheckSize() {
        if (lines.length == 0)
            throw new IllegalArgumentException(""The scheme has no lines."");
        x1 = 0;
        y1 = 0;
        y2 = lines.length;
        x2 = lines[0].length();
        for (int i = 1; i < y2; i++) if (lines[i].length() != x2)
            throw new IllegalArgumentException(""The strings are not of equal length."");
    }

    /**
     * Finds each element present on the scheme,
     * identifies it with certain type,
     * and places the element to the corresponding set
     * in the field {@code positions}.
     *
     * @throws 	IllegalArgumentException if the scheme contains improper symbols.
     * 			<p>
     * 			Note that after successful scheme initialization
     * 			there is no need to determine its characters types using
     * 			comparation with {@code CharTable.LETTERS}. One can just
     * 			use comparation with dots, lines, and spaces instead.
     */
    protected void recognizeContent() {
        positions = new Positions();
        /* Find sequentially the upper-left corner
		 * of each element on the scheme,
		 * find another end of the element,
		 * identify the element,
		 * register it.
		 */
        //A non-trivial order of visiting cells of the scheme is possible.
        boolean[][] visited = new boolean[x2][y2];
        for (int y = y1; y < y2; y++) for (int x = x1; x < x2; x++) {
            if (visited[x][y] || charAt(x, y) == ' ')
                continue;
            visited[x][y] = true;
            trackElementStartingAt(x, y, visited);
        }
    }

    /**
     * Recognizes the element containing the specified position
     * (if such element exists).
     */
    private void trackElementStartingAt(int x, int y, boolean[][] visited) {
        char c = charAt(x, y);
        if (c == '-')
            positions.hLines.add(trackHLineStartingAt(x, y, visited));
        else if (c == '|')
            positions.vLines.add(trackVLineStartingAt(x, y, visited));
        else if (isLetter(c))
            positions.components.add(trackComponentStartingAt(x, y, visited));
        else if (c == '.')
            positions.gaps.add(trackGapStartingAt(x, y, visited));
        else if (c == '+') {
            boolean startsHline = (firstNonPlusOnTheRightFrom(x, y) == '-');
            boolean startsVline = (firstNonPlusDownFrom(x, y) == '|');
            if (startsHline)
                positions.hLines.add(trackHLineStartingAt(x, y, visited));
            if (startsVline)
                positions.vLines.add(trackVLineStartingAt(x, y, visited));
            else if (!startsHline)
                throw new IllegalArgumentException(""Unrecognizable construction found in the scheme"" + "" under position ("" + x + "","" + y + "")"");
        } else
            throwWrongSymbolException(x, y, c);
    }

    private HWordPosition trackHLineStartingAt(int x, int y, boolean[][] visited) {
        //retain x and move x to the end of the line:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the line continues
            c == '-' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '|' || c == '.' || isLetter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private VWordPosition trackVLineStartingAt(int x, int y, boolean[][] visited) {
        int startY = y;
        //just in case check for pluses above:
        for (; startY - 1 >= y1 && charAt(x, startY - 1) == '+'; startY--) ;
        //retain y as startY and move y to the end of the line:
        char c;
        for (y = startY + 1; y < y2; y++) {
            c = charAt(x, y);
            if (//the line continues
            c == '|' || c == '+')
                visited[x][y] = true;
            else if (//line end
            c == ' ' || c == '-' || c == '.' || isLetter(c))
                return new VWordPosition(x, startY, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new VWordPosition(x, startY, y);
    }

    private HWordPosition trackComponentStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the component:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the component continues
            isLetter(c))
                visited[x][y] = true;
            else if (//component finished
            c == ' ' || isSplitter(c))
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private HWordPosition trackGapStartingAt(int x, int y, boolean[][] visited) {
        //retain x as startX and move x to the end of the gap:
        int startX = x;
        char c;
        for (x = startX + 1; x < x2; x++) {
            c = charAt(x, y);
            if (//the gap continues
            isWordChar(c))
                visited[x][y] = true;
            else if (//gap finished
            c == '-' || c == '+' || c == ' ')
                return new HWordPosition(startX, x, y);
            else
                throwWrongSymbolException(x, y, c);
        }
        return new HWordPosition(startX, x, y);
    }

    private char firstNonPlusOnTheRightFrom(int x, int y) {
        char c;
        for (; x < x2; x++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private char firstNonPlusDownFrom(int x, int y) {
        char c;
        for (; y < y2; y++) {
            c = charAt(x, y);
            if (c != '+')
                return c;
        }
        return ' ';
    }

    private void throwWrongSymbolException(int x, int y, char c) {
        throw new IllegalArgumentException(""A wrong symbol \'"" + c + ""\' was found on the scheme"" + "" under position ("" + x + "","" + y + "")"");
    }

    /**
     * Initializes the sets {@code names.components} and {@code names.gaps}
     * and the mapping {@code positionsToNames}
     * using the positions of all these elements on the scheme,
     * which are considered to be initialized earlier.
     */
    protected void extractNamesFromPositions() {
        names = new Names();
        positionsToNames = new HashMap<HWordPosition, String>();
        String name;
        for (HWordPosition wp : positions.components) {
            name = textAt(wp);
            registerComponentName(name);
            positionsToNames.put(wp, name);
        }
        for (HWordPosition wp : positions.gaps) {
            name = textAt(wp);
            registerGapName(name);
            positionsToNames.put(wp, name);
        }
    }

    private void registerComponentName(String name) {
        if (!names.components.add(name))
            throw new IllegalArgumentException(""cannot register the component name \"""" + name + ""\"""");
    }

    private void registerGapName(String name) {
        names.gaps.add(name);
    }

    /**
     * Initializes the variables
     * {@code hWordsAtLines} and {@code vWordsAtLines}
     * which are used in the searching methods
     * {@code horizontalElementAt()} and {@code verticalLineAt()}.
     */
    protected void organizeFastElementsSearch() {
        hWordsAtYs = new HashMap<Integer, HashSet<HWordPosition>>(lines.length);
        for (int i = 0; i < lines.length; i++) hWordsAtYs.put(i, new HashSet<HWordPosition>());
        distributeHWordsByLines(positions.components);
        distributeHWordsByLines(positions.gaps);
        distributeHWordsByLines(positions.hLines);
        vWordsAtXs = new HashMap<Integer, HashSet<VWordPosition>>();
        distributeVWordsByLines(positions.vLines);
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code hWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeHWordsByLines(Set<HWordPosition> from) {
        for (HWordPosition wp : from) {
            hWordsAtYs.get(new Integer(wp.y)).add(wp);
        }
    }

    /**
     * Puts the references at each word position in the specified
     * set {@code from} into the corresponding values of the map
     * {@code vWordsAtLines}.
     *
     * @param from	the set of positions to be distributed.
     */
    private void distributeVWordsByLines(Set<VWordPosition> from) {
        Integer key;
        for (VWordPosition wp : from) {
            key = new Integer(wp.x);
            if (!vWordsAtXs.containsKey(key))
                vWordsAtXs.put(key, new HashSet<VWordPosition>());
            vWordsAtXs.get(key).add(wp);
        }
    }

    /**
     * Investigates, which gaps must be considered as belonging to lines;
     * then modifies the corresponding lines' positions.
     * <p>
     * This method initializes the field {@code gapsAtLines}
     * and influences the fields
     * {@code positions.hLines}, {@code positions.vLines}
     * {@code hWordsAtYs}, and {@code vWordsAtXs}.
     */
    protected void recognizeGapsAtLines() {
        gapsAtLines = new HashMap<WordPosition, HWordPosition>();
        recognizeHorizontalGapsAtLines();
        recognizeVerticalGapsAtLines();
    }

    protected void recognizeHorizontalGapsAtLines() {
        HashSet<HWordPosition> hLinesToRemove = new HashSet<HWordPosition>();
        HashSet<HWordPosition> hLinesToAdd = new HashSet<HWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<HWordPosition> i = positions.hLines.iterator();
        HWordPosition hLine;
        while (i.hasNext()) {
            hLine = i.next();
            if (//already visited.
            hLinesToRemove.contains(hLine))
                continue;
            int newX1 = hLine.x1;
            HWordPosition leftGap = gapOnTheLeftFrom(hLine);
            if (leftGap != null) {
                newX1 = leftGap.x1;
                gapAtLine = leftGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition leftLine = hLineOnTheLeftFrom(leftGap);
                if (leftLine != null && positions.hLines.contains(leftLine) && !hLinesToRemove.contains(leftLine)) {
                    newX1 = leftLine.x1;
                    //the line will be changed.
                    hLinesToRemove.add(leftLine);
                    if (gapOnTheLeftFrom(leftLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            int newX2 = hLine.x2;
            HWordPosition rightGap = gapOnTheRightFrom(hLine);
            if (rightGap != null) {
                if (//this is not the first gap.
                leftGap != null)
                    throwMultipleGapsAtYException(hLine.y);
                newX2 = rightGap.x2;
                gapAtLine = rightGap;
                //the current line will be changed.
                hLinesToRemove.add(hLine);
                HWordPosition rightLine = hLineOnTheRightFrom(rightGap);
                if (rightLine != null && positions.hLines.contains(rightLine) && !hLinesToRemove.contains(rightLine)) {
                    newX2 = rightLine.x2;
                    //the line will be changed.
                    hLinesToRemove.add(rightLine);
                    if (gapOnTheRightFrom(rightLine) != null)
                        throwMultipleGapsAtYException(hLine.y);
                }
            }
            if (newX1 != hLine.x1 || newX2 != hLine.x2) {
                HWordPosition newLine = new HWordPosition(newX1, newX2, hLine.y);
                hLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        for (HWordPosition line : hLinesToRemove) {
            positions.hLines.remove(line);
            hWordsAtYs.get(line.y).remove(line);
        }
        for (HWordPosition line : hLinesToAdd) {
            positions.hLines.add(line);
            hWordsAtYs.get(line.y).add(line);
        }
    }

    private HWordPosition gapOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return gapAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition hLineOnTheLeftFrom(HWordPosition hLine) {
        CharPosition leftPos = hLine.getStart();
        return anyHElementAt(leftPos.x - 1, leftPos.y);
    }

    private HWordPosition gapOnTheRightFrom(HWordPosition hLine) {
        return gapAt(hLine.getEnd());
    }

    private HWordPosition hLineOnTheRightFrom(HWordPosition hLine) {
        CharPosition rightPos = hLine.getEnd();
        return anyHElementAt(rightPos.x, rightPos.y);
    }

    private void throwMultipleGapsAtYException(int y) {
        throw new IllegalArgumentException(""Multiple gaps on a horisontal line"" + "" at y="" + y + "" found."");
    }

    protected void recognizeVerticalGapsAtLines() {
        HashSet<VWordPosition> vLinesToRemove = new HashSet<VWordPosition>();
        HashSet<VWordPosition> vLinesToAdd = new HashSet<VWordPosition>();
        HWordPosition gapAtLine = null;
        //Searching:
        Iterator<VWordPosition> i = positions.vLines.iterator();
        VWordPosition vLine;
        while (i.hasNext()) {
            vLine = i.next();
            if (//already visited.
            vLinesToRemove.contains(vLine))
                continue;
            int newY1 = vLine.y1;
            HWordPosition topGap = gapAbove(vLine);
            if (topGap != null) {
                newY1 = topGap.y;
                gapAtLine = topGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition topLine = vLineAbove(vLine);
                if (topLine != null && positions.vLines.contains(topLine) && !vLinesToRemove.contains(topLine)) {
                    newY1 = topLine.y1;
                    //the line will be changed.
                    vLinesToRemove.add(topLine);
                    if (gapAbove(topLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            int newY2 = vLine.y2;
            HWordPosition bottomGap = gapBelow(vLine);
            if (bottomGap != null) {
                if (//this is not the first gap.
                topGap != null)
                    throwMultipleGapsAtXException(vLine.x);
                newY2 = bottomGap.y + 1;
                gapAtLine = bottomGap;
                //the current line will be changed.
                vLinesToRemove.add(vLine);
                VWordPosition bottomLine = vLineBelow(vLine);
                if (bottomLine != null && positions.vLines.contains(bottomLine) && !vLinesToRemove.contains(bottomLine)) {
                    newY2 = bottomLine.y2;
                    //the line will be changed.
                    vLinesToRemove.add(bottomLine);
                    if (gapBelow(bottomLine) != null)
                        throwMultipleGapsAtXException(vLine.x);
                }
            }
            if (newY1 != vLine.y1 || newY2 != vLine.y2) {
                VWordPosition newLine = new VWordPosition(vLine.x, newY1, newY2);
                vLinesToAdd.add(newLine);
                gapsAtLines.put(newLine, gapAtLine);
            }
        }
        //Applying the changes:
        //removing:
        for (VWordPosition line : vLinesToRemove) {
            positions.vLines.remove(line);
            vWordsAtXs.get(line.x).remove(line);
        }
        //adding:
        for (VWordPosition line : vLinesToAdd) {
            positions.vLines.add(line);
            vWordsAtXs.get(line.x).add(line);
        }
    }

    private HWordPosition gapAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return gapAt(topPos.x, topPos.y - 1);
    }

    /* 
	 * Returns the vertical line lying above the specified line
	 * and the gap lying above it.
	 */
    private VWordPosition vLineAbove(VWordPosition vLine) {
        CharPosition topPos = vLine.getStart();
        return verticalLineAt(topPos.x, topPos.y - 2);
    }

    private HWordPosition gapBelow(VWordPosition vLine) {
        return gapAt(vLine.getEnd());
    }

    /* 
	 * Returns the vertical line lying below the specified line
	 * and the gap lying below it.
	 */
    private VWordPosition vLineBelow(VWordPosition vLine) {
        CharPosition bottomPos = vLine.getEnd();
        return verticalLineAt(bottomPos.x, bottomPos.y + 1);
    }

    private void throwMultipleGapsAtXException(int x) {
        throw new IllegalArgumentException(""Multiple gaps on a vertical line"" + "" at x="" + x + "" found."");
    }

    /**
     * Verifies whether the scheme contains the specified component name.
     */
    public boolean containsComponentName(String name) {
        return names.components.contains(name);
    }

    /**
     * Verifies whether the scheme contains the specified gap denotation.
     */
    public boolean containsGapName(String name) {
        return names.gaps.contains(name);
    }

    /**
     * Returns the symbol lying on the scheme under the specified position.
     */
    public char charAt(int x, int y) {
        try {
            return lines[y].charAt(x);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""char position out of table"");
        }
    }

    /**
     * Returns the text lying on the scheme
     * specified by the given word position coordinates.
     */
    public String textAt(int x1, int x2, int y) {
        try {
            return lines[y].substring(x1, x2);
        } catch (RuntimeException re) {
            throw new IllegalArgumentException(""Improper subline coodinates."");
        }
    }

    /**
     * Returns an unmodifiable set of all positions
     * of horizontal lines on the scheme.
     */
    public Set<HWordPosition> getHLinesPositions() {
        return Collections.unmodifiableSet(positions.hLines);
    }

    /**
     * Returns an unmodifiable set of all positions
     * of vertical lines on the scheme.
     */
    public Set<VWordPosition> getVLinesPositions() {
        return Collections.unmodifiableSet(positions.vLines);
    }

    /**
     * Finds and returns (the position of) a horizontal element
     * which contains the specified point.
     * If such element does not exist, returns null.
     * <p>
     * Note that some points may lie at horizontal lines
     * and at gaps belonging to that lines simultaneously.
     * In such cases the method returns any of the two elements.
     */
    public HWordPosition anyHElementAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y))
                return hwp;
        return null;
    }

    public HWordPosition anyHElementAt(CharPosition pos) {
        return anyHElementAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the gap
     * containing the specified point
     * or null if such gap does not exist on the scheme.
     */
    public HWordPosition gapAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '|')
            return null;
        Set<HWordPosition> h = hWordsAtYs.get(new Integer(y));
        if (h != null)
            for (HWordPosition hwp : h) if (hwp.contains(x, y) && positions.gaps.contains(hwp))
                return hwp;
        return null;
    }

    public HWordPosition gapAt(CharPosition pos) {
        return gapAt(pos.x, pos.y);
    }

    /**
     * Finds and returns (the position of) the vertical line
     * which contains the specified point
     * or null if such line does not exist.
     */
    public VWordPosition verticalLineAt(int x, int y) {
        if (!contains(x, y))
            return null;
        char c = charAt(x, y);
        if (c == ' ' || c == '-')
            return null;
        Set<VWordPosition> v = vWordsAtXs.get(new Integer(x));
        if (v != null)
            for (VWordPosition vwp : v) if (vwp.contains(x, y))
                return vwp;
        return null;
    }

    public VWordPosition verticalLineAt(CharPosition pos) {
        return verticalLineAt(pos.x, pos.y);
    }

    /**
     * Returns the gap belonging to the specified horizontal or vertical line
     * or null if such gap does not exist.
     */
    public HWordPosition gapAtLine(WordPosition line) {
        if (gapsAtLines == null)
            return null;
        return gapsAtLines.get(line);
    }

    public String toString() {
        StringBuilder result = new StringBuilder((lines[0].length() + 1) * lines.length);
        for (int i = 0; i < lines.length; i++) result.append(lines[i] + '\n');
        return result.toString();
    }
}
","// Scheme_8Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#verticalLineAt(int, int)} method.
*/
class Scheme_8Test {","// Scheme_8Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Scheme}.
* It contains ten unit test cases for the {@link Scheme#verticalLineAt(int, int)} method.
*/
class Scheme_8Test {
"
cmpl-6u4SnfyFnfEAZ1pgh5jC6lebKhZVk,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_2Test.java,58.5238356590271,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public VerticalBlock(Scheme scheme) {
        super(scheme);
    }

    public VerticalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {
        return new VerticalBlock(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock cloneWith(CharPosition1 p1) {
        return new VerticalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the upper subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive horizontal line
     * does not contain elements of vertical lines
     * starting above the line.
     * <p>
     * The algorithm finds the upper entity
     * (an element of a component, gap, or vertical line)
     * using simple search along the scheme,
     * and retains it as the top of the required block.
     * Then, starting from the height of that point,
     * it sequentially finds vertical lines
     * end below but begin not below
     * and moves to lower end of such lines.
     * The lower end of the last such vertical line defines
     * the bottom of the required block.
     */
    private VerticalBlock extractFirstSequentialSubblock() {
        Set<VWordPosition> vLines = getIntersectingVLines();
        CharPosition blockStart = getBlockStart();
        int y2 = getUpperSubblockEnd(blockStart, vLines);
        return subblock(this.x1, blockStart.y, this.x2, y2);
    }

    /**
     * Returns the set of all vertical lines intersecting this block.
     */
    private Set<VWordPosition> getIntersectingVLines() {
        Set<VWordPosition> source = scheme.getVLinesPositions();
        Set<VWordPosition> result = new HashSet<VWordPosition>();
        for (VWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Finds the upper entity (an element of a word or vertical line)
     * of this block.
     * Returns its position on the scheme.
     * @throws	IllegalArgumentException if this block happens to be empty.
     */
    private CharPosition getBlockStart() {
        int x = x1;
        int y = y1;
        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))
            return new CharPosition(x, y);
        throw new IllegalArgumentException(""Can not extract elements from an empty block:\n"" + this);
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a vertical line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '-';
    }

    /**
     * Finds the last line of the subblock
     * containing the specified position {@code blockStart}.
     * Returns the coordinate {@code y2} of such block.
     */
    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {
        int nextY = blockStart.y;
        int currentY;
        do {
            currentY = nextY;
            nextY = y2OfAVLineCovering(currentY, vLines);
        } while (nextY > currentY && nextY < y2 - 1);
        return Math.min(y2, nextY + 1);
    }

    /**
     * Finds a vertical line which vertical range covers
     * the specified value {@code y}
     * and which lower point is lower than {@code y}.
     * Returns the position of the last element of such line (inclusive)
     * or {@code y} if such line does not exist.
     */
    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {
        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)
            return line.y2 - 1;
        return y;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long vertical lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {
        removeSmallVLinesFrom(vLines);
        return extractParallelSubblocksSeparatedBy(vLines);
    }

    /**
     * Finds the longest lines in the specified set of vertical lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (VWordPosition line : vLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        VWordPosition line;
        Iterator<VWordPosition> i = vLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {
        List<Block> result = new LinkedList<Block>();
        Block subBlock;
        //the left bound of a subblock
        int leftX = x1;
        //the exclusive right bound of a subblock
        int rightX;
        //(may exist; widens the separator)
        HWordPosition gapAtSeparator = null;
        for (VWordPosition rightSeparator : sortedVLines(separators)) {
            rightX = rightSeparator.x;
            //if the separator has a gap, the latter must be skipped:
            gapAtSeparator = scheme.gapAtLine(rightSeparator);
            if (gapAtSeparator != null)
                rightX = gapAtSeparator.x1;
            //adding the subblock between leftX and rightX:
            if (rightX > leftX + 1) {
                subBlock = subblock(leftX, y1, rightX, y2);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    result.add(subBlock);
            }
            //iterating leftX:
            if (gapAtSeparator == null)
                leftX = rightX + 1;
            else
                leftX = gapAtSeparator.x2;
        }
        //on the right of the last line:
        if (leftX < x2) {
            subBlock = subblock(leftX, y1, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                result.add(subBlock);
        }
        return result;
    }

    /*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {
        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);
        Collections.sort(list);
        return list;
    }

    /**
     * Divides the current block without vertical lines
     * into a set of (optimized) parallel subblocks.
     * Returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstParallelSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components or gaps
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component or gap)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstParallelSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of a word character.
     * @return	the position of the word character found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain word characters.
     */
    private CharPosition firstWordChar() {
        int y = firstWordCharBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstWordCharBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstWordCharBelow(int x, int y) {
        for (; y < y2; y++) if (wordCharAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character.
     * <p>
     * Overrides the less optimal method {@code CharTable.wordCharAt()}.
     * Since all symbols on the scheme are definitely correct
     * (which has been verified in its constructor),
     * there is no need to use slower method.
     */
    public boolean wordCharAt(int x, int y) {
        char c = charAt(x, y);
        return c != ' ' && c != '-' && c != '|' && c != '+';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !wordCharAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }
}
","// VerticalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlock_2Test {","// VerticalBlock_2Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractSequentialSubblocks()} method.
*/
class VerticalBlock_2Test {

	private Scheme scheme;
	private VerticalBlock block;
	private List<Block> result;
	
	@Test
	void test_1() {
		scheme = new Scheme(""""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v"
cmpl-6u4Tq9BJdR3h3MRAxnrJat1XpD5Ef,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_3Test.java,59.322447538375854,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public VerticalBlock(Scheme scheme) {
        super(scheme);
    }

    public VerticalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {
        return new VerticalBlock(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock cloneWith(CharPosition1 p1) {
        return new VerticalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the upper subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive horizontal line
     * does not contain elements of vertical lines
     * starting above the line.
     * <p>
     * The algorithm finds the upper entity
     * (an element of a component, gap, or vertical line)
     * using simple search along the scheme,
     * and retains it as the top of the required block.
     * Then, starting from the height of that point,
     * it sequentially finds vertical lines
     * end below but begin not below
     * and moves to lower end of such lines.
     * The lower end of the last such vertical line defines
     * the bottom of the required block.
     */
    private VerticalBlock extractFirstSequentialSubblock() {
        Set<VWordPosition> vLines = getIntersectingVLines();
        CharPosition blockStart = getBlockStart();
        int y2 = getUpperSubblockEnd(blockStart, vLines);
        return subblock(this.x1, blockStart.y, this.x2, y2);
    }

    /**
     * Returns the set of all vertical lines intersecting this block.
     */
    private Set<VWordPosition> getIntersectingVLines() {
        Set<VWordPosition> source = scheme.getVLinesPositions();
        Set<VWordPosition> result = new HashSet<VWordPosition>();
        for (VWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Finds the upper entity (an element of a word or vertical line)
     * of this block.
     * Returns its position on the scheme.
     * @throws	IllegalArgumentException if this block happens to be empty.
     */
    private CharPosition getBlockStart() {
        int x = x1;
        int y = y1;
        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))
            return new CharPosition(x, y);
        throw new IllegalArgumentException(""Can not extract elements from an empty block:\n"" + this);
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a vertical line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '-';
    }

    /**
     * Finds the last line of the subblock
     * containing the specified position {@code blockStart}.
     * Returns the coordinate {@code y2} of such block.
     */
    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {
        int nextY = blockStart.y;
        int currentY;
        do {
            currentY = nextY;
            nextY = y2OfAVLineCovering(currentY, vLines);
        } while (nextY > currentY && nextY < y2 - 1);
        return Math.min(y2, nextY + 1);
    }

    /**
     * Finds a vertical line which vertical range covers
     * the specified value {@code y}
     * and which lower point is lower than {@code y}.
     * Returns the position of the last element of such line (inclusive)
     * or {@code y} if such line does not exist.
     */
    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {
        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)
            return line.y2 - 1;
        return y;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long vertical lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {
        removeSmallVLinesFrom(vLines);
        return extractParallelSubblocksSeparatedBy(vLines);
    }

    /**
     * Finds the longest lines in the specified set of vertical lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (VWordPosition line : vLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        VWordPosition line;
        Iterator<VWordPosition> i = vLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {
        List<Block> result = new LinkedList<Block>();
        Block subBlock;
        //the left bound of a subblock
        int leftX = x1;
        //the exclusive right bound of a subblock
        int rightX;
        //(may exist; widens the separator)
        HWordPosition gapAtSeparator = null;
        for (VWordPosition rightSeparator : sortedVLines(separators)) {
            rightX = rightSeparator.x;
            //if the separator has a gap, the latter must be skipped:
            gapAtSeparator = scheme.gapAtLine(rightSeparator);
            if (gapAtSeparator != null)
                rightX = gapAtSeparator.x1;
            //adding the subblock between leftX and rightX:
            if (rightX > leftX + 1) {
                subBlock = subblock(leftX, y1, rightX, y2);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    result.add(subBlock);
            }
            //iterating leftX:
            if (gapAtSeparator == null)
                leftX = rightX + 1;
            else
                leftX = gapAtSeparator.x2;
        }
        //on the right of the last line:
        if (leftX < x2) {
            subBlock = subblock(leftX, y1, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                result.add(subBlock);
        }
        return result;
    }

    /*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {
        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);
        Collections.sort(list);
        return list;
    }

    /**
     * Divides the current block without vertical lines
     * into a set of (optimized) parallel subblocks.
     * Returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstParallelSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components or gaps
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component or gap)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstParallelSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of a word character.
     * @return	the position of the word character found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain word characters.
     */
    private CharPosition firstWordChar() {
        int y = firstWordCharBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstWordCharBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstWordCharBelow(int x, int y) {
        for (; y < y2; y++) if (wordCharAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character.
     * <p>
     * Overrides the less optimal method {@code CharTable.wordCharAt()}.
     * Since all symbols on the scheme are definitely correct
     * (which has been verified in its constructor),
     * there is no need to use slower method.
     */
    public boolean wordCharAt(int x, int y) {
        char c = charAt(x, y);
        return c != ' ' && c != '-' && c != '|' && c != '+';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !wordCharAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }
}
","// VerticalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlock_3Test {","// VerticalBlock_3Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#extractParallelSubblocks()} method.
*/
class VerticalBlock_3Test {

	private Scheme scheme;
	private VerticalBlock block;
	private List<Block> result;
	
	@Test
	void test_1() {
		scheme = new Scheme(""""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
				+ ""  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  \n""
"
cmpl-6u4Ut78Zt8P8GqBDZAkuOyc6cF2MC,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/blocks/VerticalBlock_4Test.java,55.32923078536987,length,"// VerticalBlock.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;

/**
 * An implementation of the abstract class {@code Block}
 * used for vertical layouting.
 */
public class VerticalBlock extends Block {

    public VerticalBlock(Scheme scheme, int x1, int y1, int x2, int y2) {
        super(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock(Scheme scheme, CharPosition p1, CharPosition p2) {
        super(scheme, p1, p2);
    }

    public VerticalBlock(Scheme scheme) {
        super(scheme);
    }

    public VerticalBlock(Block b) {
        super(b.scheme, b.getPos1(), b.getPos2());
    }

    public VerticalBlock(Block block, int x1, int y1, int x2, int y2) {
        super(block.scheme, x1, y1, x2, y2);
    }

    public VerticalBlock subblock(int x1, int y1, int x2, int y2) {
        return new VerticalBlock(scheme, x1, y1, x2, y2);
    }

    public VerticalBlock cloneWith(CharPosition1 p1) {
        return new VerticalBlock(scheme, p1, getPos2());
    }

    /**
     * Divides the current block into a set of sequential subblocks,
     * optimizes these subblocks and returns them as a linked list.
     *
     * @return	a list of optimized sequential subblocks.
     */
    public List<Block> extractSequentialSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        List<Block> result = new LinkedList<Block>();
        VerticalBlock firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstSequentialSubblock();
            theRest = theRest.cloneWith(new CharPosition1(this.x1, firstBlock.y2));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the upper subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive horizontal line
     * does not contain elements of vertical lines
     * starting above the line.
     * <p>
     * The algorithm finds the upper entity
     * (an element of a component, gap, or vertical line)
     * using simple search along the scheme,
     * and retains it as the top of the required block.
     * Then, starting from the height of that point,
     * it sequentially finds vertical lines
     * end below but begin not below
     * and moves to lower end of such lines.
     * The lower end of the last such vertical line defines
     * the bottom of the required block.
     */
    private VerticalBlock extractFirstSequentialSubblock() {
        Set<VWordPosition> vLines = getIntersectingVLines();
        CharPosition blockStart = getBlockStart();
        int y2 = getUpperSubblockEnd(blockStart, vLines);
        return subblock(this.x1, blockStart.y, this.x2, y2);
    }

    /**
     * Returns the set of all vertical lines intersecting this block.
     */
    private Set<VWordPosition> getIntersectingVLines() {
        Set<VWordPosition> source = scheme.getVLinesPositions();
        Set<VWordPosition> result = new HashSet<VWordPosition>();
        for (VWordPosition line : source) if (line.intersects(this))
            result.add(line);
        return result;
    }

    /**
     * Finds the upper entity (an element of a word or vertical line)
     * of this block.
     * Returns its position on the scheme.
     * @throws	IllegalArgumentException if this block happens to be empty.
     */
    private CharPosition getBlockStart() {
        int x = x1;
        int y = y1;
        for (; y < y2; y++) for (x = x1; x < x2; x++) if (entityAt(x, y))
            return new CharPosition(x, y);
        throw new IllegalArgumentException(""Can not extract elements from an empty block:\n"" + this);
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character or a vertical line character.
     */
    private boolean entityAt(int x, int y) {
        char c = charAt(x, y);
        /* 
		 * Since all symbols on the scheme are correct
		 * (which has been verified in its constructor),
		 * there is no need to use the slower method isWordChar().
		 */
        return c != ' ' && c != '-';
    }

    /**
     * Finds the last line of the subblock
     * containing the specified position {@code blockStart}.
     * Returns the coordinate {@code y2} of such block.
     */
    private int getUpperSubblockEnd(CharPosition blockStart, Set<VWordPosition> vLines) {
        int nextY = blockStart.y;
        int currentY;
        do {
            currentY = nextY;
            nextY = y2OfAVLineCovering(currentY, vLines);
        } while (nextY > currentY && nextY < y2 - 1);
        return Math.min(y2, nextY + 1);
    }

    /**
     * Finds a vertical line which vertical range covers
     * the specified value {@code y}
     * and which lower point is lower than {@code y}.
     * Returns the position of the last element of such line (inclusive)
     * or {@code y} if such line does not exist.
     */
    private int y2OfAVLineCovering(int y, Set<VWordPosition> vLines) {
        for (VWordPosition line : vLines) if (line.y1 <= y && y + 1 < line.y2)
            return line.y2 - 1;
        return y;
    }

    /**
     * Divides the current block into a set of parallel subblocks,
     * optimizes these subblocks and returns them as a linked list.
     * <p>
     * If the block has vertical lines,
     * this method divides the block by the maximal vertical lines only.
     * <p>
     * If there are no vertical lines, the block is divided into
     * usual parallel subblocks.
     */
    public List<Block> extractParallelSubblocks() {
        this.optimize();
        if (isTrivial())
            return new LinkedList<Block>();
        Set<VWordPosition> vLines = getIntersectingVLines();
        if (vLines.size() > 0)
            return extractParallelSubblocksSeparatedByLines(vLines);
        else
            return extractParallelSubblocksWithoutLines();
    }

    /**
     * Divides the current block into a set of parallel subblocks
     * by its most long vertical lines,
     * optimizes these subblocks, and returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksSeparatedByLines(Set<VWordPosition> vLines) {
        removeSmallVLinesFrom(vLines);
        return extractParallelSubblocksSeparatedBy(vLines);
    }

    /**
     * Finds the longest lines in the specified set of vertical lines
     * and then removes from it all other elements.
     * <p>
     * Note that, more formally, this method considers the lengths
     * of <i>intersections</i> of the lines with this block.
     */
    private void removeSmallVLinesFrom(Set<VWordPosition> vLines) {
        //determine the maximum length:
        int maxLength = 0;
        int length;
        for (VWordPosition line : vLines) {
            length = line.getLengthInsideOf(this);
            maxLength = Math.max(length, maxLength);
        }
        //remove the short lines:
        VWordPosition line;
        Iterator<VWordPosition> i = vLines.iterator();
        for (; i.hasNext(); ) {
            line = i.next();
            if (line.getLengthInsideOf(this) < maxLength)
                i.remove();
        }
    }

    private List<Block> extractParallelSubblocksSeparatedBy(Set<VWordPosition> separators) {
        List<Block> result = new LinkedList<Block>();
        Block subBlock;
        //the left bound of a subblock
        int leftX = x1;
        //the exclusive right bound of a subblock
        int rightX;
        //(may exist; widens the separator)
        HWordPosition gapAtSeparator = null;
        for (VWordPosition rightSeparator : sortedVLines(separators)) {
            rightX = rightSeparator.x;
            //if the separator has a gap, the latter must be skipped:
            gapAtSeparator = scheme.gapAtLine(rightSeparator);
            if (gapAtSeparator != null)
                rightX = gapAtSeparator.x1;
            //adding the subblock between leftX and rightX:
            if (rightX > leftX + 1) {
                subBlock = subblock(leftX, y1, rightX, y2);
                subBlock.optimize();
                if (!subBlock.isTrivial())
                    result.add(subBlock);
            }
            //iterating leftX:
            if (gapAtSeparator == null)
                leftX = rightX + 1;
            else
                leftX = gapAtSeparator.x2;
        }
        //on the right of the last line:
        if (leftX < x2) {
            subBlock = subblock(leftX, y1, x2, y2);
            subBlock.optimize();
            if (!subBlock.isTrivial())
                result.add(subBlock);
        }
        return result;
    }

    /*
	 * Returns a list of the specified vertical lines
	 * sorted according to the horizontal coordinates.
	 */
    private List<VWordPosition> sortedVLines(Set<VWordPosition> vLines) {
        LinkedList<VWordPosition> list = new LinkedList<VWordPosition>(vLines);
        Collections.sort(list);
        return list;
    }

    /**
     * Divides the current block without vertical lines
     * into a set of (optimized) parallel subblocks.
     * Returns them as a linked list.
     */
    protected List<Block> extractParallelSubblocksWithoutLines() {
        List<Block> result = new LinkedList<Block>();
        Block firstBlock;
        VerticalBlock theRest = this;
        do {
            firstBlock = theRest.extractFirstParallelSubblock();
            theRest = theRest.cloneWith(new CharPosition1(firstBlock.x2, this.y1));
            firstBlock.optimize();
            if (!firstBlock.isTrivial())
                result.add(firstBlock);
            theRest.optimize();
        } while (!theRest.isTrivial());
        return result;
    }

    /**
     * Extracts the left subblock of this block.
     * <p>
     * The required block is chosen so that its last exclusive vertical line
     * does not contain elements of components or gaps
     * starting on the left from the line.
     * <p>
     * The algorithm just finds the most left entity
     * (an element of a component or gap)
     * using simple search along the scheme,
     * identifies the horizontal element containing the entity found,
     * checks whether the last exclusive vertical line of the element
     * matches the requirement for the boundary of the required block,
     * and, if does not, takes the detaining horizontal element
     * and continues the cycle.
     */
    private Block extractFirstParallelSubblock() {
        final HWordPosition firstWord = scheme.anyHElementAt(firstWordChar());
        HWordPosition lastWord = firstWord;
        HWordPosition nextWord = firstWord;
        for (; nextWord != null; ) {
            lastWord = nextWord;
            nextWord = findAWordExtendingSubblockToTheRightFrom(nextWord);
        }
        int startX = firstWord.x1;
        int endX = lastWord.x2;
        //For the case of words containing cells outside of this block:
        startX = Math.max(startX, x1);
        endX = Math.min(endX, x2);
        return subblock(startX, y1, endX, y2);
    }

    /**
     * Searches down and to the right from the beginning of this block
     * for the first occurrence of a word character.
     * @return	the position of the word character found.
     * @throws	IllegalArgumentException if this block
     * 			does not contain word characters.
     */
    private CharPosition firstWordChar() {
        int y = firstWordCharBelow(x1, y1);
        if (y != y2)
            return new CharPosition(x1, y);
        int x = x1 + 1;
        for (; x < x2; x++) {
            y = firstWordCharBelow(x, y1);
            if (y != y2)
                break;
        }
        if (x != x2)
            return new CharPosition(x, y);
        else
            throw new IllegalArgumentException(""Can not extract a group from an empty block:\n"" + this);
    }

    /**
     * Finds the first entity below the specified position.
     * @return	the y-coordinate of the entity found or y2 if not found.
     */
    private int firstWordCharBelow(int x, int y) {
        for (; y < y2; y++) if (wordCharAt(x, y))
            break;
        return y;
    }

    /**
     * Verifies whether the character under the cell
     * determined by the specified coordinates
     * is a word character.
     * <p>
     * Overrides the less optimal method {@code CharTable.wordCharAt()}.
     * Since all symbols on the scheme are definitely correct
     * (which has been verified in its constructor),
     * there is no need to use slower method.
     */
    public boolean wordCharAt(int x, int y) {
        char c = charAt(x, y);
        return c != ' ' && c != '-' && c != '|' && c != '+';
    }

    /**
     * Returns a word which starts not righter than the right end of the
     * {@code currentWord} but ends strictly righter
     * (or null if does not exist).
     */
    private HWordPosition findAWordExtendingSubblockToTheRightFrom(HWordPosition currentWord) {
        int x = currentWord.x2 - 1;
        int y = y1;
        int yToSkip = currentWord.y;
        HWordPosition result;
        for (; y < y2; y++) {
            if (y == yToSkip || !wordCharAt(x, y))
                continue;
            result = scheme.anyHElementAt(x, y);
            if (result == null)
                continue;
            if (result.x2 > currentWord.x2)
                return result;
        }
        return null;
    }
}
","// VerticalBlock_4Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#wordCharAt(int, int)} method.
*/
class VerticalBlock_4Test {","// VerticalBlock_4Test.java
package glengineer.blocks;

import glengineer.positions.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VerticalBlock}.
* It contains ten unit test cases for the {@link VerticalBlock#wordCharAt(int, int)} method.
*/
class VerticalBlock_4Test {

	private static final String[] TEST_SCHEMES = {
		""  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  | "
cmpl-6u4VwcSWCSo1eXCYuLULsTt3W61Ok,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPosition_3Test.java,43.854127645492554,length,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * The horizontal coordinate of the word start.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the word end + 1.
     */
    public final int x2;

    /**
     * The vertical coordinate of the word.
     */
    public final int y;

    public HWordPosition(int x1, int x2, int y) {
        if (x1 > x2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x1 = x1;
        this.x2 = x2;
        this.y = y;
    }

    public HWordPosition(CharPosition start, int x2) {
        this(start.x, x2, start.y);
    }

    public HWordPosition(int x1, CharPosition end) {
        this(x1, end.x, end.y);
    }

    /**
     * The word position is initialized
     * representing the upper line of the specified block.
     */
    public HWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public HWordPosition(CharPosition cp) {
        this(cp.x, cp.x, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x1, y);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x2, y);
    }

    public int getWidth() {
        return x2 - x1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof HWordPosition))
            return false;
        HWordPosition hwp = (HWordPosition) wp;
        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;
    }

    public boolean isTrivial() {
        return x1 >= x2;
    }

    public boolean contains(int x, int y) {
        return y == this.y && x1 <= x && x < x2;
    }

    public boolean liesIn(CharTable ct) {
        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;
    }

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);
        return Math.max(width, 0);
    }

    public String toString() {
        return ""horizontal("" + x1 + "","" + x2 + "";"" + y + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// HWordPosition_3Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#intersects(CharTable)} method.
*/
class HWordPosition_3Test {","// HWordPosition_3Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#intersects(CharTable)} method.
*/
class HWordPosition_3Test {

	/**
	 * The first test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test1() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertTrue(hwp.intersects(block));
	}
	
	/**
	 * The second test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test2() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(5, 6, 7, 8)));
	}
	
	/**
	 * The third test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test3() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(0, 1, 3, 4)));
	}
	
	/**
	 * The fourth test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test4() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(2, 3, 3, 4)));
	}
	
	/**
	 * The fifth test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test5() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(1, 2, 2, 3)));
	}
	
	/**
	 * The sixth test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test6() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(1, 2, 4, 5)));
	}
	
	/**
	 * The seventh test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test7() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(0, 1, 2, 3)));
	}
	
	/**
	 * The eighth test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test8() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(2, 3, 2, 3)));
	}
	
	/**
	 * The ninth test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test9() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(0, 1, 4, 5)));
	}
	
	/**
	 * The tenth test case.
	 * The word position is initialized
	 * representing the upper line of the specified block.
	 */
	@Test
	void test10() {
		Block block = new Block(1, 2, 3, 4);
		HWordPosition hwp = new HWordPosition(block);
		assertFalse(hwp.intersects(new Block(2, 3, 4, 5)));
	}
}</code>



I have a problem with the test cases. I have to write 10 test cases for the method <code>intersects(CharTable ct)</code> of the class <code>HWordPosition</code>. I have written 10 test cases, but I am not sure if they are correct.
I have to test the method <code>intersects(CharTable ct)</code> of the class <code>HWordPosition</code>.
The method <code>intersects(CharTable ct)</code> returns <code>true</code> if the specified char table intersects this word position, and <code>false</code> otherwise.
The method <code>intersects(CharTable ct)</code> is defined as follows:
<code>public boolean intersects(CharTable ct) {
    return ct.y1 &lt;= y &amp;&amp; y &lt; ct.y2 &amp;&amp; ct.x1 &lt; x2 &amp;&amp; x1 &lt; ct.x2;
}
</code>
The class <code>CharTable</code> is defined as follows:
<code>public class CharTable {

    /**
     * The horizontal coordinate of the left border of the char table.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the right border of the char table + 1.
     */
    public final int x2;

    /**
     * The vertical coordinate of the upper border of the char table.
     */
    public final int y1;

    /**
     * The vertical coordinate of the lower border of the char table + 1.
     */
    public final int y2;

    public CharTable(int x1, int x2, int y1, int y2) {
        if (x1 &gt; x2 || y1 &gt; y2)
            throw new IllegalArgumentException(""wrong char table parameters"");
        this.x1 = x1;
        this.x2 = x2;
        this.y1 = y1;
        this.y2 = y2;
    }

    public CharTable(CharPosition1 pos1, CharPosition2 pos2) {
        this(pos1.x, pos2.x, pos1.y, pos2.y);
    }

    public CharTable(CharPosition1 pos1, int x2, int y2) {
        this(pos1.x, x2, pos1.y, y2);
    }

    public CharTable(int x1, int y1, CharPosition2 pos2) {
        this(x1, pos2.x, y1, pos2.y);
    }

    public CharTable(CharPosition1 pos1, int x2, CharPosition2 pos2) {
        this(pos1.x, x2, pos1.y, pos2.y);
    }

    public CharTable(int x1, CharPosition2 pos2, int y2) {
        this(x1, pos2.x, pos2.y, y2);
    }

    public CharTable(CharPosition1 pos1, int y1, CharPosition2 pos2) {
        this(pos1.x, pos2.x, y1, pos2.y);
    }

    public CharTable(int x1, int y1, int x2, int y2) {
        this(new CharPosition1(x1, y1), new CharPosition2(x2, y2));
    }

    public CharTable(CharPosition1 pos1, CharPosition2 pos2, int width) {
        this(pos1.x, pos1.y, pos1.x + width, pos2.y);
    }

    public CharTable(CharPosition1 pos1, int width, CharPosition2 pos2) {
        this(pos1.x, pos1.y, pos1.x + width, pos2.y);
    }

    public CharTable("
cmpl-6u4WzZiGQXQqSs8K87Aw33P2U5uRq,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPosition_4Test.java,52.36469507217407,length,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * The horizontal coordinate of the word start.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the word end + 1.
     */
    public final int x2;

    /**
     * The vertical coordinate of the word.
     */
    public final int y;

    public HWordPosition(int x1, int x2, int y) {
        if (x1 > x2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x1 = x1;
        this.x2 = x2;
        this.y = y;
    }

    public HWordPosition(CharPosition start, int x2) {
        this(start.x, x2, start.y);
    }

    public HWordPosition(int x1, CharPosition end) {
        this(x1, end.x, end.y);
    }

    /**
     * The word position is initialized
     * representing the upper line of the specified block.
     */
    public HWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public HWordPosition(CharPosition cp) {
        this(cp.x, cp.x, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x1, y);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x2, y);
    }

    public int getWidth() {
        return x2 - x1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof HWordPosition))
            return false;
        HWordPosition hwp = (HWordPosition) wp;
        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;
    }

    public boolean isTrivial() {
        return x1 >= x2;
    }

    public boolean contains(int x, int y) {
        return y == this.y && x1 <= x && x < x2;
    }

    public boolean liesIn(CharTable ct) {
        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;
    }

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);
        return Math.max(width, 0);
    }

    public String toString() {
        return ""horizontal("" + x1 + "","" + x2 + "";"" + y + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// HWordPosition_4Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#getLengthInsideOf(Block)} method.
*/
class HWordPosition_4Test {","// HWordPosition_4Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#getLengthInsideOf(Block)} method.
*/
class HWordPosition_4Test {

	@Test
	void test_getLengthInsideOf_1() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(0, 10, 0, 10);
		assertEquals(10, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_2() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(5, 15, 0, 10);
		assertEquals(5, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_3() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(10, 20, 0, 10);
		assertEquals(0, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_4() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(0, 5, 0, 10);
		assertEquals(5, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_5() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(5, 10, 0, 10);
		assertEquals(5, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_6() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(0, 10, 0, 10);
		assertEquals(10, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_7() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(0, 10, 0, 10);
		assertEquals(10, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_8() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(0, 10, 0, 10);
		assertEquals(10, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_9() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(0, 10, 0, 10);
		assertEquals(10, wp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_10() {
		HWordPosition wp = new HWordPosition(0, 10, 0);
		Block block = new Block(0, 10, 0, 10);
		assertEquals(10, wp.getLengthInsideOf(block));
	}
}</code>



I have a class <code>HWordPosition</code> which has a method <code>getLengthInsideOf</code>.
I have a test class <code>HWordPosition_4Test</code> which has ten test cases for the <code>getLengthInsideOf</code> method.
I want to refactor the test class to make it more readable.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common code into a method.
I want to extract the common"
cmpl-6u4Y2BWeFQOUXXPSWRqgHhVRk4Ax0,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/HWordPosition_5Test.java,11.62601900100708,stop,"// HWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying horizontally on the scheme.
 */
public class HWordPosition extends WordPosition {

    /**
     * The horizontal coordinate of the word start.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the word end + 1.
     */
    public final int x2;

    /**
     * The vertical coordinate of the word.
     */
    public final int y;

    public HWordPosition(int x1, int x2, int y) {
        if (x1 > x2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x1 = x1;
        this.x2 = x2;
        this.y = y;
    }

    public HWordPosition(CharPosition start, int x2) {
        this(start.x, x2, start.y);
    }

    public HWordPosition(int x1, CharPosition end) {
        this(x1, end.x, end.y);
    }

    /**
     * The word position is initialized
     * representing the upper line of the specified block.
     */
    public HWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public HWordPosition(CharPosition cp) {
        this(cp.x, cp.x, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x1, y);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x2, y);
    }

    public int getWidth() {
        return x2 - x1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof HWordPosition))
            return false;
        HWordPosition hwp = (HWordPosition) wp;
        return hwp.x1 == x1 && hwp.x2 == x2 && hwp.y == y;
    }

    public boolean isTrivial() {
        return x1 >= x2;
    }

    public boolean contains(int x, int y) {
        return y == this.y && x1 <= x && x < x2;
    }

    public boolean liesIn(CharTable ct) {
        return x1 >= ct.x1 && x2 <= ct.x2 && y >= ct.y1 && y < ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.y1 <= y && y < ct.y2 && ct.x1 < x2 && x1 < ct.x2;
    }

    /**
     * Returns the width of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int width = Math.min(x2, block.x2) - Math.max(x1, block.x1);
        return Math.max(width, 0);
    }

    public String toString() {
        return ""horizontal("" + x1 + "","" + x2 + "";"" + y + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// HWordPosition_5Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPosition_5Test {","// HWordPosition_5Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HWordPosition}.
* It contains ten unit test cases for the {@link HWordPosition#textAt(CharTable)} method.
*/
class HWordPosition_5Test {

	/**
	 * The char table used in the tests.
	 */
	private static final CharTable ct = new CharTable(
			new String[] {
					""abcdefghijklmnopqrstuvwxyz"",
					""ABCDEFGHIJKLMNOPQRSTUVWXYZ"",
					""0123456789"",
					""`~!@#$%^&amp;*()_+-=[]{}\\|;:'\"",./&lt;&gt;?""
			}
	);
	
	/**
	 * The word positions used in the tests.
	 */
	private static final HWordPosition[] wps = new HWordPosition[] {
			new HWordPosition(0, 0, 0),
			new HWordPosition(0, 1, 0),
			new HWordPosition(0, 2, 0),
			new HWordPosition(0, 3, 0),
			new HWordPosition(0, 4, 0),
			new HWordPosition(0, 5, 0),
			new HWordPosition(0, 6, 0),
			new HWordPosition(0, 7, 0),
			new HWordPosition(0, 8, 0),
			new HWordPosition(0, 9, 0)
	};
	
	/**
	 * The expected texts used in the tests.
	 */
	private static final String[] texts = new String[] {
			"""",
			""a"",
			""ab"",
			""abc"",
			""abcd"",
			""abcde"",
			""abcdef"",
			""abcdefg"",
			""abcdefgh"",
			""abcdefghi""
	};
	
	/**
	 * Tests the {@link HWordPosition#textAt(CharTable)} method.
	 */
	@Test
	void testTextAt() {
		for (int i = 0; i &lt; wps.length; i++) {
			assertEquals(texts[i], wps[i].textAt(ct));
		}
	}
}</code></pre>
</div>
</div>

</code>
"
cmpl-6u4Z5BjjsdxbzfT3EKUI8rk3zHXLd,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPosition_3Test.java,51.01299285888672,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * The horizontal coordinate of the word.
     */
    public final int x;

    /**
     * The vertical coordinate of the word start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the word end + 1.
     */
    public final int y2;

    public VWordPosition(int x, int y1, int y2) {
        if (y1 > y2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x = x;
        this.y1 = y1;
        this.y2 = y2;
    }

    public VWordPosition(CharPosition start, int y2) {
        this(start.x, start.y, y2);
    }

    public VWordPosition(int y, CharPosition end) {
        this(end.x, y, end.y);
    }

    public VWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public VWordPosition(CharPosition cp) {
        this(cp.x, cp.y, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x, y1);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x, y2);
    }

    public int getHeight() {
        return y2 - y1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof VWordPosition))
            return false;
        VWordPosition hwp = (VWordPosition) wp;
        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;
    }

    public boolean isTrivial() {
        return y1 >= y2;
    }

    public boolean contains(int x, int y) {
        return x == this.x && y1 <= y && y < y2;
    }

    public boolean liesIn(CharTable ct) {
        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;
    }

    /**
     * Returns the height of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);
        return Math.max(height, 0);
    }

    /**
     * Compares this vertical position with the specified one
     * according to their x-coordinates.
     */
    public int compareTo(VWordPosition vLine) {
        int xx = vLine.x;
        if (x < xx)
            return -1;
        else if (x == xx)
            return 0;
        else
            return +1;
    }

    public String toString() {
        return ""vertical("" + x + "";"" + y1 + "","" + y2 + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPosition_3Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#intersects(CharTable)} method.
*/
class VWordPosition_3Test {","// VWordPosition_3Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#intersects(CharTable)} method.
*/
class VWordPosition_3Test {

	/**
	 * Test case 1.
	 * The word position is inside the char table.
	 */
	@Test
	void testIntersects_1() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, 2, 8);
		assertTrue(vwp.intersects(ct));
	}
	
	/**
	 * Test case 2.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_2() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, 12, 18);
		assertFalse(vwp.intersects(ct));
	}
	
	/**
	 * Test case 3.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_3() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, -2, 2);
		assertFalse(vwp.intersects(ct));
	}
	
	/**
	 * Test case 4.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_4() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(-2, 2, 8);
		assertFalse(vwp.intersects(ct));
	}
	
	/**
	 * Test case 5.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_5() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(12, 2, 8);
		assertFalse(vwp.intersects(ct));
	}
	
	/**
	 * Test case 6.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_6() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, 2, 8);
		assertTrue(vwp.intersects(ct));
	}
	
	/**
	 * Test case 7.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_7() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, 2, 8);
		assertTrue(vwp.intersects(ct));
	}
	
	/**
	 * Test case 8.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_8() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, 2, 8);
		assertTrue(vwp.intersects(ct));
	}
	
	/**
	 * Test case 9.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_9() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, 2, 8);
		assertTrue(vwp.intersects(ct));
	}
	
	/**
	 * Test case 10.
	 * The word position is outside the char table.
	 */
	@Test
	void testIntersects_10() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		VWordPosition vwp = new VWordPosition(5, 2, 8);
		assertTrue(vwp.intersects(ct));
	}
}</code>



I have a class <code>VWordPosition</code> which has a method <code>intersects</code>. I have written 10 unit test cases for this method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10 unit test cases for the <code>intersects</code> method.
I have a class <code>VWordPosition_3Test</code> which contains 10"
cmpl-6u4a9MFuPDtScj2BqkMPnTh3zDlle,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPosition_4Test.java,39.60784864425659,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * The horizontal coordinate of the word.
     */
    public final int x;

    /**
     * The vertical coordinate of the word start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the word end + 1.
     */
    public final int y2;

    public VWordPosition(int x, int y1, int y2) {
        if (y1 > y2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x = x;
        this.y1 = y1;
        this.y2 = y2;
    }

    public VWordPosition(CharPosition start, int y2) {
        this(start.x, start.y, y2);
    }

    public VWordPosition(int y, CharPosition end) {
        this(end.x, y, end.y);
    }

    public VWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public VWordPosition(CharPosition cp) {
        this(cp.x, cp.y, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x, y1);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x, y2);
    }

    public int getHeight() {
        return y2 - y1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof VWordPosition))
            return false;
        VWordPosition hwp = (VWordPosition) wp;
        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;
    }

    public boolean isTrivial() {
        return y1 >= y2;
    }

    public boolean contains(int x, int y) {
        return x == this.x && y1 <= y && y < y2;
    }

    public boolean liesIn(CharTable ct) {
        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;
    }

    /**
     * Returns the height of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);
        return Math.max(height, 0);
    }

    /**
     * Compares this vertical position with the specified one
     * according to their x-coordinates.
     */
    public int compareTo(VWordPosition vLine) {
        int xx = vLine.x;
        if (x < xx)
            return -1;
        else if (x == xx)
            return 0;
        else
            return +1;
    }

    public String toString() {
        return ""vertical("" + x + "";"" + y1 + "","" + y2 + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPosition_4Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#getLengthInsideOf(Block)} method.
*/
class VWordPosition_4Test {","// VWordPosition_4Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#getLengthInsideOf(Block)} method.
*/
class VWordPosition_4Test {

	@Test
	void test_getLengthInsideOf_1() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, 0, 10, 10);
		assertEquals(10, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_2() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, 5, 10, 10);
		assertEquals(5, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_3() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, 10, 10, 10);
		assertEquals(0, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_4() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, -5, 10, 10);
		assertEquals(0, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_5() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, -5, 10, 5);
		assertEquals(0, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_6() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, -5, 10, 0);
		assertEquals(0, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_7() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, 5, 10, 15);
		assertEquals(5, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_8() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, 10, 10, 15);
		assertEquals(0, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_9() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, 15, 10, 15);
		assertEquals(0, vwp.getLengthInsideOf(block));
	}
	
	@Test
	void test_getLengthInsideOf_10() {
		VWordPosition vwp = new VWordPosition(0, 0, 10);
		Block block = new Block(0, 15, 10, 20);
		assertEquals(0, vwp.getLengthInsideOf(block));
	}
}</code>



I have a class <code>VWordPosition</code> which encapsulates the position (start and end coordinates) of a word lying vertically on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the height of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>VWordPosition_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>HWordPosition</code> which encapsulates the position (start and end coordinates) of a word lying horizontally on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the width of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>HWordPosition_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>WordPosition</code> which encapsulates the position (start and end coordinates) of a word lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>WordPosition_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>CharPosition</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>CharPosition_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>CharPosition1</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>CharPosition1_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>CharPosition2</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>CharPosition2_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>CharTable</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>CharTable_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>Block</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>Block_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>Line</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>Line_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>Line1</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected.
I have a test class <code>Line1_4Test</code> which contains ten unit test cases for the <code>getLengthInsideOf</code> method.
I have a class <code>Line2</code> which encapsulates the position (start and end coordinates) of a character lying on the scheme.
I have a method <code>getLengthInsideOf</code> which returns the length of the intersection of this line with the specified block or <code>0</code> if they are not intersected."
cmpl-6u4bBrPVCwuKfbvByDHyuw02FI0lA,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPosition_5Test.java,45.9358127117157,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * The horizontal coordinate of the word.
     */
    public final int x;

    /**
     * The vertical coordinate of the word start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the word end + 1.
     */
    public final int y2;

    public VWordPosition(int x, int y1, int y2) {
        if (y1 > y2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x = x;
        this.y1 = y1;
        this.y2 = y2;
    }

    public VWordPosition(CharPosition start, int y2) {
        this(start.x, start.y, y2);
    }

    public VWordPosition(int y, CharPosition end) {
        this(end.x, y, end.y);
    }

    public VWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public VWordPosition(CharPosition cp) {
        this(cp.x, cp.y, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x, y1);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x, y2);
    }

    public int getHeight() {
        return y2 - y1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof VWordPosition))
            return false;
        VWordPosition hwp = (VWordPosition) wp;
        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;
    }

    public boolean isTrivial() {
        return y1 >= y2;
    }

    public boolean contains(int x, int y) {
        return x == this.x && y1 <= y && y < y2;
    }

    public boolean liesIn(CharTable ct) {
        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;
    }

    /**
     * Returns the height of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);
        return Math.max(height, 0);
    }

    /**
     * Compares this vertical position with the specified one
     * according to their x-coordinates.
     */
    public int compareTo(VWordPosition vLine) {
        int xx = vLine.x;
        if (x < xx)
            return -1;
        else if (x == xx)
            return 0;
        else
            return +1;
    }

    public String toString() {
        return ""vertical("" + x + "";"" + y1 + "","" + y2 + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPosition_5Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#compareTo(VWordPosition)} method.
*/
class VWordPosition_5Test {","// VWordPosition_5Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#compareTo(VWordPosition)} method.
*/
class VWordPosition_5Test {

	@Test
	void testCompareTo() {
		CharTable ct = new CharTable(0, 0, 10, 10);
		Block b1 = new Block(ct, new CharPosition(0, 0), new CharPosition(9, 9));
		Block b2 = new Block(ct, new CharPosition(1, 1), new CharPosition(8, 8));
		Block b3 = new Block(ct, new CharPosition(2, 2), new CharPosition(7, 7));
		Block b4 = new Block(ct, new CharPosition(3, 3), new CharPosition(6, 6));
		Block b5 = new Block(ct, new CharPosition(4, 4), new CharPosition(5, 5));
		
		VWordPosition v1 = new VWordPosition(b1);
		VWordPosition v2 = new VWordPosition(b2);
		VWordPosition v3 = new VWordPosition(b3);
		VWordPosition v4 = new VWordPosition(b4);
		VWordPosition v5 = new VWordPosition(b5);
		
		assertEquals(0, v1.compareTo(v1));
		assertEquals(-1, v1.compareTo(v2));
		assertEquals(-1, v1.compareTo(v3));
		assertEquals(-1, v1.compareTo(v4));
		assertEquals(-1, v1.compareTo(v5));
		
		assertEquals(+1, v2.compareTo(v1));
		assertEquals(0, v2.compareTo(v2));
		assertEquals(-1, v2.compareTo(v3));
		assertEquals(-1, v2.compareTo(v4));
		assertEquals(-1, v2.compareTo(v5));
		
		assertEquals(+1, v3.compareTo(v1));
		assertEquals(+1, v3.compareTo(v2));
		assertEquals(0, v3.compareTo(v3));
		assertEquals(-1, v3.compareTo(v4));
		assertEquals(-1, v3.compareTo(v5));
		
		assertEquals(+1, v4.compareTo(v1));
		assertEquals(+1, v4.compareTo(v2));
		assertEquals(+1, v4.compareTo(v3));
		assertEquals(0, v4.compareTo(v4));
		assertEquals(-1, v4.compareTo(v5));
		
		assertEquals(+1, v5.compareTo(v1));
		assertEquals(+1, v5.compareTo(v2));
		assertEquals(+1, v5.compareTo(v3));
		assertEquals(+1, v5.compareTo(v4));
		assertEquals(0, v5.compareTo(v5));
	}
}</code></pre>
</div>
</div>

</div>
</div>

</div>
<div class=""cell border-box-sizing code_cell rendered"">
<div class=""input"">
<div class=""prompt input_prompt"">In&nbsp;[&nbsp;]:</div>
<div class=""inner_cell"">
    <div class=""input_area"">
<div class="" highlight hl-ipython3""><pre><span></span><span class=""n"">VWordPosition_5Test</span><span class=""o"">.</span><span class=""n"">testCompareTo</span><span class=""p"">()</span>
</pre></div>

    </div>
</div>
</div>

<div class=""output_wrapper"">
<div class=""output"">


<div class=""output_area"">

    <div class=""prompt""></div>




</div>

</div>
</div>

</div>
<div class=""cell border-box-sizing text_cell rendered""><div class=""prompt input_prompt"">
</div><div class=""inner_cell"">
<div class=""text_cell_render border-box-sizing rendered_html"">
<h3 id=""---"">   <a class=""anchor-link"" href=""#---"">&#182;</a></h3>
</div>
</div>
</div>
<div class=""cell border-box-sizing code_cell rendered"">
<div class=""input"">
<div class=""prompt input_prompt"">In&nbsp;[&nbsp;]:</div>
<div class=""inner_cell"">
    <div class=""input_area"">
<div class="" highlight hl-ipython3""><pre><span></span><span class=""c1"">// HWordPosition.java</span>
<span class=""k"">package</span> <span class=""n"">glengineer</span><span class=""o"">.</span><span class=""na"">positions</span><span class=""o"">;</span>

<span class=""k"">import</span> <span class=""n"">glengineer</span><span class=""o"">.</span><span class=""na"">blocks</span><span class=""o"">.</span><span class=""na"">Block</span><span class=""o"">;</span>
<span class=""k"">import</span> <span class=""n"">glengineer</span><span class=""o"">.</span><span class=""na"">blocks</span><span class=""o"">.</span><span class=""na"">CharTable</span><span class=""o"">;</span>

<span class=""c1"">/**</span>
<span class=""c1""> * Encapsulates the position (start and end coordinates)</span>
<span class=""c1""> * of a word lying horizontally on the scheme.</span>
<span class=""c1""> */</span>
<span class=""k"">public</span> <span class=""k"">class</span> <span class=""nc"">HWordPosition</span> <span class=""k"">extends</span> <span class=""n"">WordPosition</span> <span class=""k"">implements</span> <span class=""n"">Comparable</span><span class=""o"">&lt;</span><span class=""n"">HWordPosition</span><span class=""o"">&gt;</span> <span class=""o"">{</span>

    <span class=""c1"">/**</span>
<span class=""c1"">     * The vertical coordinate of the word.</span>
<span class=""c1"">     */</span>
    <span class=""k"">public</span> <span class=""k"">final</span> <span class=""kt"">int</span> <span class=""n"">y</span><span class=""o"">;</span>

    <span class=""c1"">/**</span>
<span class=""c1"">     * The horizontal coordinate of the word start.</span>
<span class=""c1"">     */</span>
    <span class=""k"">public</span> <span class=""k"">final</span> <span class=""kt"">int</span> <span class=""n"">x1</span><span class=""o"">;</span>

    <span class=""c1"">/**</span>
<span class=""c1"">     * The horizontal coordinate of the word end + 1.</span>
<span class=""c1"">     */</span>
    <span class=""k"">public</span> <span class=""k"">final</span> <span class=""kt"">int</span> <span class=""n"">x2</span><span class=""o"">;</span>

    <span class="""
cmpl-6u4cEEDC8dcviCAFQ13iEpqETw4Mt,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/positions/VWordPosition_6Test.java,51.82737874984741,length,"// VWordPosition.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;

/**
 * Encapsulates the position (start and end coordinates)
 * of a word lying vertically on the scheme.
 */
public class VWordPosition extends WordPosition implements Comparable<VWordPosition> {

    /**
     * The horizontal coordinate of the word.
     */
    public final int x;

    /**
     * The vertical coordinate of the word start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the word end + 1.
     */
    public final int y2;

    public VWordPosition(int x, int y1, int y2) {
        if (y1 > y2)
            throw new IllegalArgumentException(""wrong word position parameters"");
        this.x = x;
        this.y1 = y1;
        this.y2 = y2;
    }

    public VWordPosition(CharPosition start, int y2) {
        this(start.x, start.y, y2);
    }

    public VWordPosition(int y, CharPosition end) {
        this(end.x, y, end.y);
    }

    public VWordPosition(Block block) {
        this(block.getPos1(), block.getPos2().x);
    }

    /**
     * Creates a trivial word position
     * which begins and ends at the specified character position.
     */
    public VWordPosition(CharPosition cp) {
        this(cp.x, cp.y, cp.y);
    }

    /**
     * Returns the coordinates of the beginning of this word.
     */
    public CharPosition1 getStart() {
        return new CharPosition1(x, y1);
    }

    /**
     * Returns the coordinates of the ending of this word (exclusive).
     */
    public CharPosition2 getEnd() {
        return new CharPosition2(x, y2);
    }

    public int getHeight() {
        return y2 - y1;
    }

    public boolean equals(WordPosition wp) {
        if (!(wp instanceof VWordPosition))
            return false;
        VWordPosition hwp = (VWordPosition) wp;
        return hwp.x == x && hwp.y1 == y1 && hwp.y2 == y2;
    }

    public boolean isTrivial() {
        return y1 >= y2;
    }

    public boolean contains(int x, int y) {
        return x == this.x && y1 <= y && y < y2;
    }

    public boolean liesIn(CharTable ct) {
        return x >= ct.x1 && x < ct.x2 && y1 >= ct.y1 && y2 <= ct.y2;
    }

    /**
     * Verifies whether this word position intersects the specified char table.
     */
    public boolean intersects(CharTable ct) {
        return ct.x1 <= x && x < ct.x2 && ct.y1 < y2 && y1 < ct.y2;
    }

    /**
     * Returns the height of the intersection of this line
     * with the specified block
     * or <code>0</code> if they are not intersected.
     */
    public int getLengthInsideOf(Block block) {
        int height = Math.min(y2, block.y2) - Math.max(y1, block.y1);
        return Math.max(height, 0);
    }

    /**
     * Compares this vertical position with the specified one
     * according to their x-coordinates.
     */
    public int compareTo(VWordPosition vLine) {
        int xx = vLine.x;
        if (x < xx)
            return -1;
        else if (x == xx)
            return 0;
        else
            return +1;
    }

    public String toString() {
        return ""vertical("" + x + "";"" + y1 + "","" + y2 + "")"";
    }

    /**
     * Returns the text at this position on the specified char table.
     *
     * The call is dispatched back to the specified char table
     * informing it about the concrete word position type.
     *
     * @param ct	the char table from which the text must be read.
     *
     * @return		the text at this position on the specified char table.
     */
    public String textAt(CharTable ct) {
        return ct.textAt(this);
    }
}
","// VWordPosition_6Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPosition_6Test {","// VWordPosition_6Test.java
package glengineer.positions;

import glengineer.blocks.Block;
import glengineer.blocks.CharTable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link VWordPosition}.
* It contains ten unit test cases for the {@link VWordPosition#textAt(CharTable)} method.
*/
class VWordPosition_6Test {

	/**
	 * Test case #1.
	 *
	 * The word position is trivial.
	 */
	@Test
	void testTextAt_1() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 1, 1);
		assertEquals("""", wp.textAt(ct));
	}
	
	/**
	 * Test case #2.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_2() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 1, 2);
		assertEquals(""e"", wp.textAt(ct));
	}
	
	/**
	 * Test case #3.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_3() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 1, 3);
		assertEquals(""ef"", wp.textAt(ct));
	}
	
	/**
	 * Test case #4.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_4() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 3);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #5.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_5() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 4);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #6.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_6() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 5);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #7.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_7() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 6);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #8.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_8() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 7);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #9.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_9() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 8);
		assertEquals(""def"", wp.textAt(ct));
	}
	
	/**
	 * Test case #10.
	 *
	 * The word position is not trivial.
	 */
	@Test
	void testTextAt_10() {
		CharTable ct = new CharTable(new char[][] {
			{'a', 'b', 'c'},
			{'d', 'e', 'f'},
			{'g', 'h', 'i'}
		});
		VWordPosition wp = new VWordPosition(1, 0, 9);
		assertEquals(""def"", wp.textAt(ct));
	}
}</code>



   <code>CharTable</code>:


<code>// CharTable.java
package glengineer.blocks;

import glengineer.positions.CharPosition;
import glengineer.positions.HWordPosition;
import glengineer.positions.VWordPosition;
import glengineer.positions.WordPosition;

import java.util.ArrayList;
import java.util.List;

/**
 * Encapsulates a rectangular table of characters.
 */
public class CharTable {

    /**
     * The table of characters.
     */
    public final char[][] table;

    /**
     * The horizontal coordinate of the table start.
     */
    public final int x1;

    /**
     * The horizontal coordinate of the table end + 1.
     */
    public final int x2;

    /**
     * The vertical coordinate of the table start.
     */
    public final int y1;

    /**
     * The vertical coordinate of the table end + 1.
     */
    public final int y2;

    /**
     * Creates a char table from the specified two-dimensional array of characters.
     */
    public CharTable(char[][] table) {
        this(table, 0, table[0].length, 0, table.length);
    }

    /**
     * Creates a char table from the specified two-dimensional array of characters
     * and the specified coordinates of the table.
     */
    public CharTable(char[][] table, int x1, int x2, int y1, int y2) {
        if (x1 &gt; x2 || y1 &gt; y2)
            throw new IllegalArgumentException(""wrong char table parameters"");
        this.table = table;
        this.x1 = x1;
        this.x2 = x2;
        this.y1 = y1;
        this.y2 = y2;
    }

    /**
     * Creates a char table from the specified two-dimensional array of characters
     * and the specified block."
