ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6txXhYM4pXKlzcOHiMGDtpt0ndMRC,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringTools_0Test.java,52.27082920074463,length,"// StringTools.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package com.jstevh.tools;

/**
 * Some static tools for string manipulation
 *
 * @author   James Harris
 * @version  1.1
 */
public class StringTools {

    private static int count, length;

    /**
     * Searches through given string array for a given string
     * fragment and returns an array of the strings that have
     * fragment in them.
     *
     * @param    strings    string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String fragment) {
        String[] tempArray = null;
        if (strings != null && fragment != null) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < strings.length; i++) {
                tempStr2 = strings[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Searches through given index string array for a given string
     * fragment and returns an array of the strings from given base
     * array.
     *
     * @param    strings    string array that values are pulled from
     *           index      string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String[] index, String fragment) {
        String[] tempArray = null;
        if (strings != null && index != null && fragment != null && index.length <= strings.length) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < index.length; i++) {
                tempStr2 = index[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (array == null)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Searches through given string array for a given string
     * fragment and deletes fragment from strings that have
     * fragment in them.
     *
     * @param    in        string fragment to be deleted out
     *           strings   array with strings to delete fragment from
     *
     * @return   toString() on string buffer used, for debugging
     */
    public static String removeStrings(String in, String[] strings) {
        if (in == null || strings == null)
            return null;
        StringBuffer buff = new StringBuffer(in.trim());
        int pos1, length;
        for (int i = 0; i < strings.length; i++) {
            pos1 = buff.toString().indexOf(strings[i]);
            length = strings[i].length();
            while (pos1 != -1) {
                buff.delete(pos1, pos1 + length);
                pos1 = buff.toString().indexOf(strings[i]);
            }
        }
        String tempStr = buff.toString();
        return tempStr;
    }
}
","// StringTools_0Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String)} method.
*/
class StringTools_0Test {","// StringTools_0Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String)} method.
*/
class StringTools_0Test {

		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is null.
		*/
		@Test
		void testSearchStrings_0() {
				String[] strings = null;
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is empty.
		*/
		@Test
		void testSearchStrings_1() {
				String[] strings = new String[0];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string fragment is null.
		*/
		@Test
		void testSearchStrings_2() {
				String[] strings = new String[1];
				String fragment = null;
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string fragment is empty.
		*/
		@Test
		void testSearchStrings_3() {
				String[] strings = new String[1];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array contains null.
		*/
		@Test
		void testSearchStrings_4() {
				String[] strings = new String[1];
				strings[0] = null;
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array contains empty string.
		*/
		@Test
		void testSearchStrings_5() {
				String[] strings = new String[1];
				strings[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array contains string that does not contain the given string fragment.
		*/
		@Test
		void testSearchStrings_6() {
				String[] strings = new String[1];
				strings[0] = ""abc"";
				String fragment = ""def"";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array contains string that contains the given string fragment.
		*/
		@Test
		void testSearchStrings_7() {
				String[] strings = new String[1];
				strings[0] = ""abc"";
				String fragment = ""a"";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertEquals(1, result.length);
				assertEquals(""abc"", result[0]);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array contains string that contains the given string fragment.
		*/
		@Test
		void testSearchStrings_8() {
				String[] strings = new String[2];
				strings[0] = ""abc"";
				strings[1] = ""def"";
				String fragment = ""a"";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertEquals(1, result.length);
				assertEquals(""abc"", result[0]);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array contains string that contains the given string fragment.
		*/
		@Test
		void testSearchStrings_9() {
				String[] strings = new String[2];
				strings[0] = ""abc"";
				strings[1] = ""def"";
				String fragment = ""d"";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertEquals(1, result.length);
				assertEquals(""def"", result[0]);
		}
		
}

// StringTools_1Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String[], String)} method.
*/
class StringTools_1Test {
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is null.
		*/
		@Test
		void testSearchStrings_0() {
				String[] strings = null;
				String[] index = new String[1];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is empty.
		*/
		@Test
		void testSearchStrings_1() {
				String[] strings = new String[0];
				String[] index = new String[1];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given index string array is null.
		*/
		@Test
		void testSearchStrings_2() {
				String[] strings = new String[1];
				String[] index = null;
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		"
cmpl-6txYkQpASrnAgI0ZQbBrZqOaAuRV2,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringTools_1Test.java,38.889217138290405,stop,"// StringTools.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package com.jstevh.tools;

/**
 * Some static tools for string manipulation
 *
 * @author   James Harris
 * @version  1.1
 */
public class StringTools {

    private static int count, length;

    /**
     * Searches through given string array for a given string
     * fragment and returns an array of the strings that have
     * fragment in them.
     *
     * @param    strings    string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String fragment) {
        String[] tempArray = null;
        if (strings != null && fragment != null) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < strings.length; i++) {
                tempStr2 = strings[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Searches through given index string array for a given string
     * fragment and returns an array of the strings from given base
     * array.
     *
     * @param    strings    string array that values are pulled from
     *           index      string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String[] index, String fragment) {
        String[] tempArray = null;
        if (strings != null && index != null && fragment != null && index.length <= strings.length) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < index.length; i++) {
                tempStr2 = index[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (array == null)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Searches through given string array for a given string
     * fragment and deletes fragment from strings that have
     * fragment in them.
     *
     * @param    in        string fragment to be deleted out
     *           strings   array with strings to delete fragment from
     *
     * @return   toString() on string buffer used, for debugging
     */
    public static String removeStrings(String in, String[] strings) {
        if (in == null || strings == null)
            return null;
        StringBuffer buff = new StringBuffer(in.trim());
        int pos1, length;
        for (int i = 0; i < strings.length; i++) {
            pos1 = buff.toString().indexOf(strings[i]);
            length = strings[i].length();
            while (pos1 != -1) {
                buff.delete(pos1, pos1 + length);
                pos1 = buff.toString().indexOf(strings[i]);
            }
        }
        String tempStr = buff.toString();
        return tempStr;
    }
}
","// StringTools_1Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String[], String)} method.
*/
class StringTools_1Test {","// StringTools_1Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String[], String)} method.
*/
class StringTools_1Test {

		/**
		* Test case 1 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is null.
		*/
		@Test
		void testSearchStrings_1() {
				String[] strings = null;
				String[] index = null;
				String fragment = null;
				String[] expected = null;
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is empty.
		*/
		@Test
		void testSearchStrings_2() {
				String[] strings = new String[0];
				String[] index = new String[0];
				String fragment = """";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is null.
		*/
		@Test
		void testSearchStrings_3() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = null;
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is empty.
		*/
		@Test
		void testSearchStrings_4() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = """";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_5() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""a"";
				String[] expected = new String[]{""a""};
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_6() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""b"";
				String[] expected = new String[]{""b""};
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_7() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""c"";
				String[] expected = new String[]{""c""};
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_8() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""d"";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_9() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""ab"";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_10() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""abc"";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
}"
cmpl-6txZn5WCAQOqqjoxSzIh9k9w7ol7d,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringTools_2Test.java,40.50514197349548,stop,"// StringTools.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package com.jstevh.tools;

/**
 * Some static tools for string manipulation
 *
 * @author   James Harris
 * @version  1.1
 */
public class StringTools {

    private static int count, length;

    /**
     * Searches through given string array for a given string
     * fragment and returns an array of the strings that have
     * fragment in them.
     *
     * @param    strings    string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String fragment) {
        String[] tempArray = null;
        if (strings != null && fragment != null) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < strings.length; i++) {
                tempStr2 = strings[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Searches through given index string array for a given string
     * fragment and returns an array of the strings from given base
     * array.
     *
     * @param    strings    string array that values are pulled from
     *           index      string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String[] index, String fragment) {
        String[] tempArray = null;
        if (strings != null && index != null && fragment != null && index.length <= strings.length) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < index.length; i++) {
                tempStr2 = index[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (array == null)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Searches through given string array for a given string
     * fragment and deletes fragment from strings that have
     * fragment in them.
     *
     * @param    in        string fragment to be deleted out
     *           strings   array with strings to delete fragment from
     *
     * @return   toString() on string buffer used, for debugging
     */
    public static String removeStrings(String in, String[] strings) {
        if (in == null || strings == null)
            return null;
        StringBuffer buff = new StringBuffer(in.trim());
        int pos1, length;
        for (int i = 0; i < strings.length; i++) {
            pos1 = buff.toString().indexOf(strings[i]);
            length = strings[i].length();
            while (pos1 != -1) {
                buff.delete(pos1, pos1 + length);
                pos1 = buff.toString().indexOf(strings[i]);
            }
        }
        String tempStr = buff.toString();
        return tempStr;
    }
}
","// StringTools_2Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#removeStrings(String, String[])} method.
*/
class StringTools_2Test {","// StringTools_2Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#removeStrings(String, String[])} method.
*/
class StringTools_2Test {

		/**
		* Test case 1 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a null string and a null array.
		*/
		@Test
		void testRemoveStrings_1() {
				StringTools st = new StringTools();
				String in = null;
				String[] strings = null;
				String expected = null;
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_2() {
				StringTools st = new StringTools();
				String in = null;
				String[] strings = {""a"", ""b"", ""c""};
				String expected = null;
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a null array.
		*/
		@Test
		void testRemoveStrings_3() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = null;
				String expected = ""abc"";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_4() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_5() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b""};
				String expected = ""c"";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_6() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_7() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_8() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e"", ""f""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_9() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_10() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
}</code>





A:

The problem is that you are not using the <code>StringTools</code> class correctly.
You are creating a new instance of <code>StringTools</code> in each test method, but you are not using that instance.
Instead, you are calling the <code>removeStrings</code> method on the <code>StringToolsTest</code> class itself.
You should be calling the <code>removeStrings</code> method on the <code>StringTools</code> instance that you created.
"
cmpl-6txaq6R9Tzl3pLuF4MKFIzjOhavfN,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java,50.322327613830566,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_0Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {","// ClassInfo_0Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {

		@Test
		void testPrintFields() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields2() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields3() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields4() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields5() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields6() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields7() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields8() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields9() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_CLOSE"");
		}
		
		@Test
		void testPrintFields10() {
				ClassInfo ci = new ClassInfo(""java.awt.WindowConstants"");
				String[] fields = ci.printFields();
				assertEquals(fields[0], ""public static final int java.awt.WindowConstants.DISPOSE_ON_CLOSE"");
				assertEquals(fields[1], ""public static final int java.awt.WindowConstants.DO_NOTHING_ON_CLOSE"");
				assertEquals(fields[2], ""public static final int java.awt.WindowConstants.EXIT_ON_CLOSE"");
				assertEquals(fields[3], ""public static final int java.awt.WindowConstants.HIDE_ON_"
cmpl-6txbtGTpqZuBoghf3O2MXunJ8a8AF,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java,59.95929002761841,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_1Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {","// ClassInfo_1Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {

		/**
		* Test case for {@link ClassInfo#printMethods()} method.
		* <p>
		* This test case checks if the method returns the correct array of strings.
		*/
		@Test
		void testPrintMethods() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				String[] data = myClassInfo.printMethods();
				assertEquals(data[0], ""public boolean java.lang.String.equals(java.lang.Object)"");
				assertEquals(data[1], ""public java.lang.String java.lang.String.toString()"");
				assertEquals(data[2], ""public int java.lang.String.hashCode()"");
				assertEquals(data[3], ""public int java.lang.String.length()"");
				assertEquals(data[4], ""public char java.lang.String.charAt(int)"");
				assertEquals(data[5], ""public int java.lang.String.compareTo(java.lang.String)"");
				assertEquals(data[6], ""public int java.lang.String.compareTo(java.lang.Object)"");
				assertEquals(data[7], ""public int java.lang.String.compareToIgnoreCase(java.lang.String)"");
				assertEquals(data[8], ""public boolean java.lang.String.equalsIgnoreCase(java.lang.String)"");
				assertEquals(data[9], ""public int java.lang.String.indexOf(int)"");
				assertEquals(data[10], ""public int java.lang.String.indexOf(int,int)"");
				assertEquals(data[11], ""public int java.lang.String.indexOf(java.lang.String)"");
				assertEquals(data[12], ""public int java.lang.String.indexOf(java.lang.String,int)"");
				assertEquals(data[13], ""public java.lang.String java.lang.String.intern()"");
				assertEquals(data[14], ""public int java.lang.String.lastIndexOf(int)"");
				assertEquals(data[15], ""public int java.lang.String.lastIndexOf(int,int)"");
				assertEquals(data[16], ""public int java.lang.String.lastIndexOf(java.lang.String)"");
				assertEquals(data[17], ""public int java.lang.String.lastIndexOf(java.lang.String,int)"");
				assertEquals(data[18], ""public int java.lang.String.length()"");
				assertEquals(data[19], ""public boolean java.lang.String.matches(java.lang.String)"");
				assertEquals(data[20], ""public boolean java.lang.String.regionMatches(boolean,int,java.lang.String,int,int)"");
				assertEquals(data[21], ""public boolean java.lang.String.regionMatches(int,java.lang.String,int,int)"");
				assertEquals(data[22], ""public java.lang.String java.lang.String.replaceAll(java.lang.String,java.lang.String)"");
				assertEquals(data[23], ""public java.lang.String java.lang.String.replaceFirst(java.lang.String,java.lang.String)"");
				assertEquals(data[24], ""public java.lang.String[] java.lang.String.split(java.lang.String)"");
				assertEquals(data[25], ""public java.lang.String[] java.lang.String.split(java.lang.String,int)"");
				assertEquals(data[26], ""public boolean java.lang.String.startsWith(java.lang.String,int)"");
				assertEquals(data[27], ""public boolean java.lang.String.startsWith(java.lang.String)"");
				assertEquals(data[28], ""public java.lang.CharSequence java.lang.String.subSequence(int,int)"");
				assertEquals(data[29], ""public java.lang.String java.lang.String.substring(int)"");
				assertEquals(data[30], ""public java.lang.String java.lang.String.substring(int,int)"");
				assertEquals(data[31], ""public char[] java.lang.String.toCharArray()"");
				assertEquals(data[32], ""public java.lang.String java.lang.String.toLowerCase()"");
				assertEquals(data[33], ""public java.lang.String java.lang.String.toString()"");
				assertEquals(data[34], ""public java.lang.String java.lang.String.toUpperCase()"");
				assertEquals(data[35], ""public java.lang.String java.lang.String.trim()"");
				assertEquals(data[36], ""public static java.lang.String java.lang.String.valueOf(boolean)"");
				assertEquals(data[37], ""public static java.lang.String java.lang.String.valueOf(char)"");
				assertEquals(data[38], ""public static java.lang.String java.lang.String.valueOf(char[])"");
				assertEquals(data[39], ""public static java.lang.String java.lang.String.valueOf(char[],int,int)"");
				assertEquals(data[40], ""public static java.lang.String java.lang.String.valueOf(double)"");
				assertEquals(data[41], ""public static java.lang.String java.lang.String.valueOf(float)"");
				assertEquals(data[42], ""public static java.lang.String java.lang.String.valueOf(int)"");
				assertEquals(data[43], ""public static java.lang.String java.lang.String.valueOf(long)"");
				assertEquals(data[44], ""public static java.lang.String java.lang.String.valueOf(java.lang.Object)"");
				assertEquals(data[45], ""public static java.lang.String java.lang.String.valueOf(java.lang.String)"");
				assertEquals(data[46], ""public void java.lang.Object.wait(long,int) throws java.lang.InterruptedException"");
				assertEquals(data[47], ""public final void java.lang.Object.wait(long) throws java.lang.InterruptedException"");
				assertEquals(data[48], ""public final void java.lang.Object.wait() throws java.lang.InterruptedException"");
				assertEquals(data[49], ""public final native java.lang.Class java.lang.Object.getClass()"");
				assertEquals(data[50], ""public final native void java.lang.Object.notify()"");
				assertEquals(data[51], ""public final native void java.lang.Object.notifyAll()"");
		}
		
		/**
		* Test case for {@link ClassInfo#printMethods()} method.
		* <p>
		* This test case checks if the method returns the correct array of strings.
		*/
		@Test
		void testPrintMethods_1() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				String[] data = myClassInfo.printMethods();
				assertEquals(data[0], ""public boolean java.lang.String.equals(java.lang.Object)"");
				assertEquals(data[1], ""public java.lang.String java.lang.String.toString()"");
				"
cmpl-6txcw6XVXfG6262EDPGNACQEGO5ED,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java,49.12325167655945,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_2Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {","// ClassInfo_2Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {

		private ClassInfo myClassInfo;
		
		private String[] cMethods;
		
		private String[] fndMethods;
		
		private String[] tempArray;
		
		private String[] data;
		
		private String[] tempArray2;
		
		private String[] data2;
		
		private String[] tempArray3;
		
		private String[] data3;
		
		private String[] tempArray4;
		
		private String[] data4;
		
		private String[] tempArray5;
		
		private String[] data5;
		
		private String[] tempArray6;
		
		private String[] data6;
		
		private String[] tempArray7;
		
		private String[] data7;
		
		private String[] tempArray8;
		
		private String[] data8;
		
		private String[] tempArray9;
		
		private String[] data9;
		
		private String[] tempArray10;
		
		private String[] data10;
		
		private String[] tempArray11;
		
		private String[] data11;
		
		private String[] tempArray12;
		
		private String[] data12;
		
		private String[] tempArray13;
		
		private String[] data13;
		
		private String[] tempArray14;
		
		private String[] data14;
		
		private String[] tempArray15;
		
		private String[] data15;
		
		private String[] tempArray16;
		
		private String[] data16;
		
		private String[] tempArray17;
		
		private String[] data17;
		
		private String[] tempArray18;
		
		private String[] data18;
		
		private String[] tempArray19;
		
		private String[] data19;
		
		private String[] tempArray20;
		
		private String[] data20;
		
		private String[] tempArray21;
		
		private String[] data21;
		
		private String[] tempArray22;
		
		private String[] data22;
		
		private String[] tempArray23;
		
		private String[] data23;
		
		private String[] tempArray24;
		
		private String[] data24;
		
		private String[] tempArray25;
		
		private String[] data25;
		
		private String[] tempArray26;
		
		private String[] data26;
		
		private String[] tempArray27;
		
		private String[] data27;
		
		private String[] tempArray28;
		
		private String[] data28;
		
		private String[] tempArray29;
		
		private String[] data29;
		
		private String[] tempArray30;
		
		private String[] data30;
		
		private String[] tempArray31;
		
		private String[] data31;
		
		private String[] tempArray32;
		
		private String[] data32;
		
		private String[] tempArray33;
		
		private String[] data33;
		
		private String[] tempArray34;
		
		private String[] data34;
		
		private String[] tempArray35;
		
		private String[] data35;
		
		private String[] tempArray36;
		
		private String[] data36;
		
		private String[] tempArray37;
		
		private String[] data37;
		
		private String[] tempArray38;
		
		private String[] data38;
		
		private String[] tempArray39;
		
		private String[] data39;
		
		private String[] tempArray40;
		
		private String[] data40;
		
		private String[] tempArray41;
		
		private String[] data41;
		
		private String[] tempArray42;
		
		private String[] data42;
		
		private String[] tempArray43;
		
		private String[] data43;
		
		private String[] tempArray44;
		
		private String[] data44;
		
		private String[] tempArray45;
		
		private String[] data45;
		
		private String[] tempArray46;
		
		private String[] data46;
		
		private String[] tempArray47;
		
		private String[] data47;
		
		private String[] tempArray48;
		
		private String[] data48;
		
		private String[] tempArray49;
		
		private String[] data49;
		
		private String[] tempArray50;
		
		private String[] data50;
		
		private String[] tempArray51;
		
		private String[] data51;
		
		private String[] tempArray52;
		
		private String[] data52;
		
		private String[] tempArray53;
		
		private String[] data53;
		
		private String[] tempArray54;
		
		private String[] data54;
		
		private String[] tempArray55;
		
		private String[] data55;
		
		private String[] tempArray56;
		
		private String[] data56;
		
		private String[] tempArray57;
		
		private String[] data57;
		
		private String[] tempArray58;
		
		private String[] data58;
		
		private String[] tempArray59;
		
		private String[] data59;
		
		private String[] tempArray60;
		
		private String[] data60;
		
		private String[] tempArray61;
		
		private String[] data61;
		
		private String[] tempArray62;
		
		private String[] data62;
		
		private String[] tempArray63;
		
		private String[] data63;
		
		private String[] tempArray64;
		
		private String[] data64;
		
		private String[] tempArray65;
		
		private String[] data65;
		
		private String[] tempArray66;
		
		private String[] data66;
		
		private String[] tempArray67;
		
		private String[] data67;
		
		private String[] tempArray68;
		
		private String[] data68;
		
		private String[] tempArray69;
		
		private String[] data69;
		
		private String[] tempArray70;
		
		private String[] data70;
		
		private String[] tempArray71;
		
		private String[] data71;
		
		private String[] tempArray72;
		
		private String[] data72;
		
		private String[] tempArray73;
		
		private String[] data73;
		
		private String[] tempArray74;
		
		private String[] data74;
		
		private String[] tempArray75;
		
		private String[] data75;
		
		private String[] tempArray76;
		
		private String[] data76;
		
		private String[] tempArray77;
		
		private String[] data77;
		
		private String[] tempArray78;
		
		private String[] data78;
		
		private String[] tempArray79;
		
"
cmpl-6txdztwQlRjGyrNAkdEweDVAF0db3,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java,49.81235218048096,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_3Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {","// ClassInfo_3Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {

		private ClassInfo myClassInfo;
		
		private String[] cMethods;
		
		private String[] fndMethods;
		
		private String[] knownPackages;
		
		private String[] data;
		
		private String[] tempArray;
		
		private String[] tempArray2;
		
		private String[] tempArray3;
		
		private String[] tempArray4;
		
		private String[] tempArray5;
		
		private String[] tempArray6;
		
		private String[] tempArray7;
		
		private String[] tempArray8;
		
		private String[] tempArray9;
		
		private String[] tempArray10;
		
		private String[] tempArray11;
		
		private String[] tempArray12;
		
		private String[] tempArray13;
		
		private String[] tempArray14;
		
		private String[] tempArray15;
		
		private String[] tempArray16;
		
		private String[] tempArray17;
		
		private String[] tempArray18;
		
		private String[] tempArray19;
		
		private String[] tempArray20;
		
		private String[] tempArray21;
		
		private String[] tempArray22;
		
		private String[] tempArray23;
		
		private String[] tempArray24;
		
		private String[] tempArray25;
		
		private String[] tempArray26;
		
		private String[] tempArray27;
		
		private String[] tempArray28;
		
		private String[] tempArray29;
		
		private String[] tempArray30;
		
		private String[] tempArray31;
		
		private String[] tempArray32;
		
		private String[] tempArray33;
		
		private String[] tempArray34;
		
		private String[] tempArray35;
		
		private String[] tempArray36;
		
		private String[] tempArray37;
		
		private String[] tempArray38;
		
		private String[] tempArray39;
		
		private String[] tempArray40;
		
		private String[] tempArray41;
		
		private String[] tempArray42;
		
		private String[] tempArray43;
		
		private String[] tempArray44;
		
		private String[] tempArray45;
		
		private String[] tempArray46;
		
		private String[] tempArray47;
		
		private String[] tempArray48;
		
		private String[] tempArray49;
		
		private String[] tempArray50;
		
		private String[] tempArray51;
		
		private String[] tempArray52;
		
		private String[] tempArray53;
		
		private String[] tempArray54;
		
		private String[] tempArray55;
		
		private String[] tempArray56;
		
		private String[] tempArray57;
		
		private String[] tempArray58;
		
		private String[] tempArray59;
		
		private String[] tempArray60;
		
		private String[] tempArray61;
		
		private String[] tempArray62;
		
		private String[] tempArray63;
		
		private String[] tempArray64;
		
		private String[] tempArray65;
		
		private String[] tempArray66;
		
		private String[] tempArray67;
		
		private String[] tempArray68;
		
		private String[] tempArray69;
		
		private String[] tempArray70;
		
		private String[] tempArray71;
		
		private String[] tempArray72;
		
		private String[] tempArray73;
		
		private String[] tempArray74;
		
		private String[] tempArray75;
		
		private String[] tempArray76;
		
		private String[] tempArray77;
		
		private String[] tempArray78;
		
		private String[] tempArray79;
		
		private String[] tempArray80;
		
		private String[] tempArray81;
		
		private String[] tempArray82;
		
		private String[] tempArray83;
		
		private String[] tempArray84;
		
		private String[] tempArray85;
		
		private String[] tempArray86;
		
		private String[] tempArray87;
		
		private String[] tempArray88;
		
		private String[] tempArray89;
		
		private String[] tempArray90;
		
		private String[] tempArray91;
		
		private String[] tempArray92;
		
		private String[] tempArray93;
		
		private String[] tempArray94;
		
		private String[] tempArray95;
		
		private String[] tempArray96;
		
		private String[] tempArray97;
		
		private String[] tempArray98;
		
		private String[] tempArray99;
		
		private String[] tempArray100;
		
		private String[] tempArray101;
		
		private String[] tempArray102;
		
		private String[] tempArray103;
		
		private String[] tempArray104;
		
		private String[] tempArray105;
		
		private String[] tempArray106;
		
		private String[] tempArray107;
		
		private String[] tempArray108;
		
		private String[] tempArray109;
		
		private String[] tempArray110;
		
		private String[] tempArray111;
		
		private String[] tempArray112;
		
		private String[] tempArray113;
		
		private String[] tempArray114;
		
		private String[] tempArray115;
		
		private String[] tempArray116;
		
		private String[] tempArray117;
		
		private String[] tempArray118;
		
		private String[] tempArray119;
		
		private String[] tempArray120;
		
		private String[] tempArray121;
		
		private String[] tempArray122;
		
		private String[] tempArray123;
		
		private String[] tempArray124;
		
		private String[] tempArray125;
		
		private String[] tempArray126;
		
		private String[] tempArray127;
		
		private String[] tempArray128;
		
		private String[] tempArray129;
		
		private String[] tempArray130;
		
		private String[] tempArray131;
		
		private String[] tempArray132;
		
		private String[] tempArray133;
		
		private String[] tempArray134;
		
		private String[] tempArray135;
		
		private String[] tempArray136;
		
		private String[] tempArray137;
		
		private String[] tempArray138;
		
		private String[] tempArray139;
		
		private String[] tempArray140;
		
		private String[] tempArray141;
		
		private String[] tempArray142;
		
		private String[] tempArray143;
		
		private String[] tempArray144;
		
		private String[] tempArray145;
		
		private String[] tempArray146;
		
		private String[] tempArray147;
		
		private String[] tempArray148;
		
		private String[] tempArray149;
		
	"
cmpl-6txf2oCqFzjXuNC2sKtzvGWMCgKEB,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java,46.6879518032074,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_4Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {","// ClassInfo_4Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {

		private ClassInfo ci;
		
		private String[] interfaces;
		
		private String[] expected;
		
		private String[] actual;
		
		private String[] expected2;
		
		private String[] actual2;
		
		private String[] expected3;
		
		private String[] actual3;
		
		private String[] expected4;
		
		private String[] actual4;
		
		private String[] expected5;
		
		private String[] actual5;
		
		private String[] expected6;
		
		private String[] actual6;
		
		private String[] expected7;
		
		private String[] actual7;
		
		private String[] expected8;
		
		private String[] actual8;
		
		private String[] expected9;
		
		private String[] actual9;
		
		private String[] expected10;
		
		private String[] actual10;
		
		private String[] expected11;
		
		private String[] actual11;
		
		private String[] expected12;
		
		private String[] actual12;
		
		private String[] expected13;
		
		private String[] actual13;
		
		private String[] expected14;
		
		private String[] actual14;
		
		private String[] expected15;
		
		private String[] actual15;
		
		private String[] expected16;
		
		private String[] actual16;
		
		private String[] expected17;
		
		private String[] actual17;
		
		private String[] expected18;
		
		private String[] actual18;
		
		private String[] expected19;
		
		private String[] actual19;
		
		private String[] expected20;
		
		private String[] actual20;
		
		private String[] expected21;
		
		private String[] actual21;
		
		private String[] expected22;
		
		private String[] actual22;
		
		private String[] expected23;
		
		private String[] actual23;
		
		private String[] expected24;
		
		private String[] actual24;
		
		private String[] expected25;
		
		private String[] actual25;
		
		private String[] expected26;
		
		private String[] actual26;
		
		private String[] expected27;
		
		private String[] actual27;
		
		private String[] expected28;
		
		private String[] actual28;
		
		private String[] expected29;
		
		private String[] actual29;
		
		private String[] expected30;
		
		private String[] actual30;
		
		private String[] expected31;
		
		private String[] actual31;
		
		private String[] expected32;
		
		private String[] actual32;
		
		private String[] expected33;
		
		private String[] actual33;
		
		private String[] expected34;
		
		private String[] actual34;
		
		private String[] expected35;
		
		private String[] actual35;
		
		private String[] expected36;
		
		private String[] actual36;
		
		private String[] expected37;
		
		private String[] actual37;
		
		private String[] expected38;
		
		private String[] actual38;
		
		private String[] expected39;
		
		private String[] actual39;
		
		private String[] expected40;
		
		private String[] actual40;
		
		private String[] expected41;
		
		private String[] actual41;
		
		private String[] expected42;
		
		private String[] actual42;
		
		private String[] expected43;
		
		private String[] actual43;
		
		private String[] expected44;
		
		private String[] actual44;
		
		private String[] expected45;
		
		private String[] actual45;
		
		private String[] expected46;
		
		private String[] actual46;
		
		private String[] expected47;
		
		private String[] actual47;
		
		private String[] expected48;
		
		private String[] actual48;
		
		private String[] expected49;
		
		private String[] actual49;
		
		private String[] expected50;
		
		private String[] actual50;
		
		private String[] expected51;
		
		private String[] actual51;
		
		private String[] expected52;
		
		private String[] actual52;
		
		private String[] expected53;
		
		private String[] actual53;
		
		private String[] expected54;
		
		private String[] actual54;
		
		private String[] expected55;
		
		private String[] actual55;
		
		private String[] expected56;
		
		private String[] actual56;
		
		private String[] expected57;
		
		private String[] actual57;
		
		private String[] expected58;
		
		private String[] actual58;
		
		private String[] expected59;
		
		private String[] actual59;
		
		private String[] expected60;
		
		private String[] actual60;
		
		private String[] expected61;
		
		private String[] actual61;
		
		private String[] expected62;
		
		private String[] actual62;
		
		private String[] expected63;
		
		private String[] actual63;
		
		private String[] expected64;
		
		private String[] actual64;
		
		private String[] expected65;
		
		private String[] actual65;
		
		private String[] expected66;
		
		private String[] actual66;
		
		private String[] expected67;
		
		private String[] actual67;
		
		private String[] expected68;
		
		private String[] actual68;
		
		private String[] expected69;
		
		private String[] actual69;
		
		private String[] expected70;
		
		private String[] actual70;
		
		private String[] expected71;
		
		private String[] actual71;
		
		private String[] expected72;
		
		private String[] actual72;
		
		private String[] expected73;
		
		private String[] actual73;
		
		private String[] expected74;
		
		private String[] actual74;
		
		private String[] expected75;
		
		private String[] actual75;
		
		private String[] expected76;
		
		private String[] actual76;
		
		private String[] expected77;
		
		private String[] actual77;
		
		private String[] expected78;
		
		private String[] actual78;
		
		private String[] expected79;
		
		private String[] actual79;
		
		private String[] expected80;
		
		private String[] actual80;
		
		private String[] expected81;
		
		private String[] actual81;
		
		private String[] expected82;
		
		private String[] actual82;
		
		private String[] expected83;
	"
cmpl-6txg55EzXQ1lHPn9s9tZrI0he0dDA,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java,45.93574643135071,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_5Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {","// ClassInfo_5Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {

		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with a null array.
		*/
		@Test
		void testGetData_1() {
				Member[] m = null;
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an empty array.
		*/
		@Test
		void testGetData_2() {
				Member[] m = new Member[0];
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of one element.
		*/
		@Test
		void testGetData_3() {
				Member[] m = new Member[1];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(1, result.length);
				assertEquals(""test"", result[0]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of two elements.
		*/
		@Test
		void testGetData_4() {
				Member[] m = new Member[2];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(2, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of three elements.
		*/
		@Test
		void testGetData_5() {
				Member[] m = new Member[3];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				m[2] = new Member() {
						public String toString() {
								return ""test3"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(3, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
				assertEquals(""test3"", result[2]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of four elements.
		*/
		@Test
		void testGetData_6() {
				Member[] m = new Member[4];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				m[2] = new Member() {
						public String toString() {
								return ""test3"";
						}
				};
				m[3] = new Member() {
						public String toString() {
								return ""test4"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(4, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
				assertEquals(""test3"", result[2]);
				assertEquals(""test4"", result[3]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of five elements.
		*/
		@Test
		void testGetData_7() {
				Member[] m = new Member[5];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
								return ""test2"";
						}
				};
				m[2] = new Member() {
						public String toString() {
								return ""test3"";
						}
				};
				m[3] = new Member() {
						public String toString() {
								return ""test4"";
						}
				};
				m[4] = new Member() {
						public String toString() {
								return ""test5"";
						}
				};
				String[] result = ClassInfo.getData(m);
				assertEquals(5, result.length);
				assertEquals(""test"", result[0]);
				assertEquals(""test2"", result[1]);
				assertEquals(""test3"", result[2]);
				assertEquals(""test4"", result[3]);
				assertEquals(""test5"", result[4]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of six elements.
		*/
		@Test
		void testGetData_8() {
				Member[] m = new Member[6];
				m[0] = new Member() {
						public String toString() {
								return ""test"";
						}
				};
				m[1] = new Member() {
						public String toString() {
							"
cmpl-6txh8cC3qq8CUfhgwiUMr38iW9PPo,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java,46.77161455154419,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_6Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {","// ClassInfo_6Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {

		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with a null array.
		*/
		@Test
		void testGetData_1() {
				Class[] m = null;
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an empty array.
		*/
		@Test
		void testGetData_2() {
				Class[] m = new Class[0];
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of one element.
		*/
		@Test
		void testGetData_3() {
				Class[] m = new Class[1];
				m[0] = ClassInfo.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(1, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of two elements.
		*/
		@Test
		void testGetData_4() {
				Class[] m = new Class[2];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_6Test.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(2, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[1]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of three elements.
		*/
		@Test
		void testGetData_5() {
				Class[] m = new Class[3];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_6Test.class;
				m[2] = ClassInfo_6Test.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(3, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[1]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[2]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Class[])} method.
		* It tests the method with an array of four elements.
		*/
		@Test
		void testGetData_6() {
				Class[] m = new Class[4];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_6Test.class;
				m[2] = ClassInfo_6Test.class;
				m[3] = ClassInfo.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(4, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[1]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_6Test"", result[2]);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[3]);
		}
}

// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_7Test {
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with a null array.
		*/
		@Test
		void testGetData_1() {
				Member[] m = null;
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an empty array.
		*/
		@Test
		void testGetData_2() {
				Member[] m = new Member[0];
				String[] result = ClassInfo.getData(m);
				assertNull(result);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of one element.
		*/
		@Test
		void testGetData_3() {
				Member[] m = new Member[1];
				m[0] = ClassInfo.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(1, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member[])} method.
		* It tests the method with an array of two elements.
		*/
		@Test
		void testGetData_4() {
				Member[] m = new Member[2];
				m[0] = ClassInfo.class;
				m[1] = ClassInfo_7Test.class;
				String[] result = ClassInfo.getData(m);
				assertNotNull(result);
				assertEquals(2, result.length);
				assertEquals(""class com.jstevh.viewer.ClassInfo"", result[0]);
				assertEquals(""class com.jstevh.viewer.ClassInfo_7Test"", result[1]);
		}
		
		/**
		* Test case for {@link ClassInfo#getData(Member["
cmpl-6txiBIYXBi8hDTYDdCBZkDZW6WlEf,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java,56.41440749168396,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {","// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {

		private ClassInfo myClassInfo;
		
		private String[] cMethods;
		
		private String[] fndMethods;
		
		private String[] index;
		
		private String tempStr;
		
		private String[] tempArray;
		
		private String[] tempArray2;
		
		private String[] tempArray3;
		
		private String[] tempArray4;
		
		private String[] tempArray5;
		
		private String[] tempArray6;
		
		private String[] tempArray7;
		
		private String[] tempArray8;
		
		private String[] tempArray9;
		
		private String[] tempArray10;
		
		private String[] tempArray11;
		
		private String[] tempArray12;
		
		private String[] tempArray13;
		
		private String[] tempArray14;
		
		private String[] tempArray15;
		
		private String[] tempArray16;
		
		private String[] tempArray17;
		
		private String[] tempArray18;
		
		private String[] tempArray19;
		
		private String[] tempArray20;
		
		private String[] tempArray21;
		
		private String[] tempArray22;
		
		private String[] tempArray23;
		
		private String[] tempArray24;
		
		private String[] tempArray25;
		
		private String[] tempArray26;
		
		private String[] tempArray27;
		
		private String[] tempArray28;
		
		private String[] tempArray29;
		
		private String[] tempArray30;
		
		private String[] tempArray31;
		
		private String[] tempArray32;
		
		private String[] tempArray33;
		
		private String[] tempArray34;
		
		private String[] tempArray35;
		
		private String[] tempArray36;
		
		private String[] tempArray37;
		
		private String[] tempArray38;
		
		private String[] tempArray39;
		
		private String[] tempArray40;
		
		private String[] tempArray41;
		
		private String[] tempArray42;
		
		private String[] tempArray43;
		
		private String[] tempArray44;
		
		private String[] tempArray45;
		
		private String[] tempArray46;
		
		private String[] tempArray47;
		
		private String[] tempArray48;
		
		private String[] tempArray49;
		
		private String[] tempArray50;
		
		private String[] tempArray51;
		
		private String[] tempArray52;
		
		private String[] tempArray53;
		
		private String[] tempArray54;
		
		private String[] tempArray55;
		
		private String[] tempArray56;
		
		private String[] tempArray57;
		
		private String[] tempArray58;
		
		private String[] tempArray59;
		
		private String[] tempArray60;
		
		private String[] tempArray61;
		
		private String[] tempArray62;
		
		private String[] tempArray63;
		
		private String[] tempArray64;
		
		private String[] tempArray65;
		
		private String[] tempArray66;
		
		private String[] tempArray67;
		
		private String[] tempArray68;
		
		private String[] tempArray69;
		
		private String[] tempArray70;
		
		private String[] tempArray71;
		
		private String[] tempArray72;
		
		private String[] tempArray73;
		
		private String[] tempArray74;
		
		private String[] tempArray75;
		
		private String[] tempArray76;
		
		private String[] tempArray77;
		
		private String[] tempArray78;
		
		private String[] tempArray79;
		
		private String[] tempArray80;
		
		private String[] tempArray81;
		
		private String[] tempArray82;
		
		private String[] tempArray83;
		
		private String[] tempArray84;
		
		private String[] tempArray85;
		
		private String[] tempArray86;
		
		private String[] tempArray87;
		
		private String[] tempArray88;
		
		private String[] tempArray89;
		
		private String[] tempArray90;
		
		private String[] tempArray91;
		
		private String[] tempArray92;
		
		private String[] tempArray93;
		
		private String[] tempArray94;
		
		private String[] tempArray95;
		
		private String[] tempArray96;
		
		private String[] tempArray97;
		
		private String[] tempArray98;
		
		private String[] tempArray99;
		
		private String[] tempArray100;
		
		private String[] tempArray101;
		
		private String[] tempArray102;
		
		private String[] tempArray103;
		
		private String[] tempArray104;
		
		private String[] tempArray105;
		
		private String[] tempArray106;
		
		private String[] tempArray107;
		
		private String[] tempArray108;
		
		private String[] tempArray109;
		
		private String[] tempArray110;
		
		private String[] tempArray111;
		
		private String[] tempArray112;
		
		private String[] tempArray113;
		
		private String[] tempArray114;
		
		private String[] tempArray115;
		
		private String[] tempArray116;
		
		private String[] tempArray117;
		
		private String[] tempArray118;
		
		private String[] tempArray119;
		
		private String[] tempArray120;
		
		private String[] tempArray121;
		
		private String[] tempArray122;
		
		private String[] tempArray123;
		
		private String[] tempArray124;
		
		private String[] tempArray125;
		
		private String[] tempArray126;
		
		private String[] tempArray127;
		
		private String[] tempArray128;
		
		private String[] tempArray129;
		
		private String[] tempArray130;
		
		private String[] tempArray131;
		
		private String[] tempArray132;
		
		private String[] tempArray133;
		
		private String[] tempArray134;
		
		private String[] tempArray135;
		
		private String[] tempArray136;
		
		private String[] tempArray137;
		
		private String[] tempArray138;
		
		private String[] tempArray139;
		
		private String[] tempArray140;
		
		private String[] tempArray141;
		
		private String[] tempArray142;
		
		private String[] tempArray143;
		
		private String[] tempArray144;
		
		private String[] tempArray145;
		
		private String[] tempArray146;
		
		private String[] tempArray147;
		
		private String[] tempArray148;
		
		private String[] tempArray149;
		
		private"
cmpl-6txjFfE7aeWimOaAViNvJFaaekmNi,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_8Test.java,53.596471071243286,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_8Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String, String[])} method.
*/
class ClassInfo_8Test {","// ClassInfo_8Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String, String[])} method.
*/
class ClassInfo_8Test {

		private ClassInfo classInfo;
		
		private String[] index;
		
		private String[] result;
		
		private String[] expected;
		
		private String tempStr;
		
		private String[] tempArray;
		
		private String[] tempArray2;
		
		private String[] tempArray3;
		
		private String[] tempArray4;
		
		private String[] tempArray5;
		
		private String[] tempArray6;
		
		private String[] tempArray7;
		
		private String[] tempArray8;
		
		private String[] tempArray9;
		
		private String[] tempArray10;
		
		private String[] tempArray11;
		
		private String[] tempArray12;
		
		private String[] tempArray13;
		
		private String[] tempArray14;
		
		private String[] tempArray15;
		
		private String[] tempArray16;
		
		private String[] tempArray17;
		
		private String[] tempArray18;
		
		private String[] tempArray19;
		
		private String[] tempArray20;
		
		private String[] tempArray21;
		
		private String[] tempArray22;
		
		private String[] tempArray23;
		
		private String[] tempArray24;
		
		private String[] tempArray25;
		
		private String[] tempArray26;
		
		private String[] tempArray27;
		
		private String[] tempArray28;
		
		private String[] tempArray29;
		
		private String[] tempArray30;
		
		private String[] tempArray31;
		
		private String[] tempArray32;
		
		private String[] tempArray33;
		
		private String[] tempArray34;
		
		private String[] tempArray35;
		
		private String[] tempArray36;
		
		private String[] tempArray37;
		
		private String[] tempArray38;
		
		private String[] tempArray39;
		
		private String[] tempArray40;
		
		private String[] tempArray41;
		
		private String[] tempArray42;
		
		private String[] tempArray43;
		
		private String[] tempArray44;
		
		private String[] tempArray45;
		
		private String[] tempArray46;
		
		private String[] tempArray47;
		
		private String[] tempArray48;
		
		private String[] tempArray49;
		
		private String[] tempArray50;
		
		private String[] tempArray51;
		
		private String[] tempArray52;
		
		private String[] tempArray53;
		
		private String[] tempArray54;
		
		private String[] tempArray55;
		
		private String[] tempArray56;
		
		private String[] tempArray57;
		
		private String[] tempArray58;
		
		private String[] tempArray59;
		
		private String[] tempArray60;
		
		private String[] tempArray61;
		
		private String[] tempArray62;
		
		private String[] tempArray63;
		
		private String[] tempArray64;
		
		private String[] tempArray65;
		
		private String[] tempArray66;
		
		private String[] tempArray67;
		
		private String[] tempArray68;
		
		private String[] tempArray69;
		
		private String[] tempArray70;
		
		private String[] tempArray71;
		
		private String[] tempArray72;
		
		private String[] tempArray73;
		
		private String[] tempArray74;
		
		private String[] tempArray75;
		
		private String[] tempArray76;
		
		private String[] tempArray77;
		
		private String[] tempArray78;
		
		private String[] tempArray79;
		
		private String[] tempArray80;
		
		private String[] tempArray81;
		
		private String[] tempArray82;
		
		private String[] tempArray83;
		
		private String[] tempArray84;
		
		private String[] tempArray85;
		
		private String[] tempArray86;
		
		private String[] tempArray87;
		
		private String[] tempArray88;
		
		private String[] tempArray89;
		
		private String[] tempArray90;
		
		private String[] tempArray91;
		
		private String[] tempArray92;
		
		private String[] tempArray93;
		
		private String[] tempArray94;
		
		private String[] tempArray95;
		
		private String[] tempArray96;
		
		private String[] tempArray97;
		
		private String[] tempArray98;
		
		private String[] tempArray99;
		
		private String[] tempArray100;
		
		private String[] tempArray101;
		
		private String[] tempArray102;
		
		private String[] tempArray103;
		
		private String[] tempArray104;
		
		private String[] tempArray105;
		
		private String[] tempArray106;
		
		private String[] tempArray107;
		
		private String[] tempArray108;
		
		private String[] tempArray109;
		
		private String[] tempArray110;
		
		private String[] tempArray111;
		
		private String[] tempArray112;
		
		private String[] tempArray113;
		
		private String[] tempArray114;
		
		private String[] tempArray115;
		
		private String[] tempArray116;
		
		private String[] tempArray117;
		
		private String[] tempArray118;
		
		private String[] tempArray119;
		
		private String[] tempArray120;
		
		private String[] tempArray121;
		
		private String[] tempArray122;
		
		private String[] tempArray123;
		
		private String[] tempArray124;
		
		private String[] tempArray125;
		
		private String[] tempArray126;
		
		private String[] tempArray127;
		
		private String[] tempArray128;
		
		private String[] tempArray129;
		
		private String[] tempArray130;
		
		private String[] tempArray131;
		
		private String[] tempArray132;
		
		private String[] tempArray133;
		
		private String[] tempArray134;
		
		private String[] tempArray135;
		
		private String[] tempArray136;
		
		private String[] tempArray137;
		
		private String[] tempArray138;
		
		private String[] tempArray139;
		
		private String[] tempArray140;
		
		private String[] tempArray141;
		
		private String[] tempArray142;
		
		private String[] tempArray143;
		
		private String[] tempArray144;
		
		private String[] tempArray145;
		
		private String[] tempArray146;
		
		private String[] tempArray147;
		
		private String[] tempArray148;
		
		private String[] tempArray149;
		
		private String[] tempArray"
cmpl-6txkIFrMUqMKrQM4sabdtF74W5goo,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_9Test.java,46.11041617393494,length,"// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_9Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_9Test {","// ClassInfo_9Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_9Test {

		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_1() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(10));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_2() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(-1));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_3() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(0));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_4() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(1));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_5() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(2));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_6() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(3));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_7() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(4));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_8() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(5));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_9() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(6));
		}
}

// ClassInfo_Test.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_Test {
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_1() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(10));
		}
		
		/**
		* Test case for {@link ClassInfo#getFoundMethod(int)} method.
		* <p>
		* This test case checks if the method returns null when the position is out of range.
		*/
		@Test
		void testGetFoundMethod_2() {
				ClassInfo myClassInfo = new ClassInfo(""java.lang.String"");
				myClassInfo.srchMethods(""charAt"");
				assertNull(myClassInfo.getFoundMethod(-"
