[
{
    "id": "cmpl-6qY3uhJyudfMiOQcRJduBiyAtvRGn",
    "object": "text_completion",
    "created": 1677982010,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t@Test\n\tvoid testCreateNewTetrahedralStereo0D0() throws Exception {\n\t\tJniInchiAtom atC = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tINCHI_PARITY parity = INCHI_PARITY.EVEN;\n\t\tJniInchiStereo0D result = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, parity);\n\t\tassertNotNull(result);\n\t\tassertEquals(0.0, result.getCentralAtom().getX());\n\t\tassertEquals(0.0, result.getCentralAtom().getY());\n\t\tassertEquals(0.0, result.getCentralAtom().getZ());\n\t\tassertEquals(\"C\", result.getCentralAtom().getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(0).getX());\n\t\tassertEquals(0.0, result.getNeighbor(0).getY());\n\t\tassertEquals(0.0, result.getNeighbor(0).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(0).getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(1).getX());\n\t\tassertEquals(0.0, result.getNeighbor(1).getY());\n\t\tassertEquals(0.0, result.getNeighbor(1).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(1).getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(2).getX());\n\t\tassertEquals(0.0, result.getNeighbor(2).getY());\n\t\tassertEquals(0.0, result.getNeighbor(2).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(2).getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(3).getX());\n\t\tassertEquals(0.0, result.getNeighbor(3).getY());\n\t\tassertEquals(0.0, result.getNeighbor(3).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(3).getElementType());\n\t\tassertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, result.getStereoType());\n\t\tassertEquals(INCHI_PARITY.EVEN, result.getParity());\n\t\tassertEquals(INCHI_PARITY.NONE, result.getDisconnectedParity());\n\t}\n\n\t@Test\n\tvoid testCreateNewTetrahedralStereo0D1() throws Exception {\n\t\tJniInchiAtom atC = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tINCHI_PARITY parity = INCHI_PARITY.ODD;\n\t\tJniInchiStereo0D result = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, parity);\n\t\tassertNotNull(result);\n\t\tassertEquals(0.0, result.getCentralAtom().getX());\n\t\tassertEquals(0.0, result.getCentralAtom().getY());\n\t\tassertEquals(0.0, result.getCentralAtom().getZ());\n\t\tassertEquals(\"C\", result.getCentralAtom().getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(0).getX());\n\t\tassertEquals(0.0, result.getNeighbor(0).getY());\n\t\tassertEquals(0.0, result.getNeighbor(0).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(0).getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(1).getX());\n\t\tassertEquals(0.0, result.getNeighbor(1).getY());\n\t\tassertEquals(0.0, result.getNeighbor(1).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(1).getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(2).getX());\n\t\tassertEquals(0.0, result.getNeighbor(2).getY());\n\t\tassertEquals(0.0, result.getNeighbor(2).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(2).getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(3).getX());\n\t\tassertEquals(0.0, result.getNeighbor(3).getY());\n\t\tassertEquals(0.0, result.getNeighbor(3).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(3).getElementType());\n\t\tassertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, result.getStereoType());\n\t\tassertEquals(INCHI_PARITY.ODD, result.getParity());\n\t\tassertEquals(INCHI_PARITY.NONE, result.getDisconnectedParity());\n\t}\n\n\t@Test\n\tvoid testCreateNewTetrahedralStereo0D2() throws Exception {\n\t\tJniInchiAtom atC = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\tINCHI_PARITY parity = INCHI_PARITY.UNKNOWN;\n\t\tJniInchiStereo0D result = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, parity);\n\t\tassertNotNull(result);\n\t\tassertEquals(0.0, result.getCentralAtom().getX());\n\t\tassertEquals(0.0, result.getCentralAtom().getY());\n\t\tassertEquals(0.0, result.getCentralAtom().getZ());\n\t\tassertEquals(\"C\", result.getCentralAtom().getElementType());\n\t\tassertEquals(0.0, result.getNeighbor(0).getX());\n\t\tassertEquals(0.0, result.getNeighbor(0).getY());\n\t\tassertEquals(0.0, result.getNeighbor(0).getZ());\n\t\tassertEquals(\"C\", result.getNeighbor(0).getElementType());\n\t\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 3284,
        "completion_tokens": 2048,
        "total_tokens": 5332
    },
    "time_taken": 35.81624507904053,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStereo0DTest0.java",
    "original_code": "// JniInchiStereo0D.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\n/**\r\n * Encapsulates properites of InChI Stereo Parity.  See <tt>inchi_api.h</tt>.\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiStereo0D {\r\n\r\n    /**\r\n     * Indicates non-existent (central) atom. Value from inchi_api.h.\r\n     */\r\n    public static final int NO_ATOM = -1;\r\n\r\n    /**\r\n     * Neighbouring atoms.\r\n     */\r\n    private JniInchiAtom[] neighbors = new JniInchiAtom[4];\r\n\r\n    /**\r\n     * Central atom.\r\n     */\r\n    private JniInchiAtom centralAtom;\r\n\r\n    /**\r\n     * Stereo parity type.\r\n     */\r\n    private INCHI_STEREOTYPE type;\r\n\r\n    /**\r\n     * Parity.\r\n     */\r\n    private INCHI_PARITY parity;\r\n\r\n    /**\r\n     * Second parity (for disconnected systems).\r\n     */\r\n    private INCHI_PARITY disconParity = INCHI_PARITY.NONE;\r\n\r\n    /**\r\n     * Constructor.  See <tt>inchi_api.h</tt> for details of usage.\r\n     *\r\n     * @see createNewTetrahedralStereo0D()\r\n     * @see createNewDoublebondStereo0D()\r\n     *\r\n     * @param atC    Central atom\r\n     * @param at0    Neighbour atom 0\r\n     * @param at1    Neighbour atom 1\r\n     * @param at2    Neighbour atom 2\r\n     * @param at3    Neighbour atom 3\r\n     * @param type          Stereo parity type\r\n     * @param parity    Parity\r\n     */\r\n    public JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_STEREOTYPE type, final INCHI_PARITY parity) {\r\n        centralAtom = atC;\r\n        neighbors[0] = at0;\r\n        neighbors[1] = at1;\r\n        neighbors[2] = at2;\r\n        neighbors[3] = at3;\r\n        this.type = type;\r\n        this.parity = parity;\r\n    }\r\n\r\n    JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final int type, final int parity) {\r\n        this(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.getValue(type), INCHI_PARITY.getValue(parity));\r\n    }\r\n\r\n    /**\r\n     * Set second parity (for disconnected systems)\r\n     * @param parity\r\n     */\r\n    public void setDisconnectedParity(final INCHI_PARITY parity) {\r\n        this.disconParity = parity;\r\n    }\r\n\r\n    /**\r\n     * Returns central atom of stereo parity.\r\n     * @return\r\n     */\r\n    public JniInchiAtom getCentralAtom() {\r\n        return centralAtom;\r\n    }\r\n\r\n    /**\r\n     * Returns neighboring atoms of stereo parity.\r\n     * @return\r\n     */\r\n    public JniInchiAtom[] getNeighbors() {\r\n        return neighbors;\r\n    }\r\n\r\n    public JniInchiAtom getNeighbor(int i) {\r\n        return neighbors[i];\r\n    }\r\n\r\n    /**\r\n     * Returns parity.\r\n     * @return\r\n     */\r\n    public INCHI_PARITY getParity() {\r\n        return parity;\r\n    }\r\n\r\n    /**\r\n     * Returns disconnected parity.\r\n     * @return\r\n     */\r\n    public INCHI_PARITY getDisconnectedParity() {\r\n        return disconParity;\r\n    }\r\n\r\n    /**\r\n     * Returns type of stereochemistry.\r\n     * @return\r\n     */\r\n    public INCHI_STEREOTYPE getStereoType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Generates string representation of information on stereo parity,\r\n     * for debugging purposes.\r\n     */\r\n    public String getDebugString() {\r\n        return (\"InChI Stereo0D: \" + (centralAtom == null ? \"-\" : centralAtom.getElementType()) + \" [\" + neighbors[0].getElementType() + \",\" + neighbors[1].getElementType() + \",\" + neighbors[2].getElementType() + \",\" + neighbors[3].getElementType() + \"] \" + \"Type::\" + type + \" // \" + \"Parity:\" + parity);\r\n    }\r\n\r\n    /**\r\n     * Outputs information on stereo parity, for debugging purposes.\r\n     */\r\n    public void debug() {\r\n        System.out.println(getDebugString());\r\n    }\r\n\r\n    /**\r\n     * <p>Convenience method for generating 0D stereo parities at tetrahedral\r\n     * atom centres.\r\n     *\r\n     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>\r\n     * <pre>\r\n     *  4 neighbors\r\n     *\r\n     *           X                    neighbor[4] : {#W, #X, #Y, #Z}\r\n     *           |                    central_atom: #A\r\n     *        W--A--Y                 type        : INCHI_StereoType_Tetrahedral\r\n     *           |\r\n     *           Z\r\n     *  parity: if (X,Y,Z) are clockwize when seen from W then parity is 'e' otherwise 'o'\r\n     *  Example (see AXYZW above): if W is above the plane XYZ then parity = 'e'\r\n     *\r\n     *  3 neighbors\r\n     *\r\n     *             Y          Y       neighbor[4] : {#A, #X, #Y, #Z}\r\n     *            /          /        central_atom: #A\r\n     *        X--A  (e.g. O=S   )     type        : INCHI_StereoType_Tetrahedral\r\n     *            \\          \\\r\n     *             Z          Z\r\n     *\r\n     *  parity: if (X,Y,Z) are clockwize when seen from A then parity is 'e',\r\n     *                                                         otherwise 'o'\r\n     *  unknown parity = 'u'\r\n     *  Example (see AXYZ above): if A is above the plane XYZ then parity = 'e'\r\n     *  This approach may be used also in case of an implicit H attached to A.\r\n     *\r\n     *  ==============================================\r\n     *  Note. Correspondence to CML 0D stereo parities\r\n     *  ==============================================\r\n     *  a list of 4 atoms corresponds to CML atomRefs4\r\n     *\r\n     *  tetrahedral atom\r\n     *  ================\r\n     *  CML atomParity > 0 <=> INCHI_PARITY_EVEN\r\n     *  CML atomParity < 0 <=> INCHI_PARITY_ODD\r\n     *\r\n     *                               | 1   1   1   1  |  where xW is x-coordinate of\r\n     *                               | xW  xX  xY  xZ |  atom W, etc. (xyz is a\r\n     *  CML atomParity = determinant | yW  yX  yY  yZ |  'right-handed' Cartesian\r\n     *                               | zW  zX  xY  zZ |  coordinate system)\r\n     * </pre>\r\n     *\r\n     * @param atC    Central atom\r\n     * @param at0    Neighbour atom 0\r\n     * @param at1    Neighbour atom 1\r\n     * @param at2    Neighbour atom 2\r\n     * @param at3    Neighbour atom 3\r\n     * @param parity Parity\r\n     */\r\n    public static JniInchiStereo0D createNewTetrahedralStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, INCHI_PARITY parity) {\r\n        JniInchiStereo0D stereo = new JniInchiStereo0D(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.TETRAHEDRAL, parity);\r\n        return stereo;\r\n    }\r\n\r\n    /**\r\n     * <p>Convenience method for generating 0D stereo parities at stereogenic\r\n     * double bonds.\r\n     *\r\n     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>\r\n     * <pre>\r\n     *  =============================================\r\n     *  stereogenic bond >A=B< or cumulene >A=C=C=B<\r\n     *  =============================================\r\n     *\r\n     *                              neighbor[4]  : {#X,#A,#B,#Y} in this order\r\n     *  X                           central_atom : NO_ATOM\r\n     *   \\            X      Y      type         : INCHI_StereoType_DoubleBond\r\n     *    A==B         \\    /\r\n     *        \\         A==B\r\n     *         Y\r\n     *\r\n     *  parity= 'e'    parity= 'o'   unknown parity = 'u'\r\n     *\r\n     *  ==============================================\r\n     *  Note. Correspondence to CML 0D stereo parities\r\n     *  ==============================================\r\n     *\r\n     *  stereogenic double bond and (not yet defined in CML) cumulenes\r\n     *  ==============================================================\r\n     *  CML 'C' (cis)      <=> INCHI_PARITY_ODD\r\n     *  CML 'T' (trans)    <=> INCHI_PARITY_EVEN\r\n     * </pre>\r\n     *\r\n     * @param at0    Neighbour atom 0\r\n     * @param at1    Neighbour atom 1\r\n     * @param at2    Neighbour atom 2\r\n     * @param at3    Neighbour atom 3\r\n     * @param parity Parity\r\n     * @return\r\n     */\r\n    public static JniInchiStereo0D createNewDoublebondStereo0D(final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_PARITY parity) {\r\n        JniInchiStereo0D stereo = new JniInchiStereo0D(null, at0, at1, at2, at3, INCHI_STEREOTYPE.DOUBLEBOND, parity);\r\n        return stereo;\r\n    }\r\n\r\n    int getInchiStereoType() {\r\n        return type.getIndx();\r\n    }\r\n\r\n    int getInchiParity() {\r\n        return parity.getIndx();\r\n    }\r\n}\r\n",
    "test_prompt": "// JniInchiStereo0DTest0.java\npackage net.sf.jniinchi;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiStereo0D}.\n* It contains ten unit test cases for the {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.\n*/\nclass JniInchiStereo0DTest0 {"
},
{
    "id": "cmpl-6qY4xygVyZQAsWtge5L4bqUS3Cyte",
    "object": "text_completion",
    "created": 1677982075,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tvoid testCreateNewDoublebondStereo0D() {\n\t\t\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.EVEN);\n\t\t\t\tassertEquals(stereo.getNeighbor(0), at0);\n\t\t\t\tassertEquals(stereo.getNeighbor(1), at1);\n\t\t\t\tassertEquals(stereo.getNeighbor(2), at2);\n\t\t\t\tassertEquals(stereo.getNeighbor(3), at3);\n\t\t\t\tassertEquals(stereo.getStereoType(), INCHI_STEREOTYPE.DOUBLEBOND);\n\t\t\t\tassertEquals(stereo.getParity(), INCHI_PARITY.EVEN);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid testCreateNewDoublebondStereo0D1() {\n\t\t\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.ODD);\n\t\t\t\tassertEquals(stereo.getNeighbor(0), at0);\n\t\t\t\tassertEquals(stereo.getNeighbor(1), at1);\n\t\t\t\tassertEquals(stereo.getNeighbor(2), at2);\n\t\t\t\tassertEquals(stereo.getNeighbor(3), at3);\n\t\t\t\tassertEquals(stereo.getStereoType(), INCHI_STEREOTYPE.DOUBLEBOND);\n\t\t\t\tassertEquals(stereo.getParity(), INCHI_PARITY.ODD);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid testCreateNewDoublebondStereo0D2() {\n\t\t\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.UNKNOWN);\n\t\t\t\tassertEquals(stereo.getNeighbor(0), at0);\n\t\t\t\tassertEquals(stereo.getNeighbor(1), at1);\n\t\t\t\tassertEquals(stereo.getNeighbor(2), at2);\n\t\t\t\tassertEquals(stereo.getNeighbor(3), at3);\n\t\t\t\tassertEquals(stereo.getStereoType(), INCHI_STEREOTYPE.DOUBLEBOND);\n\t\t\t\tassertEquals(stereo.getParity(), INCHI_PARITY.UNKNOWN);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid testCreateNewDoublebondStereo0D3() {\n\t\t\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.NONE);\n\t\t\t\tassertEquals(stereo.getNeighbor(0), at0);\n\t\t\t\tassertEquals(stereo.getNeighbor(1), at1);\n\t\t\t\tassertEquals(stereo.getNeighbor(2), at2);\n\t\t\t\tassertEquals(stereo.getNeighbor(3), at3);\n\t\t\t\tassertEquals(stereo.getStereoType(), INCHI_STEREOTYPE.DOUBLEBOND);\n\t\t\t\tassertEquals(stereo.getParity(), INCHI_PARITY.NONE);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid testCreateNewDoublebondStereo0D4() {\n\t\t\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at3 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.UNSPECIFIED);\n\t\t\t\tassertEquals(stereo.getNeighbor(0), at0);\n\t\t\t\tassertEquals(stereo.getNeighbor(1), at1);\n\t\t\t\tassertEquals(stereo.getNeighbor(2), at2);\n\t\t\t\tassertEquals(stereo.getNeighbor(3), at3);\n\t\t\t\tassertEquals(stereo.getStereoType(), INCHI_STEREOTYPE.DOUBLEBOND);\n\t\t\t\tassertEquals(stereo.getParity(), INCHI_PARITY.UNSPECIFIED);\n\t\t}\n\t\t\n\t\t@Test\n\t\tvoid testCreateNewDoublebondStereo0D5() {\n\t\t\t\tJniInchiAtom at0 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at1 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom at2 = new JniInchiAtom(\"C\", 0.0, 0.0, 0.0, \"\");\n\t\t\t\tJniInchiAtom",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 3276,
        "completion_tokens": 2048,
        "total_tokens": 5324
    },
    "time_taken": 35.557557106018066,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStereo0DTest1.java",
    "original_code": "// JniInchiStereo0D.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\n/**\r\n * Encapsulates properites of InChI Stereo Parity.  See <tt>inchi_api.h</tt>.\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiStereo0D {\r\n\r\n    /**\r\n     * Indicates non-existent (central) atom. Value from inchi_api.h.\r\n     */\r\n    public static final int NO_ATOM = -1;\r\n\r\n    /**\r\n     * Neighbouring atoms.\r\n     */\r\n    private JniInchiAtom[] neighbors = new JniInchiAtom[4];\r\n\r\n    /**\r\n     * Central atom.\r\n     */\r\n    private JniInchiAtom centralAtom;\r\n\r\n    /**\r\n     * Stereo parity type.\r\n     */\r\n    private INCHI_STEREOTYPE type;\r\n\r\n    /**\r\n     * Parity.\r\n     */\r\n    private INCHI_PARITY parity;\r\n\r\n    /**\r\n     * Second parity (for disconnected systems).\r\n     */\r\n    private INCHI_PARITY disconParity = INCHI_PARITY.NONE;\r\n\r\n    /**\r\n     * Constructor.  See <tt>inchi_api.h</tt> for details of usage.\r\n     *\r\n     * @see createNewTetrahedralStereo0D()\r\n     * @see createNewDoublebondStereo0D()\r\n     *\r\n     * @param atC    Central atom\r\n     * @param at0    Neighbour atom 0\r\n     * @param at1    Neighbour atom 1\r\n     * @param at2    Neighbour atom 2\r\n     * @param at3    Neighbour atom 3\r\n     * @param type          Stereo parity type\r\n     * @param parity    Parity\r\n     */\r\n    public JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_STEREOTYPE type, final INCHI_PARITY parity) {\r\n        centralAtom = atC;\r\n        neighbors[0] = at0;\r\n        neighbors[1] = at1;\r\n        neighbors[2] = at2;\r\n        neighbors[3] = at3;\r\n        this.type = type;\r\n        this.parity = parity;\r\n    }\r\n\r\n    JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final int type, final int parity) {\r\n        this(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.getValue(type), INCHI_PARITY.getValue(parity));\r\n    }\r\n\r\n    /**\r\n     * Set second parity (for disconnected systems)\r\n     * @param parity\r\n     */\r\n    public void setDisconnectedParity(final INCHI_PARITY parity) {\r\n        this.disconParity = parity;\r\n    }\r\n\r\n    /**\r\n     * Returns central atom of stereo parity.\r\n     * @return\r\n     */\r\n    public JniInchiAtom getCentralAtom() {\r\n        return centralAtom;\r\n    }\r\n\r\n    /**\r\n     * Returns neighboring atoms of stereo parity.\r\n     * @return\r\n     */\r\n    public JniInchiAtom[] getNeighbors() {\r\n        return neighbors;\r\n    }\r\n\r\n    public JniInchiAtom getNeighbor(int i) {\r\n        return neighbors[i];\r\n    }\r\n\r\n    /**\r\n     * Returns parity.\r\n     * @return\r\n     */\r\n    public INCHI_PARITY getParity() {\r\n        return parity;\r\n    }\r\n\r\n    /**\r\n     * Returns disconnected parity.\r\n     * @return\r\n     */\r\n    public INCHI_PARITY getDisconnectedParity() {\r\n        return disconParity;\r\n    }\r\n\r\n    /**\r\n     * Returns type of stereochemistry.\r\n     * @return\r\n     */\r\n    public INCHI_STEREOTYPE getStereoType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Generates string representation of information on stereo parity,\r\n     * for debugging purposes.\r\n     */\r\n    public String getDebugString() {\r\n        return (\"InChI Stereo0D: \" + (centralAtom == null ? \"-\" : centralAtom.getElementType()) + \" [\" + neighbors[0].getElementType() + \",\" + neighbors[1].getElementType() + \",\" + neighbors[2].getElementType() + \",\" + neighbors[3].getElementType() + \"] \" + \"Type::\" + type + \" // \" + \"Parity:\" + parity);\r\n    }\r\n\r\n    /**\r\n     * Outputs information on stereo parity, for debugging purposes.\r\n     */\r\n    public void debug() {\r\n        System.out.println(getDebugString());\r\n    }\r\n\r\n    /**\r\n     * <p>Convenience method for generating 0D stereo parities at tetrahedral\r\n     * atom centres.\r\n     *\r\n     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>\r\n     * <pre>\r\n     *  4 neighbors\r\n     *\r\n     *           X                    neighbor[4] : {#W, #X, #Y, #Z}\r\n     *           |                    central_atom: #A\r\n     *        W--A--Y                 type        : INCHI_StereoType_Tetrahedral\r\n     *           |\r\n     *           Z\r\n     *  parity: if (X,Y,Z) are clockwize when seen from W then parity is 'e' otherwise 'o'\r\n     *  Example (see AXYZW above): if W is above the plane XYZ then parity = 'e'\r\n     *\r\n     *  3 neighbors\r\n     *\r\n     *             Y          Y       neighbor[4] : {#A, #X, #Y, #Z}\r\n     *            /          /        central_atom: #A\r\n     *        X--A  (e.g. O=S   )     type        : INCHI_StereoType_Tetrahedral\r\n     *            \\          \\\r\n     *             Z          Z\r\n     *\r\n     *  parity: if (X,Y,Z) are clockwize when seen from A then parity is 'e',\r\n     *                                                         otherwise 'o'\r\n     *  unknown parity = 'u'\r\n     *  Example (see AXYZ above): if A is above the plane XYZ then parity = 'e'\r\n     *  This approach may be used also in case of an implicit H attached to A.\r\n     *\r\n     *  ==============================================\r\n     *  Note. Correspondence to CML 0D stereo parities\r\n     *  ==============================================\r\n     *  a list of 4 atoms corresponds to CML atomRefs4\r\n     *\r\n     *  tetrahedral atom\r\n     *  ================\r\n     *  CML atomParity > 0 <=> INCHI_PARITY_EVEN\r\n     *  CML atomParity < 0 <=> INCHI_PARITY_ODD\r\n     *\r\n     *                               | 1   1   1   1  |  where xW is x-coordinate of\r\n     *                               | xW  xX  xY  xZ |  atom W, etc. (xyz is a\r\n     *  CML atomParity = determinant | yW  yX  yY  yZ |  'right-handed' Cartesian\r\n     *                               | zW  zX  xY  zZ |  coordinate system)\r\n     * </pre>\r\n     *\r\n     * @param atC    Central atom\r\n     * @param at0    Neighbour atom 0\r\n     * @param at1    Neighbour atom 1\r\n     * @param at2    Neighbour atom 2\r\n     * @param at3    Neighbour atom 3\r\n     * @param parity Parity\r\n     */\r\n    public static JniInchiStereo0D createNewTetrahedralStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, INCHI_PARITY parity) {\r\n        JniInchiStereo0D stereo = new JniInchiStereo0D(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.TETRAHEDRAL, parity);\r\n        return stereo;\r\n    }\r\n\r\n    /**\r\n     * <p>Convenience method for generating 0D stereo parities at stereogenic\r\n     * double bonds.\r\n     *\r\n     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>\r\n     * <pre>\r\n     *  =============================================\r\n     *  stereogenic bond >A=B< or cumulene >A=C=C=B<\r\n     *  =============================================\r\n     *\r\n     *                              neighbor[4]  : {#X,#A,#B,#Y} in this order\r\n     *  X                           central_atom : NO_ATOM\r\n     *   \\            X      Y      type         : INCHI_StereoType_DoubleBond\r\n     *    A==B         \\    /\r\n     *        \\         A==B\r\n     *         Y\r\n     *\r\n     *  parity= 'e'    parity= 'o'   unknown parity = 'u'\r\n     *\r\n     *  ==============================================\r\n     *  Note. Correspondence to CML 0D stereo parities\r\n     *  ==============================================\r\n     *\r\n     *  stereogenic double bond and (not yet defined in CML) cumulenes\r\n     *  ==============================================================\r\n     *  CML 'C' (cis)      <=> INCHI_PARITY_ODD\r\n     *  CML 'T' (trans)    <=> INCHI_PARITY_EVEN\r\n     * </pre>\r\n     *\r\n     * @param at0    Neighbour atom 0\r\n     * @param at1    Neighbour atom 1\r\n     * @param at2    Neighbour atom 2\r\n     * @param at3    Neighbour atom 3\r\n     * @param parity Parity\r\n     * @return\r\n     */\r\n    public static JniInchiStereo0D createNewDoublebondStereo0D(final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_PARITY parity) {\r\n        JniInchiStereo0D stereo = new JniInchiStereo0D(null, at0, at1, at2, at3, INCHI_STEREOTYPE.DOUBLEBOND, parity);\r\n        return stereo;\r\n    }\r\n\r\n    int getInchiStereoType() {\r\n        return type.getIndx();\r\n    }\r\n\r\n    int getInchiParity() {\r\n        return parity.getIndx();\r\n    }\r\n}\r\n",
    "test_prompt": "// JniInchiStereo0DTest1.java\npackage net.sf.jniinchi;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiStereo0D}.\n* It contains ten unit test cases for the {@link JniInchiStereo0D#createNewDoublebondStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.\n*/\nclass JniInchiStereo0DTest1 {"
},
{
    "id": "cmpl-6qY60q2ADPzEiEigw7Hzy0uALgaYP",
    "object": "text_completion",
    "created": 1677982140,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t@Test\n\t\tpublic void testCase0() {\n\t\t\t\tJniInchiAtom jniInchiAtom0 = new JniInchiAtom(\"\");\n\t\t\t\tJniInchiStructure jniInchiStructure0 = new JniInchiStructure();\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t\t\tjniInchiStructure0.addAtom(jniInchiAtom0);\n\t\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1563,
        "completion_tokens": 2048,
        "total_tokens": 3611
    },
    "time_taken": 30.121938943862915,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructureTest0.java",
    "original_code": "// JniInchiStructure.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiStructure {\r\n\r\n    /**\r\n     * List of atoms.\r\n     */\r\n    private List atomList = new ArrayList();\r\n\r\n    /**\r\n     * List of bonds.\r\n     */\r\n    private List bondList = new ArrayList();\r\n\r\n    /**\r\n     * List of stero parities.\r\n     */\r\n    private List stereoList = new ArrayList();\r\n\r\n    /**\r\n     * Returns number of atoms in structure.\r\n     */\r\n    public int getNumAtoms() {\r\n        return atomList.size();\r\n    }\r\n\r\n    /**\r\n     * Returns number of bonds in structure.\r\n     */\r\n    public int getNumBonds() {\r\n        return bondList.size();\r\n    }\r\n\r\n    /**\r\n     * Returns number of stereo parities in strucuture.\r\n     */\r\n    public int getNumStereo0D() {\r\n        return stereoList.size();\r\n    }\r\n\r\n    /**\r\n     * Adds atom to inchi molecule.\r\n     *\r\n     * @param atom  Atom to add\r\n     * @return      Added atom\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiAtom addAtom(JniInchiAtom atom) {\r\n        atomList.add(atom);\r\n        return atom;\r\n    }\r\n\r\n    /**\r\n     * Convenience method to add multiple atoms to molecule.\r\n     * @param atoms\r\n     */\r\n    public void addAtoms(JniInchiAtom... atoms) {\r\n        for (JniInchiAtom atom : atoms) {\r\n            addAtom(atom);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds bond to inchi molecule.\r\n     *\r\n     * @param bond  Bond to add\r\n     * @return      Added bond\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiBond addBond(JniInchiBond bond) {\r\n        bondList.add(bond);\r\n        return bond;\r\n    }\r\n\r\n    /**\r\n     * Convenience method to add multiple bonds to molecule.\r\n     * @param bonds\r\n     */\r\n    public void addBonds(JniInchiBond... bonds) {\r\n        for (JniInchiBond bond : bonds) {\r\n            addBond(bond);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds 0D stereo parity to inchi molecule.\r\n     *\r\n     * @param parity  Parity to add\r\n     * @return        Added parity\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {\r\n        stereoList.add(parity);\r\n        return parity;\r\n    }\r\n\r\n    /**\r\n     * Returns atom from structure.\r\n     * @param i    Index of atom to return.\r\n     * @return\r\n     */\r\n    public JniInchiAtom getAtom(final int i) {\r\n        return (JniInchiAtom) atomList.get(i);\r\n    }\r\n\r\n    /**\r\n     * Returns bond from structure.\r\n     * @param i    Index of bond to return.\r\n     * @return\r\n     */\r\n    public JniInchiBond getBond(final int i) {\r\n        return (JniInchiBond) bondList.get(i);\r\n    }\r\n\r\n    /**\r\n     * Returns stereo parity from structure.\r\n     * @param i    Index of stereo parity to return.\r\n     * @return\r\n     */\r\n    public JniInchiStereo0D getStereo0D(final int i) {\r\n        return (JniInchiStereo0D) stereoList.get(i);\r\n    }\r\n\r\n    public void setStructure(JniInchiStructure structure) {\r\n        this.atomList = structure.atomList;\r\n        this.bondList = structure.bondList;\r\n        this.stereoList = structure.stereoList;\r\n    }\r\n\r\n    int getAtomIndex(JniInchiAtom atom) {\r\n        return atomList.indexOf(atom);\r\n    }\r\n\r\n    int getStereo0DIndex(JniInchiStereo0D stereo) {\r\n        return stereoList.indexOf(stereo);\r\n    }\r\n}\r\n",
    "test_prompt": "// JniInchiStructureTest0.java\npackage net.sf.jniinchi;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiStructure}.\n* It contains ten unit test cases for the {@link JniInchiStructure#addAtom(JniInchiAtom)} method.\n*/\nclass JniInchiStructureTest0 {"
},
{
    "id": "cmpl-6qY73SYHqHxE5ZSbqSynRuNWGivJf",
    "object": "text_completion",
    "created": 1677982205,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test case 1 for method {@link JniInchiStructure#addBond(JniInchiBond)}.\n\t\t * \n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testAddBond1() throws JniInchiException {\n\t\t\t\tJniInchiAtom atom1 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom2 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom3 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom4 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom5 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom6 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom7 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom8 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom9 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom10 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom11 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom12 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom13 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom14 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom15 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom16 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom17 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom18 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom19 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom20 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom21 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom22 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom23 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom24 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom25 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom26 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom27 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom28 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom29 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom30 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom31 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom32 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom33 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom34 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom35 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom36 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom37 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom38 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom39 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom40 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom41 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom42 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom43 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom44 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom45 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom46 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom47 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom48 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom49 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom50 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom51 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom52 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom53 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom54 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom55 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom56 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom57 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom58 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom59 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom60 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom61 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom62 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom63 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom64 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom65 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom66 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom67 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom68 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom69 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom70 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom71 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom72 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom73 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom74 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom75 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom76 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom77 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom78 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom79 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom80 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom81 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom82 = new JniInchiAtom(\"C\");\n\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1563,
        "completion_tokens": 2048,
        "total_tokens": 3611
    },
    "time_taken": 30.42177700996399,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructureTest1.java",
    "original_code": "// JniInchiStructure.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiStructure {\r\n\r\n    /**\r\n     * List of atoms.\r\n     */\r\n    private List atomList = new ArrayList();\r\n\r\n    /**\r\n     * List of bonds.\r\n     */\r\n    private List bondList = new ArrayList();\r\n\r\n    /**\r\n     * List of stero parities.\r\n     */\r\n    private List stereoList = new ArrayList();\r\n\r\n    /**\r\n     * Returns number of atoms in structure.\r\n     */\r\n    public int getNumAtoms() {\r\n        return atomList.size();\r\n    }\r\n\r\n    /**\r\n     * Returns number of bonds in structure.\r\n     */\r\n    public int getNumBonds() {\r\n        return bondList.size();\r\n    }\r\n\r\n    /**\r\n     * Returns number of stereo parities in strucuture.\r\n     */\r\n    public int getNumStereo0D() {\r\n        return stereoList.size();\r\n    }\r\n\r\n    /**\r\n     * Adds atom to inchi molecule.\r\n     *\r\n     * @param atom  Atom to add\r\n     * @return      Added atom\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiAtom addAtom(JniInchiAtom atom) {\r\n        atomList.add(atom);\r\n        return atom;\r\n    }\r\n\r\n    /**\r\n     * Convenience method to add multiple atoms to molecule.\r\n     * @param atoms\r\n     */\r\n    public void addAtoms(JniInchiAtom... atoms) {\r\n        for (JniInchiAtom atom : atoms) {\r\n            addAtom(atom);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds bond to inchi molecule.\r\n     *\r\n     * @param bond  Bond to add\r\n     * @return      Added bond\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiBond addBond(JniInchiBond bond) {\r\n        bondList.add(bond);\r\n        return bond;\r\n    }\r\n\r\n    /**\r\n     * Convenience method to add multiple bonds to molecule.\r\n     * @param bonds\r\n     */\r\n    public void addBonds(JniInchiBond... bonds) {\r\n        for (JniInchiBond bond : bonds) {\r\n            addBond(bond);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds 0D stereo parity to inchi molecule.\r\n     *\r\n     * @param parity  Parity to add\r\n     * @return        Added parity\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {\r\n        stereoList.add(parity);\r\n        return parity;\r\n    }\r\n\r\n    /**\r\n     * Returns atom from structure.\r\n     * @param i    Index of atom to return.\r\n     * @return\r\n     */\r\n    public JniInchiAtom getAtom(final int i) {\r\n        return (JniInchiAtom) atomList.get(i);\r\n    }\r\n\r\n    /**\r\n     * Returns bond from structure.\r\n     * @param i    Index of bond to return.\r\n     * @return\r\n     */\r\n    public JniInchiBond getBond(final int i) {\r\n        return (JniInchiBond) bondList.get(i);\r\n    }\r\n\r\n    /**\r\n     * Returns stereo parity from structure.\r\n     * @param i    Index of stereo parity to return.\r\n     * @return\r\n     */\r\n    public JniInchiStereo0D getStereo0D(final int i) {\r\n        return (JniInchiStereo0D) stereoList.get(i);\r\n    }\r\n\r\n    public void setStructure(JniInchiStructure structure) {\r\n        this.atomList = structure.atomList;\r\n        this.bondList = structure.bondList;\r\n        this.stereoList = structure.stereoList;\r\n    }\r\n\r\n    int getAtomIndex(JniInchiAtom atom) {\r\n        return atomList.indexOf(atom);\r\n    }\r\n\r\n    int getStereo0DIndex(JniInchiStereo0D stereo) {\r\n        return stereoList.indexOf(stereo);\r\n    }\r\n}\r\n",
    "test_prompt": "// JniInchiStructureTest1.java\npackage net.sf.jniinchi;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiStructure}.\n* It contains ten unit test cases for the {@link JniInchiStructure#addBond(JniInchiBond)} method.\n*/\nclass JniInchiStructureTest1 {"
},
{
    "id": "cmpl-6qY86gckXJyx1ZYLGsQNJryGMGVZ3",
    "object": "text_completion",
    "created": 1677982270,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test case 1 for method {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)}.\n\t\t * \n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testAddStereo0D1() throws JniInchiException {\n\t\t\t\tJniInchiAtom atom1 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom2 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom3 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom4 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom5 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom6 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom7 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom8 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom9 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom10 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom11 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom12 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom13 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom14 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom15 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom16 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom17 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom18 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom19 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom20 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom21 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom22 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom23 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom24 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom25 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom26 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom27 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom28 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom29 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom30 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom31 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom32 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom33 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom34 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom35 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom36 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom37 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom38 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom39 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom40 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom41 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom42 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom43 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom44 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom45 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom46 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom47 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom48 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom49 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom50 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom51 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom52 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom53 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom54 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom55 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom56 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom57 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom58 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom59 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom60 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom61 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom62 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom63 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom64 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom65 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom66 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom67 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom68 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom69 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom70 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom71 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom72 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom73 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom74 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom75 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom76 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom77 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom78 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom79 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom80 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom81 = new JniInchiAtom(\"C\");\n\t\t\t\tJniInchiAtom atom82 = new JniInchiAt",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 1567,
        "completion_tokens": 2048,
        "total_tokens": 3615
    },
    "time_taken": 30.35227608680725,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructureTest2.java",
    "original_code": "// JniInchiStructure.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n/**\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiStructure {\r\n\r\n    /**\r\n     * List of atoms.\r\n     */\r\n    private List atomList = new ArrayList();\r\n\r\n    /**\r\n     * List of bonds.\r\n     */\r\n    private List bondList = new ArrayList();\r\n\r\n    /**\r\n     * List of stero parities.\r\n     */\r\n    private List stereoList = new ArrayList();\r\n\r\n    /**\r\n     * Returns number of atoms in structure.\r\n     */\r\n    public int getNumAtoms() {\r\n        return atomList.size();\r\n    }\r\n\r\n    /**\r\n     * Returns number of bonds in structure.\r\n     */\r\n    public int getNumBonds() {\r\n        return bondList.size();\r\n    }\r\n\r\n    /**\r\n     * Returns number of stereo parities in strucuture.\r\n     */\r\n    public int getNumStereo0D() {\r\n        return stereoList.size();\r\n    }\r\n\r\n    /**\r\n     * Adds atom to inchi molecule.\r\n     *\r\n     * @param atom  Atom to add\r\n     * @return      Added atom\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiAtom addAtom(JniInchiAtom atom) {\r\n        atomList.add(atom);\r\n        return atom;\r\n    }\r\n\r\n    /**\r\n     * Convenience method to add multiple atoms to molecule.\r\n     * @param atoms\r\n     */\r\n    public void addAtoms(JniInchiAtom... atoms) {\r\n        for (JniInchiAtom atom : atoms) {\r\n            addAtom(atom);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds bond to inchi molecule.\r\n     *\r\n     * @param bond  Bond to add\r\n     * @return      Added bond\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiBond addBond(JniInchiBond bond) {\r\n        bondList.add(bond);\r\n        return bond;\r\n    }\r\n\r\n    /**\r\n     * Convenience method to add multiple bonds to molecule.\r\n     * @param bonds\r\n     */\r\n    public void addBonds(JniInchiBond... bonds) {\r\n        for (JniInchiBond bond : bonds) {\r\n            addBond(bond);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds 0D stereo parity to inchi molecule.\r\n     *\r\n     * @param parity  Parity to add\r\n     * @return        Added parity\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {\r\n        stereoList.add(parity);\r\n        return parity;\r\n    }\r\n\r\n    /**\r\n     * Returns atom from structure.\r\n     * @param i    Index of atom to return.\r\n     * @return\r\n     */\r\n    public JniInchiAtom getAtom(final int i) {\r\n        return (JniInchiAtom) atomList.get(i);\r\n    }\r\n\r\n    /**\r\n     * Returns bond from structure.\r\n     * @param i    Index of bond to return.\r\n     * @return\r\n     */\r\n    public JniInchiBond getBond(final int i) {\r\n        return (JniInchiBond) bondList.get(i);\r\n    }\r\n\r\n    /**\r\n     * Returns stereo parity from structure.\r\n     * @param i    Index of stereo parity to return.\r\n     * @return\r\n     */\r\n    public JniInchiStereo0D getStereo0D(final int i) {\r\n        return (JniInchiStereo0D) stereoList.get(i);\r\n    }\r\n\r\n    public void setStructure(JniInchiStructure structure) {\r\n        this.atomList = structure.atomList;\r\n        this.bondList = structure.bondList;\r\n        this.stereoList = structure.stereoList;\r\n    }\r\n\r\n    int getAtomIndex(JniInchiAtom atom) {\r\n        return atomList.indexOf(atom);\r\n    }\r\n\r\n    int getStereo0DIndex(JniInchiStereo0D stereo) {\r\n        return stereoList.indexOf(stereo);\r\n    }\r\n}\r\n",
    "test_prompt": "// JniInchiStructureTest2.java\npackage net.sf.jniinchi;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiStructure}.\n* It contains ten unit test cases for the {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)} method.\n*/\nclass JniInchiStructureTest2 {"
},
{
    "id": "cmpl-6qY990fKI5jfMe7tBCI0w3awJw4vN",
    "object": "text_completion",
    "created": 1677982335,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchi(JniInchiInput)} method.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchi() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/1/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;+2;+3;+4;+5;+6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: Empty structure\", output.getMessage());\n\t\t\t\tassertEquals(\"\", output.getLog());\n\t\t\t\tassertEquals(0, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchi(JniInchiInput)} method.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchi1() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/1/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;+2;+3;+4;+5;+6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: Empty structure\", output.getMessage());\n\t\t\t\tassertEquals(\"\", output.getLog());\n\t\t\t\tassertEquals(0, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchi(JniInchiInput)} method.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchi2() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/1/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;+2;+3;+4;+5;+6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: Empty structure\", output.getMessage());\n\t\t\t\tassertEquals(\"\", output.getLog());\n\t\t\t\tassertEquals(0, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchi(JniInchiInput)} method.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchi3() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/1/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;+2;+3;+4;+5;+6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: Empty structure\", output.getMessage());\n\t\t\t\tassertEquals(\"\", output.getLog());\n\t\t\t\tassertEquals(0, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchi(JniInchiInput)} method.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchi4() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/1/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;+2;+3;+4;+5;+6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: Empty structure\", output.getMessage());\n\t\t\t\tassertEquals(\"\", output.getLog());\n\t\t\t\tassertEquals(0, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchi(JniInchiInput)} method.\n\t\t * @th",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4792,
        "completion_tokens": 2048,
        "total_tokens": 6840
    },
    "time_taken": 39.8881139755249,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest0.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest0.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#getInchi(JniInchiInput)} method.\n*/\nclass JniInchiWrapperTest0 {"
},
{
    "id": "cmpl-6qYAC5xkih21Zz7lottqfIvz75GnB",
    "object": "text_completion",
    "created": 1677982400,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test case 1.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetStdInchi1() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getStdInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/0/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;-2;+3;-4;+5;-6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: no 2D or 3D coordinates\", output.getMessage());\n\t\t\t\tassertEquals(\"Ok\", output.getLog());\n\t\t\t\tassertEquals(INCHI_RET.OKAY, output.getReturnStatus());\n\t\t\t\tassertEquals(INCHI_RET.WARNING, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case 2.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetStdInchi2() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getStdInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/0/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;-2;+3;-4;+5;-6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: no 2D or 3D coordinates\", output.getMessage());\n\t\t\t\tassertEquals(\"Ok\", output.getLog());\n\t\t\t\tassertEquals(INCHI_RET.OKAY, output.getReturnStatus());\n\t\t\t\tassertEquals(INCHI_RET.WARNING, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case 3.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetStdInchi3() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getStdInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/0/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;-2;+3;-4;+5;-6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: no 2D or 3D coordinates\", output.getMessage());\n\t\t\t\tassertEquals(\"Ok\", output.getLog());\n\t\t\t\tassertEquals(INCHI_RET.OKAY, output.getReturnStatus());\n\t\t\t\tassertEquals(INCHI_RET.WARNING, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case 4.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetStdInchi4() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getStdInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/0/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;-2;+3;-4;+5;-6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: no 2D or 3D coordinates\", output.getMessage());\n\t\t\t\tassertEquals(\"Ok\", output.getLog());\n\t\t\t\tassertEquals(INCHI_RET.OKAY, output.getReturnStatus());\n\t\t\t\tassertEquals(INCHI_RET.WARNING, output.getReturnStatus());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case 5.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetStdInchi5() throws JniInchiException {\n\t\t\t\tJniInchiInput input = new JniInchiInput(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getStdInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t\t\tassertEquals(\"InChIKey=UHOVQNZJYSORNB-UHFFFAOYSA-N\", output.getInchiKey());\n\t\t\t\tassertEquals(\"AuxInfo=1/0/N:1,2,3,4,5,6/E:(1,2,3,4,5,6)/rA:6CCCCCC/rB:s1;s2;s3;s4;s5;s6;/rC:;;;;;;;;/rD:+1;-2;+3;-4;+5;-6\", output.getAuxInfo());\n\t\t\t\tassertEquals(\"Warning: no 2D or 3D coordinates\", output.getMessage());\n\t\t\t\tassertEquals(\"Ok\", output.",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4794,
        "completion_tokens": 2048,
        "total_tokens": 6842
    },
    "time_taken": 40.40289306640625,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest1.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest1.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#getStdInchi(JniInchiInput)} method.\n*/\nclass JniInchiWrapperTest1 {"
},
{
    "id": "cmpl-6qYBFkmQzh7gdymdBVCXDh1ISlqgZ",
    "object": "text_completion",
    "created": 1677982465,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is null.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_NullInchi() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(null, null);\n\t\t\t\tassertThrows(IllegalArgumentException.class, () -> {\n\t\t\t\t\t\tJniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\t});\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is empty.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_EmptyInchi() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"\", null);\n\t\t\t\tassertThrows(JniInchiException.class, () -> {\n\t\t\t\t\t\tJniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\t});\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is invalid.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_InvalidInchi() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", null);\n\t\t\t\tassertThrows(JniInchiException.class, () -> {\n\t\t\t\t\t\tJniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\t});\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is valid.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_ValidInchi() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", null);\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is valid and the options string is null.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_ValidInchi_NullOptions() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", null);\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is valid and the options string is empty.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_ValidInchi_EmptyOptions() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", \"\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is valid and the options string is invalid.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_ValidInchi_InvalidOptions() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", \"/Snon\");\n\t\t\t\tassertThrows(JniInchiException.class, () -> {\n\t\t\t\t\t\tJniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\t});\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is valid and the options string is valid.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_ValidInchi_ValidOptions() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", \"/InChI2InChI\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", output.getInchi());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n\t\t * It tests the case when the input InChI string is valid and the options string is valid.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiFromInchi_ValidInchi_ValidOptions2() throws JniInchiException {\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\", \"/InChI2InChI /Snon\");\n\t\t\t\tJniInchiOutput output = JniInchiWrapper.getInchiFromInchi(input);\n\t\t\t\tassertEquals(\"InChI=1S/C6H6/c1-2-4-6-5",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4797,
        "completion_tokens": 2048,
        "total_tokens": 6845
    },
    "time_taken": 39.4549400806427,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest2.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest2.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.\n*/\nclass JniInchiWrapperTest2 {"
},
{
    "id": "cmpl-6qYCIJ9mJ0BLRiHQQVhy60OV6Yt1i",
    "object": "text_completion",
    "created": 1677982530,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t* Test case 1.\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testGetStructureFromInchi1() throws JniInchiException {\n\t\t\t\tJniInchiWrapper.loadLibrary();\n\t\t\t\tJniInchiWrapper.init();\n\t\t\t\tJniInchiInputInchi input = new JniInchiInputInchi(\"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\");\n\t\t\t\tJniInchiOutputStructure output = JniInchiWrapper.getStructureFromInchi(input);\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getReturnStatus(), INCHI_RET.OKAY);\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getLog(), \"\");\n\t\t\t\tassertEquals(output.getAuxInfo(), \"\");\n\t\t\t\tassertEquals(output.getMessage(), \"Structure OK. Warning: no stereo0D\");\n\t\t\t\tassertEquals(output.getWarningFlags(), \"Warning: no stereo0D\");\n\t\t\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4797,
        "completion_tokens": 2048,
        "total_tokens": 6845
    },
    "time_taken": 40.57038903236389,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest3.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest3.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#getStructureFromInchi(JniInchiInputInchi)} method.\n*/\nclass JniInchiWrapperTest3 {"
},
{
    "id": "cmpl-6qYDMvcE3XburE8WbbHo5hhazUCrf",
    "object": "text_completion",
    "created": 1677982596,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey1() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey2() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey3() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+/f/h2H\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey4() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+/f/h2H/q+1\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey5() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+/f/h2H/q+1/p-1\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey6() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+/f/h2H/q+1/p-1/t2-,4+\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey7() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+/f/h2H/q+1/p-1/t2-,4+/m1/s1\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey8() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+/f/h2H/q+1/p-1/t2-,4+/m1/s1/i2+1\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniInchiOutputKey output = JniInchiWrapper.getInchiKey(inchi);\n\t\t\t\tassertEquals(expected, output.getKey());\n\t\t}\n\t\t\n\t\t/**\n\t\t * Test case for {@link JniInchiWrapper#getInchiKey(String)} method.\n\t\t * It tests the method with a valid InChI string.\n\t\t * @throws JniInchiException\n\t\t */\n\t\t@Test\n\t\tvoid testGetInchiKey9() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+/f/h2H/q+1/p-1/t2-,4+/m1/s1/i2+1/c2-1-,3-4+\";\n\t\t\t\tString expected = \"UHOVQNZJYSORNB-UHFFFAOYSA-N\";\n\t\t\t\tJniIn",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4789,
        "completion_tokens": 2048,
        "total_tokens": 6837
    },
    "time_taken": 40.3431670665741,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest4.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest4.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#getInchiKey(String)} method.\n*/\nclass JniInchiWrapperTest4 {"
},
{
    "id": "cmpl-6qYEOfInsASeCVjnPS3EWvxzfQkRU",
    "object": "text_completion",
    "created": 1677982660,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t* Test case 1.\n\t\t* Test method: {@link JniInchiWrapper#checkInchiKey(String)}.\n\t\t* Test data: {@code null}.\n\t\t* Expected result: {@code IllegalArgumentException}.\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchiKey1() {\n\t\t\t\tassertThrows(IllegalArgumentException.class, () -> {\n\t\t\t\t\t\tJniInchiWrapper.checkInchiKey(null);\n\t\t\t\t});\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 2.\n\t\t* Test method: {@link JniInchiWrapper#checkInchiKey(String)}.\n\t\t* Test data: {@code \"InChIKey=ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210/ZYXWVUTSR",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4789,
        "completion_tokens": 2048,
        "total_tokens": 6837
    },
    "time_taken": 40.072121143341064,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest5.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest5.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#checkInchiKey(String)} method.\n*/\nclass JniInchiWrapperTest5 {"
},
{
    "id": "cmpl-6qYFRs1QsBEHRuN0ywpA3AaqcdgPx",
    "object": "text_completion",
    "created": 1677982725,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t* Test case 1.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi1() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\";\n\t\t\t\tboolean strict = false;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 2.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi2() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H\";\n\t\t\t\tboolean strict = true;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 3.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi3() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+\";\n\t\t\t\tboolean strict = false;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 4.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi4() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/b2-1-,4-3+\";\n\t\t\t\tboolean strict = true;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 5.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi5() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/p-1\";\n\t\t\t\tboolean strict = false;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 6.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi6() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/p-1\";\n\t\t\t\tboolean strict = true;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 7.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi7() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/q+1\";\n\t\t\t\tboolean strict = false;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 8.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi8() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/q+1\";\n\t\t\t\tboolean strict = true;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 9.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi9() throws JniInchiException {\n\t\t\t\tString inchi = \"InChI=1S/C6H6/c1-2-4-6-5-3-1/h1-6H/q+1/p-1\";\n\t\t\t\tboolean strict = false;\n\t\t\t\tINCHI_STATUS status = JniInchiWrapper.checkInchi(inchi, strict);\n\t\t\t\tassertEquals(INCHI_STATUS.OKAY, status);\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 10.\n\t\t* <p>\n\t\t* This test case checks the {@link JniInchiWrapper#checkInchi(String, boolean)} method with a valid InChI string.\n\t\t* </p>\n\t\t* @throws JniInchiException\n\t\t*/\n\t\t@Test\n\t\tvoid testCheckInchi10() throws JniInchiException {\n\t\t\t\t",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4790,
        "completion_tokens": 2048,
        "total_tokens": 6838
    },
    "time_taken": 39.42697882652283,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest6.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest6.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#checkInchi(String, boolean)} method.\n*/\nclass JniInchiWrapperTest6 {"
},
{
    "id": "cmpl-6qYGVn0HumVnNNF7G0p0T6102sD1M",
    "object": "text_completion",
    "created": 1677982791,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t* Test case 1.\n\t\t* Test method: {@link JniInchiWrapper#getInputFromAuxInfo(String)}.\n\t\t* Test data: AuxInfo with one atom.\n\t\t* Expected result: JniInchiInputData object with one atom.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetInputFromAuxInfo1() throws JniInchiException {\n\t\t\t\tString auxInfo = \"AuxInfo=1/0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/\";\n\t\t\t\tJniInchiInputData inputData = JniInchiWrapper.getInputFromAuxInfo(auxInfo);\n\t\t\t\tassertEquals(1, inputData.getNumAtoms());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 2.\n\t\t* Test method: {@link JniInchiWrapper#getInputFromAuxInfo(String)}.\n\t\t* Test data: AuxInfo with two atoms.\n\t\t* Expected result: JniInchiInputData object with two atoms.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetInputFromAuxInfo2() throws JniInchiException {\n\t\t\t\tString auxInfo = \"AuxInfo=2/0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/\";\n\t\t\t\tJniInchiInputData inputData = JniInchiWrapper.getInputFromAuxInfo(auxInfo);\n\t\t\t\tassertEquals(2, inputData.getNumAtoms());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 3.\n\t\t* Test method: {@link JniInchiWrapper#getInputFromAuxInfo(String)}.\n\t\t* Test data: AuxInfo with one atom and one bond.\n\t\t* Expected result: JniInchiInputData object with one atom and one bond.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetInputFromAuxInfo3() throws JniInchiException {\n\t\t\t\tString auxInfo = \"AuxInfo=1/1/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/\";\n\t\t\t\tJniInchiInputData inputData = JniInchiWrapper.getInputFromAuxInfo(auxInfo);\n\t\t\t\tassertEquals(1, inputData.getNumAtoms());\n\t\t\t\tassertEquals(1, inputData.getNumBonds());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 4.\n\t\t* Test method: {@link JniInchiWrapper#getInputFromAuxInfo(String)}.\n\t\t* Test data: AuxInfo with two atoms and one bond.\n\t\t* Expected result: JniInchiInputData object with two atoms and one bond.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetInputFromAuxInfo4() throws JniInchiException {\n\t\t\t\tString auxInfo = \"AuxInfo=2/1/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/\";\n\t\t\t\tJniInchiInputData inputData = JniInchiWrapper.getInputFromAuxInfo(auxInfo);\n\t\t\t\tassertEquals(2, inputData.getNumAtoms());\n\t\t\t\tassertEquals(1, inputData.getNumBonds());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 5.\n\t\t* Test method: {@link JniInchiWrapper#getInputFromAuxInfo(String)}.\n\t\t* Test data: AuxInfo with one atom and two bonds.\n\t\t* Expected result: JniInchiInputData object with one atom and two bonds.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetInputFromAuxInfo5() throws JniInchiException {\n\t\t\t\tString auxInfo = \"AuxInfo=1/2/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/\";\n\t\t\t\tJniInchiInputData inputData = JniInchiWrapper.getInputFromAuxInfo(auxInfo);\n\t\t\t\tassertEquals(1, inputData.getNumAtoms());\n\t\t\t\tassertEquals(2, inputData.getNumBonds());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 6.\n\t\t* Test method: {@link JniInchiWrapper#getInputFromAuxInfo(String)}.\n\t\t* Test data: AuxInfo with two atoms and two bonds.\n\t\t* Expected result: JniInchiInputData object with two atoms and two bonds.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetInputFromAuxInfo6() throws JniInchiException {\n\t\t\t\tString auxInfo = \"AuxInfo=2/2/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/\";\n\t\t\t\tJniInchiInputData inputData = JniInchiWrapper.getInputFromAuxInfo(auxInfo);\n\t\t\t\tassertEquals(2, inputData.getNumAtoms());\n\t\t\t\tassertEquals(2, inputData.getNumBonds());\n\t\t}\n\t\t\n\t\t/**\n\t\t* Test case 7.\n\t\t* Test method: {@link JniInchiWrapper#getInputFromAuxInfo(String)}.\n\t\t* Test data: AuxInfo with one atom and one bond and one atom label.\n\t\t* Expected result: JniInchiInputData object with one atom and one bond and one atom label.\n\t\t*/\n\t\t@Test\n\t\tvoid testGetInputFromAuxInfo7() throws JniInchiException {\n\t\t\t\tString auxInfo = \"AuxInfo=1/1/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/N:0,0,0,0,0/E:(1,1,1,0,0)/rA:6.0/rB:1.0/rC:1.0/p:0/t:0/L:1/\";\n\t\t\t\tJniInchiInputData inputData = JniInchiWrapper.getInputFromAuxInfo(auxInfo);\n\t\t\t\tassertEquals(1, inputData.getNumAtoms());\n\t\t\t\tassertEquals(1, inputData.getNum",
            "index": 0,
            "logprobs": null,
            "finish_reason": "length"
        }
    ],
    "usage": {
        "prompt_tokens": 4791,
        "completion_tokens": 2048,
        "total_tokens": 6839
    },
    "time_taken": 40.01803016662598,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapperTest7.java",
    "original_code": "// JniInchiWrapper.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport net.sf.jnati.NativeCodeException;\r\nimport net.sf.jnati.deploy.NativeLibraryLoader;\r\nimport java.util.List;\r\nimport java.util.StringTokenizer;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.TimeoutException;\r\nimport java.util.concurrent.locks.Lock;\r\nimport java.util.concurrent.locks.ReentrantLock;\r\n\r\n/**\r\n * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.\r\n *\r\n * <p>This class is not intended to be used directly, but should be accessed\r\n * through subclasses that read data formats and load them into the InChI\r\n * data structures.\r\n *\r\n * <p>Subclasses should load data through the addAtom, addBond and addParity\r\n * methods. Once the molecule is fully loaded then the generateInchi method\r\n * should be called. Ideally this should all take place within the subclass's\r\n * constructor. The public get methods will all return null until this has\r\n * happened.\r\n *\r\n * <p>See <tt>inchi_api.h</tt>.\r\n *\r\n * @author Sam Adams\r\n */\r\npublic class JniInchiWrapper {\r\n\r\n    private static final String ID = \"jniinchi\";\r\n\r\n    private static final String VERSION = \"1.03_1\";\r\n\r\n    /**\r\n     * Maximum time to wait for a lock (in seconds).\r\n     */\r\n    private static final int MAX_LOCK_TIMEOUT = 15;\r\n\r\n    /**\r\n     * Flag indicating windows or linux.\r\n     */\r\n    private static final boolean IS_WINDOWS = System.getProperty(\"os.name\", \"\").toLowerCase().startsWith(\"windows\");\r\n\r\n    /**\r\n     * Switch character for passing options. / in windows, - on other systems.\r\n     */\r\n    static final String flagChar = IS_WINDOWS ? \"/\" : \"-\";\r\n\r\n    /**\r\n     * Records whether native library has been loaded by system.\r\n     */\r\n    private static boolean libraryLoaded = false;\r\n\r\n    private static JniInchiWrapper inchiWrapper;\r\n\r\n    private static final Lock lock = new ReentrantLock(true);\r\n\r\n    /**\r\n     * Loads native library.\r\n     * @throws JniInchiException Library failed to load\r\n     */\r\n    public static synchronized void loadLibrary() throws LoadNativeLibraryException {\r\n        if (!libraryLoaded) {\r\n            try {\r\n                NativeLibraryLoader.loadLibrary(ID, VERSION);\r\n                // Check expected version of native code loaded\r\n                // Throws NativeCodeException if unable to make call / wrong version\r\n                checkNativeCodeVersion();\r\n                // Everything is set up!\r\n                libraryLoaded = true;\r\n            } catch (NativeCodeException ex) {\r\n                System.err.println();\r\n                System.err.println(\"Error loading JNI InChI native code.\");\r\n                System.err.println(\"You may need to compile the native code for your platform.\");\r\n                System.err.println(\"See http://jni-inchi.sourceforge.net for instructions.\");\r\n                System.err.println();\r\n                throw new LoadNativeLibraryException(ex);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks the expected native code version has been loaded.\r\n     * @throws NativeCodeException\r\n     */\r\n    private static void checkNativeCodeVersion() throws NativeCodeException {\r\n        // Get native code version string\r\n        String nativeVersion;\r\n        try {\r\n            nativeVersion = JniInchiWrapper.LibInchiGetVersion();\r\n        } catch (UnsatisfiedLinkError e) {\r\n            throw new NativeCodeException(\"Unable get native code version\", e);\r\n        }\r\n        // Compare to expected version\r\n        if (!VERSION.equals(nativeVersion)) {\r\n            throw new NativeCodeException(\"JNI InChI native code version mismatch: expected \" + VERSION + \", found \" + nativeVersion);\r\n        }\r\n    }\r\n\r\n    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {\r\n        if (inchiWrapper == null) {\r\n            loadLibrary();\r\n            init();\r\n            inchiWrapper = new JniInchiWrapper();\r\n        }\r\n        return inchiWrapper;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    private JniInchiWrapper() throws LoadNativeLibraryException {\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops  List of INCHI_OPTION\r\n     */\r\n    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuffer sbOptions = new StringBuffer();\r\n        for (int i = 0; i < ops.size(); i++) {\r\n            Object op = ops.get(i);\r\n            if (op instanceof INCHI_OPTION) {\r\n                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + \" \");\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * Checks and canonicalises options.\r\n     *\r\n     * @param ops          Space delimited string of options to pass to InChI library.\r\n     *                     Each option may optionally be preceded by a command line\r\n     *                     switch (/ or -).\r\n     */\r\n    protected static String checkOptions(final String ops) throws JniInchiException {\r\n        if (ops == null) {\r\n            throw new IllegalArgumentException(\"Null options\");\r\n        }\r\n        StringBuilder sbOptions = new StringBuilder();\r\n        StringTokenizer tok = new StringTokenizer(ops);\r\n        while (tok.hasMoreTokens()) {\r\n            String op = tok.nextToken();\r\n            if (op.startsWith(\"-\") || op.startsWith(\"/\")) {\r\n                op = op.substring(1);\r\n            }\r\n            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);\r\n            if (option != null) {\r\n                sbOptions.append(flagChar + option.name());\r\n                if (tok.hasMoreTokens()) {\r\n                    sbOptions.append(\" \");\r\n                }\r\n            } else {\r\n                throw new JniInchiException(\"Unrecognised InChI option\");\r\n            }\r\n        }\r\n        return sbOptions.toString();\r\n    }\r\n\r\n    /**\r\n     * <p>Generates the InChI for a chemical structure.</p>\r\n     *\r\n     * <p>If no InChI creation/stereo modification options are specified then a standard\r\n     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>\r\n     *\r\n     * <p><b>Valid options:</b></p>\r\n     * <pre>\r\n     *  Structure perception (compatible with stdInChI):\r\n     *    /NEWPSOFF   /DoNotAddH   /SNon\r\n     *  Stereo interpretation (lead to generation of non-standard InChI)\r\n     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF\r\n     *  InChI creation options (lead to generation of non-standard InChI)\r\n     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T\r\n     * </pre>\r\n     *\r\n     * <p><b>Other options:</b></p>\r\n     * <pre>\r\n     *  /AuxNone    Omit auxiliary information (default: Include)\r\n     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited\r\n     *              In InChI library the default value is unlimited\r\n     *  /OutputSDF  Output SDfile instead of InChI\r\n     *  /WarnOnEmptyStructure\r\n     *              Warn and produce empty InChI for empty structure\r\n     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)\r\n     * </pre>\r\n     *\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Calculates the Standard InChI string for a chemical structure.</p>\r\n     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural\r\n     * perception options are specified then the calculation will fail.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    @SuppressWarnings(\"unchecked\")\r\n    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStdINCHI(input);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>\r\n     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the\r\n     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.\r\n     * In order to keep all InChI layers use options string \"/FixedH /RecMet\"; option /InChI2InChI is not needed.</p>\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generated 0D structure from an InChI string.\r\n     * @param input\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {\r\n        if (input == null) {\r\n            throw new IllegalArgumentException(\"Null input\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculates the InChIKey for an InChI string.\r\n     * @param inchi     source InChI string\r\n     * @return  InChIKey output\r\n     * @throws  JniInchiException\r\n     */\r\n    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIKeyFromINCHI(inchi);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Checks whether a string represents valid InChIKey.\r\n     * @param key\r\n     * @return\r\n     * @throws JniInchiException\r\n     */\r\n    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {\r\n        if (key == null) {\r\n            throw new IllegalArgumentException(\"Null InChI key\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHIKey(key);\r\n            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * <p>Checks if the string represents valid InChI/standard InChI.</p>\r\n     *\r\n     * @param inchi  source InChI\r\n     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result\r\n     *               may not be strict.\r\n     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting\r\n     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of\r\n     */\r\n    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {\r\n        if (inchi == null) {\r\n            throw new IllegalArgumentException(\"Null InChI\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            int ret = wrapper.CheckINCHI(inchi, strict);\r\n            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);\r\n            if (retStatus == null) {\r\n                throw new JniInchiException(\"Unknown return status: \" + ret);\r\n            }\r\n            return retStatus;\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {\r\n        if (auxInfo == null) {\r\n            throw new IllegalArgumentException(\"Null AuxInfo\");\r\n        }\r\n        JniInchiWrapper wrapper = getWrapper();\r\n        wrapper.getLock();\r\n        try {\r\n            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);\r\n        } finally {\r\n            lock.unlock();\r\n        }\r\n    }\r\n\r\n    private static synchronized void getLock() throws JniInchiException {\r\n        try {\r\n            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {\r\n                throw new TimeoutException(\"Unable to get lock\");\r\n            }\r\n        } catch (TimeoutException ex) {\r\n            throw new JniInchiException(ex);\r\n        } catch (InterruptedException ex) {\r\n            throw new JniInchiException(ex);\r\n        }\r\n    }\r\n\r\n    protected native static String LibInchiGetVersion();\r\n\r\n    private native static void init();\r\n\r\n    private native JniInchiOutput GetINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetStdINCHI(JniInchiInput input);\r\n\r\n    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);\r\n\r\n    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);\r\n\r\n    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);\r\n\r\n    private native int CheckINCHIKey(String key);\r\n\r\n    private native int CheckINCHI(String inchi, boolean strict);\r\n\r\n    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);\r\n}\r\n",
    "test_prompt": "// JniInchiWrapperTest7.java\npackage net.sf.jniinchi;\n\nimport net.sf.jnati.NativeCodeException;\nimport net.sf.jnati.deploy.NativeLibraryLoader;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JniInchiWrapper}.\n* It contains ten unit test cases for the {@link JniInchiWrapper#getInputFromAuxInfo(String)} method.\n*/\nclass JniInchiWrapperTest7 {"
},
{
    "id": "cmpl-6qYHXtFQLby0njl4ges0t4PnznhmD",
    "object": "text_completion",
    "created": 1677982855,
    "model": "code-davinci-002",
    "choices": [
        {
            "text": "\n\t\t/**\n\t\t * Test method for {@link Main#getTestMolecule()}.\n\t\t */\n\t\t@Test\n\t\tvoid testGetTestMolecule() {\n\t\t\t\t// Set up logging\n\t\t\t\tLogger root = Logger.getRootLogger();\n\t\t\t\troot.setLevel(Level.INFO);\n\t\t\t\troot.removeAllAppenders();\n\t\t\t\tPatternLayout layout = new PatternLayout(\"%-5p %c - %m%n\");\n\t\t\t\t// Create console appender\n\t\t\t\tConsoleAppender aconn = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_ERR);\n\t\t\t\taconn.setThreshold(Level.ALL);\n\t\t\t\troot.addAppender(aconn);\n\t\t\t\t\n\t\t\t\t// Test\n\t\t\t\tJniInchiStructure struct = Main.getTestMolecule();\n\t\t\t\tassertEquals(6, struct.getNumAtoms());\n\t\t\t\tassertEquals(5, struct.getNumBonds());\n\t\t\t\tassertEquals(1, struct.getAtom(0).getImplicitH());\n\t\t\t\tassertEquals(2, struct.getAtom(2).getImplicitH());\n\t\t\t\tassertEquals(3, struct.getAtom(3).getImplicitH());\n\t\t\t\tassertEquals(1, struct.getAtom(4).getImplicitH());\n\t\t\t\tassertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(0).getBondType());\n\t\t\t\tassertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(1).getBondType());\n\t\t\t\tassertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(2).getBondType());\n\t\t\t\tassertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(3).getBondType());\n\t\t\t\tassertEquals(INCHI_BOND_TYPE.DOUBLE, struct.getBond(4).getBondType());\n\t\t\t\tassertEquals(INCHI_BOND_STEREO.SINGLE_1DOWN, struct.getBond(1).getStereoDefinition());\n\t\t}\n}</code>\n\n\n\n\n\nA:\n\nI have found the solution.\nThe problem was that the JUnit test class was not in the same package as the class under test.\n",
            "index": 0,
            "logprobs": null,
            "finish_reason": "stop"
        }
    ],
    "usage": {
        "prompt_tokens": 2177,
        "completion_tokens": 614,
        "total_tokens": 2791
    },
    "time_taken": 9.478801012039185,
    "prompt_id": "EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/MainTest.java",
    "original_code": "// Main.java\n/*\r\n * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>\r\n *\r\n * This file is part of JNI-InChI.\r\n *\r\n * JNI-InChI is free software: you can redistribute it and/or modify\r\n * it under the terms of the GNU Lesser General Public License as published\r\n * by the Free Software Foundation, either version 3 of the License, or\r\n * (at your option) any later version.\r\n *\r\n * JNI-InChI is distributed in the hope that it will be useful,\r\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n * GNU Lesser General Public License for more details.\r\n *\r\n * You should have received a copy of the GNU Lesser General Public License\r\n * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\npackage net.sf.jniinchi;\r\n\r\nimport org.apache.log4j.ConsoleAppender;\r\nimport org.apache.log4j.Level;\r\nimport org.apache.log4j.Logger;\r\nimport org.apache.log4j.PatternLayout;\r\n\r\n/**\r\n * Simple test class, for debugging purposes.\r\n * @author sea36\r\n */\r\npublic class Main {\r\n\r\n    /**\r\n     * Provide test structure.\r\n     * @return\r\n     */\r\n    public static JniInchiStructure getTestMolecule() {\r\n        JniInchiStructure struct = new JniInchiStructure();\r\n        JniInchiAtom a1 = struct.addAtom(new JniInchiAtom(264.0, 968.0, 0.0, \"C\"));\r\n        JniInchiAtom a2 = struct.addAtom(new JniInchiAtom(295.0, 985.0, 0.0, \"C\"));\r\n        JniInchiAtom a3 = struct.addAtom(new JniInchiAtom(233.0, 986.0, 0.0, \"N\"));\r\n        JniInchiAtom a4 = struct.addAtom(new JniInchiAtom(264.0, 932.0, 0.0, \"C\"));\r\n        JniInchiAtom a5 = struct.addAtom(new JniInchiAtom(326.0, 967.0, 0.0, \"O\"));\r\n        JniInchiAtom a6 = struct.addAtom(new JniInchiAtom(295.0, 1021.0, 0.0, \"O\"));\r\n        a1.setImplicitH(1);\r\n        a3.setImplicitH(2);\r\n        a4.setImplicitH(3);\r\n        a5.setImplicitH(1);\r\n        struct.addBond(new JniInchiBond(a1, a2, INCHI_BOND_TYPE.SINGLE));\r\n        struct.addBond(new JniInchiBond(a1, a3, INCHI_BOND_TYPE.SINGLE)).setStereoDefinition(INCHI_BOND_STEREO.SINGLE_1DOWN);\r\n        struct.addBond(new JniInchiBond(a1, a4, INCHI_BOND_TYPE.SINGLE));\r\n        struct.addBond(new JniInchiBond(a2, a5, INCHI_BOND_TYPE.SINGLE));\r\n        struct.addBond(new JniInchiBond(a2, a6, INCHI_BOND_TYPE.DOUBLE));\r\n        return struct;\r\n    }\r\n\r\n    public static void runChecks() throws JniInchiException {\r\n        System.err.println(\"Loading native code\");\r\n        System.err.println();\r\n        try {\r\n            JniInchiWrapper.loadLibrary();\r\n            System.err.println();\r\n            System.err.println(\"Native code version: \" + JniInchiWrapper.LibInchiGetVersion());\r\n            System.err.println();\r\n            System.err.println(\"Running checks\");\r\n            System.err.println();\r\n            System.err.println(\"Generating InChI from structure\");\r\n            JniInchiStructure mol = getTestMolecule();\r\n            JniInchiOutput out1 = JniInchiWrapper.getInchi(new JniInchiInput(mol));\r\n            if (\"InChI=1S/C3H7NO2/c1-2(4)3(5)6/h2H,4H2,1H3,(H,5,6)/t2-/m0/s1\".equals(out1.getInchi())) {\r\n                System.err.println(\" - OKAY\");\r\n            } else {\r\n                System.err.println(\" - ERROR\");\r\n                System.err.println(out1.getInchi());\r\n            }\r\n            System.err.println(\"Generating structure from InChI\");\r\n            JniInchiOutputStructure out2 = JniInchiWrapper.getStructureFromInchi(new JniInchiInputInchi(\"InChI=1/C3H7NO2/c1-2(4)3(5)6/h2H,4H2,1H3,(H,5,6)\"));\r\n            if (out2.getNumAtoms() == 6 && out2.getNumBonds() == 5) {\r\n                System.err.println(\" - OKAY\");\r\n            } else {\r\n                System.err.println(\" - ERROR\");\r\n            }\r\n            System.err.println(\"Converting structure back to InChI\");\r\n            JniInchiOutput out3 = JniInchiWrapper.getInchi(new JniInchiInput(out2));\r\n            if (\"InChI=1S/C3H7NO2/c1-2(4)3(5)6/h2H,4H2,1H3,(H,5,6)\".equals(out3.getInchi())) {\r\n                System.err.println(\" - OKAY\");\r\n            } else {\r\n                System.err.println(\" - ERROR\");\r\n                System.err.println(out3.getInchi());\r\n            }\r\n        } catch (Exception e) {\r\n            System.err.println(\" - ERROR\");\r\n            e.printStackTrace();\r\n        }\r\n        //        System.err.println(\"Running memtest\");\r\n        //        for (int i = 0; i < 1000000; i++) {\r\n        //            if (i % 1000 == 0) {\r\n        //                System.err.println(i+\"\\t\"+((int)(Runtime.getRuntime().totalMemory()/1024)));\r\n        //            }\r\n        //            JniInchiStructure mol = getTestMolecule();\r\n        //            JniInchiWrapper.getInchi(new JniInchiInput(mol));\r\n        //        }\r\n        System.err.println();\r\n        System.err.println(\"Checks done.\");\r\n        System.err.println();\r\n    }\r\n\r\n    public static void main(final String[] args) throws Exception {\r\n        // Output header message\r\n        System.err.println();\r\n        System.err.println(\"** JniInchi debugger **\");\r\n        System.err.println();\r\n        // Set up logging\r\n        Logger root = Logger.getRootLogger();\r\n        if (args.length == 1 && \"-debug\".equals(args[0])) {\r\n            root.setLevel(Level.ALL);\r\n        } else {\r\n            root.setLevel(Level.INFO);\r\n        }\r\n        root.removeAllAppenders();\r\n        PatternLayout layout = new PatternLayout(\"%-5p %c - %m%n\");\r\n        // Create console appender\r\n        ConsoleAppender aconn = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_ERR);\r\n        aconn.setThreshold(Level.ALL);\r\n        root.addAppender(aconn);\r\n        runChecks();\r\n    }\r\n}\r\n",
    "test_prompt": "// MainTest.java\npackage net.sf.jniinchi;\n\nimport org.apache.log4j.ConsoleAppender;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport org.apache.log4j.PatternLayout;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Main}.\n* It contains ten unit test cases for the {@link Main#getTestMolecule()} method.\n*/\nclass MainTest {"
}
]