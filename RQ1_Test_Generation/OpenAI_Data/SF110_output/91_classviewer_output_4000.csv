ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6u4zWvIjRTDHz4bhCjOYAQ7aFhITG,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringTools_0Test.java,94.4218430519104,length,"// StringTools.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package com.jstevh.tools;

/**
 * Some static tools for string manipulation
 *
 * @author   James Harris
 * @version  1.1
 */
public class StringTools {

    private static int count, length;

    /**
     * Searches through given string array for a given string
     * fragment and returns an array of the strings that have
     * fragment in them.
     *
     * @param    strings    string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String fragment) {
        String[] tempArray = null;
        if (strings != null && fragment != null) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < strings.length; i++) {
                tempStr2 = strings[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Searches through given index string array for a given string
     * fragment and returns an array of the strings from given base
     * array.
     *
     * @param    strings    string array that values are pulled from
     *           index      string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String[] index, String fragment) {
        String[] tempArray = null;
        if (strings != null && index != null && fragment != null && index.length <= strings.length) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < index.length; i++) {
                tempStr2 = index[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (array == null)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Searches through given string array for a given string
     * fragment and deletes fragment from strings that have
     * fragment in them.
     *
     * @param    in        string fragment to be deleted out
     *           strings   array with strings to delete fragment from
     *
     * @return   toString() on string buffer used, for debugging
     */
    public static String removeStrings(String in, String[] strings) {
        if (in == null || strings == null)
            return null;
        StringBuffer buff = new StringBuffer(in.trim());
        int pos1, length;
        for (int i = 0; i < strings.length; i++) {
            pos1 = buff.toString().indexOf(strings[i]);
            length = strings[i].length();
            while (pos1 != -1) {
                buff.delete(pos1, pos1 + length);
                pos1 = buff.toString().indexOf(strings[i]);
            }
        }
        String tempStr = buff.toString();
        return tempStr;
    }
}
","// StringTools_0Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String)} method.
*/
class StringTools_0Test {","// StringTools_0Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String)} method.
*/
class StringTools_0Test {

		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is null.
		*/
		@Test
		void testSearchStrings_0() {
				String[] strings = null;
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is empty.
		*/
		@Test
		void testSearchStrings_1() {
				String[] strings = new String[0];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string fragment is null.
		*/
		@Test
		void testSearchStrings_2() {
				String[] strings = new String[0];
				String fragment = null;
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string fragment is empty.
		*/
		@Test
		void testSearchStrings_3() {
				String[] strings = new String[0];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_4() {
				String[] strings = new String[1];
				strings[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_5() {
				String[] strings = new String[1];
				strings[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_6() {
				String[] strings = new String[1];
				strings[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_7() {
				String[] strings = new String[1];
				strings[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_8() {
				String[] strings = new String[1];
				strings[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_9() {
				String[] strings = new String[1];
				strings[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, fragment);
				assertNull(result);
		}
		
}

// StringTools_1Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String[], String)} method.
*/
class StringTools_1Test {
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is null.
		*/
		@Test
		void testSearchStrings_0() {
				String[] strings = null;
				String[] index = null;
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is empty.
		*/
		@Test
		void testSearchStrings_1() {
				String[] strings = new String[0];
				String[] index = new String[0];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string fragment is null.
		*/
		@Test
		void testSearchStrings_2() {
				String[] strings = new String[0];
				String[] index = new String[0];
				String fragment = null;
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string fragment is empty.
		*/
		@Test
		void testSearchStrings_3() {
				String[] strings = new String[0];
				String[] index = new String[0];
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_4() {
				String[] strings = new String[1];
				strings[0] = """";
				String[] index = new String[1];
				index[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_5() {
				String[] strings = new String[1];
				strings[0] = """";
				String[] index = new String[1];
				index[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_6() {
				String[] strings = new String[1];
				strings[0] = """";
				String[] index = new String[1];
				index[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_7() {
				String[] strings = new String[1];
				strings[0] = """";
				String[] index = new String[1];
				index[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_8() {
				String[] strings = new String[1];
				strings[0] = """";
				String[] index = new String[1];
				index[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#searchStrings(String[], String[], String)} method.
		* It tests the case when the given string array is not empty and the given string fragment is not empty.
		*/
		@Test
		void testSearchStrings_9() {
				String[] strings = new String[1];
				strings[0] = """";
				String[] index = new String[1];
				index[0] = """";
				String fragment = """";
				String[] result = StringTools.searchStrings(strings, index, fragment);
				assertNull(result);
		}
		
}

// StringTools_2Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#removeStrings(String, String[])} method.
*/
class StringTools_2Test {
		
		/**
		* Test case for {@link StringTools#removeStrings(String, String[])} method.
		* It tests the case when the given string is null.
		*/
		@Test
		void testRemoveStrings_0() {
				String in = null;
				String[] strings = null;
				String result = StringTools.removeStrings(in, strings);
				assertNull(result);
		}
		
		/**
		* Test case for {@link StringTools#removeStrings(String, String[])} method.
		* It tests the case when the given string is empty.
		*/
		@Test
		void testRemoveStrings_1() {
				String in = """";
				String[] strings = new String[0];
				String result = StringTools.removeStrings(in, strings);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link StringTools#removeStrings(String, String[])} method.
		* It tests the case when the given string array is null.
		*/
		@Test
		void testRemoveStrings_2() {
				String in = """";
				String[] strings = null;
				String result = StringTools.removeStrings(in, strings);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link StringTools#removeStrings(String, String[])} method.
		* It tests the case when the given string array is empty.
		*/
		@Test
		void testRemoveStrings_3() {
				String in = """";
				String[] strings = new String[0];
				String result = StringTools.removeStrings(in, strings);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link StringTools#removeStrings(String, String[])} method.
		* It tests the case when the given string is not empty and the given string array is not empty.
		*/
		@Test
		void testRemoveStrings_4() {
				String in = """";
				String[] strings = new String[1];
				strings[0] = """";
				String result = StringTools.removeStrings(in, strings);
				assertEquals("""", result);
		}
		
		/**
		* Test case for {@link StringTools#removeStrings(String, String[])} method.
		* It tests the case when the given string is not empty and the given string array is not empty.
		*/
		@Test
		void testRemoveStrings_5() {
				String in = """";
				String[] strings = new String[1];
		"
cmpl-6u512BKcmG6Vyvo0W8eB5jcDA2TUZ,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringTools_1Test.java,33.49458861351013,stop,"// StringTools.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package com.jstevh.tools;

/**
 * Some static tools for string manipulation
 *
 * @author   James Harris
 * @version  1.1
 */
public class StringTools {

    private static int count, length;

    /**
     * Searches through given string array for a given string
     * fragment and returns an array of the strings that have
     * fragment in them.
     *
     * @param    strings    string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String fragment) {
        String[] tempArray = null;
        if (strings != null && fragment != null) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < strings.length; i++) {
                tempStr2 = strings[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Searches through given index string array for a given string
     * fragment and returns an array of the strings from given base
     * array.
     *
     * @param    strings    string array that values are pulled from
     *           index      string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String[] index, String fragment) {
        String[] tempArray = null;
        if (strings != null && index != null && fragment != null && index.length <= strings.length) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < index.length; i++) {
                tempStr2 = index[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (array == null)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Searches through given string array for a given string
     * fragment and deletes fragment from strings that have
     * fragment in them.
     *
     * @param    in        string fragment to be deleted out
     *           strings   array with strings to delete fragment from
     *
     * @return   toString() on string buffer used, for debugging
     */
    public static String removeStrings(String in, String[] strings) {
        if (in == null || strings == null)
            return null;
        StringBuffer buff = new StringBuffer(in.trim());
        int pos1, length;
        for (int i = 0; i < strings.length; i++) {
            pos1 = buff.toString().indexOf(strings[i]);
            length = strings[i].length();
            while (pos1 != -1) {
                buff.delete(pos1, pos1 + length);
                pos1 = buff.toString().indexOf(strings[i]);
            }
        }
        String tempStr = buff.toString();
        return tempStr;
    }
}
","// StringTools_1Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String[], String)} method.
*/
class StringTools_1Test {","// StringTools_1Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#searchStrings(String[], String[], String)} method.
*/
class StringTools_1Test {

		/**
		* Test case 1 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is null.
		*/
		@Test
		void testSearchStrings_1() {
				String[] strings = null;
				String[] index = null;
				String fragment = null;
				String[] expected = null;
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is empty.
		*/
		@Test
		void testSearchStrings_2() {
				String[] strings = new String[0];
				String[] index = new String[0];
				String fragment = """";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is null.
		*/
		@Test
		void testSearchStrings_3() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = null;
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is empty.
		*/
		@Test
		void testSearchStrings_4() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = """";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_5() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""a"";
				String[] expected = new String[]{""a""};
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_6() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""b"";
				String[] expected = new String[]{""b""};
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_7() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""c"";
				String[] expected = new String[]{""c""};
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_8() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""d"";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_9() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""ab"";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link StringTools#searchStrings(String[], String[], String)}.
		* It tests the case where the input array is not empty and the fragment is not empty.
		*/
		@Test
		void testSearchStrings_10() {
				String[] strings = new String[]{""a"", ""b"", ""c""};
				String[] index = new String[]{""a"", ""b"", ""c""};
				String fragment = ""bc"";
				String[] expected = new String[0];
				String[] actual = StringTools.searchStrings(strings, index, fragment);
				assertArrayEquals(expected, actual);
		}
}"
cmpl-6u525hfIo9j7yIFlFw848iZjkdv1t,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/tools/StringTools_2Test.java,31.180032968521118,stop,"// StringTools.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
package com.jstevh.tools;

/**
 * Some static tools for string manipulation
 *
 * @author   James Harris
 * @version  1.1
 */
public class StringTools {

    private static int count, length;

    /**
     * Searches through given string array for a given string
     * fragment and returns an array of the strings that have
     * fragment in them.
     *
     * @param    strings    string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String fragment) {
        String[] tempArray = null;
        if (strings != null && fragment != null) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < strings.length; i++) {
                tempStr2 = strings[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Searches through given index string array for a given string
     * fragment and returns an array of the strings from given base
     * array.
     *
     * @param    strings    string array that values are pulled from
     *           index      string array that is searched through
     *           fragment   string fragment with which to search
     *
     * @return   string array of found strings
     */
    public static String[] searchStrings(String[] strings, String[] index, String fragment) {
        String[] tempArray = null;
        if (strings != null && index != null && fragment != null && index.length <= strings.length) {
            String tempStr, tempStr2;
            StringList hold = new StringList();
            for (int i = 0; i < index.length; i++) {
                tempStr2 = index[i].toLowerCase();
                tempStr = fragment.toLowerCase();
                if (tempStr2.indexOf(tempStr) != -1) {
                    hold.add(strings[i]);
                }
            }
            if (!hold.isEmpty())
                tempArray = hold.toArray();
        }
        return tempArray;
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (array == null)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Searches through given string array for a given string
     * fragment and deletes fragment from strings that have
     * fragment in them.
     *
     * @param    in        string fragment to be deleted out
     *           strings   array with strings to delete fragment from
     *
     * @return   toString() on string buffer used, for debugging
     */
    public static String removeStrings(String in, String[] strings) {
        if (in == null || strings == null)
            return null;
        StringBuffer buff = new StringBuffer(in.trim());
        int pos1, length;
        for (int i = 0; i < strings.length; i++) {
            pos1 = buff.toString().indexOf(strings[i]);
            length = strings[i].length();
            while (pos1 != -1) {
                buff.delete(pos1, pos1 + length);
                pos1 = buff.toString().indexOf(strings[i]);
            }
        }
        String tempStr = buff.toString();
        return tempStr;
    }
}
","// StringTools_2Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#removeStrings(String, String[])} method.
*/
class StringTools_2Test {","// StringTools_2Test.java
package com.jstevh.tools;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringTools}.
* It contains ten unit test cases for the {@link StringTools#removeStrings(String, String[])} method.
*/
class StringTools_2Test {

		/**
		* Test case 1 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a null string and a null array.
		*/
		@Test
		void testRemoveStrings_1() {
				StringTools st = new StringTools();
				String in = null;
				String[] strings = null;
				String expected = null;
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_2() {
				StringTools st = new StringTools();
				String in = null;
				String[] strings = {""a"", ""b"", ""c""};
				String expected = null;
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a null array.
		*/
		@Test
		void testRemoveStrings_3() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = null;
				String expected = ""abc"";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_4() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_5() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_6() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_7() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e"", ""f""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_8() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_9() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link StringTools#removeStrings(String, String[])}.
		* It tests the method with a non-null string and a non-null array.
		*/
		@Test
		void testRemoveStrings_10() {
				StringTools st = new StringTools();
				String in = ""abc"";
				String[] strings = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i""};
				String expected = """";
				String actual = st.removeStrings(in, strings);
				assertEquals(expected, actual);
		}
}</code>





A:

The problem is that you are not using the <code>StringTools</code> class correctly.
You are creating a new instance of <code>StringTools</code> in each test method, but you are not using that instance.
Instead, you are calling the <code>removeStrings</code> method on the <code>StringToolsTest</code> class itself.
You should be calling the <code>removeStrings</code> method on the <code>StringTools</code> instance that you created.
"
5f15e2d2-4b13-4d34-ae4e-72f497c93dfe,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9833 tokens (5833 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_0Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {","// ClassInfo_0Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printFields()} method.
*/
class ClassInfo_0Test {
"
8b081e9e-9545-4a7a-9d2f-1cea0582d981,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9835 tokens (5835 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_1Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {","// ClassInfo_1Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods()} method.
*/
class ClassInfo_1Test {
"
59ff7214-6d62-4b90-8420-7daa73de8340,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9836 tokens (5836 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_2Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {","// ClassInfo_2Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printMethods(int)} method.
*/
class ClassInfo_2Test {
"
2e6f510b-f16f-463d-9a39-0bb9b3fd650c,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9836 tokens (5836 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_3Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {","// ClassInfo_3Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printConstructors()} method.
*/
class ClassInfo_3Test {
"
5885bee9-d6c0-4f79-a307-452e6760e691,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9836 tokens (5836 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_4Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {","// ClassInfo_4Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#printInterfaces()} method.
*/
class ClassInfo_4Test {
"
ea687645-ed26-4a4c-bc63-fb9300c35265,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9838 tokens (5838 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_5Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {","// ClassInfo_5Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Member[])} method.
*/
class ClassInfo_5Test {
"
5f91acf6-313a-4df2-8235-ace1f5d8f0d8,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9838 tokens (5838 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_6Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {","// ClassInfo_6Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getData(Class[])} method.
*/
class ClassInfo_6Test {
"
ed1727cc-b525-47a2-b43e-e8a136a7b4db,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_7Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9837 tokens (5837 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {","// ClassInfo_7Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String)} method.
*/
class ClassInfo_7Test {
"
4ba7da9b-57d7-4628-958a-7bf214423358,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_8Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9841 tokens (5841 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_8Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String, String[])} method.
*/
class ClassInfo_8Test {","// ClassInfo_8Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#srchMethods(String, String[])} method.
*/
class ClassInfo_8Test {
"
3712b3b0-351c-4088-9d90-ae72093a7162,/EvoSuiteBenchmark/91_classviewer/src/main/java/com/jstevh/viewer/ClassInfo_9Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9837 tokens (5837 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ClassInfo.java
/* 
 * Copyright (C) 2004  James Harris 
 *
 * This library is free software; you can redistribute it and/or
 *
 * modify it under the terms of the GNU Lesser General Public
 *
 * License as published by the Free Software Foundation; either
 *
 * version 2.1 of the License, or (at your option) any later version.
 *
 *
 *
 * This library is distributed in the hope that it will be useful,
 *
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 *
 * Lesser General Public License for more details.
 *
 *
 * You should have received a copy of the GNU Lesser General Public
 *
 * License along with this library; if not, write to the Free Software
 *
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 */
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;

/**
 * Obtains the interfaces as well as the public constructors, methods
 * and fields from a Class object.
 * <p>
 * This class is for obtaining data and handling.
 *
 * @author   James Harris
 * @version  2.0a
 */
public class ClassInfo {

    public static boolean debug;

    private boolean statusAbstract;

    private Class c = javax.swing.WindowConstants.class;

    private DirManager dirMan;

    private static int count, length;

    public final static int NO_OBJECT_METHODS = 1, NO_INHERITED_METHODS = 2;

    private String[] cMethods, fndMethods = null;

    protected String[] knownPackages;

    public boolean isAbstract() {
        return statusAbstract;
    }

    public boolean isInterface() {
        return c.isInterface();
    }

    public String getClassName() {
        return c.getName();
    }

    public String getClassPackage() {
        return c.getPackage() != null ? c.getPackage().getName() : null;
    }

    public String getSuperClassName() {
        if (c != java.lang.Object.class && !c.isInterface())
            return c.getSuperclass().getName();
        else
            return null;
    }

    private ClassInfo() {
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param  name the name of the class on which to get info
     */
    public ClassInfo(String name) throws ClassNotFoundException {
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Constructor for when the class name is known at creation.
     *
     * @param    name  name of class
     *           locManager    class that manages package information
     */
    public ClassInfo(String name, DirManager locManager) throws ClassNotFoundException {
        dirMan = locManager;
        knownPackages = dirMan.getPackageList();
        c = getClass(name);
        if (c == null)
            throw new ClassNotFoundException();
        Method[] m = c.getMethods();
        Object[] obj = null;
        cMethods = getData(m);
        if (cMethods != null) {
            if (c != java.lang.Object.class) {
                StringList tempList = new StringList();
                for (count = 0; count < cMethods.length; count++) {
                    if (cMethods[count].indexOf(""Object."") == -1)
                        tempList.add(cMethods[count]);
                }
                cMethods = tempList.toArray();
            }
            for (count = 0; count < cMethods.length; count++) {
                if (!statusAbstract && cMethods[count].indexOf(""abstract"") != -1)
                    statusAbstract = true;
            }
        }
    }

    /**
     * Returns an array of strings that contain the public fields for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public fields
     */
    public String[] printFields() {
        Field[] f = c.getFields();
        length = f.length;
        String[] StringData = null;
        if (length > 0) {
            StringData = new String[length];
            String tempStr;
            Object obj = new Object();
            if (debug)
                System.out.println(""****************************************"");
            for (count = 0; count < length; count++) {
                try {
                    tempStr = f[count] + ""="" + f[count].get(obj);
                    StringData[count] = tempStr;
                    if (debug)
                        System.out.println(tempStr);
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ACCESS EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                } catch (IllegalArgumentException j) {
                    j.printStackTrace();
                    tempStr = f[count] + ""= ILLEGAL ARGUMENT EXCEPTION, unable to load"";
                    StringData[count] = tempStr;
                }
            }
        } else if (debug)
            System.out.println(""No public fields."");
        return StringData;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @return      string array of public methods
     */
    public String[] printMethods() {
        if (debug)
            System.out.println(""****************************************"");
        String[] tempArray = null;
        if (cMethods != null) {
            tempArray = new String[cMethods.length];
            System.arraycopy(cMethods, 0, tempArray, 0, cMethods.length);
        }
        if (debug && tempArray == null)
            System.out.println(""No public methods."");
        else {
            printArray(tempArray);
        }
        return tempArray;
    }

    /**
     * Returns an array of strings that contain the public methods for
     * the class excluding inherited methods. The data is pulled from
     * the c private Class object.
     * <p>
     * This method always returns immediately.
     *
     * @param  param (not currently implemented) selects whether inherited
     *               objects are returned
     * @return      string array of public methods
     */
    public String[] printMethods(int param) {
        if (cMethods == null)
            return null;
        if (debug)
            System.out.println(""****************************************"");
        String[] data = cMethods;
        StringList tempList = new StringList();
        for (int i = 0; i < cMethods.length; i++) {
            if (cMethods[i].indexOf(getClassName() + '.') != -1)
                tempList.add(cMethods[i]);
        }
        if (!tempList.isEmpty())
            data = tempList.toArray();
        else
            data = null;
        if (debug && data == null)
            System.out.println(""No public methods."");
        else {
            printArray(data);
        }
        return data;
    }

    /**
     * Returns an array of strings that contain the public constructors for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of public constructors
     */
    public String[] printConstructors() {
        Constructor[] constr = c.getConstructors();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(constr);
        if (debug && data == null)
            System.out.println(""No public constructors."");
        else
            printArray(data);
        return data;
    }

    /**
     * Returns an array of strings that contain the interfaces for
     * the class. The data is pulled from the c private Class object.
     * <p>
     * This method calls  {@link #getData(java.lang.Class[])} method for constructors.
     *
     * @return      string array of interfaces
     */
    public String[] printInterfaces() {
        Class[] inter = c.getInterfaces();
        if (debug)
            System.out.println(""****************************************"");
        String[] data = getData(inter);
        if (c != java.lang.Object.class && !c.isInterface()) {
            Class superC = c.getSuperclass();
            TreeSet<String> hInterfaces = new TreeSet<String>();
            int i = 0;
            if (data != null)
                for (i = 0; i < data.length; i++) {
                    hInterfaces.add(data[i]);
                }
            while (superC != null && superC != java.lang.Object.class) {
                inter = superC.getInterfaces();
                if (debug)
                    System.out.println(""****************************************"");
                data = getData(inter);
                if (data != null)
                    for (i = 0; i < data.length; i++) {
                        hInterfaces.add(data[i]);
                    }
                superC = superC.getSuperclass();
            }
            if (hInterfaces.size() != 0) {
                data = new String[hInterfaces.size()];
                Iterator it = hInterfaces.iterator();
                i = 0;
                while (it.hasNext()) {
                    data[i] = (String) it.next();
                    i++;
                }
            }
        }
        if (debug && data == null)
            System.out.println(""No interfaces."");
        else
            printArray(data);
        return data;
    }

    /**
     * Takes an array of Member objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Member objects
     *
     * @return    string array of names
     */
    public static String[] getData(Member[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].toString();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Takes an array of Class objects and gets names from toString().
     * <p>
     * This method always returns immediately.
     *
     * @param  m  array of Class objects
     *
     * @return    string array of names
     */
    public static String[] getData(Class[] m) {
        length = m.length;
        if (length == 0)
            return null;
        String[] StringData = new String[length];
        String tempStr;
        for (count = 0; count < m.length; count++) {
            tempStr = m[count].getName();
            StringData[count] = tempStr;
        }
        return StringData;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, and selects methods that have that
     * fragment in them.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through cMethods, the private array of public methods
     * for a given string fragment, with a given string index, and searches
     * on the index for the fragment in them but gets method from cMethods.
     * <p>
     * This method calls searchStrings().
     *
     * @param    tempStr  string fragment with which to search
     *           index    string array that is searched through
     *
     * @return   string array of found methods
     */
    public String[] srchMethods(String tempStr, String[] index) {
        if (tempStr == null)
            return null;
        fndMethods = StringTools.searchStrings(cMethods, index, tempStr);
        if (fndMethods != null) {
            String[] tempArray = new String[fndMethods.length];
            System.arraycopy(fndMethods, 0, tempArray, 0, fndMethods.length);
            return tempArray;
        }
        return null;
    }

    /**
     * Searches through found methods and returns method at given
     * position, uses anonymous inner class.  If no methods
     * have been searched for it returns null.
     *
     * @param    pos  position of found methods in array 0 is first.
     *
     * @return   MethodData object with information about method
     */
    public MethodData getFoundMethod(final int pos) {
        if (fndMethods == null || pos > fndMethods.length)
            return null;
        return new MethodData() {

            //check to make sure position isn't out of range
            String tempStr = fndMethods[pos], tempStr2;

            String className, methodName;

            int begin, end;

            Class methClass;

            {
                end = tempStr.indexOf("")"");
                tempStr = tempStr.substring(0, end + 1);
                begin = tempStr.lastIndexOf("" "");
                tempStr = tempStr.substring(begin + 1, tempStr.length());
                begin = tempStr.indexOf(""("");
                end = tempStr.lastIndexOf(""."", begin);
                className = tempStr.substring(0, end);
                methodName = tempStr.substring(end + 1, tempStr.length());
                if (debug)
                    System.out.println(""className="" + className);
                methClass = ClassInfo.tryClass(className);
                if (debug)
                    System.out.println(""methClass="" + methClass);
            }

            public String getMethPackage() {
                if (methClass == null)
                    return null;
                return methClass.getPackage() != null ? methClass.getPackage().getName() : null;
            }

            public String getMethClass() {
                if (methClass == null)
                    return null;
                return methClass.getName();
            }

            public String getMethName() {
                return methodName;
            }
        };
    }

    /**
     * Takes any given array and prints out with System.out.println
     *
     * @param    array   an array of objects
     */
    private void printArray(Object[] array) {
        if (!debug)
            return;
        length = array.length;
        if (length == 0)
            return;
        for (count = 0; count < length; count++) {
            System.out.println(array[count]);
        }
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it tries all known packages
     * to see if any of them will work with the class name.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private Class getClass(String name) {
        String tempStr = name;
        Class tempClass = null;
        tempClass = tryClass(name);
        if (tempClass == null) {
            for (int i = 0; i < knownPackages.length; i++) {
                tempStr = knownPackages[i] + name;
                tempClass = tryClass(tempStr);
                if (tempClass != null)
                    break;
            }
        }
        return tempClass;
    }

    /**
     * Takes a given class name and tries to to find the class.
     * If the initial try does not work it returns null.
     *
     * @param    name    name of class
     *
     * @return   found Class
     */
    private static Class tryClass(String name) {
        Class tempClass = null;
        try {
            if (name != null)
                tempClass = Class.forName(name.trim());
        } catch (java.lang.ClassNotFoundException e) {
            return null;
        } catch (java.lang.NoClassDefFoundError f) {
            //f.printStackTrace();
            return null;
        }
        return tempClass;
    }

    /**
     * Prints out class info with System.out.println
     */
    private void printClassInfo() {
        printMethods();
        if (!c.isInterface()) {
            printConstructors();
            if (debug)
                System.out.println(""****************************************"");
            printInterfaces();
            if (debug)
                System.out.println(""****************************************"");
            if (statusAbstract) {
                System.out.println(""Abstract "" + c);
            } else
                System.out.println(c.getName());
            if (c != java.lang.Object.class)
                System.out.println(""Superclass is "" + c.getSuperclass().getName() + ""."");
        } else {
            printFields();
            if (debug)
                System.out.println(""****************************************"");
            System.out.println(c.getName() + "" is an interface."");
        }
    }

    /**
     * Main method for getting class information.
     * Prints out data with System.out.println.
     *
     * @param    args    string array for main
     */
    public static void main(String[] args) throws Exception {
        long t1 = System.currentTimeMillis();
        debug = true;
        String name = null;
        ClassInfo myClassInfo;
        if (args.length > 0) {
            if (args[0].equals(""new"")) {
                name = args[1];
            } else {
                name = args[0];
                try {
                    myClassInfo = new ClassInfo(name);
                    myClassInfo.printClassInfo();
                } catch (ClassNotFoundException e) {
                    System.out.println(""Class not found."");
                    System.exit(0);
                }
            }
        } else {
            myClassInfo = new ClassInfo();
            myClassInfo.printClassInfo();
        }
        System.out.println(""Total time: "" + (System.currentTimeMillis() - t1));
    }
}
","// ClassInfo_9Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_9Test {","// ClassInfo_9Test.java
//5-5-04  Added recursive search to find all interfaces.   ___JSH
//7-30-04 Switched to TreeList to keep from getting interfaces twice in list.  ___JSH
//8-01-04 Handled exceptions with fields.   ___JSH
package com.jstevh.viewer;

import java.awt.*;
import java.lang.reflect.*;
import java.util.*;
import javax.swing.*;
import javax.swing.border.*;
import com.jstevh.tools.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ClassInfo}.
* It contains ten unit test cases for the {@link ClassInfo#getFoundMethod(int)} method.
*/
class ClassInfo_9Test {
"
