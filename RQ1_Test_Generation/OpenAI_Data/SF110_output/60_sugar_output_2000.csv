ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6u7SCUEBO5qB1JDExkMdLwqdVUxtd,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/DefaultFSPath_0Test.java,50.67602777481079,length,"// DefaultFSPath.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 *  The default implementation of the FSPath interface.
 *  This class uses the JDK's XPath implementation as the basis for
 *  FSPath queries.
 *  On instantiation, a DOM is created of the filesystem metadata starting form the <code>rootDirectory</code>.
 *  This DOM can then be queried using standard XML tools.
 *  <br/>
 *  Whilst this approach has been relatively quick to implement, it is still tied to the limitations of XPath.
 *  Future implementations of this class are likely to implement the FSPath language fully themselves wthout relying on XPath.
 *  <br/>
 *  todo: develop some front end substitution to enable the short queries i.e. /var/www etc
 *
 * @author keith
 *  $Id$
 */
public class DefaultFSPath implements FSPath {

    /**
     *  Escape characters, we must escape any characters that are
     *  illegal in XML attribute text.
     *
     *  i.e. &amp; "" < >
     */
    private Map escapeChars;

    private DocumentBuilder documentBuilder;

    private XPath xpath;

    private Document dom;

    /**
     *  The date format used to correspond to the xs:date format i.e. yyyy-MM-dd'T'HH:mm:ss.SSS
     */
    private DateFormat format;

    private File rootDirectory;

    public DefaultFSPath() {
        //used for unit test instantiation
        this.xpath = XPathFactory.newInstance().newXPath();
        //this.xpath.setNamespaceContext(new FSNamespaceContext());
        //this effectively enables the user of our custom XPath function
        //fs:match()
        this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());
        this.escapeChars = this.createEscapeCharsMap();
        this.format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
    }

    /**
     * Creates a new instance of DefaultFSPath, based on the directory supplied
     */
    public DefaultFSPath(File currentDir) {
        this();
        this.rootDirectory = currentDir;
        //check if file is a directory
        if (!currentDir.isDirectory()) {
            throw new InstantiationError(""the java.io.File specified must be a Directory"");
        }
        try {
            this.createDocumentBuilder();
            //build DOM representation
            this.dom = this.buildDOM(currentDir);
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw new InstantiationError(""FSDom threw a ParserConfigurationException : "" + pce.getMessage());
        } catch (IOException ioe) {
            ioe.printStackTrace();
            throw new InstantiationError(""FSDom threw an IOException : "" + ioe.getMessage());
        }
    }

    protected Map createEscapeCharsMap() {
        Map<String, String> escapeChars = new HashMap<String, String>();
        escapeChars.put(""&"", ""&#26;"");
        escapeChars.put(""<"", ""&#3c;"");
        escapeChars.put("">"", ""&#3e;"");
        escapeChars.put(""\"""", ""&#22;"");
        return escapeChars;
    }

    protected void createDocumentBuilder() throws ParserConfigurationException {
        try {
            this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw pce;
        }
    }

    protected Document buildDOM(File currentDir) throws IOException {
        Document dom = this.documentBuilder.newDocument();
        dom.appendChild(this.createChildElement(dom, currentDir));
        return dom;
    }

    private Element createChildElement(Document dom, File currentFile) throws IOException {
        Element currentElement = null;
        if (currentFile.isDirectory()) {
            currentElement = dom.createElement(FSPathAttributes.dir.name());
            //recurse and create child elements for all its children
            File[] children = currentFile.listFiles();
            if (children != null) {
                for (int i = 0; i < children.length; i++) {
                    currentElement.appendChild(this.createChildElement(dom, children[i]));
                }
            }
        } else {
            currentElement = dom.createElement(FSPathAttributes.file.name());
        }
        currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());
        currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));
        currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));
        currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));
        currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));
        currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));
        currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));
        currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));
        currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));
        currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());
        currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());
        return currentElement;
    }

    /**
     *  Calls this.query(expression, XPathConstants.NODESET)
     *
     *  Note : This method MUST be passed an expression which returns a nodeset.
     *
     *  @param expression the FSPath expression to execute.
     *  @returns <code>FSPathResultList</code> the FSPathResult objects contained
     *  in this list will be of type <code>java.io.File</code>,
     *  <code>java.lang.Double</code>, <code>java.lang.Boolean</code>,
     *  <code>java.lang.String</code>
     */
    public FSPathResultList query(String expression) {
        return this.query(expression, XPathConstants.NODESET);
    }

    /**
     */
    public FSPathResultList query(String expression, QName returnType) {
        FSPathResultList results = new FSPathResultListImpl();
        try {
            if (XPathConstants.NODESET.equals(returnType)) {
                NodeList nodelist = (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);
                if (nodelist.getLength() > 0) {
                    for (int i = 0; i < nodelist.getLength(); i++) {
                        processNode(nodelist.item(i), results);
                    }
                }
                return results;
            }
            if (XPathConstants.NODE.equals(returnType)) {
                Node node = (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);
                processNode(node, results);
                return results;
            }
            if (XPathConstants.BOOLEAN.equals(returnType)) {
                Boolean result = (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.NUMBER.equals(returnType)) {
                Double result = (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.STRING.equals(returnType)) {
                String result = (String) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.STRING);
                results.add(new FSPathResult(result));
                return results;
            }
        } catch (XPathExpressionException xpee) {
            System.out.println(""Invalid FSPath expression : "" + xpee.getCause().getMessage());
        } catch (IllegalArgumentException iae) {
            iae.printStackTrace();
            System.out.println(""IllegalArgumentException"");
        } catch (ParseException pe) {
            pe.printStackTrace();
            System.out.println(""ParseException"");
        }
        return results;
    }

    private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {
        //as the only elements in our dom are files or directories we will try to
        //create File objects of those nodes.
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            String fileName = node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();
            //System.out.println(""Filename : "" + fileName);
            results.add(new FSPathResult(new File(fileName)));
            return;
        }
        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
            Attr attr = (Attr) node;
            //now work out which attirutes were Dates, Longs and Strings
            if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {
                results.add(new FSPathResult(attr.getValue()));
                return;
            }
            if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {
                results.add(new FSPathResult(new Boolean(attr.getValue())));
                return;
            }
            if (FSPathAttributes.lastModified.name().equals(attr.getName())) {
                results.add(new FSPathResult(this.format.parse(attr.getValue())));
                return;
            }
            if (FSPathAttributes.length.name().equals(attr.getName())) {
                results.add(new FSPathResult(Double.parseDouble(attr.getValue())));
                return;
            }
        }
    }

    public File getRootDirectory() {
        return this.rootDirectory;
    }
}
","// DefaultFSPath_0Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains ten unit test cases for the {@link DefaultFSPath#query(String)} method.
*/
class DefaultFSPath_0Test {","// DefaultFSPath_0Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains ten unit test cases for the {@link DefaultFSPath#query(String)} method.
*/
class DefaultFSPath_0Test {

		private DefaultFSPath defaultFSPath;
		
		private File rootDirectory;
		
		private XPath xpath;
		
		private Document dom;
		
		private DateFormat format;
		
		private Map escapeChars;
		
		private DocumentBuilder documentBuilder;
		
		private void setUp() throws ParserConfigurationException, IOException {
				this.xpath = XPathFactory.newInstance().newXPath();
				this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());
				this.escapeChars = this.createEscapeCharsMap();
				this.format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
				this.rootDirectory = new File(""/home/keith/workspace/FSPath/test/net/sf/sugar/fspath/testdata"");
				this.createDocumentBuilder();
				this.dom = this.buildDOM(this.rootDirectory);
				this.defaultFSPath = new DefaultFSPath();
		}
		
		private Map createEscapeCharsMap() {
				Map<String, String> escapeChars = new HashMap<String, String>();
				escapeChars.put(""&"", ""&#26;"");
				escapeChars.put(""<"", ""&#3c;"");
				escapeChars.put("">"", ""&#3e;"");
				escapeChars.put(""\"""", ""&#22;"");
				return escapeChars;
		}
		
		private void createDocumentBuilder() throws ParserConfigurationException {
				try {
						this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
				} catch (ParserConfigurationException pce) {
						pce.printStackTrace();
						throw pce;
				}
		}
		
		private Document buildDOM(File currentDir) throws IOException {
				Document dom = this.documentBuilder.newDocument();
				dom.appendChild(this.createChildElement(dom, currentDir));
				return dom;
		}
		
		private Element createChildElement(Document dom, File currentFile) throws IOException {
				Element currentElement = null;
				if (currentFile.isDirectory()) {
						currentElement = dom.createElement(FSPathAttributes.dir.name());
						//recurse and create child elements for all its children
						File[] children = currentFile.listFiles();
						if (children != null) {
								for (int i = 0; i < children.length; i++) {
										currentElement.appendChild(this.createChildElement(dom, children[i]));
								}
						}
				} else {
						currentElement = dom.createElement(FSPathAttributes.file.name());
				}
				currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());
				currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());
				//optional for speed?
				currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));
				//optional for speed?
				currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));
				currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());
				//optional for speed?
				currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));
				currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));
				currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));
				currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));
				currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));
				currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));
				currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));
				currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());
				currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());
				return currentElement;
		}
		
		private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {
				//as the only elements in our dom are files or directories we will try to
				//create File objects of those nodes.
				if (node.getNodeType() == Node.ELEMENT_NODE) {
						String fileName = node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();
						//System.out.println(""Filename : "" + fileName);
						results.add(new FSPathResult(new File(fileName)));
						return;
				}
				if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
						Attr attr = (Attr) node;
						//now work out which attirutes were Dates, Longs and Strings
						if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {
								results.add(new FSPathResult(attr.getValue()));
								return;
						}
						if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {
								results.add(new FSPathResult(new Boolean(attr.getValue())));
								return;
						}
						if (FSPathAttributes.lastModified.name().equals(attr.getName())) {
								results.add(new FSPathResult(this.format.parse(attr.getValue())));
								return;
						}
						if (FSPathAttributes.length"
cmpl-6u7TFtuu0PBTbRURlHO0xssQHKgUc,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/DefaultFSPath_1Test.java,43.79843711853027,length,"// DefaultFSPath.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 *  The default implementation of the FSPath interface.
 *  This class uses the JDK's XPath implementation as the basis for
 *  FSPath queries.
 *  On instantiation, a DOM is created of the filesystem metadata starting form the <code>rootDirectory</code>.
 *  This DOM can then be queried using standard XML tools.
 *  <br/>
 *  Whilst this approach has been relatively quick to implement, it is still tied to the limitations of XPath.
 *  Future implementations of this class are likely to implement the FSPath language fully themselves wthout relying on XPath.
 *  <br/>
 *  todo: develop some front end substitution to enable the short queries i.e. /var/www etc
 *
 * @author keith
 *  $Id$
 */
public class DefaultFSPath implements FSPath {

    /**
     *  Escape characters, we must escape any characters that are
     *  illegal in XML attribute text.
     *
     *  i.e. &amp; "" < >
     */
    private Map escapeChars;

    private DocumentBuilder documentBuilder;

    private XPath xpath;

    private Document dom;

    /**
     *  The date format used to correspond to the xs:date format i.e. yyyy-MM-dd'T'HH:mm:ss.SSS
     */
    private DateFormat format;

    private File rootDirectory;

    public DefaultFSPath() {
        //used for unit test instantiation
        this.xpath = XPathFactory.newInstance().newXPath();
        //this.xpath.setNamespaceContext(new FSNamespaceContext());
        //this effectively enables the user of our custom XPath function
        //fs:match()
        this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());
        this.escapeChars = this.createEscapeCharsMap();
        this.format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
    }

    /**
     * Creates a new instance of DefaultFSPath, based on the directory supplied
     */
    public DefaultFSPath(File currentDir) {
        this();
        this.rootDirectory = currentDir;
        //check if file is a directory
        if (!currentDir.isDirectory()) {
            throw new InstantiationError(""the java.io.File specified must be a Directory"");
        }
        try {
            this.createDocumentBuilder();
            //build DOM representation
            this.dom = this.buildDOM(currentDir);
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw new InstantiationError(""FSDom threw a ParserConfigurationException : "" + pce.getMessage());
        } catch (IOException ioe) {
            ioe.printStackTrace();
            throw new InstantiationError(""FSDom threw an IOException : "" + ioe.getMessage());
        }
    }

    protected Map createEscapeCharsMap() {
        Map<String, String> escapeChars = new HashMap<String, String>();
        escapeChars.put(""&"", ""&#26;"");
        escapeChars.put(""<"", ""&#3c;"");
        escapeChars.put("">"", ""&#3e;"");
        escapeChars.put(""\"""", ""&#22;"");
        return escapeChars;
    }

    protected void createDocumentBuilder() throws ParserConfigurationException {
        try {
            this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
        } catch (ParserConfigurationException pce) {
            pce.printStackTrace();
            throw pce;
        }
    }

    protected Document buildDOM(File currentDir) throws IOException {
        Document dom = this.documentBuilder.newDocument();
        dom.appendChild(this.createChildElement(dom, currentDir));
        return dom;
    }

    private Element createChildElement(Document dom, File currentFile) throws IOException {
        Element currentElement = null;
        if (currentFile.isDirectory()) {
            currentElement = dom.createElement(FSPathAttributes.dir.name());
            //recurse and create child elements for all its children
            File[] children = currentFile.listFiles();
            if (children != null) {
                for (int i = 0; i < children.length; i++) {
                    currentElement.appendChild(this.createChildElement(dom, children[i]));
                }
            }
        } else {
            currentElement = dom.createElement(FSPathAttributes.file.name());
        }
        currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());
        currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));
        currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());
        //optional for speed?
        currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));
        currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));
        currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));
        currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));
        currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));
        currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));
        currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));
        currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());
        currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());
        return currentElement;
    }

    /**
     *  Calls this.query(expression, XPathConstants.NODESET)
     *
     *  Note : This method MUST be passed an expression which returns a nodeset.
     *
     *  @param expression the FSPath expression to execute.
     *  @returns <code>FSPathResultList</code> the FSPathResult objects contained
     *  in this list will be of type <code>java.io.File</code>,
     *  <code>java.lang.Double</code>, <code>java.lang.Boolean</code>,
     *  <code>java.lang.String</code>
     */
    public FSPathResultList query(String expression) {
        return this.query(expression, XPathConstants.NODESET);
    }

    /**
     */
    public FSPathResultList query(String expression, QName returnType) {
        FSPathResultList results = new FSPathResultListImpl();
        try {
            if (XPathConstants.NODESET.equals(returnType)) {
                NodeList nodelist = (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);
                if (nodelist.getLength() > 0) {
                    for (int i = 0; i < nodelist.getLength(); i++) {
                        processNode(nodelist.item(i), results);
                    }
                }
                return results;
            }
            if (XPathConstants.NODE.equals(returnType)) {
                Node node = (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);
                processNode(node, results);
                return results;
            }
            if (XPathConstants.BOOLEAN.equals(returnType)) {
                Boolean result = (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.NUMBER.equals(returnType)) {
                Double result = (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);
                results.add(new FSPathResult(result));
                return results;
            }
            if (XPathConstants.STRING.equals(returnType)) {
                String result = (String) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.STRING);
                results.add(new FSPathResult(result));
                return results;
            }
        } catch (XPathExpressionException xpee) {
            System.out.println(""Invalid FSPath expression : "" + xpee.getCause().getMessage());
        } catch (IllegalArgumentException iae) {
            iae.printStackTrace();
            System.out.println(""IllegalArgumentException"");
        } catch (ParseException pe) {
            pe.printStackTrace();
            System.out.println(""ParseException"");
        }
        return results;
    }

    private void processNode(Node node, FSPathResultList results) throws XPathExpressionException, IllegalArgumentException, ParseException {
        //as the only elements in our dom are files or directories we will try to
        //create File objects of those nodes.
        if (node.getNodeType() == Node.ELEMENT_NODE) {
            String fileName = node.getAttributes().getNamedItem(FSPathAttributes.absolutePath.name()).getNodeValue();
            //System.out.println(""Filename : "" + fileName);
            results.add(new FSPathResult(new File(fileName)));
            return;
        }
        if (node.getNodeType() == Node.ATTRIBUTE_NODE) {
            Attr attr = (Attr) node;
            //now work out which attirutes were Dates, Longs and Strings
            if (FSPathAttributes.absolutePath.name().equals(attr.getName()) | FSPathAttributes.canonicalPath.name().equals(attr.getName()) | FSPathAttributes.name.name().equals(attr.getName()) | FSPathAttributes.parent.name().equals(attr.getName()) | FSPathAttributes.path.name().equals(attr.getName())) {
                results.add(new FSPathResult(attr.getValue()));
                return;
            }
            if (FSPathAttributes.canRead.name().equals(attr.getName()) | FSPathAttributes.canWrite.name().equals(attr.getName()) | FSPathAttributes.exists.name().equals(attr.getName()) | FSPathAttributes.isAbsolute.name().equals(attr.getName()) | FSPathAttributes.isDirectory.name().equals(attr.getName()) | FSPathAttributes.isFile.name().equals(attr.getName()) | FSPathAttributes.isHidden.name().equals(attr.getName())) {
                results.add(new FSPathResult(new Boolean(attr.getValue())));
                return;
            }
            if (FSPathAttributes.lastModified.name().equals(attr.getName())) {
                results.add(new FSPathResult(this.format.parse(attr.getValue())));
                return;
            }
            if (FSPathAttributes.length.name().equals(attr.getName())) {
                results.add(new FSPathResult(Double.parseDouble(attr.getValue())));
                return;
            }
        }
    }

    public File getRootDirectory() {
        return this.rootDirectory;
    }
}
","// DefaultFSPath_1Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains ten unit test cases for the {@link DefaultFSPath#query(String, QName)} method.
*/
class DefaultFSPath_1Test {","// DefaultFSPath_1Test.java
/*
 * DefaultFSPath.java
 *
 * Created on 18 September 2006, 00:25
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import javax.xml.namespace.QName;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;
import net.sf.sugar.fspath.xpath.RegexFunctionResolver;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultFSPath}.
* It contains ten unit test cases for the {@link DefaultFSPath#query(String, QName)} method.
*/
class DefaultFSPath_1Test {

		private DefaultFSPath defaultFSPath;
		
		private File rootDirectory;
		
		private XPath xpath;
		
		private Document dom;
		
		private DateFormat format;
		
		private Map escapeChars;
		
		private DocumentBuilder documentBuilder;
		
		public DefaultFSPath_1Test() {
				this.xpath = XPathFactory.newInstance().newXPath();
				this.xpath.setXPathFunctionResolver(new RegexFunctionResolver());
				this.escapeChars = this.createEscapeCharsMap();
				this.format = new SimpleDateFormat(""yyyy-MM-dd'T'HH:mm:ss.SSS"");
		}
		
		protected Map createEscapeCharsMap() {
				Map<String, String> escapeChars = new HashMap<String, String>();
				escapeChars.put(""&"", ""&#26;"");
				escapeChars.put(""<"", ""&#3c;"");
				escapeChars.put("">"", ""&#3e;"");
				escapeChars.put(""\"""", ""&#22;"");
				return escapeChars;
		}
		
		protected void createDocumentBuilder() throws ParserConfigurationException {
				try {
						this.documentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
				} catch (ParserConfigurationException pce) {
						pce.printStackTrace();
						throw pce;
				}
		}
		
		protected Document buildDOM(File currentDir) throws IOException {
				Document dom = this.documentBuilder.newDocument();
				dom.appendChild(this.createChildElement(dom, currentDir));
				return dom;
		}
		
		private Element createChildElement(Document dom, File currentFile) throws IOException {
				Element currentElement = null;
				if (currentFile.isDirectory()) {
						currentElement = dom.createElement(FSPathAttributes.dir.name());
						//recurse and create child elements for all its children
						File[] children = currentFile.listFiles();
						if (children != null) {
								for (int i = 0; i < children.length; i++) {
										currentElement.appendChild(this.createChildElement(dom, children[i]));
								}
						}
				} else {
						currentElement = dom.createElement(FSPathAttributes.file.name());
				}
				currentElement.setAttribute(FSPathAttributes.name.name(), currentFile.getName());
				currentElement.setAttribute(FSPathAttributes.absolutePath.name(), currentFile.getAbsolutePath());
				//optional for speed?
				currentElement.setAttribute(FSPathAttributes.canRead.name(), Boolean.toString(currentFile.canRead()));
				//optional for speed?
				currentElement.setAttribute(FSPathAttributes.canWrite.name(), Boolean.toString(currentFile.canWrite()));
				currentElement.setAttribute(FSPathAttributes.canonicalPath.name(), currentFile.getCanonicalPath());
				//optional for speed?
				currentElement.setAttribute(FSPathAttributes.exists.name(), Boolean.toString(currentFile.exists()));
				currentElement.setAttribute(FSPathAttributes.isAbsolute.name(), Boolean.toString(currentFile.isAbsolute()));
				currentElement.setAttribute(FSPathAttributes.isDirectory.name(), Boolean.toString(currentFile.isDirectory()));
				currentElement.setAttribute(FSPathAttributes.isFile.name(), Boolean.toString(currentFile.isFile()));
				currentElement.setAttribute(FSPathAttributes.isHidden.name(), Boolean.toString(currentFile.isHidden()));
				currentElement.setAttribute(FSPathAttributes.lastModified.name(), this.format.format(new Date(currentFile.lastModified())));
				currentElement.setAttribute(FSPathAttributes.length.name(), Long.toString(currentFile.length()));
				currentElement.setAttribute(FSPathAttributes.parent.name(), currentFile.getParent());
				currentElement.setAttribute(FSPathAttributes.path.name(), currentFile.getPath());
				return currentElement;
		}
		
		/**
		 *  Calls this.query(expression, XPathConstants.NODESET)
		 *
		 *  Note : This method MUST be passed an expression which returns a nodeset.
		 *
		 *  @param expression the FSPath expression to execute.
		 *  @returns <code>FSPathResultList</code> the FSPathResult objects contained
		 *  in this list will be of type <code>java.io.File</code>,
		 *  <code>java.lang.Double</code>, <code>java.lang.Boolean</code>,
		 *  <code>java.lang.String</code>
		 */
		public FSPathResultList query(String expression) {
				return this.query(expression, XPathConstants.NODESET);
		}
		
		/**
		 */
		public FSPathResultList query(String expression, QName returnType) {
				FSPathResultList results = new FSPathResultListImpl();
				try {
						if (XPathConstants.NODESET.equals(returnType)) {
								NodeList nodelist = (NodeList) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODESET);
								if (nodelist.getLength() > 0) {
										for (int i = 0; i < nodelist.getLength(); i++) {
												processNode(nodelist.item(i), results);
										}
								}
								return results;
						}
						if (XPathConstants.NODE.equals(returnType)) {
								Node node = (Node) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NODE);
								processNode(node, results);
								return results;
						}
						if (XPathConstants.BOOLEAN.equals(returnType)) {
								Boolean result = (Boolean) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.BOOLEAN);
								results.add(new FSPathResult(result));
								return results;
						}
						if (XPathConstants.NUMBER.equals(returnType)) {
								Double result = (Double) this.xpath.evaluate(expression, this.dom.getDocumentElement(), XPathConstants.NUMBER);
								results.add(new FSPathResult(result));
								return results;
						}
						if (XPath"
cmpl-6u7UIQtaJbWteD0kOPbpkOPlodLwu,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_0Test.java,39.360920906066895,length,"// FSPathFactory.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;

/**
 * @author kbishop
 */
public class FSPathFactory {

    /**
     * Creates a new instance of FSPathFactory
     */
    public FSPathFactory() {
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(""user.dir"")) to search from.
     */
    public static FSPath newFSPath() {
        return new DefaultFSPath(new File(System.getProperty(""user.dir"")));
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.
     */
    public static FSPath newFSPath(File file) {
        return new DefaultFSPath(file);
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.
     */
    public static FSPath newFSPath(String path) {
        return new DefaultFSPath(new File(path));
    }
}
","// FSPathFactory_0Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath()} method.
*/
class FSPathFactory_0Test {","// FSPathFactory_0Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath()} method.
*/
class FSPathFactory_0Test {

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath() {
		System.out.println(""newFSPath"");
		FSPath result = FSPathFactory.newFSPath();
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}
}

// FSPathFactory_1Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(File)} method.
*/
class FSPathFactory_1Test {
		
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath() {
		System.out.println(""newFSPath"");
		File file = new File(""."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(file, result.getFile());
	}
}

// FSPathFactory_2Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(String)} method.
*/
class FSPathFactory_2Test {
		
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath() {
		System.out.println(""newFSPath"");
		String path = ""."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertNotNull(result);
		assertEquals(new File(path), result.getFile());
	}
}

// FSPath_0Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getFile()} method.
*/
class FSPath_0Test {
		
	/**
	 * Test of getFile method, of class FSPath.
	 */
	@Test
	void testGetFile() {
		System.out.println(""getFile"");
		FSPath instance = FSPathFactory.newFSPath();
		File expResult = new File(System.getProperty(""user.dir""));
		File result = instance.getFile();
		assertEquals(expResult, result);
	}
}

// FSPath_1Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getPath()} method.
*/
class FSPath_1Test {
		
	/**
	 * Test of getPath method, of class FSPath.
	 */
	@Test
	void testGetPath() {
		System.out.println(""getPath"");
		FSPath instance = FSPathFactory.newFSPath();
		String expResult = System.getProperty(""user.dir"");
		String result = instance.getPath();
		assertEquals(expResult, result);
	}
}

// FSPath_2Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getName()} method.
*/
class FSPath_2Test {
		
	/**
	 * Test of getName method, of class FSPath.
	 */
	@Test
	void testGetName() {
		System.out.println(""getName"");
		FSPath instance = FSPathFactory.newFSPath();
		String expResult = new File(System.getProperty(""user.dir"")).getName();
		String result = instance.getName();
		assertEquals(expResult, result);
	}
}

// FSPath_3Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getParent()} method.
*/
class FSPath_3Test {
		
	/**
	 * Test of getParent method, of class FSPath.
	 */
	@Test
	void testGetParent() {
		System.out.println(""getParent"");
		FSPath instance = FSPathFactory.newFSPath();
		FSPath expResult = FSPathFactory.newFSPath(new File(System.getProperty(""user.dir"")).getParent());
		FSPath result = instance.getParent();
		assertEquals(expResult, result);
	}
}

// FSPath_4Test.java
/*
 * FSPath.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPath}.
* It contains ten unit test cases for the {@link FSPath#getParentPath()} method.
*/
class FSPath_4Test {
		
	/**
	 * Test of getParentPath method, of class FSPath.
	 */
	@Test
	void testGetParentPath() {
		System.out.println(""getParent"
cmpl-6u7VLpt6GVp4up4a1pZNbvQoV8duJ,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_1Test.java,40.38337159156799,length,"// FSPathFactory.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;

/**
 * @author kbishop
 */
public class FSPathFactory {

    /**
     * Creates a new instance of FSPathFactory
     */
    public FSPathFactory() {
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(""user.dir"")) to search from.
     */
    public static FSPath newFSPath() {
        return new DefaultFSPath(new File(System.getProperty(""user.dir"")));
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.
     */
    public static FSPath newFSPath(File file) {
        return new DefaultFSPath(file);
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.
     */
    public static FSPath newFSPath(String path) {
        return new DefaultFSPath(new File(path));
    }
}
","// FSPathFactory_1Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(File)} method.
*/
class FSPathFactory_1Test {","// FSPathFactory_1Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(File)} method.
*/
class FSPathFactory_1Test {

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File() {
		System.out.println(""newFSPath"");
		File file = null;
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_1() {
		System.out.println(""newFSPath"");
		File file = new File(""."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_2() {
		System.out.println(""newFSPath"");
		File file = new File("".."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile(), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_3() {
		System.out.println(""newFSPath"");
		File file = new File(""/"");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/""), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_4() {
		System.out.println(""newFSPath"");
		File file = new File(""/tmp"");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/tmp""), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_5() {
		System.out.println(""newFSPath"");
		File file = new File(""/tmp/"");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/tmp""), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_6() {
		System.out.println(""newFSPath"");
		File file = new File(""/tmp/.."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/""), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_7() {
		System.out.println(""newFSPath"");
		File file = new File(""/tmp/../"");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/""), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_8() {
		System.out.println(""newFSPath"");
		File file = new File(""/tmp/../.."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/""), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_9() {
		System.out.println(""newFSPath"");
		File file = new File(""/tmp/../../"");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/""), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_10() {
		System.out.println(""newFSPath"");
		File file = new File(""/tmp/../../.."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertNotNull(result);
		assertEquals(new File(""/""), result.getFile());
	}
	
}

// FSPathFactory_2Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(String)} method.
*/
class FSPathFactory_2Test {
		
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String() {
		System.out.println(""newFSPath"");
		String path = null;
		FSPath result = FSPathFactory.newFSPath(path);
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_1() {
		System.out.println(""newFSPath"");
		String path = ""."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_2() {
		System.out.println(""newFSPath"");
		String path = "".."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertNotNull(result);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile(), result.getFile());
	}
	
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_3() {
		System.out.println(""newFSPath"");
		String path = ""/"";
		FSPath result = FSPathFactory.newFSPath(path);
		assertNotNull(result);
		assertEquals(new File(""/""), result.getFile());
	}
	
	/**
	 * Test of newFSPath"
cmpl-6u7WOffTxAyIEoOees6as9uAybTYg,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathFactory_2Test.java,45.287296295166016,length,"// FSPathFactory.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;

/**
 * @author kbishop
 */
public class FSPathFactory {

    /**
     * Creates a new instance of FSPathFactory
     */
    public FSPathFactory() {
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the current user directory (System.getProperty(""user.dir"")) to search from.
     */
    public static FSPath newFSPath() {
        return new DefaultFSPath(new File(System.getProperty(""user.dir"")));
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory provided to search from.
     */
    public static FSPath newFSPath(File file) {
        return new DefaultFSPath(file);
    }

    /**
     *  @returns FSPath a new DefaultFSPath instance which uses the directory path String provided to search from.
     */
    public static FSPath newFSPath(String path) {
        return new DefaultFSPath(new File(path));
    }
}
","// FSPathFactory_2Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(String)} method.
*/
class FSPathFactory_2Test {","// FSPathFactory_2Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(String)} method.
*/
class FSPathFactory_2Test {

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String() {
		System.out.println(""newFSPath"");
		String path = """";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_2() {
		System.out.println(""newFSPath"");
		String path = ""."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_3() {
		System.out.println(""newFSPath"");
		String path = ""./"";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_4() {
		System.out.println(""newFSPath"");
		String path = ""./."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_5() {
		System.out.println(""newFSPath"");
		String path = ""./.."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile(), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_6() {
		System.out.println(""newFSPath"");
		String path = ""../."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile(), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_7() {
		System.out.println(""newFSPath"");
		String path = ""../.."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile().getParentFile(), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_8() {
		System.out.println(""newFSPath"");
		String path = ""../../"";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile().getParentFile(), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_9() {
		System.out.println(""newFSPath"");
		String path = ""../../."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile().getParentFile(), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_String_10() {
		System.out.println(""newFSPath"");
		String path = ""../../.."";
		FSPath result = FSPathFactory.newFSPath(path);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile().getParentFile().getParentFile(), result.getFile());
	}
}

// FSPathFactory_3Test.java
/*
 * FSPathFactory.java
 *
 * Created on 06 April 2008, 17:04
 *
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathFactory}.
* It contains ten unit test cases for the {@link FSPathFactory#newFSPath(File)} method.
*/
class FSPathFactory_3Test {
		
	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File() {
		System.out.println(""newFSPath"");
		File file = null;
		FSPath result = FSPathFactory.newFSPath(file);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_2() {
		System.out.println(""newFSPath"");
		File file = new File(""."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_3() {
		System.out.println(""newFSPath"");
		File file = new File(""./"");
		FSPath result = FSPathFactory.newFSPath(file);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_4() {
		System.out.println(""newFSPath"");
		File file = new File(""./."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertEquals(new File(System.getProperty(""user.dir"")), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_5() {
		System.out.println(""newFSPath"");
		File file = new File(""./.."");
		FSPath result = FSPathFactory.newFSPath(file);
		assertEquals(new File(System.getProperty(""user.dir"")).getParentFile(), result.getFile());
	}

	/**
	 * Test of newFSPath method, of class FSPathFactory.
	 */
	@Test
	void testNewFSPath_File_6() {
		System.out.println(""newFSPath"");
		File file = new File(""../."");
		FSPath result = FSPathFactory.newFSPath("
cmpl-6u7XRMzxLb4ivEUqv9Dsz6aBYxxy7,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_0Test.java,48.222644329071045,length,"// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_0Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_0Test {","// FSPathResultListImpl_0Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_0Test {

	/**
	 * Test of each method, of class FSPathResultListImpl.
	 */
	@Test
	void testEach() throws Exception {
		System.out.println(""each"");
		Callback callback = null;
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultList expResult = null;
		FSPathResultList result = instance.each(callback);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.delete();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 */
	@Test
	void testCopy() throws Exception {
		System.out.println(""copy"");
		String destinationDirPath = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of isListOfFiles method, of class FSPathResultListImpl.
	 */
	@Test
	void testIsListOfFiles() {
		System.out.println(""isListOfFiles"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		boolean expResult = false;
		boolean result = instance.isListOfFiles();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 */
	@Test
	void testRename() throws Exception {
		System.out.println(""rename"");
		String matchExpression = """";
		String replaceExpresion = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of move method, of class FSPathResultListImpl.
	 */
	@Test
	void testMove() throws Exception {
		System.out.println(""move"");
		String destinationPath = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.move(destinationPath);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
}

// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#each(Callback)} method.
*/
class FSPathResultListImpl_1Test {
		
	/**
	 * Test of each method, of class FSPathResultListImpl.
	 */
	@Test
	void testEach() throws Exception {
		System.out.println(""each"");
		Callback callback = null;
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultList expResult = null;
		FSPathResultList result = instance.each(callback);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.delete();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 */
	@Test
	void testCopy() throws Exception {
		System.out.println(""copy"");
		String destinationDirPath = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of isListOfFiles method, of class FSPathResultListImpl.
	 */
	@Test
	void testIsListOfFiles() {
		System.out.println(""isListOfFiles"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		boolean expResult = false;
		boolean result = instance.isListOfFiles();
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 */
	@Test
	void testRename() throws Exception {
		System.out.println(""rename"");
		String matchExpression = """";
		String replaceExpresion = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
	/**
	 * Test of move method, of class FSPathResultListImpl.
	 */
	@Test
	void testMove() throws Exception {
		System.out.println(""move"");
		String destinationPath ="
cmpl-6u7YUaHY3AvNh6a511eyYlODnAjvM,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_1Test.java,43.193737745285034,length,"// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#delete()} method.
*/
class FSPathResultListImpl_1Test {","// FSPathResultListImpl_1Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#delete()} method.
*/
class FSPathResultListImpl_1Test {

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().isEmpty());
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_1() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().isEmpty());
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_2() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 1);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_3() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_4() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 1);
		assertTrue(result.getFailures().size() == 1);
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_5() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_6() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_7() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_8() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
		writer.write(""test"");
		writer.close();
		writer = new FileWriter(new File(""/tmp/test2.txt""));
		writer.write(""test"");
		writer.close();
		FSPathResultModificationList result = instance.delete();
		assertTrue(result.getSuccesses().size() == 2);
		assertTrue(result.getFailures().isEmpty());
	}

	/**
	 * Test of delete method, of class FSPathResultListImpl.
	 */
	@Test
	void testDelete_9() throws Exception {
		System.out.println(""delete"");
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""/tmp/test.txt"")));
		instance.add(new FSPathResult(new File(""/tmp/test2.txt"")));
		FileWriter writer = new FileWriter(new File(""/tmp/test.txt""));
"
cmpl-6u7ZXm2X5O0MuBQi5MyO2xHo0wkjh,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_2Test.java,46.115421533584595,length,"// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_2Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#copy(String)} method.
*/
class FSPathResultListImpl_2Test {","// FSPathResultListImpl_2Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#copy(String)} method.
*/
class FSPathResultListImpl_2Test {

	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is null.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNull() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = null;
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is empty.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsEmpty() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = """";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory2() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory3() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory4() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory5() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory6() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory7() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	}
	
	/**
	 * Test of copy method, of class FSPathResultListImpl.
	 * It tests the case when the destination path is not a directory.
	 * @throws java.io.IOException
	 * @throws net.sf.sugar.fspath.OperationNotPermittedException
	 */
	@Test
	void testCopy_DestinationPathIsNotADirectory8() throws IOException, OperationNotPermittedException {
		System.out.println(""copy"");
		String destinationDirPath = ""test/resources/test.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		FSPathResultModificationList expResult = null;
		FSPathResultModificationList result = instance.copy(destinationDirPath);
		assertEquals(expResult, result);
	"
cmpl-6u7aaqxgBajB9HCA87tM3bSgQ8djQ,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_3Test.java,44.330222845077515,length,"// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_3Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#rename(String, String)} method.
*/
class FSPathResultListImpl_3Test {","// FSPathResultListImpl_3Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#rename(String, String)} method.
*/
class FSPathResultListImpl_3Test {

	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 * This test case tests the rename method with a simple rename.
	 * It renames the file ""a.txt"" to ""b.txt"".
	 */
	@Test
	void testRename_SimpleRename() throws Exception {
		System.out.println(""rename"");
		String matchExpression = ""a.txt"";
		String replaceExpresion = ""b.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""a.txt"")));
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(1, result.getSuccesses().size());
		assertEquals(0, result.getFailures().size());
		assertEquals(""b.txt"", result.getSuccesses().get(0).getFile().getName());
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 * This test case tests the rename method with a simple rename.
	 * It renames the file ""a.txt"" to ""b.txt"".
	 */
	@Test
	void testRename_SimpleRename_2() throws Exception {
		System.out.println(""rename"");
		String matchExpression = ""a.txt"";
		String replaceExpresion = ""b.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""a.txt"")));
		instance.add(new FSPathResult(new File(""b.txt"")));
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(1, result.getSuccesses().size());
		assertEquals(1, result.getFailures().size());
		assertEquals(""b.txt"", result.getSuccesses().get(0).getFile().getName());
		assertEquals(""b.txt"", result.getFailures().get(0).getFile().getName());
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 * This test case tests the rename method with a simple rename.
	 * It renames the file ""a.txt"" to ""b.txt"".
	 */
	@Test
	void testRename_SimpleRename_3() throws Exception {
		System.out.println(""rename"");
		String matchExpression = ""a.txt"";
		String replaceExpresion = ""b.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""a.txt"")));
		instance.add(new FSPathResult(new File(""b.txt"")));
		instance.add(new FSPathResult(new File(""c.txt"")));
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(1, result.getSuccesses().size());
		assertEquals(2, result.getFailures().size());
		assertEquals(""b.txt"", result.getSuccesses().get(0).getFile().getName());
		assertEquals(""b.txt"", result.getFailures().get(0).getFile().getName());
		assertEquals(""c.txt"", result.getFailures().get(1).getFile().getName());
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 * This test case tests the rename method with a simple rename.
	 * It renames the file ""a.txt"" to ""b.txt"".
	 */
	@Test
	void testRename_SimpleRename_4() throws Exception {
		System.out.println(""rename"");
		String matchExpression = ""a.txt"";
		String replaceExpresion = ""b.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""a.txt"")));
		instance.add(new FSPathResult(new File(""b.txt"")));
		instance.add(new FSPathResult(new File(""c.txt"")));
		instance.add(new FSPathResult(new File(""d.txt"")));
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(1, result.getSuccesses().size());
		assertEquals(3, result.getFailures().size());
		assertEquals(""b.txt"", result.getSuccesses().get(0).getFile().getName());
		assertEquals(""b.txt"", result.getFailures().get(0).getFile().getName());
		assertEquals(""c.txt"", result.getFailures().get(1).getFile().getName());
		assertEquals(""d.txt"", result.getFailures().get(2).getFile().getName());
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 * This test case tests the rename method with a simple rename.
	 * It renames the file ""a.txt"" to ""b.txt"".
	 */
	@Test
	void testRename_SimpleRename_5() throws Exception {
		System.out.println(""rename"");
		String matchExpression = ""a.txt"";
		String replaceExpresion = ""b.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""a.txt"")));
		instance.add(new FSPathResult(new File(""b.txt"")));
		instance.add(new FSPathResult(new File(""c.txt"")));
		instance.add(new FSPathResult(new File(""d.txt"")));
		instance.add(new FSPathResult(new File(""e.txt"")));
		FSPathResultModificationList result = instance.rename(matchExpression, replaceExpresion);
		assertEquals(1, result.getSuccesses().size());
		assertEquals(4, result.getFailures().size());
		assertEquals(""b.txt"", result.getSuccesses().get(0).getFile().getName());
		assertEquals(""b.txt"", result.getFailures().get(0).getFile().getName());
		assertEquals(""c.txt"", result.getFailures().get(1).getFile().getName());
		assertEquals(""d.txt"", result.getFailures().get(2).getFile().getName());
		assertEquals(""e.txt"", result.getFailures().get(3).getFile().getName());
	}
	
	/**
	 * Test of rename method, of class FSPathResultListImpl.
	 * This test case tests the rename method with a simple rename.
	 * It renames the file ""a.txt"" to ""b.txt"".
	 */
	@Test
	void testRename_SimpleRename_6() throws Exception {
		System.out.println(""rename"");
		String matchExpression = ""a.txt"";
		String replaceExpresion = ""b.txt"";
		FSPathResultListImpl instance = new FSPathResultListImpl();
		instance.add(new FSPathResult(new File(""a.txt"")));
		instance.add(new FSPathResult(new File(""b.txt"")));
		instance.add(new FSPathResult(new File(""c.txt"")));
		instance.add(new FSPathResult(new File(""d.txt"")));
		instance.add(new FSPathResult(new File(""e.txt"")));
		instance.add(new FSPathResult(new File(""f.txt"")));
		FSPathResultModificationList result = instance.rename(matchExpression,"
cmpl-6u7bd35weFT8lf5HWFhLV1NFRl52W,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/FSPathResultListImpl_4Test.java,43.92958927154541,length,"// FSPathResultListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * @author kbishop
 * @version $Id$
 */
public class FSPathResultListImpl extends ArrayList<FSPathResult> implements FSPathResultList {

    /**
     * Creates a new instance of FSPathResultListImpl
     */
    public FSPathResultListImpl() {
    }

    /**
     *  A convenience method for defining custom filesystem interaction
     *  across the whole list of results.
     *
     *  This method loops through the results and calls the call(Result result)
     *  method of the Callback class passed to it for each individual result.
     *
     *  @param Callback - a custom implementation of the Callback interface.
     *  @throws IOException
     */
    public FSPathResultList each(Callback callback) throws IOException {
        for (FSPathResult result : this) {
            callback.call(result);
        }
        return this;
    }

    /**
     *  Deletes each file contained in this FSPathResultList.
     *  <br/>
     *  <pre>
     *  ************************************************************************
     *  *               IMPORTANT !!!!!    Use with caution                    *
     *  *   This method makes it extremely easy to trash your filesystem       *
     *  *   Its advised that FSPath queries are tested thouroughly before use  *
     *  *   in order to verify which files would be deleted                    *
     *  *                                                                      *
     *  ************************************************************************
     *  </pre>
     *  @returns FSPathResultModificationListImpl - all successfully deleted files<br/>
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @throws IOException - NOTE this method does not currently thrown an IOException
     *  @throws OperationNotPermittedException - this exception will be thrown if<br/>
     *  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *  java.io.File objects<br/>
     *  (i.e the FSPath query was written to return Boolean, String nor numerical results).
     */
    public FSPathResultModificationList delete() throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Delete is only permitted on FSPathResult objects containing a File object"");
        }
        FSPathResultModificationList deletionList = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            try {
                File file = result.getFile();
                boolean success = file.delete();
                if (success) {
                    deletionList.addSuccess(result);
                } else {
                    deletionList.addFailure(result);
                }
            } catch (Exception e) {
                //todo: log this ?
                deletionList.addFailure(result);
            }
        }
        return deletionList;
    }

    /**
     *  This method will copy each file contained in this FSPathResultList to the
     *  destination path supplied.
     *
     *  @param String - the destination path which you would like to copy files to.
     *
     *  @returns FSPathResultModificationListImpl - all successfully copied files
     *  will be added as a success, and the failures will be added as failures.
     *
     *  @param String the absolute or realtive path of the destination Directory
     *  @throws IOException - NOTE this is currently not thrown by this method.
     *  @throws OperationNotPermittedException - this exception is thrown upon
     *  the following conditions :<br/>
     *  <br/>
     *  1)  The FSPathResult objects contained in this FSPathResultList don't contain<br/>
     *      java.io.File objects<br/>
     *      (i.e the FSPath query was written to return Boolean, String nor numerical results).<br/>
     *  2)  The directory denoted by the destination path doesn't exist.<br/>
     *  3)  The destination path doesn't resolve to a directory.<br/>
     *  4)  The destination path isn't writeable.<br/>
     *  5)  The current java process doesn't have sufficient priveledges to<br/>
     *      access the destination path.<br/>
     */
    public FSPathResultModificationList copy(String destinationDirPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        File destinationDir = new File(destinationDirPath);
        try {
            if (!destinationDir.exists()) {
                throw new OperationNotPermittedException(""Unable to copy to a directory that doesn't exist"");
            }
            if (!destinationDir.isDirectory()) {
                throw new OperationNotPermittedException(""Destination path "" + destinationDir.getAbsolutePath() + "" does not resolve to a directory"");
            }
            if (!destinationDir.canWrite()) {
                throw new OperationNotPermittedException(""Desination path "" + destinationDir.getAbsolutePath() + "" is not writable"");
            }
        } catch (SecurityException se) {
            throw new OperationNotPermittedException(""The current process does not have sufficent priveledges to access "" + destinationDir.getAbsolutePath(), se);
        }
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File destinationFile = new File(destinationDir + result.getFile().getName());
            try {
                FileReader inputReader = new FileReader(result.getFile());
                FileWriter outputReader = new FileWriter(destinationFile);
                int charsRead = 0;
                while ((charsRead = inputReader.read()) != -1) {
                    outputReader.write(charsRead);
                }
                inputReader.close();
                outputReader.close();
                results.addSuccess(new FSPathResult(destinationFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(destinationFile));
            }
        }
        return results;
    }

    public boolean isListOfFiles() {
        return (this.size() > 0 && this.get(0).getFile() != null);
    }

    /**
     *  Renames each file in the FSPathResultList based on a regex match
     *  expression and a replace expression.
     *  <br/>
     *  This method is designed to enable simple renaming i.e. renaming from<br/>
     *  ""a.txt"" to ""b.txt"" but also complex renaming using regular expressions.<br/>
     *  <br/>
     *  Example simple renaming : <br/>
     *  <pre>fspath.query(""/dir[@name='logs']/file[@name='error.log']"").rename(""error.log"", ""error.log.1"");</pre> <br/>
     *  This would work fine for a single file but not much use for multiple files.<br/>
     *  <br/>
     *  Example complex renaming : <br/>
     *  <br/>
     *  Imagine a directory full of files with a format such as : <br/>
     *  <pre>
     *  appLog-01_01_2008.log.1
     *  appLog-01_01_2008.log.2
     *  ...
     *  </pre>
     *  Now imagine that we wanted to rename the files so that they end in .log but they also keep their<br/>
     *  uniqueness (i.e. the number at the end of the file needs to move to a new position in the filename)<br/>
     *  <br/>
     *  The following code expression would work :<br/>
     *  <pre>fspath.query(""dir[@name = 'logs']/file"").rename(""(.*)\.log\.([0-9]+)"", ""$1_$2.log"");</pre> <br/>
     *  Here the matchExpression has two capturing groups, one being everything up to the '.log' in the filename, <br/>
     *  and the other being the number after the "".log."" .<br/>
     *  The replace expression simply specifies that the new file name will have the text in the first capturing group,<br/>
     *  followed by a ""_"" then the text in the second capturing group and then "".log"".
     */
    public FSPathResultModificationList rename(String matchExpression, String replaceExpresion) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""Copy is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        Pattern pattern = Pattern.compile(matchExpression);
        FSPathResultModificationList results = new FSPathResultModificationListImpl();
        for (FSPathResult result : this) {
            File origFile = null;
            File newFile = null;
            try {
                origFile = result.getFile();
                Matcher matcher = pattern.matcher(origFile.getName());
                String newName = matcher.replaceAll(replaceExpresion);
                newFile = new File(newName);
                origFile.renameTo(newFile);
                results.addSuccess(new FSPathResult(newFile));
            } catch (Exception e) {
                results.addFailure(new FSPathResult(newFile));
            }
        }
        return results;
    }

    /**
     *  Moves each file in the list to the specified desination path.
     *
     *  This method effecively calls copy() and then delete() on itself.
     *  If any file fails to sucessfully copy, then this method 'fails fast'
     *  and returns the results of the copy. This should prevent the situation arising
     *  where the copied files are completely deleted.
     *  If the copy suceeds, then it will attempt to delete the original files.
     *
     *  @param String - the directory path to move the files to.
     *  @throws OperationNotPermittedException - see the comments for <code>copy</code>
     */
    public FSPathResultModificationList move(String destinationPath) throws IOException, OperationNotPermittedException {
        if (!isListOfFiles()) {
            throw new OperationNotPermittedException(""move is only permitted on FSPathResult objects containing a java.io.File object"");
        }
        FSPathResultModificationList copyResults = this.copy(destinationPath);
        //if we detect a failure then cease what we're doing and return the results so far
        if (copyResults.hasFailures()) {
            return copyResults;
        }
        //if we're happy with the copy, delete the original files,
        //and return the results of the deletion
        return this.delete();
    }
}
","// FSPathResultListImpl_4Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#move(String)} method.
*/
class FSPathResultListImpl_4Test {","// FSPathResultListImpl_4Test.java
/*
 * FSPathResultListImpl.java
 *
 * Created on 08 April 2008, 18:00
 *
 */
package net.sf.sugar.fspath;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FSPathResultListImpl}.
* It contains ten unit test cases for the {@link FSPathResultListImpl#move(String)} method.
*/
class FSPathResultListImpl_4Test {

		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is null.
		 * It expects an IllegalArgumentException.
		 */
		@Test
		public void testMove_DestinationPathIsNull() throws Exception {
				System.out.println(""move"");
				String destinationPath = null;
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(IllegalArgumentException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is empty.
		 * It expects an IllegalArgumentException.
		 */
		@Test
		public void testMove_DestinationPathIsEmpty() throws Exception {
				System.out.println(""move"");
				String destinationPath = """";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(IllegalArgumentException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not a directory.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotADirectory() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test.txt"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not writable.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotWritable() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not accessible.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotAccessible() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not a directory.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotADirectory2() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test.txt"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not writable.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotWritable2() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not accessible.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotAccessible2() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not a directory.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotADirectory3() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test.txt"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not writable.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotWritable3() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
		/**
		 * Test of move method, of class FSPathResultListImpl.
		 * It tests the case when the destination path is not accessible.
		 * It expects an OperationNotPermittedException.
		 */
		@Test
		public void testMove_DestinationPathIsNotAccessible3() throws Exception {
				System.out.println(""move"");
				String destinationPath = ""test/resources/test"";
				FSPathResultListImpl instance = new FSPathResultListImpl();
				assertThrows(OperationNotPermittedException.class, () -> {
						instance.move(destinationPath);
				});
		}
		
}

// FSPathResultModificationListImpl.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This"
cmpl-6u7cgtGOWoebGJlVDCb63dkQqGzIO,/EvoSuiteBenchmark/60_sugar/src/main/java/net/sf/sugar/fspath/xpath/RegexFunction.java,37.59538245201111,length,"// RegexFunction.java
/**
 * Copyright 2008 (C) Keith Bishop (bishi@users.sourceforge.net)
 *
 * All rights reserved.
 *
 * This file is part of FSPath.
 *
 * FSPath is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FSPath is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with FSPath.  If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * RegexFunction.java
 *
 * Created on 23 April 2008, 22:30
 *
 */
package net.sf.sugar.fspath.xpath;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.xml.xpath.XPathFunctionException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

/**
 * 	This class enables the use of regular expressions in FSPath queries.
 *   For instance :
 *   <pre>
 *   //file[fs:matches('[0-9]{6}-[\w]{4}\.log')]
 *   </pre>
 *   would match files of the pattern nnnnnn-xxxx.log where n is a numerical character and x is a word character.
 *
 *  @author kbishop
 *  @version $Id$
 */
public class RegexFunction implements javax.xml.xpath.XPathFunction {

    private Pattern mostRecentPattern;

    private String mostRecentExpression;

    /**
     * Creates a new instance of RegexFunction
     */
    public RegexFunction() {
    }

    /**
     */
    public Object evaluate(List args) throws XPathFunctionException {
        String nodeValue = this.getNodeValue(args);
        Pattern pattern = this.getPattern(args);
        Boolean isMatch = new Boolean(pattern.matcher(nodeValue).matches());
        return isMatch;
    }

    protected String getNodeValue(List args) throws XPathFunctionException {
        //we know there will be two args
        Object o = args.get(0);
        String nodeValue = """";
        if (o instanceof String) {
            nodeValue = (String) o;
        } else if (o instanceof Boolean) {
            nodeValue = o.toString();
        } else if (o instanceof Double) {
            nodeValue = o.toString();
        } else if (o instanceof NodeList) {
            nodeValue = ((Node) ((NodeList) o).item(0)).getTextContent();
        } else {
            throw new XPathFunctionException(""Unable to evaluate fs:match() function, could not convert argument type"");
        }
        return nodeValue;
    }

    protected Pattern getPattern(List args) throws XPathFunctionException {
        try {
            String expression = (String) args.get(1);
            //For situations where the expression is being applied to a large number of nodes
            //it's desrable to only compile the pattern once.
            if (this.mostRecentExpression == null || !(expression.equals(this.mostRecentExpression))) {
                this.mostRecentExpression = expression;
                Pattern pattern = Pattern.compile(this.mostRecentExpression);
                this.mostRecentPattern = pattern;
            }
            return this.mostRecentPattern;
        } catch (ClassCastException cce) {
            throw new XPathFunctionException(""Unable to evaluate fs:match() function, the second parameter must evaluate to a String type"");
        } catch (PatternSyntaxException pse) {
            throw new XPathFunctionException(""Unable to evaluate fs:match() function, the second parameter is not a valid regex : "" + pse.getMessage());
        }
    }
}
","// RegexFunctionTest.java
/*
 * RegexFunction.java
 *
 * Created on 23 April 2008, 22:30
 *
 */
package net.sf.sugar.fspath.xpath;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.xml.xpath.XPathFunctionException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RegexFunction}.
* It contains ten unit test cases for the {@link RegexFunction#evaluate(List)} method.
*/
class RegexFunctionTest {","// RegexFunctionTest.java
/*
 * RegexFunction.java
 *
 * Created on 23 April 2008, 22:30
 *
 */
package net.sf.sugar.fspath.xpath;

import java.util.List;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;
import javax.xml.xpath.XPathFunctionException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RegexFunction}.
* It contains ten unit test cases for the {@link RegexFunction#evaluate(List)} method.
*/
class RegexFunctionTest {

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a String argument.
	 */
	@Test
	void testEvaluate_String() throws Exception {
		System.out.println(""evaluate(String)"");
		List args = new java.util.ArrayList();
		args.add(""abc"");
		args.add(""[a-z]{3}"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(true);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a Boolean argument.
	 */
	@Test
	void testEvaluate_Boolean() throws Exception {
		System.out.println(""evaluate(Boolean)"");
		List args = new java.util.ArrayList();
		args.add(new Boolean(true));
		args.add(""true"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(true);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a Double argument.
	 */
	@Test
	void testEvaluate_Double() throws Exception {
		System.out.println(""evaluate(Double)"");
		List args = new java.util.ArrayList();
		args.add(new Double(1.0));
		args.add(""[0-9]\\.[0-9]"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(true);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a NodeList argument.
	 */
	@Test
	void testEvaluate_NodeList() throws Exception {
		System.out.println(""evaluate(NodeList)"");
		List args = new java.util.ArrayList();
		args.add(new org.w3c.dom.NodeList() {
			public org.w3c.dom.Node item(int index) {
				return new org.w3c.dom.Node() {
					public String getTextContent() {
						return ""abc"";
					}
				};
			}
			public int getLength() {
				return 1;
			}
		});
		args.add(""[a-z]{3}"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(true);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a NodeList argument.
	 */
	@Test
	void testEvaluate_NodeList_2() throws Exception {
		System.out.println(""evaluate(NodeList)"");
		List args = new java.util.ArrayList();
		args.add(new org.w3c.dom.NodeList() {
			public org.w3c.dom.Node item(int index) {
				return new org.w3c.dom.Node() {
					public String getTextContent() {
						return ""abc"";
					}
				};
			}
			public int getLength() {
				return 0;
			}
		});
		args.add(""[a-z]{3}"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(false);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a NodeList argument.
	 */
	@Test
	void testEvaluate_NodeList_3() throws Exception {
		System.out.println(""evaluate(NodeList)"");
		List args = new java.util.ArrayList();
		args.add(new org.w3c.dom.NodeList() {
			public org.w3c.dom.Node item(int index) {
				return new org.w3c.dom.Node() {
					public String getTextContent() {
						return ""abc"";
					}
				};
			}
			public int getLength() {
				return 2;
			}
		});
		args.add(""[a-z]{3}"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(true);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a NodeList argument.
	 */
	@Test
	void testEvaluate_NodeList_4() throws Exception {
		System.out.println(""evaluate(NodeList)"");
		List args = new java.util.ArrayList();
		args.add(new org.w3c.dom.NodeList() {
			public org.w3c.dom.Node item(int index) {
				return new org.w3c.dom.Node() {
					public String getTextContent() {
						return ""abc"";
					}
				};
			}
			public int getLength() {
				return 2;
			}
		});
		args.add(""[a-z]{4}"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(false);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a NodeList argument.
	 */
	@Test
	void testEvaluate_NodeList_5() throws Exception {
		System.out.println(""evaluate(NodeList)"");
		List args = new java.util.ArrayList();
		args.add(new org.w3c.dom.NodeList() {
			public org.w3c.dom.Node item(int index) {
				return new org.w3c.dom.Node() {
					public String getTextContent() {
						return ""abc"";
					}
				};
			}
			public int getLength() {
				return 2;
			}
		});
		args.add(""[a-z]{3}"");
		RegexFunction instance = new RegexFunction();
		Object expResult = new Boolean(true);
		Object result = instance.evaluate(args);
		assertEquals(expResult, result);
	}

	/**
	 * Test of evaluate method, of class RegexFunction.
	 * This test case tests the evaluation of a NodeList argument.
	 */
	@Test
	void testEvaluate_NodeList_6() throws Exception {
		System.out.println(""evaluate(NodeList)"");
		List args = new java.util.ArrayList();
		args.add(new org.w3c.dom.NodeList() {
			public org.w3c.dom.Node item(int index) {
				return new org."
