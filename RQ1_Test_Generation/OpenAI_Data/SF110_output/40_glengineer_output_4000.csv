ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
356a4ac3-d026-49f7-8a00-2e5d04b63908,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 13508 tokens (9508 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {","// GroupLayoutEngineer_0Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getComponent(Axis, String)} method.
*/
class GroupLayoutEngineer_0Test {
"
de0b559a-66bc-4a85-96f4-1c37743752a1,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 13510 tokens (9510 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {","// GroupLayoutEngineer_1Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_1Test {
"
c12209e6-156e-49a3-ade7-7ee7ea30ed7a,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 13512 tokens (9512 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {","// GroupLayoutEngineer_2Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getParallelGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_2Test {
"
364a7e49-5c64-40f3-aadc-b3cc0f38707e,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 13512 tokens (9512 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {","// GroupLayoutEngineer_3Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getSequentialGroup(Axis, String, String)} method.
*/
class GroupLayoutEngineer_3Test {
"
9e96ebb6-0ca6-4bac-8f30-05eabf2b7629,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/GroupLayoutEngineer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 13509 tokens (9509 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GroupLayoutEngineer.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;

/**
 * {@code GroupLayoutEngineer} is a shell for the layout manager
 * {@code GroupLayout}. It allows to control components' placement
 * using simple 2-dimensional textual schemes.
 * <p>
 * Such approach to GUI creation removes the problem
 * of representing a 2-dimensional GUI by 1-dimensional code.
 *
 * <h3>How to use the {@code GroupLayoutEngineer}</h3>
 *
 * <ol>
 * <li> Create an instance of the {@code GroupLayoutEngineer}.
 * The first parameter of the constructor is a reference to the container,
 * and the rest are the lines of the textual scheme. For example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL  TEXTFIELD      FINDBUTTON  "",
 * 	""          --------------+             "",
 * 	""           CB11   CB12  | CANSELBUTTON"",
 * 	""                        |             "",
 * 	""           CB21   CB22  |             "");
 * </pre>
 *
 * <li> Associate the names on the scheme with concrete components, for example:
 * <pre>
 * gle.associate(""FINDLABEL"", new JLabel(""Find What:""));
 * gle.associate(""TEXTFIELD"", new JTextField());
 * gle.associate(""FINDBUTTON"", new JButton(""Find""));
 * gle.associate(""CB11"", new JCheckBox(""Match Case""));
 * gle.associate(""CB12"", new JCheckBox(""Wrap Around""));
 * gle.associate(""CB21"", new JCheckBox(""Whole Words""));
 * gle.associate(""CB22"", new JCheckBox(""Search Backwards""));
 * gle.associate(""CANSELBUTTON"", new JButton(""Cancel""));
 * </pre>
 *
 * <li> Apply optional preferences (such as special alignment), for example:
 * <pre>
 * gle.linkSize(""FINDBUTTON"", ""CANSELBUTTON"");
 *
 * gle.getParallelGroup(Axis.VERTICAL, ""FINDLABEL"",""FINDBUTTON"")
 * 	.setContentAlignment(Alignment.BASELINE);
 *
 * gle.setAutoCreateGaps(true);
 * gle.setAutoCreateContainerGaps(true);
 * </pre>
 * Note that the alignment in the group above
 * could also be automatically set to {@code Baseline}
 * by calling the method {@code setAutoAlignJTextFields()}.
 * <p><br>
 *
 * <li> Invoke the method
 * <pre>
 * gle.engineer();
 * </pre>
 * </ol>
 *
 * <h3>How to control gaps</h3>
 *
 * If you wish to control the gaps yourself instead of relying
 * on automatic gaps creation, you will have two choices.
 * <p>
 * We recommend to deal with gaps like with components, i.e.,
 * to place the required gaps at the scheme
 * and then to associate them with concrete parameters (types and lengthes),
 * for example:
 * <pre>
 * GroupLayoutEngineer gle = new GroupLayoutEngineer(
 *    getContentPane(),
 * 	""FINDLABEL .. TEXTFIELD      . FINDBUTTON  "",
 * 	""            --------------+       .       "",
 * 	""             CB11 .g CB12 |   CANSELBUTTON"",
 * 	""               .          |               "",
 * 	""             CB21    CB22 |               "");
 *
 * gle.associateGap(""."", ComponentPlacement.RELATED);
 * gle.associateGap("".."", ComponentPlacement.UNRELATED);
 * gle.associateGap("".g1"", 20);
 * </pre>
 *
 * Note that each gap on the scheme must be started from a dot
 * (in order to make it looking different from components).
 * <p>
 * Also note that any gap (associated with the required parameters)
 * may appear on the scheme any number of times,
 * unlike the components, which appear on the scheme only once.
 * <p>
 * Note that you may skip the associations of the denotations ""."" and ""..""
 * with related and unrelated gaps respectively,
 * because these associations are always applied by default.
 *
 * <p><br>
 * Alternatively, you may add gaps to the layout
 * without making additional changes to the scheme.
 * This approach requires specifying concrete sequential or parallel groups
 * and their concrete elements near which a gap should be added, for example:
 * <pre>
 * gle.getSequentialGroup(Axis.HORIZONTAL, ""CB11"", ""CB22"")
 *   .getGroup(""CB12"",""CB22"")
 *     .addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE,Short.MAX_VALUE);
 * </pre>
 * We do not recommend to use the letter approach because it minimizes
 * the advantages of the group layout engineer.
 *
 * <h3>How to draw schemes</h3>
 *
 * In order to avoid formal introduction to this topic,
 * we refer to the examples in the package {@code glengineer.demos}
 * for general introduction to the schemes.
 * <p>
 * Here we mention specific yet essential details only.
 *
 * <ol>
 * <li> The names of components (and gaps) on the scheme may consist of
 * letters of any case, numbers, and underscores '_'.
 * <li> For each layout direction (horizontal and vertical)
 * the engineer tries to divide every non-trivial block of elements
 * on the scheme into a sequential or a parallel
 * (if the former is not possible) group of elements or subblocks.
 * <li> One may place on the scheme horizontal and vertical lines
 * which consist of symbols '-' and '|' respectively
 * (and optionally of symbols '+' for the intersections).
 * <li> If a block on the scheme is intersected by
 * a (horizontal or vertical) line, then this block will
 * not be divided into a sequential group of that direction.
 * Hence, it will be divided into a parallel group.
 * <li> The lines do not influence the layout in the perpendicular direction
 * (but, certainly, this layout direction is influenced
 * by the space under the line).
 * <li> If a block is divided into a parallel group by a number of lines,
 * it is divided only by those of them which have the maximum length,
 * and the smaller lines (if they exist) are left for the subblocks.
 * <li> Gaps on the scheme affect sequential groups only.
 * <li> If two sequential subblocks are divided by a number of gaps,
 * then these gaps will be replaced by a single gap of that type.
 * <li> Gaps on the scheme may lie AT lines.
 * Such lines are considered as being continued under that gaps,
 * and the gaps affect only the direction perpendicular to the
 * corresponding line.
 * <li> A line may be intersected only by one gap.
 * <li> If a gap touches one of the sides of a line,
 * it is also assumed that they intersect.
 * </ol>
 *
 * @author Yevgen Ivakhno
 * @version 1.1, 18/05/2009
 */
public class GroupLayoutEngineer {

    private Scheme scheme;

    /**
     * The mapping of the names on the scheme to the associated components.
     */
    private NamesToComponents namesToComponents;

    private NamesToGapAgents namesToGapAgents;

    /**
     * The layout manager {@code GroupLayout} under control.
     */
    private GroupLayout gl;

    /**
     * The object which can create sequential and parallel
     * {@code GroupLayout} groups and add components to groups
     * using the components' names.
     * <p>
     * A reference to this object is given to the agents of elements.
     *
     * @see glengineer.agents
     */
    private GroupCreatorAndElementAdderClass creatorAndAdder;

    /**
     * The agent of the top level horizontal group.
     */
    private TopSequentialGroupAgent horizontalLayoutAgent;

    /**
     * The agent of the top level vertical group.
     */
    private TopSequentialGroupAgent verticalLayoutAgent;

    /**
     * Whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    private boolean autoBaselineAlignment = false;

    /**
     * @param container	the container that needs to be laid out
     * @param lines		a sequence of lines representing the scheme
     */
    public GroupLayoutEngineer(Container container, String... lines) {
        scheme = new Scheme(lines);
        namesToComponents = new NamesToComponents();
        namesToGapAgents = new NamesToGapAgents();
        horizontalLayoutAgent = compouseTopSequentialGroup(Axis.HORIZONTAL);
        verticalLayoutAgent = compouseTopSequentialGroup(Axis.VERTICAL);
        horizontalLayoutAgent.removeGapsFromParallelGroups();
        verticalLayoutAgent.removeGapsFromParallelGroups();
        gl = new GroupLayout(container);
        container.setLayout(gl);
        //		setAutoCreateGaps(true);
        //		setAutoCreateContainerGaps(true);
    }

    /**
     * Returns a top sequential group agent for the specified layout direction.
     * <p>
     * A group will be created even if it would contain a single element.
     *
     * @param axis	the layout direction
     *
     * @return		the agent of the new sequential group
     */
    protected TopSequentialGroupAgent compouseTopSequentialGroup(Axis axis) {
        Block topBlock;
        if (axis == Axis.HORIZONTAL)
            topBlock = new HorizontalBlock(scheme);
        else
            //VERTICAL
            topBlock = new VerticalBlock(scheme);
        topBlock.optimize();
        if (topBlock.isTrivial())
            throw new IllegalArgumentException(""the scheme does not possess components' names"");
        TopSequentialGroupAgent result = new TopSequentialGroupAgent();
        List<Block> blocksList = topBlock.extractSequentialSubblocks();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Returns a new sequential group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new sequential group.
     */
    protected Agent compouseSequentialGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractSequentialSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfSequentialGroup(block);
        SequentialGroupAgent result = new SequentialGroupAgent();
        for (Block subBlock : blocksList) result.addAgent(processSubblockOfSequentialGroup(subBlock));
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and either returns the agent of the corresponding element,
     * or divides the set of elements into a new parallel subgroup
     * and returns the corresponding agent.
     *
     * @param subblock	a block in a sequential group.
     *
     * @return			the agent of the specified subblock content.
     */
    private Agent processSubblockOfSequentialGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return composeParallelGroupFromBlock(subblock);
    }

    /**
     * Returns the agent of the unique element (a component or a gap)
     * in the specified block which is added into a sequential group.
     *
     * @param block	a block with an only element in a parallel group.
     *
     * @return		the agent of the unique element in the specified block.
     */
    private Agent getElementFromBlockWithOnlyWord(Block block) {
        String word = block.textAt(block.firstWord_Horizontally());
        if (word.charAt(0) == '.')
            return new TemporaryGapAgent(word);
        return new ComponentAgent(word);
    }

    /**
     * Returns a new parallel group agent filled with
     * the agents of the specified block content.
     *
     * @param block	the block which content should be placed
     * 				into a sequential group.
     *
     * @return		the agent of the new parallel group.
     */
    protected Agent composeParallelGroupFromBlock(Block block) {
        block.optimize();
        if (block.isTrivial())
            return null;
        List<Block> blocksList = block.extractParallelSubblocks();
        if (blocksList.size() == 1)
            return processSubblockOfParallelGroup(block);
        ParallelGroupAgent result = new ParallelGroupAgent();
        Agent agent;
        for (Block subBlock : blocksList) {
            agent = processSubblockOfParallelGroup(subBlock);
            if (agent != null)
                result.addAgent(agent);
        }
        return result;
    }

    /**
     * Verifies whether the specified subblock contains a single element
     * or a set of elements
     * and then either returns the agent of the corresponding element,
     * or divides the set of elements into a new sequential subgroup
     * and returns the corresponding agent.
     * <p>
     * If there is a unique element and it is a gap,
     *
     * @param subblock	a block in a parallel group.
     *
     * @return	the agent of the specified subblock content.
     */
    private Agent processSubblockOfParallelGroup(Block subblock) {
        if (subblock.containsOnlyOneWord())
            return getElementFromBlockWithOnlyWord(subblock);
        else
            return compouseSequentialGroupFromBlock(subblock);
    }

    /**
     * Associates the specified {@code name} on the scheme
     * with the specified {@code component}.
     *
     * @param name		the component name present on the scheme.
     * @param component	the component to be associated with the name.
     */
    public void associate(String name, Component component) {
        namesToComponents.put(name, component);
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with gaps of the specified {@code size}.
     */
    public void associateGap(String denotation, int size) {
        namesToGapAgents.put(denotation, new GapAgent(size));
    }

    /**
     * Associates the specified {@code denotation} on the scheme with gaps
     * of the specified {@code min}, {@code pref}, and {@code max} sizes.
     */
    public void associateGap(String denotation, int min, int pref, int max) {
        namesToGapAgents.put(denotation, new GapAgent(min, pref, max));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated).
     */
    public void associateGap(String denotation, ComponentPlacement type) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type));
    }

    /**
     * Associates the specified {@code denotation} on the scheme
     * with preferred gaps
     * of the specified component placement type (related or unrelated)
     * and of the specified preferred and maximum sizes.
     */
    public void associateGap(String denotation, ComponentPlacement type, int pref, int max) {
        namesToGapAgents.put(denotation, new PreferredGapAgent(type, pref, max));
    }

    /**
     * Sets whether a gap between components should automatically be
     * created. For example, if this is {@code true} and you add two
     * components to a {@code SequentialGroup} a gap between the
     * two components is automatically be created.
     *
     * @param autoCreatePadding	whether a gap between components is
     *        					automatically created.
     */
    public void setAutoCreateGaps(boolean autoCreatePadding) {
        gl.setAutoCreateGaps(autoCreatePadding);
    }

    /**
     * Sets whether a gap between the container and components that touch
     * the border of the container should automatically be created.
     *
     * @param autoCreateContainerGaps	whether a gap between the container
     * 									and components that touch the border
     * 									of the container should automatically
     * 									be created.
     */
    public void setAutoCreateContainerGaps(boolean autoCreateContainerGaps) {
        gl.setAutoCreateContainerGaps(autoCreateContainerGaps);
    }

    /**
     * Sets whether all vertical parallel groups
     * containing JTextFields but not containing other groups
     * should automatically have baseline alignment.
     */
    public void setAutoAlignJTextFields(boolean autoBaselineAlignment) {
        this.autoBaselineAlignment = autoBaselineAlignment;
    }

    /**
     * Forces the specified components to have the same size
     * regardless of their preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(String... names) {
        Component[] components = namesToComponents.getComponents(names);
        gl.linkSize(components);
    }

    /**
     * Forces the specified components to have the same size
     * along the specified axis regardless of their
     * preferred, minimum or maximum sizes.
     * Components that are linked are given the maximum
     * of the preferred size of each of the linked components.
     *
     * @param axis	the axis to link the size along.
     * @param names	the names of the components	that are
     * 				to have the same size.
     */
    public void linkSize(Axis axis, String... names) {
        Component[] components = namesToComponents.getComponents(names);
        if (axis == Axis.HORIZONTAL)
            gl.linkSize(SwingConstants.HORIZONTAL, components);
        else
            //axis==Axis.VERTICAL
            gl.linkSize(SwingConstants.VERTICAL, components);
    }

    /**
     * Disables the components under the specified names.
     * <p>
     * Each component must be associated with its name
     * before this method is applied.
     */
    public void disable(String... componentsNames) {
        for (Component c : namesToComponents.getComponents(componentsNames)) c.setEnabled(false);
    }

    /**
     * Finds the agent of the component with the specified name
     * and returns an interface for adjusting that component.
     *
     * @param axis			layout direction
     * @param componentName	the name of the component to be found
     * @return				an interface {@code FunctionsOnComponent}
     * 						for adjusting the component
     */
    public FunctionsOnComponent getComponent(Axis axis, String componentName) {
        Agent agent = getAgent(axis, componentName);
        if (agent == null)
            throw new IllegalArgumentException(""no such component found: "" + componentName);
        return ((ComponentAgent) agent).getFunctionsOnComponentImplementation();
    }

    /**
     * Finds the agent of the group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnGroup getGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getGroupAgent(axis, firstName, lastName);
        if (agent == null || !(agent instanceof GroupAgent))
            throw new IllegalArgumentException(""no such group found: <"" + firstName + "","" + lastName + "">"");
        return ((GroupAgent) agent).getFunctionsOnGroupImplemenation();
    }

    /**
     * Finds the agent of the parallel group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnParallelGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnParallelGroup getParallelGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getParallelGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""no such parallel group found: <"" + firstName + "","" + lastName + "">"");
        return ((ParallelGroupAgent) agent).getFunctionsOnParallelGroupImplemenation();
    }

    /**
     * Finds the agent of the sequential group which first and last components
     * have the specified names;
     * returns an interface for adjusting that group and adding gaps into it.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			an interface {@code FunctionsOnSequentialGroup}
     * 					for adjusting that group and adding gaps into it
     */
    public FunctionsOnSequentialGroup getSequentialGroup(Axis axis, String firstName, String lastName) {
        Agent agent = getSequentialGroupAgent(axis, firstName, lastName);
        if (agent == null)
            throw new IllegalArgumentException(""No such sequential group found: <"" + firstName + "","" + lastName + "">."");
        return ((SequentialGroupAgent) agent).getFunctionsOnSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the top level sequential group
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the agent of the top level sequential group
     * 				under the specified layout direction
     */
    public FunctionsOnTopSequentialGroup getTopSequentialGroup(Axis axis) {
        return getTopAgent(axis).getFunctionsOnTopSequentialGroupImplemenation();
    }

    /**
     * Returns the agent of the component with the specified name
     * under the specified layout direction.
     *
     * @param axis	layout direction
     * @param name	the name of the component to be found
     * @return		the corresponding agent
     */
    private Agent getAgent(Axis axis, String name) {
        return getTopAgent(axis).findDependingComponentByName(name);
    }

    /**
     * Returns the agent of the group with the specified first and last names
     * under the specified layout direction.
     *
     * @param axis		layout direction
     * @param firstName	the name of the first component in the group
     * @param lastName	the name of the last component in the group
     * @return			the agent of the corresponding group
     */
    private GroupAgent getGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingGroupByNames(firstName, lastName);
    }

    private SequentialGroupAgent getSequentialGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingSequentialGroupByNames(firstName, lastName);
    }

    private ParallelGroupAgent getParallelGroupAgent(Axis axis, String firstName, String lastName) {
        return getTopAgent(axis).findDependingParallelGroupByNames(firstName, lastName);
    }

    /**
     * Returns (a reference to) the top agent
     * for the specified layout direction.
     *
     * @param axis	layout direction
     * @return		the corresponding top agent
     */
    private TopSequentialGroupAgent getTopAgent(Axis axis) {
        return axis == Axis.HORIZONTAL ? horizontalLayoutAgent : verticalLayoutAgent;
    }

    /**
     * Places the components into the container
     * according to the scheme and to all additional preferences.
     */
    public void engineer() {
        horizontalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        verticalLayoutAgent.replaceTemporaryGapsByRealGaps(namesToGapAgents);
        if (autoBaselineAlignment)
            makeTextFieldsBaselineIn(verticalLayoutAgent);
        creatorAndAdder = new GroupCreatorAndElementAdderClass();
        gl.setHorizontalGroup(horizontalLayoutAgent.groupContent(creatorAndAdder));
        gl.setVerticalGroup(verticalLayoutAgent.groupContent(creatorAndAdder));
    }

    /**
     * If the specified group is parallel,
     * contains directly a component of type {@code JTextField},
     * and does not contain other groups with components,
     * then this method makes the alignment of the group {@code Baseline}.
     * <p>
     * In the case of a group having subgroups with components
     * this method passes the call to that subgroups.
     * <p>
     * As a result of applying this method,
     * all parallel groups having TextFields (but having no subgroups)
     * will be aligned along baselines.
     */
    private void makeTextFieldsBaselineIn(GroupAgent group) {
        boolean containsGroups = false;
        //the group must be baseline aligned
        boolean containsTextfields = false;
        boolean isParallel = group instanceof ParallelGroupAgent;
        for (Agent child : group.getChildren()) {
            if (child instanceof GroupAgent && ((GroupAgent) child).getFirstName() != null) {
                //child is a group with components.
                makeTextFieldsBaselineIn((GroupAgent) child);
                containsGroups = true;
            } else if (child instanceof ComponentAgent && isParallel && !containsGroups) {
                ComponentAgent agent = (ComponentAgent) child;
                Component comp = namesToComponents.compMap.get(agent.getFirstName());
                if (comp instanceof JTextField)
                    containsTextfields = true;
            }
        }
        if (containsTextfields) {
            ParallelGroupSettings settings = ((ParallelGroupAgent) group).getSettings();
            if (settings.contentAlignment == null)
                settings.contentAlignment = Alignment.BASELINE;
        }
    }

    /**
     * Outputs the groups hierarchy.
     */
    public void printGroupStructure() {
        new GroupPrinter().printTopGroupsStructure();
    }

    /**
     * Encapsulates the ""names of components - to - components"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToComponents {

        /**
         * Holds the association between the names of the components on
         * the scheme and the corresponding components.
         */
        private HashMap<String, Component> compMap = new HashMap<String, Component>();

        public NamesToComponents() {
        }

        @SuppressWarnings(""unused"")
        public boolean contains(String name) {
            return compMap.containsKey(name);
        }

        @SuppressWarnings(""unused"")
        public boolean contains(Component component) {
            return compMap.containsValue(component);
        }

        public void put(String name, Component component) {
            if (name == null || component == null || !scheme.containsComponentName(name) || compMap.put(name, component) != null)
                throw new IllegalArgumentException(""Cannot associate a component"" + "" with the name \"""" + name + ""\"""");
        }

        /**
         * Returns the component associated with the specified name.
         *
         * @param name	the name of the component to return
         *
         * @return		the component associated with the specified name
         */
        public Component getComponent(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Component result = compMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a component"" + "" with the specified name \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the components associated with the specified names.
         *
         * @param names	the names of the components to return
         *
         * @return		the components associated with the specified names
         */
        public Component[] getComponents(String... names) {
            int l = names.length;
            Component[] components = new Component[l];
            for (int i = 0; i < l; i++) components[i] = getComponent(names[i]);
            return components;
        }
    }

    /**
     * Declares the method of possessing the gap agent
     * by a temporary gap agent.
     */
    public interface TemporaryGapsToGaps {

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp);
    }

    /**
     * Encapsulates the ""names of the gaps - to - agents of these gaps"" mapping
     * and the corresponding methods of access and modification.
     */
    private class NamesToGapAgents implements TemporaryGapsToGaps {

        /**
         * Holds the association between the gaps denotations
         * on the scheme and the corresponding gap types.
         * <p>
         * The gaps (which can be preferred or simple) are represented
         * by instances of {@code Agent}, which is a superclass
         * for both {@code PreferredGapAgent} and {@code GapAgent}.
         */
        private HashMap<String, Agent> gapMap = new HashMap<String, Agent>();

        public NamesToGapAgents() {
            safePut(""."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED));
            safePut("".."", new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED));
        }

        public void put(String name, GapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, GapAgent agent) {
            gapMap.put(name, agent);
        }

        public void put(String name, PreferredGapAgent agent) {
            if (name == null)
                throw new IllegalArgumentException(""Cannot associate a gap with a null name."");
            if (agent == null)
                throw new IllegalArgumentException(""Cannot associate null agents."");
            if (!scheme.containsGapName(name))
                return;
            /*throw new IllegalArgumentException(
					""The gap name "" + name + "" not found on the scheme."");*/
            safePut(name, agent);
        }

        protected void safePut(String name, PreferredGapAgent agent) {
            gapMap.put(name, agent);
        }

        /**
         * Returns the gap agent associated with the specified name.
         */
        public Agent gap(String name) {
            if (name == null)
                throw new IllegalArgumentException(""No name specified"");
            Agent result = gapMap.get(name);
            if (result == null)
                throw new IllegalArgumentException(""cannot find a gap denoted by \"""" + name + ""\"""");
            return result;
        }

        /**
         * Returns the gap agent associated with the specified
         * temporary gap agent.
         */
        public Agent gap(TemporaryGapAgent temp) {
            return gap(temp.getDenotation());
        }
    }

    /**
     * An adapter for such functions of the {@code GroupLayout}
     * as creating new groups and adding groups and components to groups.
     */
    private class GroupCreatorAndElementAdderClass implements GroupCreatorAndElementAdder {

        /**
         * Creates and returns a new {@code SequentialGroup}.
         */
        public SequentialGroup createSequentialGroup() {
            return gl.createSequentialGroup();
        }

        /**
         * Creates and returns a new {@code ParallelGroup}
         * with the specified settings.
         */
        public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
            if (settings.contentAlignment != null)
                if (settings.resizable != null)
                    return gl.createParallelGroup(settings.contentAlignment, settings.resizable);
                else
                    //(resizable == null)
                    return gl.createParallelGroup(settings.contentAlignment);
            else //(settings.contentAlignment == null)
            if (settings.resizable != null)
                return gl.createParallelGroup(Alignment.LEADING, settings.resizable);
            else
                return gl.createParallelGroup();
        }

        /**
         * Adds the component having the specified {@code compName}
         * to the specified {@code group},
         * applies to it the specified {@code settings}.
         */
        public void addComponentToGroup(String compName, Group group, ComponentSettings settings) {
            if (settings.alignmentWithRespectToParent != null)
                //It seems that we must add to a parallel group.
                if (group instanceof ParallelGroup)
                    //Really, to a parallel.
                    if (settings.sizes != null) {
                        Sizes sizes = settings.sizes;
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent, sizes.min, sizes.pref, sizes.max);
                    } else
                        ((ParallelGroup) group).addComponent(namesToComponents.getComponent(compName), settings.alignmentWithRespectToParent);
                else
                    //Parallel group not found.
                    throw new IllegalArgumentException(""components can be aligned in parallel groups only"");
            else //Alignment not specified.
            if (settings.sizes != null) {
                Sizes sizes = settings.sizes;
                group.addComponent(namesToComponents.getComponent(compName), sizes.min, sizes.pref, sizes.max);
            } else
                //Even sizes aren't specified.
                group.addComponent(namesToComponents.getComponent(compName));
        }

        /**
         * Adds the specified {@code group} with the specified {@code settings}
         * to another group {@code parentGroup}.
         */
        public void addGroupToGroup(Group group, Settings settings, Group parentGroup) {
            if (settings.alignmentWithRespectToParent != null)
                if (parentGroup instanceof ParallelGroup)
                    ((ParallelGroup) parentGroup).addGroup(settings.alignmentWithRespectToParent, group);
                else
                    throw new IllegalArgumentException(""content can be aligned in parallel groups only"");
            parentGroup.addGroup(group);
        }
    }

    /**
     * Provides output of the created groups' structure.
     * <p>
     * Is maintained for debugging purposes.
     */
    public class GroupPrinter {

        /**
         * Outputs the both directions top groups structures.
         */
        public void printTopGroupsStructure() {
            Axis axis;
            axis = Axis.HORIZONTAL;
            System.out.println(""\nTop "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
            System.out.println(""\n-----------------------------\n"");
            axis = Axis.VERTICAL;
            System.out.println(""Top "" + axis.toString().toUpperCase() + "" group structure."");
            printTopGroupStructure(axis);
        }

        /**
         * Outputs the specified direction top group structure.
         */
        public void printTopGroupStructure(Axis axis) {
            printGroupStructure(getTopAgent(axis));
        }

        /**
         * Outputs the specified group structure.
         */
        public void printGroupStructure(GroupAgent group) {
            System.out.println();
            System.out.println(""Elements of "" + group.toString() + "":"");
            List<Agent> childrenAgents = group.getChildren();
            for (Agent child : childrenAgents) System.out.println(child.toString());
            for (Agent child : childrenAgents) if (child instanceof GroupAgent)
                printGroupStructure((GroupAgent) child);
        }
    }
}
","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {","// GroupLayoutEngineer_4Test.java
package glengineer;

import glengineer.agents.*;
import glengineer.agents.setters.*;
import glengineer.agents.settings.*;
import glengineer.blocks.*;
import java.util.*;
import java.awt.Component;
import java.awt.Container;
import javax.swing.*;
import javax.swing.GroupLayout.*;
import javax.swing.LayoutStyle.ComponentPlacement;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GroupLayoutEngineer}.
* It contains ten unit test cases for the {@link GroupLayoutEngineer#getTopSequentialGroup(Axis)} method.
*/
class GroupLayoutEngineer_4Test {
"
cmpl-6uCfnIWJXhBP6xZEHEhrFnfdvvmEG,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ComponentAgent_3Test.java,23.618295192718506,stop,"// ComponentAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnComponent;
import glengineer.agents.settings.ComponentSettings;
import glengineer.agents.settings.Sizes;
import javax.swing.GroupLayout.Group;

/**
 * The agent representing a component.
 */
public class ComponentAgent extends Agent {

    private String componentName;

    public ComponentAgent(String componentName) {
        this.componentName = componentName;
        settings = new ComponentSettings();
    }

    public String getFirstName() {
        return componentName;
    }

    public String getLastName() {
        return componentName;
    }

    public boolean isComponent(String componentName) {
        return this.componentName.equals(componentName);
    }

    public boolean isGroup(String firstName, String lastName) {
        return false;
    }

    public boolean isGap() {
        return false;
    }

    public boolean equals(Agent agent) {
        return agent.isComponent(componentName);
    }

    private ComponentSettings getSettings() {
        return (ComponentSettings) settings;
    }

    /**
     * Returns this component agent if its name equals the specified one
     * or null if it is not the case.
     */
    public ComponentAgent findDependingComponentByName(String componentName) {
        if (isComponent(componentName))
            return this;
        else
            return null;
    }

    public GroupAgent findDependingGroupByNames(String firstName, String lastName) {
        return null;
    }

    public ParallelGroupAgent findDependingParallelGroupByNames(String firstName, String lastName) {
        return null;
    }

    public SequentialGroupAgent findDependingSequentialGroupByNames(String firstName, String lastName) {
        return null;
    }

    /**
     * ��������� �������������� ��������� � ������, ��������
     * ��������� ��� ���� ������������ ���������.
     * ��� ��������� ���������� �� ��� ���������� �������� �����������
     * ��������������� ����� ���������� {@code ComponentAdder}.
     * <p>
     * ���������� �������-���������.
     *
     * @param targetGroup		������, ���� ����������� ��������������
     * 							���������
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     */
    public void addContentToGroup(Group targetGroup, GroupCreatorAndElementAdder creatorAndAdder) {
        creatorAndAdder.addComponentToGroup(componentName, targetGroup, getSettings());
    }

    /**
     * Returns a class implementing the interface {@code FunctionsOnComponent}
     * which allows the user to control the sizes of this component.
     */
    public FunctionsOnComponent getFunctionsOnComponentImplementation() {
        return new FunctionsOnComponent() {

            public void setSize(int size) {
                ComponentAgent.this.getSettings().sizes = new Sizes(size);
            }

            public void setSize(int min, int pref, int max) {
                ComponentAgent.this.getSettings().sizes = new Sizes(min, pref, max);
            }
        };
    }

    public String toString() {
        return ""component "" + componentName;
    }
}
","// ComponentAgent_3Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnComponent;
import glengineer.agents.settings.ComponentSettings;
import glengineer.agents.settings.Sizes;
import javax.swing.GroupLayout.Group;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentAgent}.
* It contains ten unit test cases for the {@link ComponentAgent#findDependingComponentByName(String)} method.
*/
class ComponentAgent_3Test {","// ComponentAgent_3Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnComponent;
import glengineer.agents.settings.ComponentSettings;
import glengineer.agents.settings.Sizes;
import javax.swing.GroupLayout.Group;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ComponentAgent}.
* It contains ten unit test cases for the {@link ComponentAgent#findDependingComponentByName(String)} method.
*/
class ComponentAgent_3Test {

	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns the component agent itself
	 * if its name equals the specified one.
	 */
	@Test
	void testFindDependingComponentByName_1() {
		ComponentAgent componentAgent = new ComponentAgent(""component"");
		assertEquals(componentAgent, componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent does not equal the specified one.
	 */
	@Test
	void testFindDependingComponentByName_2() {
		ComponentAgent componentAgent = new ComponentAgent(""component"");
		assertNull(componentAgent.findDependingComponentByName(""another component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is null.
	 */
	@Test
	void testFindDependingComponentByName_3() {
		ComponentAgent componentAgent = new ComponentAgent(null);
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is empty.
	 */
	@Test
	void testFindDependingComponentByName_4() {
		ComponentAgent componentAgent = new ComponentAgent("""");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_5() {
		ComponentAgent componentAgent = new ComponentAgent("" "");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_6() {
		ComponentAgent componentAgent = new ComponentAgent(""\t"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_7() {
		ComponentAgent componentAgent = new ComponentAgent(""\n"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_8() {
		ComponentAgent componentAgent = new ComponentAgent(""\r"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_9() {
		ComponentAgent componentAgent = new ComponentAgent(""\f"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
	/**
	 * Test case for the {@link ComponentAgent#findDependingComponentByName(String)} method.
	 * <p>
	 * The test case checks that the method returns null
	 * if the name of the component agent is blank.
	 */
	@Test
	void testFindDependingComponentByName_10() {
		ComponentAgent componentAgent = new ComponentAgent(""\b"");
		assertNull(componentAgent.findDependingComponentByName(""component""));
	}
	
}</code>





A:

В общем, проблема была в том, что в классе <code>ComponentAgent</code> не было переопределено метода <code>equals</code>. После его переопределения все заработало.
"
cmpl-6uCgq1W8yST0aecLXg7etR27UyHKn,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_0Test.java,90.82537794113159,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
        settings = new ParallelGroupSettings();
    }

    public ParallelGroupSettings getSettings() {
        return (ParallelGroupSettings) settings;
    }

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps() {
        Iterator<Agent> i = childrenAgents.iterator();
        while (i.hasNext()) if (i.next().isGap())
            i.remove();
    }

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType() {
        Iterator<Agent> i = childrenAgents.iterator();
        Agent firstGapFound = null;
        Agent next;
        while (i.hasNext()) {
            next = i.next();
            if (!next.isGap())
                continue;
            if (firstGapFound == null)
                firstGapFound = next;
            else //the first gap has been already found.
            if (next != firstGapFound)
                throw new IllegalArgumentException(""A parallel group consists of gaps only "" + ""but the gaps have different types."");
        }
        return firstGapFound;
    }

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnParallelGroupImplemenation();
    }

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {
        return new FunctionsOnParallelGroupImplemenation();
    }

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         * ������������� ������ ������������ ����������� ������������ ������.
         *
         * @param alignment	������ ������������
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ��������� ���������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param componentName	�������� �������� ����������
         * @return				���������
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ���������� ���������� ������� � ���������� �����������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param firstName	�������� ������� ���������� ������� ������
         * @param lastName	�������� ���������� ���������� ������� ������
         * @return			���������
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString() {
        return ""parallel group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {","// ParallelGroupAgent_0Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#containsGapsOnly()} method.
*/
class ParallelGroupAgent_0Test {

	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		assertTrue(parallelGroupAgent.containsGapsOnly());
	}
	
	/**
	 * Test case #4.
	 * <p>
	 * The parallel group contains gaps only.
	 * <p>
	 * Expected result: {@code true}.
	 */
	@Test
	void testContainsGapsOnly_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addGap(new GapAgent());
		parallelGroupAgent.addG"
cmpl-6uCiJUonq5EE7Mx7bmkGrGIc65cdK,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/ParallelGroupAgent_1Test.java,93.13567280769348,length,"// ParallelGroupAgent.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;

/**
 * �����, �������������� ������������ ������.
 */
public class ParallelGroupAgent extends GroupAgent {

    public ParallelGroupAgent() {
        settings = new ParallelGroupSettings();
    }

    public ParallelGroupSettings getSettings() {
        return (ParallelGroupSettings) settings;
    }

    /**
     * Verifies whether all of the elements of this parallel group agent
     * are gaps.
     */
    public boolean containsGapsOnly() {
        for (Agent child : childrenAgents) if (!child.isGap())
            return false;
        return true;
    }

    /**
     * Removes all gaps from this parallel group.
     */
    public void removeAllGaps() {
        Iterator<Agent> i = childrenAgents.iterator();
        while (i.hasNext()) if (i.next().isGap())
            i.remove();
    }

    /**
     * Returns the gap of the type contained in this parallel group
     * or null if this group has no gaps.
     * If the gaps possess different types, throws a runtime exception.
     * <p>
     * After calling this method this parallel group,
     * which typically consists of gaps only,
     * can be replaced by the gap returned by this method.
     */
    public Agent getGapsType() {
        Iterator<Agent> i = childrenAgents.iterator();
        Agent firstGapFound = null;
        Agent next;
        while (i.hasNext()) {
            next = i.next();
            if (!next.isGap())
                continue;
            if (firstGapFound == null)
                firstGapFound = next;
            else //the first gap has been already found.
            if (next != firstGapFound)
                throw new IllegalArgumentException(""A parallel group consists of gaps only "" + ""but the gaps have different types."");
        }
        return firstGapFound;
    }

    /**
     * ���������� �������������� ���������� � ����� ������������ ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public ParallelGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        ParallelGroup result = creatorAndAdder.createParallelGroup(getSettings());
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnParallelGroupImplemenation();
    }

    public FunctionsOnParallelGroup getFunctionsOnParallelGroupImplemenation() {
        return new FunctionsOnParallelGroupImplemenation();
    }

    private class FunctionsOnParallelGroupImplemenation implements FunctionsOnParallelGroup {

        /**
         * ������������� ������ ������������ ����������� ������������ ������.
         *
         * @param alignment	������ ������������
         */
        public void setContentAlignment(Alignment alignment) {
            ParallelGroupAgent.this.getSettings().contentAlignment = alignment;
        }

        /**
         * Determines the {@code resize} behavior of the {@code ParallelGroup}.
         *
         * @param resizable	{@code true} if the group is resizable;
         * 					if the group is not resizable
         * 					the preferred size is used for
         * 					the minimum and maximum size of the group.
         */
        public void setResizable(boolean resizable) {
            ParallelGroupAgent.this.getSettings().resizable = resizable;
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ��������� ���������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param componentName	�������� �������� ����������
         * @return				���������
         * 						{@code FunctionsOnParallelGroupAndElement}
         * 						��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getComponent(String componentName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getComponent(componentName));
        }

        /**
         * ������� ����� ""���������������� �����"" ������������ ������
         * ��������� � ���������� ���������� ������� � ���������� �����������.
         * <p>
         * ���������� ��������� {@code FunctionsOnParallelGroupAndElement}
         * ��������� ������������ �������� � ������������ ������.
         *
         * @param firstName	�������� ������� ���������� ������� ������
         * @param lastName	�������� ���������� ���������� ������� ������
         * @return			���������
         * 					{@code FunctionsOnParallelGroupAndElement}
         * 					��������� ������������ ��������
         */
        public FunctionsOnParallelGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnParallelGroupAndElementImplementation(ParallelGroupAgent.this, ParallelGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnParallelGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnParallelGroupAndElement {

        public FunctionsOnParallelGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        /**
         * Assigns the specified alignment of the element {@code elementAgent}
         * in the parallel group {@code parentAgent}.
         */
        public void setAlignmentWithinParent(Alignment alignment) {
            elementAgent.settings.alignmentWithRespectToParent = alignment;
        }
    }

    public String toString() {
        return ""parallel group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {","// ParallelGroupAgent_1Test.java
package glengineer.agents;

import glengineer.agents.setters.FunctionsOnGroup;
import glengineer.agents.setters.FunctionsOnParallelGroup;
import glengineer.agents.setters.FunctionsOnParallelGroupAndElement;
import glengineer.agents.settings.ParallelGroupSettings;
import java.util.Iterator;
import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParallelGroupAgent}.
* It contains ten unit test cases for the {@link ParallelGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class ParallelGroupAgent_1Test {

	/**
	 * Test case #1.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 */
	@Test
	void testGroupContent_1() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(10, parallelGroup.getChild(0).getPreferredSize());
	}
	
	/**
	 * Test case #2.
	 * <p>
	 * The parallel group contains a single component.
	 * <p>
	 * The component is added to the parallel group.
	 */
	@Test
	void testGroupContent_2() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addComponent(""component"");
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""component"", parallelGroup.getChild(0).getComponent().getName());
	}
	
	/**
	 * Test case #3.
	 * <p>
	 * The parallel group contains a single group.
	 * <p>
	 * The group is added to the parallel group.
	 */
	@Test
	void testGroupContent_3() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGroup(""group"");
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				group.addGroup(groupAgent.groupContent(this));
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""group"", parallelGroup.getChild(0).getName());
	}
	
	/**
	 * Test case #4.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 * <p>
	 * The gap is resizable.
	 */
	@Test
	void testGroupContent_4() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.getGapsType().setResizable(true);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(10, parallelGroup.getChild(0).getPreferredSize());
		assertEquals(10, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(10, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #5.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 * <p>
	 * The gap is not resizable.
	 */
	@Test
	void testGroupContent_5() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.getGapsType().setResizable(false);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(10, parallelGroup.getChild(0).getPreferredSize());
		assertEquals(10, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(10, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #6.
	 * <p>
	 * The parallel group contains a single component.
	 * <p>
	 * The component is added to the parallel group.
	 * <p>
	 * The component is resizable.
	 */
	@Test
	void testGroupContent_6() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addComponent(""component"");
		parallelGroupAgent.getComponent(""component"").setResizable(true);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""component"", parallelGroup.getChild(0).getComponent().getName());
		assertEquals(0, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(0, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #7.
	 * <p>
	 * The parallel group contains a single component.
	 * <p>
	 * The component is added to the parallel group.
	 * <p>
	 * The component is not resizable.
	 */
	@Test
	void testGroupContent_7() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addComponent(""component"");
		parallelGroupAgent.getComponent(""component"").setResizable(false);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""component"", parallelGroup.getChild(0).getComponent().getName());
		assertEquals(0, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(0, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #8.
	 * <p>
	 * The parallel group contains a single group.
	 * <p>
	 * The group is added to the parallel group.
	 * <p>
	 * The group is resizable.
	 */
	@Test
	void testGroupContent_8() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGroup(""group"");
		parallelGroupAgent.getGroup(""group"").setResizable(true);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				group.addGroup(groupAgent.groupContent(this));
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""group"", parallelGroup.getChild(0).getName());
		assertEquals(0, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(0, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #9.
	 * <p>
	 * The parallel group contains a single group.
	 * <p>
	 * The group is added to the parallel group.
	 * <p>
	 * The group is not resizable.
	 */
	@Test
	void testGroupContent_9() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGroup(""group"");
		parallelGroupAgent.getGroup(""group"").setResizable(false);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				group.addGroup(groupAgent.groupContent(this));
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""group"", parallelGroup.getChild(0).getName());
		assertEquals(0, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(0, parallelGroup.getChild(0).getMaximumSize());
	}
	
	/**
	 * Test case #10.
	 * <p>
	 * The parallel group contains a single gap.
	 * <p>
	 * The gap is added to the parallel group.
	 * <p>
	 * The gap is resizable.
	 * <p>
	 * The gap is aligned with respect to the parallel group.
	 */
	@Test
	void testGroupContent_10() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addGap(10);
		parallelGroupAgent.getGapsType().setResizable(true);
		parallelGroupAgent.getGapsType().setAlignmentWithinParent(Alignment.TRAILING);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(10, parallelGroup.getChild(0).getPreferredSize());
		assertEquals(10, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(10, parallelGroup.getChild(0).getMaximumSize());
		assertEquals(Alignment.TRAILING, parallelGroup.getChild(0).getAlignment());
	}
	
	/**
	 * Test case #11.
	 * <p>
	 * The parallel group contains a single component.
	 * <p>
	 * The component is added to the parallel group.
	 * <p>
	 * The component is resizable.
	 * <p>
	 * The component is aligned with respect to the parallel group.
	 */
	@Test
	void testGroupContent_11() {
		ParallelGroupAgent parallelGroupAgent = new ParallelGroupAgent();
		parallelGroupAgent.addComponent(""component"");
		parallelGroupAgent.getComponent(""component"").setResizable(true);
		parallelGroupAgent.getComponent(""component"").setAlignmentWithinParent(Alignment.TRAILING);
		
		ParallelGroup parallelGroup = parallelGroupAgent.groupContent(new GroupCreatorAndElementAdder() {
			public ParallelGroup createParallelGroup(ParallelGroupSettings settings) {
				return new ParallelGroup(Alignment.LEADING);
			}
			public void addComponentToGroup(ParallelGroup group, Agent componentAgent) {
				group.addComponent(componentAgent.getComponent());
			}
			public void addGroupToGroup(ParallelGroup group, GroupAgent groupAgent) {
				throw new UnsupportedOperationException(""Not supported yet."");
			}
		});
		
		assertEquals(1, parallelGroup.getSize());
		assertEquals(""component"", parallelGroup.getChild(0).getComponent().getName());
		assertEquals(0, parallelGroup.getChild(0).getMinimumSize());
		assertEquals(0, parallelGroup.getChild("
cmpl-6uCjoYxEqtGiNmJN3Inexsbd7cgki,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/SequentialGroupAgent.java,91.57452154159546,length,"// SequentialGroupAgent.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;

/**
 * �����, �������������� ���������������� ������.
 */
public class SequentialGroupAgent extends GroupAgent {

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������
     * � ���������� �.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnSequentialGroupImplemenation();
    }

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {
        return new FunctionsOnSequentialGroupImplemenation();
    }

    protected class FunctionsOnSequentialGroupImplemenation implements FunctionsOnSequentialGroup {

        public FunctionsOnSequentialGroupAndElement getComponent(String name) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getComponent(name));
        }

        public FunctionsOnSequentialGroupAndElement getGroup(String firstName, String lastName) {
            return new FunctionsOnSequentialGroupAndElementImplementation(SequentialGroupAgent.this, SequentialGroupAgent.this.getGroup(firstName, lastName));
        }
    }

    private static class FunctionsOnSequentialGroupAndElementImplementation extends GroupAgent.FunctionsOnGroupAndElementImplementation implements FunctionsOnSequentialGroupAndElement {

        public FunctionsOnSequentialGroupAndElementImplementation(GroupAgent parent, Agent element) {
            super(parent, element);
        }

        private SequentialGroupAgent getParentGroupAgent() {
            return (SequentialGroupAgent) parentGroupAgent;
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addPrecedingRelatedGap() {
            addPrecedingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� ��������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addPrecedingUnrelatedGap() {
            addPrecedingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""���������"" ����������.
         */
        public void addFollowingRelatedGap() {
            addFollowingRelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� ����� �������� ������������ ������
         *  ""�����������"" ����������.
         */
        public void addFollowingUnrelatedGap() {
            addFollowingUnrelatedGap(GroupLayout.DEFAULT_SIZE, GroupLayout.DEFAULT_SIZE);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ���������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addPrecedingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapBefore(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""���������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingRelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.RELATED, pref, max), elementAgent);
        }

        /**
         * ��������� � ������������ ������ ����� � ��������
         *  ""�����������"" ���������� � ������������� ���������� ��� ����
         *  �������������� � ������������ �������.
         */
        public void addFollowingUnrelatedGap(int pref, int max) {
            getParentGroupAgent().addPreferredGapAfter(new PreferredGapAgent(LayoutStyle.ComponentPlacement.UNRELATED, pref, max), elementAgent);
        }
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list before that element.
     */
    public void addPreferredGapBefore(PreferredGapAgent gap, Agent element) {
        if (childrenAgents.isEmpty()) {
            childrenAgents.add(gap);
            return;
        }
        ListIterator<Agent> iter = childrenAgents.listIterator();
        while (iter.hasNext()) if (iter.next().equals(element)) {
            iter.previous();
            iter.add(gap);
            return;
        }
        throw new IllegalArgumentException(""the "" + element.toString() + "" in the "" + toString() + "" not found"");
    }

    /**
     * Finds the specified element in the list of
     * this sequential group's children and inserts
     * the specified preferred gap into that list after that element.
     */
    public void addPreferredGapAfter(PreferredGapAgent gap, Agent element) {
        if (childrenAgents.isEmpty()) {
            childrenAgents.add(gap);
            return;
        }
        ListIterator<Agent> iter = childrenAgents.listIterator();
        while (iter.hasNext()) if (iter.next().equals(element)) {
            iter.add(gap);
            return;
        }
        throw new IllegalArgumentException(""the "" + element.toString() + "" in the "" + toString() + "" not found"");
    }

    public String toString() {
        return ""sequential group <"" + getFirstName() + "","" + getLastName() + "">"";
    }
}
","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {","// SequentialGroupAgentTest.java
package glengineer.agents;

import java.util.ListIterator;
import glengineer.agents.setters.*;
import javax.swing.GroupLayout;
import javax.swing.LayoutStyle;
import javax.swing.GroupLayout.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialGroupAgent}.
* It contains ten unit test cases for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class SequentialGroupAgentTest {

	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has no children.
	 */
	@Test
	void testGroupContent_NoChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(0, result.getComponents().length);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one child.
	 */
	@Test
	void testGroupContent_OneChild() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child = new ComponentAgent(""child"");
		group.add(child);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(1, result.getComponents().length);
		assertEquals(child.getComponent(), result.getComponents()[0]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has two children.
	 */
	@Test
	void testGroupContent_TwoChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		group.add(child1);
		group.add(child2);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(2, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has three children.
	 */
	@Test
	void testGroupContent_ThreeChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(3, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has four children.
	 */
	@Test
	void testGroupContent_FourChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		ComponentAgent child4 = new ComponentAgent(""child4"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		group.add(child4);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(4, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
		assertEquals(child4.getComponent(), result.getComponents()[3]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has five children.
	 */
	@Test
	void testGroupContent_FiveChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		ComponentAgent child4 = new ComponentAgent(""child4"");
		ComponentAgent child5 = new ComponentAgent(""child5"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		group.add(child4);
		group.add(child5);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(5, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
		assertEquals(child4.getComponent(), result.getComponents()[3]);
		assertEquals(child5.getComponent(), result.getComponents()[4]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has six children.
	 */
	@Test
	void testGroupContent_SixChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		ComponentAgent child4 = new ComponentAgent(""child4"");
		ComponentAgent child5 = new ComponentAgent(""child5"");
		ComponentAgent child6 = new ComponentAgent(""child6"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		group.add(child4);
		group.add(child5);
		group.add(child6);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(6, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
		assertEquals(child4.getComponent(), result.getComponents()[3]);
		assertEquals(child5.getComponent(), result.getComponents()[4]);
		assertEquals(child6.getComponent(), result.getComponents()[5]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has seven children.
	 */
	@Test
	void testGroupContent_SevenChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		ComponentAgent child4 = new ComponentAgent(""child4"");
		ComponentAgent child5 = new ComponentAgent(""child5"");
		ComponentAgent child6 = new ComponentAgent(""child6"");
		ComponentAgent child7 = new ComponentAgent(""child7"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		group.add(child4);
		group.add(child5);
		group.add(child6);
		group.add(child7);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(7, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
		assertEquals(child4.getComponent(), result.getComponents()[3]);
		assertEquals(child5.getComponent(), result.getComponents()[4]);
		assertEquals(child6.getComponent(), result.getComponents()[5]);
		assertEquals(child7.getComponent(), result.getComponents()[6]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has eight children.
	 */
	@Test
	void testGroupContent_EightChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		ComponentAgent child4 = new ComponentAgent(""child4"");
		ComponentAgent child5 = new ComponentAgent(""child5"");
		ComponentAgent child6 = new ComponentAgent(""child6"");
		ComponentAgent child7 = new ComponentAgent(""child7"");
		ComponentAgent child8 = new ComponentAgent(""child8"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		group.add(child4);
		group.add(child5);
		group.add(child6);
		group.add(child7);
		group.add(child8);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(8, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
		assertEquals(child4.getComponent(), result.getComponents()[3]);
		assertEquals(child5.getComponent(), result.getComponents()[4]);
		assertEquals(child6.getComponent(), result.getComponents()[5]);
		assertEquals(child7.getComponent(), result.getComponents()[6]);
		assertEquals(child8.getComponent(), result.getComponents()[7]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has nine children.
	 */
	@Test
	void testGroupContent_NineChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		ComponentAgent child4 = new ComponentAgent(""child4"");
		ComponentAgent child5 = new ComponentAgent(""child5"");
		ComponentAgent child6 = new ComponentAgent(""child6"");
		ComponentAgent child7 = new ComponentAgent(""child7"");
		ComponentAgent child8 = new ComponentAgent(""child8"");
		ComponentAgent child9 = new ComponentAgent(""child9"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		group.add(child4);
		group.add(child5);
		group.add(child6);
		group.add(child7);
		group.add(child8);
		group.add(child9);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(9, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
		assertEquals(child4.getComponent(), result.getComponents()[3]);
		assertEquals(child5.getComponent(), result.getComponents()[4]);
		assertEquals(child6.getComponent(), result.getComponents()[5]);
		assertEquals(child7.getComponent(), result.getComponents()[6]);
		assertEquals(child8.getComponent(), result.getComponents()[7]);
		assertEquals(child9.getComponent(), result.getComponents()[8]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has ten children.
	 */
	@Test
	void testGroupContent_TenChildren() {
		SequentialGroupAgent group = new SequentialGroupAgent();
		ComponentAgent child1 = new ComponentAgent(""child1"");
		ComponentAgent child2 = new ComponentAgent(""child2"");
		ComponentAgent child3 = new ComponentAgent(""child3"");
		ComponentAgent child4 = new ComponentAgent(""child4"");
		ComponentAgent child5 = new ComponentAgent(""child5"");
		ComponentAgent child6 = new ComponentAgent(""child6"");
		ComponentAgent child7 = new ComponentAgent(""child7"");
		ComponentAgent child8 = new ComponentAgent(""child8"");
		ComponentAgent child9 = new ComponentAgent(""child9"");
		ComponentAgent child10 = new ComponentAgent(""child10"");
		group.add(child1);
		group.add(child2);
		group.add(child3);
		group.add(child4);
		group.add(child5);
		group.add(child6);
		group.add(child7);
		group.add(child8);
		group.add(child9);
		group.add(child10);
		SequentialGroup result = group.groupContent(new GroupCreatorAndElementAdderImplementation());
		assertEquals(10, result.getComponents().length);
		assertEquals(child1.getComponent(), result.getComponents()[0]);
		assertEquals(child2.getComponent(), result.getComponents()[1]);
		assertEquals(child3.getComponent(), result.getComponents()[2]);
		assertEquals(child4.getComponent(), result.getComponents()[3]);
		assertEquals(child5.getComponent(), result.getComponents()[4]);
		assertEquals(child6.getComponent(), result.getComponents()[5]);
		assertEquals(child7.getComponent(), result.getComponents()[6]);
		assertEquals(child8.getComponent(), result.getComponents()[7]);
		assertEquals(child9.getComponent(), result.getComponents()[8]);
		assertEquals(child10.getComponent(), result.getComponents()[9]);
	}
	
	/**
	 * Test case for the {@link SequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * It tests the case when the sequential group has one"
cmpl-6uClI1g6ahzBDWkkoRDAn1dFIG1eN,/EvoSuiteBenchmark/40_glengineer/src/main/java/glengineer/agents/TopSequentialGroupAgent.java,91.05809044837952,length,"// TopSequentialGroupAgent.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * �����, �������������� ���������������� ������ �������� ������.
 * <p>
 * ��������� ��������� {@code FunctionsOnTopSequentialGroup}
 * ���������� �������������� ������������ �����������
 * � ������ � � ����� ���������������� ������ �������� ������.
 */
public class TopSequentialGroupAgent extends SequentialGroupAgent {

    /**
     * �����, �������������� ������������ ���������� � ������ ������.
     */
    private ContainerGapAgent precedingContainerGap;

    /**
     * �����, �������������� ������������ ���������� � ����� ������.
     */
    private ContainerGapAgent followingContainerGap;

    /**
     * ���������� �������������� ���������� � ����� ���������������� ������,
     * ��������, ���� ����, ������������ ���������� � ������ � � �����,
     * � ���������� ���������� ������.
     * <p>
     * ����������� ����� {@code TopSequentialGroupAgent.groupContent()},
     * �������� ������ � ������������� ������������.
     *
     * @param creatorAndAdder	��������� ��� �������� �����
     * 							� ���������� � ��� �����������
     * @return					������, ������������ �� ���������������
     * 							�����������.
     */
    public SequentialGroup groupContent(GroupCreatorAndElementAdder creatorAndAdder) {
        SequentialGroup result = creatorAndAdder.createSequentialGroup();
        if (precedingContainerGap != null)
            precedingContainerGap.addOneselfToGroup(result);
        for (Agent child : childrenAgents) child.addContentToGroup(result, creatorAndAdder);
        if (followingContainerGap != null)
            followingContainerGap.addOneselfToGroup(result);
        return result;
    }

    public FunctionsOnGroup getFunctionsOnGroupImplemenation() {
        return getFunctionsOnTopSequentialGroupImplemenation();
    }

    public FunctionsOnSequentialGroup getFunctionsOnSequentialGroupImplemenation() {
        return getFunctionsOnTopSequentialGroupImplemenation();
    }

    public FunctionsOnTopSequentialGroup getFunctionsOnTopSequentialGroupImplemenation() {
        return new FunctionsOnTopSequentialGroupImplemenation();
    }

    private class FunctionsOnTopSequentialGroupImplemenation extends SequentialGroupAgent.FunctionsOnSequentialGroupImplemenation implements FunctionsOnTopSequentialGroup {

        /**
         * ��������� ������������ ����������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap() {
            precedingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ������ ���������������� ������ �������� ������.
         */
        public void addPrecedingContainerGap(int pref, int max) {
            precedingContainerGap = new ContainerGapAgent(pref, max);
        }

        /**
         * ��������� ������������ ����������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap() {
            followingContainerGap = new ContainerGapAgent();
        }

        /**
         * ��������� ������������ ���������� � ���������� ����������� �������
         * � ����� ���������������� ������ �������� ������.
         */
        public void addFollowingContainerGap(int pref, int max) {
            followingContainerGap = new ContainerGapAgent(pref, max);
        }

        public void addBothContainerGaps() {
            addPrecedingContainerGap();
            addFollowingContainerGap();
        }

        public void addBothContainerGaps(int pref, int max) {
            addPrecedingContainerGap(pref, max);
            addFollowingContainerGap(pref, max);
        }
    }
}
","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {","// TopSequentialGroupAgentTest.java
package glengineer.agents;

import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TopSequentialGroupAgent}.
* It contains ten unit test cases for the {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
*/
class TopSequentialGroupAgentTest {

	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object does not contain any gaps.
	 */
	@Test
	void testGroupContent_TwoComponents_NoGaps() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		ComponentAgent componentAgent1 = new ComponentAgent();
		ComponentAgent componentAgent2 = new ComponentAgent();
		topSequentialGroupAgent.addChildAgent(componentAgent1);
		topSequentialGroupAgent.addChildAgent(componentAgent2);
		
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(new GroupCreatorAndElementAdderImplemenation());
		
		assertEquals(2, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a preceding gap.
	 */
	@Test
	void testGroupContent_TwoComponents_PrecedingGap() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		ComponentAgent componentAgent1 = new ComponentAgent();
		ComponentAgent componentAgent2 = new ComponentAgent();
		topSequentialGroupAgent.addChildAgent(componentAgent1);
		topSequentialGroupAgent.addChildAgent(componentAgent2);
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addPrecedingContainerGap();
		
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(new GroupCreatorAndElementAdderImplemenation());
		
		assertEquals(3, sequentialGroup.getComponents().length);
	}
	
	/**
	 * Test case for {@link TopSequentialGroupAgent#groupContent(GroupCreatorAndElementAdder)} method.
	 * <p>
	 * The test case checks that the method returns a {@link SequentialGroup} object,
	 * which contains the same elements as the {@link TopSequentialGroupAgent} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains two {@link ComponentAgent} objects,
	 * which are added to the {@link SequentialGroup} object.
	 * <p>
	 * The {@link TopSequentialGroupAgent} object contains a following gap.
	 */
	@Test
	void testGroupContent_TwoComponents_FollowingGap() {
		TopSequentialGroupAgent topSequentialGroupAgent = new TopSequentialGroupAgent();
		ComponentAgent componentAgent1 = new ComponentAgent();
		ComponentAgent componentAgent2 = new ComponentAgent();
		topSequentialGroupAgent.addChildAgent(componentAgent1);
		topSequentialGroupAgent.addChildAgent(componentAgent2);
		topSequentialGroupAgent.getFunctionsOnTopSequentialGroupImplemenation().addFollowingContainerGap();
		
		SequentialGroup sequentialGroup = topSequentialGroupAgent.groupContent(new GroupCreatorAndElementAdderImplemenation());
		
		assertEquals(3, sequentialGroup.getComponents().length);
}

// GroupCreatorAndElementAdderImplemenation.java
package glengineer.agents;

import javax.swing.GroupLayout.Alignment;
import javax.swing.GroupLayout.ParallelGroup;
import javax.swing.GroupLayout.SequentialGroup;
import glengineer.agents.setters.*;

/**
 * �������������� �������������� �������������� ���������� � ���������� ����������� �������.
 * <p>
 * ��������� ��������� {@code GroupCreatorAndElementAdder}.
 * ���������� �������������� ������������ �����������
 * � ���������� � ���������� ����������� �������.
 */
public class GroupCreatorAndElementAdderImplemenation implements GroupCreatorAndElementAdder {

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment) {
        return new ParallelGroup(alignment);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup() {
        return new SequentialGroup();
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable) {
        return new ParallelGroup(alignment, resizable);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup(boolean resizable) {
        return new SequentialGroup(resizable);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable, boolean resizableOnBasisOfContent) {
        return new ParallelGroup(alignment, resizable, resizableOnBasisOfContent);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup(boolean resizable, boolean resizableOnBasisOfContent) {
        return new SequentialGroup(resizable, resizableOnBasisOfContent);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable, boolean resizableOnBasisOfContent, int preferredSize) {
        return new ParallelGroup(alignment, resizable, resizableOnBasisOfContent, preferredSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup(boolean resizable, boolean resizableOnBasisOfContent, int preferredSize) {
        return new SequentialGroup(resizable, resizableOnBasisOfContent, preferredSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize) {
        return new ParallelGroup(alignment, resizable, resizableOnBasisOfContent, preferredSize, maximumSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup(boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize) {
        return new SequentialGroup(resizable, resizableOnBasisOfContent, preferredSize, maximumSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize, int minimumSize) {
        return new ParallelGroup(alignment, resizable, resizableOnBasisOfContent, preferredSize, maximumSize, minimumSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup(boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize, int minimumSize) {
        return new SequentialGroup(resizable, resizableOnBasisOfContent, preferredSize, maximumSize, minimumSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize, int minimumSize, int alignmentSize) {
        return new ParallelGroup(alignment, resizable, resizableOnBasisOfContent, preferredSize, maximumSize, minimumSize, alignmentSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup(boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize, int minimumSize, int alignmentSize) {
        return new SequentialGroup(resizable, resizableOnBasisOfContent, preferredSize, maximumSize, minimumSize, alignmentSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize, int minimumSize, int alignmentSize, int alignmentBasisSize) {
        return new ParallelGroup(alignment, resizable, resizableOnBasisOfContent, preferredSize, maximumSize, minimumSize, alignmentSize, alignmentBasisSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ���������� � ���������� ����������� �������
     */
    public SequentialGroup createSequentialGroup(boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize, int minimumSize, int alignmentSize, int alignmentBasisSize) {
        return new SequentialGroup(resizable, resizableOnBasisOfContent, preferredSize, maximumSize, minimumSize, alignmentSize, alignmentBasisSize);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createParallelGroup()}.
     *
     * @param alignment	�������������� ����������
     * @return			���������� ���������� � ���������� ����������� �������
     */
    public ParallelGroup createParallelGroup(Alignment alignment, boolean resizable, boolean resizableOnBasisOfContent, int preferredSize, int maximumSize, int minimumSize, int alignmentSize, int alignmentBasisSize, int alignmentBasisSize2) {
        return new ParallelGroup(alignment, resizable, resizableOnBasisOfContent, preferredSize, maximumSize, minimumSize, alignmentSize, alignmentBasisSize, alignmentBasisSize2);
    }

    /**
     * ���������� �������������� ���������� � ���������� ����������� �������.
     * <p>
     * ����������� ����� {@code GroupCreatorAndElementAdderImplemenation.createSequentialGroup()}.
     *
     * @return	���������� ����������"
