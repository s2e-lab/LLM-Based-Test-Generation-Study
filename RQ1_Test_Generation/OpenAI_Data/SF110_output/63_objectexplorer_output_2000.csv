ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6u9Ra4GgVVSR2e7SdhpeIeFzvkgtg,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/ExplorerFigure_0Test.java,49.40917634963989,length,"// ExplorerFigure.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.figure;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import org.apache.log4j.Logger;
import de.paragon.explorer.Explorer;
import de.paragon.explorer.event.DrawEvent;
import de.paragon.explorer.event.DrawListener;
import de.paragon.explorer.event.FocusManager;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.gui.ExplorerFrame;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.ExplorerModel;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;

/**
 * Klassenbeschreibung
 *
 * Instanzvariablen: frame: Beziehung zum Frame, auf dem die Figur dargestellt
 * wird. model: Verknuepfung mit dem ExplorerModel, das fuer den Inhalt der
 * ExplorerFigure zustaendig ist.
 */
public class ExplorerFigure extends StandardCompositeFigure implements DrawListener {

    private static final int NUMBER_15 = 15;

    private static final String EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE = ""explorerfigure.error_finding_hit_figure "";

    private static final String EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE = ""explorerfigure.error_drawing_explorer_figure"";

    private static final String EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE = ""explorerfigure.error_calculating_graphic_size"";

    private static final Logger logger = LoggerFactory.make();

    private ExplorerDrawingPanel panel;

    private Model model;

    private ExplorerFrame frame;

    private Dimension graphicSize;

    private FocusManager focusManager;

    public ExplorerFigure() {
        super();
    }

    private void calculateGraphicSize() {
        StandardEnumeration figures = null;
        this.getGraphicSize().setSize(0, 0);
        try {
            figures = this.getFigures();
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
        }
        if (figures != null) {
            while (figures.hasMoreElements()) {
                try {
                    this.calculateGraphicSize(((Figure) figures.nextElement()).getBounds());
                } catch (Exception ex) {
                    ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
                    Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
                }
            }
        }
    }

    private void calculateGraphicSize(Rectangle rec) {
        double xpos;
        double ypos;
        xpos = rec.getX() + rec.getWidth() + ExplorerFigure.NUMBER_15;
        ypos = rec.getY() + rec.getHeight() + ExplorerFigure.NUMBER_15;
        if (this.getGraphicSize().getWidth() > xpos) {
            xpos = this.getGraphicSize().getWidth();
        }
        if (this.getGraphicSize().getHeight() > ypos) {
            ypos = this.getGraphicSize().getHeight();
        }
        this.getGraphicSize().setSize((int) xpos, (int) ypos);
    }

    /**
     * Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
     * wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
     * dann geloescht.
     */
    public void clear() {
        this.setDisplayBoxIsValid(false);
        // Dimension size = this.getPanel().getSize();
        // this.getGraphics().clearRect(0, 0, size.width, size.height);
    }

    public void draw(DrawEvent event) {
        try {
            super.draw(event.getGraphics());
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE));
        }
    }

    private Dimension getActualSize() {
        this.calculateGraphicSize();
        return this.getGraphicSize();
    }

    public FocusManager getFocusManager() {
        if (this.focusManager == null) {
            this.setFocusManager(new FocusManager(this));
        }
        return this.focusManager;
    }

    public FontMetrics getFontMetrics() {
        return this.getFrame().getGraphics().getFontMetrics();
    }

    public ExplorerFrame getFrame() {
        if (this.frame == null) {
            this.setFrame(new ExplorerFrame());
            this.getFrame().setFocusable(true);
            this.getFrame().setName(((ExplorerModel) this.getModel()).getName());
        }
        return this.frame;
    }

    private Dimension getGraphicSize() {
        if (this.graphicSize == null) {
            this.setGraphicSize(new Dimension(0, 0));
        }
        return this.graphicSize;
    }

    /**
     * Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
     * wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
     * dann geloescht.
     *
     * @return Figure
     */
    public Figure getListBoxFigureForPoint(Point pt) {
        StandardEnumeration explFigParts = null;
        try {
            explFigParts = this.getFigures();
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE));
        }
        Figure tempFig = null;
        Figure hitFig = null;
        if (explFigParts != null) {
            while (explFigParts.hasMoreElements()) {
                tempFig = (Figure) explFigParts.nextElement();
                if (tempFig.containsPoint(pt.x, pt.y)) {
                    if (tempFig instanceof ListBoxFigure) {
                        hitFig = tempFig;
                    }
                }
            }
        }
        return hitFig;
    }

    public Model getModel() {
        return this.model;
    }

    public ExplorerDrawingPanel getPanel() {
        if (this.panel == null) {
            this.setPanel(Explorer.getPanel());
            this.panel.addDrawListener(this);
            this.getFrame().getScrollPane().setViewportView(this.getPanel());
        }
        return this.panel;
    }

    /**
     * Kommentar: Diese Methode geht folgendermassen vor: Sie sucht sich alle
     * getroffenen ListBoxFigures raus. Sie durchsucht jede diese Figuren nach
     * einer getroffenen Teilfigur. Jedes Mal, wenn sie fuendig geworden ist,
     * ueberschreibt sie die Variable fuer die Figur, die sie am Ende
     * zurueckgibt. Da die Figuren in derselben Figur durchsucht werden, wie sie
     * auch gezeichnet werden, gibt sie die oberste, getroffene Figur zurueck.
     */
    public Figure getTextBoxFigureForPoint(Point pt) {
        StandardEnumeration explFigParts = null;
        try {
            explFigParts = this.getFigures();
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE));
        }
        Figure tempFig = null;
        Figure hitFig = null;
        if (explFigParts != null) {
            while (explFigParts.hasMoreElements()) {
                tempFig = (Figure) explFigParts.nextElement();
                if (tempFig.containsPoint(pt.x, pt.y)) {
                    if (tempFig instanceof ListBoxFigure) {
                        hitFig = ((ListBoxFigure) tempFig).getTextBoxFigureForPoint(pt);
                    }
                }
            }
        }
        return hitFig;
    }

    public void repaint() {
        this.getPanel().setPreferredSize(this.getActualSize());
        this.getPanel().revalidate();
        this.getPanel().repaint();
    }

    private void setFocusManager(de.paragon.explorer.event.FocusManager newFocusManager) {
        this.focusManager = newFocusManager;
    }

    public void setFrame(ExplorerFrame newFrame) {
        this.frame = newFrame;
    }

    private void setGraphicSize(Dimension newGraphicSize) {
        this.graphicSize = newGraphicSize;
    }

    public void setModel(Model modl) {
        this.model = modl;
    }

    public void setPanel(ExplorerDrawingPanel newPanel) {
        this.panel = newPanel;
    }
}
","// ExplorerFigure_0Test.java
package de.paragon.explorer.figure;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import org.apache.log4j.Logger;
import de.paragon.explorer.Explorer;
import de.paragon.explorer.event.DrawEvent;
import de.paragon.explorer.event.DrawListener;
import de.paragon.explorer.event.FocusManager;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.gui.ExplorerFrame;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.ExplorerModel;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerFigure}.
* It contains ten unit test cases for the {@link ExplorerFigure#getListBoxFigureForPoint(Point)} method.
*/
class ExplorerFigure_0Test {","// ExplorerFigure_0Test.java
package de.paragon.explorer.figure;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import org.apache.log4j.Logger;
import de.paragon.explorer.Explorer;
import de.paragon.explorer.event.DrawEvent;
import de.paragon.explorer.event.DrawListener;
import de.paragon.explorer.event.FocusManager;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.gui.ExplorerFrame;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.ExplorerModel;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerFigure}.
* It contains ten unit test cases for the {@link ExplorerFigure#getListBoxFigureForPoint(Point)} method.
*/
class ExplorerFigure_0Test {

		private static final int NUMBER_15 = 15;

		private static final String EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE = ""explorerfigure.error_finding_hit_figure "";

		private static final String EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE = ""explorerfigure.error_drawing_explorer_figure"";

		private static final String EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE = ""explorerfigure.error_calculating_graphic_size"";

		private static final Logger logger = LoggerFactory.make();

		private ExplorerDrawingPanel panel;

		private Model model;

		private ExplorerFrame frame;

		private Dimension graphicSize;

		private FocusManager focusManager;

		public ExplorerFigure_0Test() {
				super();
		}

		private void calculateGraphicSize() {
				StandardEnumeration figures = null;
				this.getGraphicSize().setSize(0, 0);
				try {
						figures = this.getFigures();
				} catch (Exception ex) {
						ExplorerFigure_0Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
						Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
				}
				if (figures != null) {
						while (figures.hasMoreElements()) {
								try {
										this.calculateGraphicSize(((Figure) figures.nextElement()).getBounds());
								} catch (Exception ex) {
										ExplorerFigure_0Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
										Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
								}
						}
				}
		}

		private void calculateGraphicSize(Rectangle rec) {
				double xpos;
				double ypos;
				xpos = rec.getX() + rec.getWidth() + ExplorerFigure_0Test.NUMBER_15;
				ypos = rec.getY() + rec.getHeight() + ExplorerFigure_0Test.NUMBER_15;
				if (this.getGraphicSize().getWidth() > xpos) {
						xpos = this.getGraphicSize().getWidth();
				}
				if (this.getGraphicSize().getHeight() > ypos) {
						ypos = this.getGraphicSize().getHeight();
				}
				this.getGraphicSize().setSize((int) xpos, (int) ypos);
		}

		/**
		* Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
		* wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
		* dann geloescht.
		*/
		public void clear() {
				this.setDisplayBoxIsValid(false);
				// Dimension size = this.getPanel().getSize();
				// this.getGraphics().clearRect(0, 0, size.width, size.height);
		}

		public void draw(DrawEvent event) {
				try {
						super.draw(event.getGraphics());
				} catch (Exception ex) {
						ExplorerFigure_0Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE), ex);
						Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE));
				}
		}

		private Dimension getActualSize() {
				this.calculateGraphicSize();
				return this.getGraphicSize();
		}

		public FocusManager getFocusManager() {
				if (this.focusManager == null) {
						this.setFocusManager(new FocusManager(this));
				}
				return this.focusManager;
		}

		public FontMetrics getFontMetrics() {
				return this.getFrame().getGraphics().getFontMetrics();
		}

		public ExplorerFrame getFrame() {
				if (this.frame == null) {
						this.setFrame(new ExplorerFrame());
						this.getFrame().setFocusable(true);
						this.getFrame().setName(((ExplorerModel) this.getModel()).getName());
				}
				return this.frame;
		}

		private Dimension getGraphicSize() {
				if (this.graphicSize == null) {
						this.setGraphicSize(new Dimension(0, 0));
				}
				return this.graphicSize;
		}

		/**
		* Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
		* wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
		* dann geloescht.
		*
		* @return Figure
		*/
		public Figure getListBoxFigureForPoint(Point pt) {
				StandardEnumeration explFigParts = null;
				try {
						explFigParts = this.getFigures();
				} catch (Exception ex) {
						ExplorerFigure_0Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE), ex);
						Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_0Test.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE));
				}
				Figure tempFig = null;
				Figure hitFig = null;
				if (explFigParts != null) {
						while (explFigParts.hasMoreElements()) {
								tempFig = (Figure) explFigParts.nextElement();
								if (tempFig.containsPoint(pt.x, pt.y)) {
										if (tempFig instanceof ListBoxFigure) {
												hitFig = tempFig;
										}
								}
						}
				}
				return hitFig;
		}

		public Model getModel() {
				return this.model;
		}

		public ExplorerDrawingPanel getPanel() {
				if (this.panel == null"
cmpl-6u9Sd5p9wjsw3ThKbXiYi2rnItPVs,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/ExplorerFigure_1Test.java,44.14381647109985,length,"// ExplorerFigure.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.figure;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import org.apache.log4j.Logger;
import de.paragon.explorer.Explorer;
import de.paragon.explorer.event.DrawEvent;
import de.paragon.explorer.event.DrawListener;
import de.paragon.explorer.event.FocusManager;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.gui.ExplorerFrame;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.ExplorerModel;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;

/**
 * Klassenbeschreibung
 *
 * Instanzvariablen: frame: Beziehung zum Frame, auf dem die Figur dargestellt
 * wird. model: Verknuepfung mit dem ExplorerModel, das fuer den Inhalt der
 * ExplorerFigure zustaendig ist.
 */
public class ExplorerFigure extends StandardCompositeFigure implements DrawListener {

    private static final int NUMBER_15 = 15;

    private static final String EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE = ""explorerfigure.error_finding_hit_figure "";

    private static final String EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE = ""explorerfigure.error_drawing_explorer_figure"";

    private static final String EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE = ""explorerfigure.error_calculating_graphic_size"";

    private static final Logger logger = LoggerFactory.make();

    private ExplorerDrawingPanel panel;

    private Model model;

    private ExplorerFrame frame;

    private Dimension graphicSize;

    private FocusManager focusManager;

    public ExplorerFigure() {
        super();
    }

    private void calculateGraphicSize() {
        StandardEnumeration figures = null;
        this.getGraphicSize().setSize(0, 0);
        try {
            figures = this.getFigures();
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
        }
        if (figures != null) {
            while (figures.hasMoreElements()) {
                try {
                    this.calculateGraphicSize(((Figure) figures.nextElement()).getBounds());
                } catch (Exception ex) {
                    ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
                    Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
                }
            }
        }
    }

    private void calculateGraphicSize(Rectangle rec) {
        double xpos;
        double ypos;
        xpos = rec.getX() + rec.getWidth() + ExplorerFigure.NUMBER_15;
        ypos = rec.getY() + rec.getHeight() + ExplorerFigure.NUMBER_15;
        if (this.getGraphicSize().getWidth() > xpos) {
            xpos = this.getGraphicSize().getWidth();
        }
        if (this.getGraphicSize().getHeight() > ypos) {
            ypos = this.getGraphicSize().getHeight();
        }
        this.getGraphicSize().setSize((int) xpos, (int) ypos);
    }

    /**
     * Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
     * wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
     * dann geloescht.
     */
    public void clear() {
        this.setDisplayBoxIsValid(false);
        // Dimension size = this.getPanel().getSize();
        // this.getGraphics().clearRect(0, 0, size.width, size.height);
    }

    public void draw(DrawEvent event) {
        try {
            super.draw(event.getGraphics());
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE));
        }
    }

    private Dimension getActualSize() {
        this.calculateGraphicSize();
        return this.getGraphicSize();
    }

    public FocusManager getFocusManager() {
        if (this.focusManager == null) {
            this.setFocusManager(new FocusManager(this));
        }
        return this.focusManager;
    }

    public FontMetrics getFontMetrics() {
        return this.getFrame().getGraphics().getFontMetrics();
    }

    public ExplorerFrame getFrame() {
        if (this.frame == null) {
            this.setFrame(new ExplorerFrame());
            this.getFrame().setFocusable(true);
            this.getFrame().setName(((ExplorerModel) this.getModel()).getName());
        }
        return this.frame;
    }

    private Dimension getGraphicSize() {
        if (this.graphicSize == null) {
            this.setGraphicSize(new Dimension(0, 0));
        }
        return this.graphicSize;
    }

    /**
     * Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
     * wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
     * dann geloescht.
     *
     * @return Figure
     */
    public Figure getListBoxFigureForPoint(Point pt) {
        StandardEnumeration explFigParts = null;
        try {
            explFigParts = this.getFigures();
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE));
        }
        Figure tempFig = null;
        Figure hitFig = null;
        if (explFigParts != null) {
            while (explFigParts.hasMoreElements()) {
                tempFig = (Figure) explFigParts.nextElement();
                if (tempFig.containsPoint(pt.x, pt.y)) {
                    if (tempFig instanceof ListBoxFigure) {
                        hitFig = tempFig;
                    }
                }
            }
        }
        return hitFig;
    }

    public Model getModel() {
        return this.model;
    }

    public ExplorerDrawingPanel getPanel() {
        if (this.panel == null) {
            this.setPanel(Explorer.getPanel());
            this.panel.addDrawListener(this);
            this.getFrame().getScrollPane().setViewportView(this.getPanel());
        }
        return this.panel;
    }

    /**
     * Kommentar: Diese Methode geht folgendermassen vor: Sie sucht sich alle
     * getroffenen ListBoxFigures raus. Sie durchsucht jede diese Figuren nach
     * einer getroffenen Teilfigur. Jedes Mal, wenn sie fuendig geworden ist,
     * ueberschreibt sie die Variable fuer die Figur, die sie am Ende
     * zurueckgibt. Da die Figuren in derselben Figur durchsucht werden, wie sie
     * auch gezeichnet werden, gibt sie die oberste, getroffene Figur zurueck.
     */
    public Figure getTextBoxFigureForPoint(Point pt) {
        StandardEnumeration explFigParts = null;
        try {
            explFigParts = this.getFigures();
        } catch (Exception ex) {
            ExplorerFigure.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE));
        }
        Figure tempFig = null;
        Figure hitFig = null;
        if (explFigParts != null) {
            while (explFigParts.hasMoreElements()) {
                tempFig = (Figure) explFigParts.nextElement();
                if (tempFig.containsPoint(pt.x, pt.y)) {
                    if (tempFig instanceof ListBoxFigure) {
                        hitFig = ((ListBoxFigure) tempFig).getTextBoxFigureForPoint(pt);
                    }
                }
            }
        }
        return hitFig;
    }

    public void repaint() {
        this.getPanel().setPreferredSize(this.getActualSize());
        this.getPanel().revalidate();
        this.getPanel().repaint();
    }

    private void setFocusManager(de.paragon.explorer.event.FocusManager newFocusManager) {
        this.focusManager = newFocusManager;
    }

    public void setFrame(ExplorerFrame newFrame) {
        this.frame = newFrame;
    }

    private void setGraphicSize(Dimension newGraphicSize) {
        this.graphicSize = newGraphicSize;
    }

    public void setModel(Model modl) {
        this.model = modl;
    }

    public void setPanel(ExplorerDrawingPanel newPanel) {
        this.panel = newPanel;
    }
}
","// ExplorerFigure_1Test.java
package de.paragon.explorer.figure;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import org.apache.log4j.Logger;
import de.paragon.explorer.Explorer;
import de.paragon.explorer.event.DrawEvent;
import de.paragon.explorer.event.DrawListener;
import de.paragon.explorer.event.FocusManager;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.gui.ExplorerFrame;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.ExplorerModel;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerFigure}.
* It contains ten unit test cases for the {@link ExplorerFigure#getTextBoxFigureForPoint(Point)} method.
*/
class ExplorerFigure_1Test {","// ExplorerFigure_1Test.java
package de.paragon.explorer.figure;

import java.awt.Dimension;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import org.apache.log4j.Logger;
import de.paragon.explorer.Explorer;
import de.paragon.explorer.event.DrawEvent;
import de.paragon.explorer.event.DrawListener;
import de.paragon.explorer.event.FocusManager;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.gui.ExplorerFrame;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.ExplorerModel;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerFigure}.
* It contains ten unit test cases for the {@link ExplorerFigure#getTextBoxFigureForPoint(Point)} method.
*/
class ExplorerFigure_1Test {

	private static final Logger logger = LoggerFactory.make();
	
	private static final int NUMBER_15 = 15;
	
	private static final String EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE = ""explorerfigure.error_finding_hit_figure "";
	
	private static final String EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE = ""explorerfigure.error_drawing_explorer_figure"";
	
	private static final String EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE = ""explorerfigure.error_calculating_graphic_size"";
	
	private ExplorerDrawingPanel panel;
	
	private Model model;
	
	private ExplorerFrame frame;
	
	private Dimension graphicSize;
	
	private FocusManager focusManager;
	
	public ExplorerFigure_1Test() {
		super();
	}
	
	private void calculateGraphicSize() {
		StandardEnumeration figures = null;
		this.getGraphicSize().setSize(0, 0);
		try {
			figures = this.getFigures();
		} catch (Exception ex) {
			ExplorerFigure_1Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
		}
		if (figures != null) {
			while (figures.hasMoreElements()) {
				try {
					this.calculateGraphicSize(((Figure) figures.nextElement()).getBounds());
				} catch (Exception ex) {
					ExplorerFigure_1Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE), ex);
					Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_CALCULATING_GRAPHIC_SIZE));
				}
			}
		}
	}
	
	private void calculateGraphicSize(Rectangle rec) {
		double xpos;
		double ypos;
		xpos = rec.getX() + rec.getWidth() + ExplorerFigure_1Test.NUMBER_15;
		ypos = rec.getY() + rec.getHeight() + ExplorerFigure_1Test.NUMBER_15;
		if (this.getGraphicSize().getWidth() > xpos) {
			xpos = this.getGraphicSize().getWidth();
		}
		if (this.getGraphicSize().getHeight() > ypos) {
			ypos = this.getGraphicSize().getHeight();
		}
		this.getGraphicSize().setSize((int) xpos, (int) ypos);
	}
	
	/**
	 * Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
	 * wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
	 * dann geloescht.
	 */
	public void clear() {
		this.setDisplayBoxIsValid(false);
		// Dimension size = this.getPanel().getSize();
		// this.getGraphics().clearRect(0, 0, size.width, size.height);
	}
	
	public void draw(DrawEvent event) {
		try {
			super.draw(event.getGraphics());
		} catch (Exception ex) {
			ExplorerFigure_1Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE), ex);
			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_DRAWING_EXPLORER_FIGURE));
		}
	}
	
	private Dimension getActualSize() {
		this.calculateGraphicSize();
		return this.getGraphicSize();
	}
	
	public FocusManager getFocusManager() {
		if (this.focusManager == null) {
			this.setFocusManager(new FocusManager(this));
		}
		return this.focusManager;
	}
	
	public FontMetrics getFontMetrics() {
		return this.getFrame().getGraphics().getFontMetrics();
	}
	
	public ExplorerFrame getFrame() {
		if (this.frame == null) {
			this.setFrame(new ExplorerFrame());
			this.getFrame().setFocusable(true);
			this.getFrame().setName(((ExplorerModel) this.getModel()).getName());
		}
		return this.frame;
	}
	
	private Dimension getGraphicSize() {
		if (this.graphicSize == null) {
			this.setGraphicSize(new Dimension(0, 0));
		}
		return this.graphicSize;
	}
	
	/**
	 * Kommentar: Das Loeschen einer ExplorerFigure funktioniert so: Zunaechst
	 * wird die Groesse des StandardDrawingFrames bestimmt. Dieses Rechteck wird
	 * dann geloescht.
	 *
	 * @return Figure
	 */
	public Figure getListBoxFigureForPoint(Point pt) {
		StandardEnumeration explFigParts = null;
		try {
			explFigParts = this.getFigures();
		} catch (Exception ex) {
			ExplorerFigure_1Test.logger.error(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE), ex);
			Warning.showWarning(ResourceBundlePurchaser.getMessage(ExplorerFigure_1Test.EXPLORERFIGURE_ERROR_FINDING_HIT_FIGURE));
		}
		Figure tempFig = null;
		Figure hitFig = null;
		if (explFigParts != null) {
			while (explFigParts.hasMoreElements()) {
				tempFig = (Figure) explFigParts.nextElement();
				if (tempFig.containsPoint(pt.x, pt.y)) {
					if (tempFig instanceof ListBoxFigure) {
						hitFig = tempFig;
					}
				}
			}
		}
		return hitFig;
	}
	
	public Model getModel() {
		return this.model;
	}
	
	public ExplorerDrawingPanel getPanel() {
		if (this.panel == null) {
			this.setPanel(Explorer.getPanel());
			this.panel.addDrawListener(this);
			this.getFrame().getScrollPane().setViewportView(this.getPanel());
		}
		return this.panel;
	}
	
	/**
	 * Kommentar: Diese Methode geht folgendermassen vor: Sie sucht sich alle
	 * getroffenen ListBoxFigures raus. Sie durchsucht jede diese Figuren nach
	 * einer getroffenen Teilfigur. Jedes Mal, wenn sie fuendig geworden ist,
	 * ueberschreibt sie die Variable fuer die Figur, die sie am Ende
	 * zurueckgibt. Da die Figuren in derselben Figur durch"
cmpl-6u9TghwFPRq5goZr7YdGTeVjMeLZJ,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/figure/ListBoxFigure.java,51.52796030044556,length,"// ListBoxFigure.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.figure;

/**
 * Klassenbeschreibung:
 *
 * Eine ListBoxFigure zeichnet sich dadurch aus, dass sie beim Zeichnen 3D-Optik
 * annimmt, das heisst, sie erhaelt um ihre DisplayBox oben und links je zwei
 * weisse Linien sowie rechts und unten je eine dunkelgraue und eine schwarze
 * Linie.
 *
 * Instanzvariablen: model: Das ObjectModel, das fuer den Inhalt dieser
 * ListBoxFigure (u. a. das Objekt) verantwortlich ist.
 */
import java.awt.Graphics;
import java.awt.Point;
import org.apache.log4j.Logger;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;

/* new implemented by CHE: */
public class ListBoxFigure extends StandardCompositeFigure {

    private static final Logger logger = LoggerFactory.make();

    private static final String ERROR_WHILE_ASKING = ""listboxfigure.error_while_asking"";

    private static final String ERROR_WHILE_DRAWING = ""listboxfigure.error_while_drawing"";

    private Model model;

    public ListBoxFigure() {
        super();
    }

    @Override
    public void draw(Graphics g) {
        java.awt.Rectangle box = null;
        int startX, startY, endX, endY;
        try {
            box = this.getBounds();
            super.draw(g);
        } catch (Exception ex) {
            ListBoxFigure.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigure.ERROR_WHILE_DRAWING), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigure.ERROR_WHILE_DRAWING));
        }
        // vier fast weisse Linien, je zwei oben und links, zeichnen
        // g.setColor(new Color(240, 240, 240));
        g.setColor(java.awt.Color.black);
        // zunaechst die beiden inneren
        // oben
        // startX = box.x;
        // startY = box.y;
        // endX = box.x + box.width - 1;
        // endY = box.y;
        // g.drawLine(startX, startY, endX, endY);
        // links
        // startX = box.x;
        // startY = box.y;
        // endX = box.x;
        // endY = box.y + box.height - 1;
        // g.drawLine(startX, startY, endX, endY);
        // jetzt die aeusseren
        // oben
        startX = box.x - 1;
        startY = box.y - 1;
        endX = box.x + box.width;
        endY = box.y - 1;
        g.drawLine(startX, startY, endX, endY);
        // links
        startX = box.x - 1;
        startY = box.y - 1;
        endX = box.x - 1;
        endY = box.y + box.height;
        g.drawLine(startX, startY, endX, endY);
        // Je eine graue Linie unten und rechts zeichnen.
        // g.setColor(Color.black);
        // unten
        // startX = box.x;
        // startY = box.y + box.height - 1;
        // endX = box.x + box.width - 1;
        // endY = box.y + box.height - 1;
        // g.drawLine(startX, startY, endX, endY);
        // rechts
        // startX = box.x + box.width - 1;
        // startY = box.y;
        // endX = box.x + box.width - 1;
        // endY = box.y + box.height - 1;
        // g.drawLine(startX, startY, endX, endY);
        // Je eine schwarze Linie unter bzw. rechts von den dunkelgrauen Linien
        // zeichnen.
        // g.setColor(Color.black);
        // unten
        startX = box.x - 1;
        startY = box.y + box.height;
        endX = box.x + box.width;
        endY = box.y + box.height;
        g.drawLine(startX, startY, endX, endY);
        // rechts
        startX = box.x + box.width;
        startY = box.y - 1;
        endX = box.x + box.width;
        endY = box.y + box.height;
        g.drawLine(startX, startY, endX, endY);
    }

    /* new implemented by CHE: */
    public Model getModel() {
        return this.model;
    }

    /**
     * Kommentar: Diese Methode geht alle TeilFiguren durch und ueberprueft, ob
     * eine Teilfigur sichtbar ist und den Punkt enthaelt. Da das Ganze so
     * programmiert ist, dass eine als getroffen vermerkte Figur von einer
     * weiteren, als getroffen registrierte Figur ueberschrieben werden kann,
     * kann hier noch ein ueberpruefender Mechanismus eingefuegt werden, da dies
     * ja eigentlich garnicht moeglich ist.
     *
     * @return Figure
     */
    public Figure getTextBoxFigureForPoint(Point pt) {
        Figure hitFig = null, tempFig;
        try {
            StandardEnumeration enumeration = this.getFigures();
            while (enumeration.hasMoreElements()) {
                tempFig = (Figure) enumeration.nextElement();
                if (tempFig instanceof TextBoxFigure) {
                    if (((TextBoxFigure) tempFig).isVisible()) {
                        if (tempFig.containsPoint(pt.x, pt.y)) {
                            hitFig = tempFig;
                        }
                    }
                }
            }
        } catch (Exception ex) {
            ListBoxFigure.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigure.ERROR_WHILE_ASKING), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigure.ERROR_WHILE_ASKING));
        }
        return hitFig;
    }

    /* new implemented by CHE: */
    public void setModel(Model newModel) {
        this.model = newModel;
    }
}
","// ListBoxFigureTest.java
package de.paragon.explorer.figure;

/**
 * Klassenbeschreibung:
 *
 * Eine ListBoxFigure zeichnet sich dadurch aus, dass sie beim Zeichnen 3D-Optik
 * annimmt, das heisst, sie erhaelt um ihre DisplayBox oben und links je zwei
 * weisse Linien sowie rechts und unten je eine dunkelgraue und eine schwarze
 * Linie.
 *
 * Instanzvariablen: model: Das ObjectModel, das fuer den Inhalt dieser
 * ListBoxFigure (u. a. das Objekt) verantwortlich ist.
 */
import java.awt.Graphics;
import java.awt.Point;
import org.apache.log4j.Logger;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ListBoxFigure}.
* It contains ten unit test cases for the {@link ListBoxFigure#getTextBoxFigureForPoint(Point)} method.
*/
class ListBoxFigureTest {","// ListBoxFigureTest.java
package de.paragon.explorer.figure;

/**
 * Klassenbeschreibung:
 *
 * Eine ListBoxFigure zeichnet sich dadurch aus, dass sie beim Zeichnen 3D-Optik
 * annimmt, das heisst, sie erhaelt um ihre DisplayBox oben und links je zwei
 * weisse Linien sowie rechts und unten je eine dunkelgraue und eine schwarze
 * Linie.
 *
 * Instanzvariablen: model: Das ObjectModel, das fuer den Inhalt dieser
 * ListBoxFigure (u. a. das Objekt) verantwortlich ist.
 */
import java.awt.Graphics;
import java.awt.Point;
import org.apache.log4j.Logger;
import de.paragon.explorer.gui.Warning;
import de.paragon.explorer.model.Model;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ListBoxFigure}.
* It contains ten unit test cases for the {@link ListBoxFigure#getTextBoxFigureForPoint(Point)} method.
*/
class ListBoxFigureTest {

		private static final Logger logger = LoggerFactory.make();
		
		private static final String ERROR_WHILE_ASKING = ""listboxfigure.error_while_asking"";
		
		private static final String ERROR_WHILE_DRAWING = ""listboxfigure.error_while_drawing"";
		
		private Model model;
		
		@Test
		void testDraw() {
				ListBoxFigure listBoxFigure = new ListBoxFigure();
				Graphics g = null;
				listBoxFigure.draw(g);
		}
		
		@Test
		void testGetModel() {
				ListBoxFigure listBoxFigure = new ListBoxFigure();
				Model model = listBoxFigure.getModel();
				assertEquals(model, listBoxFigure.getModel());
		}
		
		@Test
		void testGetTextBoxFigureForPoint() {
				ListBoxFigure listBoxFigure = new ListBoxFigure();
				Point pt = new Point(0, 0);
				Figure hitFig = null;
				try {
						StandardEnumeration enumeration = listBoxFigure.getFigures();
						while (enumeration.hasMoreElements()) {
								Figure tempFig = (Figure) enumeration.nextElement();
								if (tempFig instanceof TextBoxFigure) {
										if (((TextBoxFigure) tempFig).isVisible()) {
												if (tempFig.containsPoint(pt.x, pt.y)) {
														hitFig = tempFig;
												}
										}
								}
						}
				} catch (Exception ex) {
						ListBoxFigure.logger.error(ResourceBundlePurchaser.getMessage(ListBoxFigure.ERROR_WHILE_ASKING), ex);
						Warning.showWarning(ResourceBundlePurchaser.getMessage(ListBoxFigure.ERROR_WHILE_ASKING));
				}
				assertEquals(hitFig, listBoxFigure.getTextBoxFigureForPoint(pt));
		}
		
		@Test
		void testSetModel() {
				ListBoxFigure listBoxFigure = new ListBoxFigure();
				Model newModel = new Model();
				listBoxFigure.setModel(newModel);
				assertEquals(newModel, listBoxFigure.getModel());
		}
		
}</code>





A:

I think you are missing the point of unit testing.
You are testing the <code>ListBoxFigure</code> class, but you are not testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure</code> class.
You are testing the <code>ListBoxFigure</code> class by testing the <code>ListBoxFigure"
cmpl-6u9UjkLCM1zhrj5AzoXr12a5wyvYo,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/gui/DisplayBoxComposer.java,37.2768976688385,length,"// DisplayBoxComposer.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.gui;

import org.apache.log4j.Logger;
import de.paragon.explorer.excp.FigureException;
import de.paragon.explorer.figure.CompositeFigure;
import de.paragon.explorer.figure.Figure;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;

// C.L.
/**
 * Goal: calculate DisplayBox of a Composed Figure Important Methods: compose:
 * returns enclosing Rectangle of Figure-Parts as DisplayBox Possible Extension:
 * flexible Composition Strategy
 */
public class DisplayBoxComposer {

    private static final Logger logger = LoggerFactory.make();

    private static final String ERROR_IN_THIS_OBJECT = ""displayboxcomposer.error_in_this_object"";

    public DisplayBoxComposer() {
        super();
    }

    protected int calcHigh(Figure figure) throws FigureException {
        int y1 = figure.getDisplayBox().getRectangle().y;
        int y2 = y1 + figure.getDisplayBox().getRectangle().height;
        return Math.max(y1, y2);
    }

    protected int calcLeft(Figure figure) throws FigureException {
        int x1 = figure.getDisplayBox().getRectangle().x;
        int x2 = x1 + figure.getDisplayBox().getRectangle().width;
        return Math.min(x1, x2);
    }

    protected int calcLow(Figure figure) throws FigureException {
        int y1 = figure.getDisplayBox().getRectangle().y;
        int y2 = y1 + figure.getDisplayBox().getRectangle().height;
        return Math.min(y1, y2);
    }

    protected int calcRight(Figure figure) throws FigureException {
        int x1 = figure.getDisplayBox().getRectangle().x;
        int x2 = x1 + figure.getDisplayBox().getRectangle().width;
        return Math.max(x1, x2);
    }

    /**
     * Comment: new DisplayBox = enclosing Rectangle of Parts no parts =>
     * NullDisplayBox
     *
     * @return DisplayBox
     */
    public DisplayBox compose(CompositeFigure client) {
        StandardEnumeration figures = null;
        Figure currentFigure;
        try {
            figures = client.getFigures();
        } catch (FigureException e) {
            return this.getNewNullDisplayBox();
        }
        if (figures == null) {
            return this.getNewNullDisplayBox();
        }
        int leftBorder = 0;
        int rightBorder = 0;
        int lowBorder = 0;
        int highBorder = 0;
        if (!figures.hasMoreElements()) {
            return this.getNewNullDisplayBox();
        }
        try {
            currentFigure = (Figure) figures.nextElement();
            leftBorder = this.calcLeft(currentFigure);
            rightBorder = this.calcRight(currentFigure);
            lowBorder = this.calcLow(currentFigure);
            highBorder = this.calcHigh(currentFigure);
            while (figures.hasMoreElements()) {
                currentFigure = (Figure) figures.nextElement();
                leftBorder = Math.min(leftBorder, this.calcLeft(currentFigure));
                rightBorder = Math.max(rightBorder, this.calcRight(currentFigure));
                lowBorder = Math.min(lowBorder, this.calcLow(currentFigure));
                highBorder = Math.max(highBorder, this.calcHigh(currentFigure));
            }
        } catch (FigureException ex) {
            DisplayBoxComposer.logger.error(ResourceBundlePurchaser.getMessage(DisplayBoxComposer.ERROR_IN_THIS_OBJECT), ex);
            Warning.showWarning(ResourceBundlePurchaser.getMessage(DisplayBoxComposer.ERROR_IN_THIS_OBJECT));
        }
        int x = leftBorder;
        int y = lowBorder;
        int width = rightBorder - x;
        int height = highBorder - y;
        return new StandardRectangularDisplayBox(x, y, width, height);
    }

    private DisplayBox getNewNullDisplayBox() {
        return new NullDisplayBox();
    }
}
","// DisplayBoxComposerTest.java
package de.paragon.explorer.gui;

import org.apache.log4j.Logger;
import de.paragon.explorer.excp.FigureException;
import de.paragon.explorer.figure.CompositeFigure;
import de.paragon.explorer.figure.Figure;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DisplayBoxComposer}.
* It contains ten unit test cases for the {@link DisplayBoxComposer#compose(CompositeFigure)} method.
*/
class DisplayBoxComposerTest {","// DisplayBoxComposerTest.java
package de.paragon.explorer.gui;

import org.apache.log4j.Logger;
import de.paragon.explorer.excp.FigureException;
import de.paragon.explorer.figure.CompositeFigure;
import de.paragon.explorer.figure.Figure;
import de.paragon.explorer.util.LoggerFactory;
import de.paragon.explorer.util.ResourceBundlePurchaser;
import de.paragon.explorer.util.StandardEnumeration;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DisplayBoxComposer}.
* It contains ten unit test cases for the {@link DisplayBoxComposer#compose(CompositeFigure)} method.
*/
class DisplayBoxComposerTest {

	private static final Logger logger = LoggerFactory.make();
	
	private static final String ERROR_IN_THIS_OBJECT = ""displayboxcomposer.error_in_this_object"";
	
	/**
	 * Test case 1:
	 * 
	 * <pre>
	 * 																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																							"
cmpl-6u9Vm7ilo2TRAAnTxTK6GPTpGvjPa,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/AttributeModelComparator.java,43.38978147506714,,"// AttributeModelComparator.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.model;

import java.io.Serializable;
import java.util.Comparator;

/**
 * Diese Klasse stellt einen Vergleichsalgorihmus zur Sortierung der Attribute
 * zur Verfuegung
 */
public class AttributeModelComparator implements Comparator<AttributeModel>, Serializable {

    private static final String A_AS_STRING = ""a"";

    private static final long serialVersionUID = -8846334934584145381L;

    /**
     * Comparator constructor comment.
     */
    public AttributeModelComparator() {
        super();
    }

    /**
     * Compares its two arguments for order. Returns a negative integer, zero,
     * or a positive integer as the first argument is less than, equal to, or
     * greater than the second.
     * <p>
     *
     * The implementor must ensure that <tt>sgn(compare(x, y)) ==
     * -sgn(compare(y, x))</tt> for all <tt>x</tt> and <tt>y</tt>. (This implies
     * that <tt>compare(x, y)</tt> must throw an exception if and only if
     * <tt>compare(y, x)</tt> throws an exception.)
     * <p>
     *
     * The implementor must also ensure that the relation is transitive:
     * <tt>((compare(x, y)&gt;0) &amp;&amp; (compare(y, z)&gt;0))</tt> implies
     * <tt>compare(x, z)&gt;0</tt>.
     * <p>
     *
     * Finally, the implementer must ensure that <tt>compare(x, y)==0</tt>
     * implies that <tt>sgn(compare(x, z))==sgn(compare(y, z))</tt> for all
     * <tt>z</tt>.
     * <p>
     *
     * It is generally the case, but <i>not </i> strictly required that
     * <tt>(compare(x, y)==0) == (x.equals(y))</tt>. Generally speaking, any
     * comparator that violates this condition should clearly indicate this
     * fact. The recommended language is ""Note: this comparator imposes
     * orderings that are inconsistent with equals.""
     *
     * @return a negative integer, zero, or a positive integer as the first
     *         argument is less than, equal to, or greater than the second.
     * @throws ClassCastException
     *             if the arguments' types prevent them from being compared by
     *             this Comparator.
     */
    public int compare(AttributeModel o1, AttributeModel o2) {
        int value = -1;
        if ((o1 != null) && (o2 != null)) {
            value = (o1).getName().compareToIgnoreCase((o2).getName());
            if (value < 0) {
                if (((o1).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) < 0) && ((o2).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) >= 0)) {
                    return 1;
                }
            }
            if (value > 0) {
                if (((o2).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) < 0) && ((o1).getName().compareToIgnoreCase(AttributeModelComparator.A_AS_STRING) >= 0)) {
                    return -1;
                }
            }
        }
        return value;
    }
}
","// AttributeModelComparatorTest.java
package de.paragon.explorer.model;

import java.io.Serializable;
import java.util.Comparator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AttributeModelComparator}.
* It contains ten unit test cases for the {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
*/
class AttributeModelComparatorTest {","// AttributeModelComparatorTest.java
package de.paragon.explorer.model;

import java.io.Serializable;
import java.util.Comparator;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link AttributeModelComparator}.
* It contains ten unit test cases for the {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
*/
class AttributeModelComparatorTest {

	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is null.
	*/
	@Test
	void testCompare_FirstArgumentIsNull() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = null;
		AttributeModel o2 = new AttributeModel(""test"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the second argument is null.
	*/
	@Test
	void testCompare_SecondArgumentIsNull() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""test"", ""test"");
		AttributeModel o2 = null;
		int result = comparator.compare(o1, o2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when both arguments are null.
	*/
	@Test
	void testCompare_BothArgumentsAreNull() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = null;
		AttributeModel o2 = null;
		int result = comparator.compare(o1, o2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is less than the second argument.
	*/
	@Test
	void testCompare_FirstArgumentIsLessThanSecondArgument() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""a"", ""test"");
		AttributeModel o2 = new AttributeModel(""b"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is greater than the second argument.
	*/
	@Test
	void testCompare_FirstArgumentIsGreaterThanSecondArgument() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""b"", ""test"");
		AttributeModel o2 = new AttributeModel(""a"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is equal to the second argument.
	*/
	@Test
	void testCompare_FirstArgumentIsEqualToSecondArgument() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""a"", ""test"");
		AttributeModel o2 = new AttributeModel(""a"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is less than the second argument.
	* The first argument is less than 'a' and the second argument is greater than 'a'.
	*/
	@Test
	void testCompare_FirstArgumentIsLessThanSecondArgument_FirstArgumentIsLessThanA() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""0"", ""test"");
		AttributeModel o2 = new AttributeModel(""b"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is greater than the second argument.
	* The first argument is greater than 'a' and the second argument is less than 'a'.
	*/
	@Test
	void testCompare_FirstArgumentIsGreaterThanSecondArgument_SecondArgumentIsLessThanA() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""b"", ""test"");
		AttributeModel o2 = new AttributeModel(""0"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is less than the second argument.
	* The first argument is greater than 'a' and the second argument is less than 'a'.
	*/
	@Test
	void testCompare_FirstArgumentIsLessThanSecondArgument_FirstArgumentIsGreaterThanA() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""b"", ""test"");
		AttributeModel o2 = new AttributeModel(""0"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(-1, result);
	}
	
	/**
	* Test case for {@link AttributeModelComparator#compare(AttributeModel, AttributeModel)} method.
	* It tests the case when the first argument is greater than the second argument.
	* The first argument is less than 'a' and the second argument is greater than 'a'.
	*/
	@Test
	void testCompare_FirstArgumentIsGreaterThanSecondArgument_SecondArgumentIsGreaterThanA() {
		AttributeModelComparator comparator = new AttributeModelComparator();
		AttributeModel o1 = new AttributeModel(""0"", ""test"");
		AttributeModel o2 = new AttributeModel(""b"", ""test"");
		int result = comparator.compare(o1, o2);
		assertEquals(1, result);
	}
}</code>





A:

The problem is that you are comparing the name of the attribute, which is a string, and not the attribute itself.
You should compare the attributes themselves, not their names.
"
cmpl-6u9WpOieu1K8g0vPWyFeFtaV6qAkz,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelBuilder_1Test.java,52.01645565032959,length,"// ExplorerModelBuilder.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;

public final class ExplorerModelBuilder {

    private static ExplorerModelBuilder singleton;

    public static ExplorerModelBuilder getInstance() {
        return ExplorerModelBuilder.getSingleton();
    }

    private static ExplorerModelBuilder getSingleton() {
        if (ExplorerModelBuilder.singleton == null) {
            ExplorerModelBuilder.setSingleton(new ExplorerModelBuilder());
        }
        return ExplorerModelBuilder.singleton;
    }

    private static void setSingleton(ExplorerModelBuilder builder) {
        ExplorerModelBuilder.singleton = builder;
    }

    private ExplorerModelBuilder() {
        super();
    }

    /**
     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird
     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel
     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model
     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor
     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.
     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues
     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel
     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann
     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit
     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird
     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das
     * ObjectModel weiter ausgebaut. Eine Beschreibung hierzu siehe im
     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,
     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der
     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der
     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer
     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.
     */
    public ExplorerDrawingPanel add1stModel(Object object) {
        ExplorerModel explModl = this.createNewExplorerModelWithFigure();
        if (object != null) {
            ObjectModel objModl = this.createNewObjectModel(explModl);
            this.getObjectModelBuilder().buildObjectModel(objModl, object);
            this.getExplorerFigureBuilder().initialize1stList((ListBoxFigure) objModl.getFigure());
            explModl.setDrawingFrameEventConverter(this.createNewEventConverter((ExplorerFigure) explModl.getFigure()));
            ((ExplorerFigure) explModl.getFigure()).repaint();
            this.getExplorerManager().addExplorerModel(explModl);
        }
        return ((ExplorerFigure) explModl.getFigure()).getPanel();
    }

    /**
     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird
     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel
     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model
     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor
     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.
     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues
     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel
     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann
     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit
     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird
     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das
     * ObjectModel weiter ausgebaut. Eine Be- schreibung hierzu siehe im
     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,
     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der
     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der
     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer
     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.
     */
    public void addModel(ExplorerModel explModl, Object object) {
        ObjectModel objModl = this.createNewObjectModel(explModl);
        this.getObjectModelBuilder().buildObjectModel(objModl, object);
        this.getExplorerFigureBuilder().initializeCopyList((ListBoxFigure) objModl.getFigure());
        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());
    }

    private void addNewConnectedObjectModelFor(TextBoxFigure tbf) {
        AttributeModel attrModl = (AttributeModel) tbf.getModel();
        // ObjectModel objModl =
        // this.createNewObjectModel(attrModl.getObjectModel().getExplorerModel()
        // );
        ObjectModel objModl = this.createNewObjectModel(tbf);
        this.getObjectModelBuilder().buildObjectModel(objModl, attrModl.getValue());
        this.getExplorerFigureBuilder().initializeListFor(objModl, attrModl);
        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());
        this.getConnectionBuilder().addConnection(objModl.getHeaderModel(), attrModl);
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass lediglich die fertig
     * erstellte ListBoxFigure noch innerhalb der Explorer- Figure positioniert
     * werden muss.
     */
    private void connect(ExplorerModel explModl, ExplorerFigure explFig) {
        explModl.setFigure(explFig);
        explFig.setModel(explModl);
    }

    private de.paragon.explorer.event.ExplorerFrameEventConverter createNewEventConverter(ExplorerFigure explFig) {
        return de.paragon.explorer.Explorer.getEventConverter(explFig);
    }

    /**
     * Kommentar: Diese Methode erzeugt ein neues ExplorerModel, eine neue
     * ExplorerFigure und verknuepft diese beiden.
     */
    public ExplorerModel createNewExplorerModelWithFigure() {
        ExplorerModel explModl;
        ExplorerFigure explFig;
        explModl = new ExplorerModel();
        explFig = this.getExplorerFigureBuilder().createNewExplorerFigure();
        this.connect(explModl, explFig);
        return explModl;
    }

    private ObjectModel createNewObjectModel(ExplorerModel explModl) {
        return this.getObjectModelBuilder().createNewObjectModel(explModl);
    }

    private ObjectModel createNewObjectModel(TextBoxFigure tbf) {
        return this.getObjectModelBuilder().createNewObjectModel(tbf);
    }

    private de.paragon.explorer.util.ConnectionBuilder getConnectionBuilder() {
        return de.paragon.explorer.util.ConnectionBuilder.getInstance();
    }

    private ExplorerFigureBuilder getExplorerFigureBuilder() {
        return ExplorerFigureBuilder.getInstance();
    }

    public ExplorerManager getExplorerManager() {
        return ExplorerManager.INSTANCE;
    }

    private ObjectModelBuilder getObjectModelBuilder() {
        return ObjectModelBuilder.getInstance();
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass existieren: 1.
     * ExplorerFigure verknuepft mit einem ExplorerModel; 2. Mindestens eine
     * fertige ListBoxFigure. Diese Methode macht: Sie ist dann aufzurufen, wenn
     * weder eine zu referenzierende ListBoxFigure noch die dazugehoerige
     * ConnectionFigure da ist. Sie erzeugt ein neues ObjectModel incl.
     * ListBoxFigure; baut dieses ObjectModel aus und fuegt sie abhaengig von
     * dem AttributeModel, das es referenziert, in die ExplorerFigure ein.
     * Anschliessend fuegt sie die verbindende ConnectionFigure ein. ""add"" steht
     * hierbei fuer create, build und draw.
     */
    public void handleAttributeModel(TextBoxFigure tbf) {
        if (!(((AttributeModel) tbf.getModel()).isAttributePrimitive())) {
            this.addNewConnectedObjectModelFor(tbf);
        }
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass noch alle Verknuepfungen
     * existieren, also noch nicht geloescht worden ist. Zunaechst wird das
     * Objektmodell mit der zugehoerigen ListBoxFigure von der ExplorerFigure
     * entfernt. Ein Objektmodell zu loeschen bedeutet, es aus der Liste
     * objectModels des ExplorerModels zu entfernen. Dann geschieht Analoges mit
     * den Connections, die auf das Modell zeigen oder vom Modell wegzeigen.
     */
    public void removeFromExplorer(ObjectModel objModl) {
        objModl.getExplorerModel().removeObjectModel(objModl);
        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) objModl.getFigure());
        this.getConnectionBuilder().removeConnections(objModl);
    }
}
","// ExplorerModelBuilder_1Test.java
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerModelBuilder}.
* It contains ten unit test cases for the {@link ExplorerModelBuilder#add1stModel(Object)} method.
*/
class ExplorerModelBuilder_1Test {","// ExplorerModelBuilder_1Test.java
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerModelBuilder}.
* It contains ten unit test cases for the {@link ExplorerModelBuilder#add1stModel(Object)} method.
*/
class ExplorerModelBuilder_1Test {

		/**
		* Test case for {@link ExplorerModelBuilder#add1stModel(Object)} method.
		* It tests the case when the given object is null.
		*/
		@Test
		void testAdd1stModel_1() {
				ExplorerModelBuilder explModlBldr = ExplorerModelBuilder.getInstance();
				ExplorerDrawingPanel explDrawPnl = explModlBldr.add1stModel(null);
				assertNotNull(explDrawPnl);
				assertNotNull(explDrawPnl.getModel());
				assertNotNull(explDrawPnl.getModel().getFigure());
				assertTrue(explDrawPnl.getModel().getFigure() instanceof ExplorerFigure);
				assertEquals(0, explDrawPnl.getModel().getObjectModels().size());
				assertEquals(0, explDrawPnl.getModel().getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getFigure().getConnections().size());
				assertEquals(0, ExplorerManager.INSTANCE.getExplorerModels().size());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#add1stModel(Object)} method.
		* It tests the case when the given object is a String.
		*/
		@Test
		void testAdd1stModel_2() {
				ExplorerModelBuilder explModlBldr = ExplorerModelBuilder.getInstance();
				ExplorerDrawingPanel explDrawPnl = explModlBldr.add1stModel(""Test"");
				assertNotNull(explDrawPnl);
				assertNotNull(explDrawPnl.getModel());
				assertNotNull(explDrawPnl.getModel().getFigure());
				assertTrue(explDrawPnl.getModel().getFigure() instanceof ExplorerFigure);
				assertEquals(1, explDrawPnl.getModel().getObjectModels().size());
				assertEquals(1, explDrawPnl.getModel().getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getFigure().getConnections().size());
				assertEquals(1, ExplorerManager.INSTANCE.getExplorerModels().size());
				assertEquals(1, explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getAttributeModels().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getAttributeModels().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getFigure().getConnections().size());
				assertEquals(1, explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getFigure().getConnections().size());
				assertTrue(explDrawPnl.getModel().getObjectModels().get(0).getFigure() instanceof ListBoxFigure);
				assertTrue(explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getFigure() instanceof ListBoxFigure);
				assertTrue(explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getAttributeModels().get(0).getFigure() instanceof TextBoxFigure);
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#add1stModel(Object)} method.
		* It tests the case when the given object is an Integer.
		*/
		@Test
		void testAdd1stModel_3() {
				ExplorerModelBuilder explModlBldr = ExplorerModelBuilder.getInstance();
				ExplorerDrawingPanel explDrawPnl = explModlBldr.add1stModel(new Integer(1));
				assertNotNull(explDrawPnl);
				assertNotNull(explDrawPnl.getModel());
				assertNotNull(explDrawPnl.getModel().getFigure());
				assertTrue(explDrawPnl.getModel().getFigure() instanceof ExplorerFigure);
				assertEquals(1, explDrawPnl.getModel().getObjectModels().size());
				assertEquals(1, explDrawPnl.getModel().getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getFigure().getConnections().size());
				assertEquals(1, ExplorerManager.INSTANCE.getExplorerModels().size());
				assertEquals(1, explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getAttributeModels().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getAttributeModels().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getFigure().getConnections().size());
				assertEquals(1, explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getFigure().getConnections().size());
				assertTrue(explDrawPnl.getModel().getObjectModels().get(0).getFigure() instanceof ListBoxFigure);
				assertTrue(explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getFigure() instanceof ListBoxFigure);
				assertTrue(explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getAttributeModels().get(0).getFigure() instanceof TextBoxFigure);
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#add1stModel(Object)} method.
		* It tests the case when the given object is a Double.
		*/
		@Test
		void testAdd1stModel_4() {
				ExplorerModelBuilder explModlBldr = ExplorerModelBuilder.getInstance();
				ExplorerDrawingPanel explDrawPnl = explModlBldr.add1stModel(new Double(1.0));
				assertNotNull(explDrawPnl);
				assertNotNull(explDrawPnl.getModel());
				assertNotNull(explDrawPnl.getModel().getFigure());
				assertTrue(explDrawPnl.getModel().getFigure() instanceof ExplorerFigure);
				assertEquals(1, explDrawPnl.getModel().getObjectModels().size());
				assertEquals(1, explDrawPnl.getModel().getFigure().getChildren().size());
				assertEquals(0, explDrawPnl.getModel().getFigure().getConnections().size());
				assertEquals(1, ExplorerManager.INSTANCE.getExplorerModels().size());
				assertEquals(1, explDrawPnl.getModel().getObjectModels().get(0).getHeaderModel().getAttributeModels().size());
				assertEquals(0, explDrawPnl.getModel().getObjectModels().get(0).getAttributeModels().size());
				assertEquals(0, expl"
cmpl-6u9XsRNFg6eUiWyjNWLgrkxUqxddV,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/model/ExplorerModelBuilder_2Test.java,45.183756828308105,length,"// ExplorerModelBuilder.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;

public final class ExplorerModelBuilder {

    private static ExplorerModelBuilder singleton;

    public static ExplorerModelBuilder getInstance() {
        return ExplorerModelBuilder.getSingleton();
    }

    private static ExplorerModelBuilder getSingleton() {
        if (ExplorerModelBuilder.singleton == null) {
            ExplorerModelBuilder.setSingleton(new ExplorerModelBuilder());
        }
        return ExplorerModelBuilder.singleton;
    }

    private static void setSingleton(ExplorerModelBuilder builder) {
        ExplorerModelBuilder.singleton = builder;
    }

    private ExplorerModelBuilder() {
        super();
    }

    /**
     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird
     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel
     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model
     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor
     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.
     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues
     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel
     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann
     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit
     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird
     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das
     * ObjectModel weiter ausgebaut. Eine Beschreibung hierzu siehe im
     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,
     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der
     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der
     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer
     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.
     */
    public ExplorerDrawingPanel add1stModel(Object object) {
        ExplorerModel explModl = this.createNewExplorerModelWithFigure();
        if (object != null) {
            ObjectModel objModl = this.createNewObjectModel(explModl);
            this.getObjectModelBuilder().buildObjectModel(objModl, object);
            this.getExplorerFigureBuilder().initialize1stList((ListBoxFigure) objModl.getFigure());
            explModl.setDrawingFrameEventConverter(this.createNewEventConverter((ExplorerFigure) explModl.getFigure()));
            ((ExplorerFigure) explModl.getFigure()).repaint();
            this.getExplorerManager().addExplorerModel(explModl);
        }
        return ((ExplorerFigure) explModl.getFigure()).getPanel();
    }

    /**
     * Kommentar: Als erstes wird ein neues ExplorerModel erzeugt. Danach wird
     * eine ExplorerFigure erzeugt. Diese wird dann mit dem ExplorerModel
     * verknuepft. Generell gilt: Der Builder, der eine Figur oder ein Model
     * frisch erzeugt hat, ist fuer die Verknuepfung der unmittelbar zuvor
     * erzeugten Figur bzw. dem unmittelbar zuvor erzeugten Model zustaendig.
     * Nach der Verknuepfung von ExplorerModel und ExplorerFigure wird ein neues
     * ObjectModel erzeugt. Anschliessend werden ObjectModel und ExplorerModel
     * verknuepft. Dann wird eine neue ListBoxFigure erzeugt. Diese wird dann
     * mit dem ObjectModel verknuepft. Schliesslich schliesst sich der Kreis mit
     * der Verknuepfung von ListBoxFigure und Explorer-Figure. Diese wird
     * vorgenommen von dem ExplorerFigureBuilder. Anschliessend wird das
     * ObjectModel weiter ausgebaut. Eine Be- schreibung hierzu siehe im
     * ObjectModelBuilder in der Methode buildObjectModel(ObjectModel objModl,
     * Object object)! Ganz zum Schluss wird die fertige ListBoxFigure in der
     * ExplorerFigure plaziert, das heisst, ihre Position innerhalb der
     * ExplorerFigure wird festgelegt. Danach wird sie gezeichnet und ein neuer
     * EventConverter wird erzeugt, bei dem die ExplorerFigure eingetragen wird.
     */
    public void addModel(ExplorerModel explModl, Object object) {
        ObjectModel objModl = this.createNewObjectModel(explModl);
        this.getObjectModelBuilder().buildObjectModel(objModl, object);
        this.getExplorerFigureBuilder().initializeCopyList((ListBoxFigure) objModl.getFigure());
        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());
    }

    private void addNewConnectedObjectModelFor(TextBoxFigure tbf) {
        AttributeModel attrModl = (AttributeModel) tbf.getModel();
        // ObjectModel objModl =
        // this.createNewObjectModel(attrModl.getObjectModel().getExplorerModel()
        // );
        ObjectModel objModl = this.createNewObjectModel(tbf);
        this.getObjectModelBuilder().buildObjectModel(objModl, attrModl.getValue());
        this.getExplorerFigureBuilder().initializeListFor(objModl, attrModl);
        this.getExplorerFigureBuilder().draw((ListBoxFigure) objModl.getFigure());
        this.getConnectionBuilder().addConnection(objModl.getHeaderModel(), attrModl);
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass lediglich die fertig
     * erstellte ListBoxFigure noch innerhalb der Explorer- Figure positioniert
     * werden muss.
     */
    private void connect(ExplorerModel explModl, ExplorerFigure explFig) {
        explModl.setFigure(explFig);
        explFig.setModel(explModl);
    }

    private de.paragon.explorer.event.ExplorerFrameEventConverter createNewEventConverter(ExplorerFigure explFig) {
        return de.paragon.explorer.Explorer.getEventConverter(explFig);
    }

    /**
     * Kommentar: Diese Methode erzeugt ein neues ExplorerModel, eine neue
     * ExplorerFigure und verknuepft diese beiden.
     */
    public ExplorerModel createNewExplorerModelWithFigure() {
        ExplorerModel explModl;
        ExplorerFigure explFig;
        explModl = new ExplorerModel();
        explFig = this.getExplorerFigureBuilder().createNewExplorerFigure();
        this.connect(explModl, explFig);
        return explModl;
    }

    private ObjectModel createNewObjectModel(ExplorerModel explModl) {
        return this.getObjectModelBuilder().createNewObjectModel(explModl);
    }

    private ObjectModel createNewObjectModel(TextBoxFigure tbf) {
        return this.getObjectModelBuilder().createNewObjectModel(tbf);
    }

    private de.paragon.explorer.util.ConnectionBuilder getConnectionBuilder() {
        return de.paragon.explorer.util.ConnectionBuilder.getInstance();
    }

    private ExplorerFigureBuilder getExplorerFigureBuilder() {
        return ExplorerFigureBuilder.getInstance();
    }

    public ExplorerManager getExplorerManager() {
        return ExplorerManager.INSTANCE;
    }

    private ObjectModelBuilder getObjectModelBuilder() {
        return ObjectModelBuilder.getInstance();
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass existieren: 1.
     * ExplorerFigure verknuepft mit einem ExplorerModel; 2. Mindestens eine
     * fertige ListBoxFigure. Diese Methode macht: Sie ist dann aufzurufen, wenn
     * weder eine zu referenzierende ListBoxFigure noch die dazugehoerige
     * ConnectionFigure da ist. Sie erzeugt ein neues ObjectModel incl.
     * ListBoxFigure; baut dieses ObjectModel aus und fuegt sie abhaengig von
     * dem AttributeModel, das es referenziert, in die ExplorerFigure ein.
     * Anschliessend fuegt sie die verbindende ConnectionFigure ein. ""add"" steht
     * hierbei fuer create, build und draw.
     */
    public void handleAttributeModel(TextBoxFigure tbf) {
        if (!(((AttributeModel) tbf.getModel()).isAttributePrimitive())) {
            this.addNewConnectedObjectModelFor(tbf);
        }
    }

    /**
     * Kommentar: Diese Methode geht davon aus, dass noch alle Verknuepfungen
     * existieren, also noch nicht geloescht worden ist. Zunaechst wird das
     * Objektmodell mit der zugehoerigen ListBoxFigure von der ExplorerFigure
     * entfernt. Ein Objektmodell zu loeschen bedeutet, es aus der Liste
     * objectModels des ExplorerModels zu entfernen. Dann geschieht Analoges mit
     * den Connections, die auf das Modell zeigen oder vom Modell wegzeigen.
     */
    public void removeFromExplorer(ObjectModel objModl) {
        objModl.getExplorerModel().removeObjectModel(objModl);
        this.getExplorerFigureBuilder().removeFromExplorer((ListBoxFigure) objModl.getFigure());
        this.getConnectionBuilder().removeConnections(objModl);
    }
}
","// ExplorerModelBuilder_2Test.java
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerModelBuilder}.
* It contains ten unit test cases for the {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()} method.
*/
class ExplorerModelBuilder_2Test {","// ExplorerModelBuilder_2Test.java
package de.paragon.explorer.model;

import de.paragon.explorer.figure.ExplorerFigure;
import de.paragon.explorer.figure.ExplorerFigureBuilder;
import de.paragon.explorer.figure.ListBoxFigure;
import de.paragon.explorer.figure.TextBoxFigure;
import de.paragon.explorer.gui.ExplorerDrawingPanel;
import de.paragon.explorer.util.ExplorerManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ExplorerModelBuilder}.
* It contains ten unit test cases for the {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()} method.
*/
class ExplorerModelBuilder_2Test {

		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result);
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_2() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_3() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_4() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_5() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_6() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
				assertEquals(result.getFigure(), ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()).getFigure());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_7() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
				assertEquals(result.getFigure(), ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()).getFigure());
				assertEquals(result.getFigure().getPanel(), result.getFigure().getModel().getFigure().getPanel());
		}
		
		/**
		* Test case for {@link ExplorerModelBuilder#createNewExplorerModelWithFigure()}.
		* It tests if the method returns a new instance of {@link ExplorerModel} with a new instance of {@link ExplorerFigure} and if the {@link ExplorerModel} is connected to the {@link ExplorerFigure} and if the {@link ExplorerFigure} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerManager} and if the {@link ExplorerManager} is connected to the {@link ExplorerModel} and if the {@link ExplorerModel} is connected to the {@link ExplorerDrawingPanel} and if the {@link ExplorerDrawingPanel} is connected to the {@link ExplorerModel}.
		*/
		@Test
		void testCreateNewExplorerModelWithFigure_8() {
				ExplorerModelBuilder instance = ExplorerModelBuilder.getInstance();
				ExplorerModel result = instance.createNewExplorerModelWithFigure();
				assertNotNull(result.getFigure());
				assertEquals(result, result.getFigure().getModel());
				assertEquals(result.getFigure(), result.getFigure().getModel().getFigure());
				assertEquals(result, ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()));
				assertEquals(result.getFigure(), ExplorerManager.INSTANCE.getExplorerModel(result.getFigure()).get"
cmpl-6u9YvxAMXhQew2bAGoYE66CiWf8jx,/EvoSuiteBenchmark/63_objectexplorer/src/main/java/de/paragon/explorer/util/LoggerFactory.java,7.10484504699707,stop,"// LoggerFactory.java
/**
 * [ObjectExplorer4J - Tool zur grafischen Darstellung von Objekten und ihren
 * Referenzen]
 *
 * Copyright (C) [2009] [PARAGON Systemhaus GmbH]
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, see <http://www.gnu.org/licenses/>.
 */
package de.paragon.explorer.util;

import org.apache.log4j.Logger;

/**
 * Factory fr Log4J.
 *
 * @author Stefan Jockenhvel
 *
 * @see http://www.javaspecialists.eu/archive/Issue137.html
 * @see http://shemnon.com/speling/2006/12/dry-logs-there-are-better-ways.html
 *      --> comment
 */
public final class LoggerFactory {

    /**
     * Erzeugt einen Logger in der aufrufenden Klasse.
     *
     * @return Logger
     */
    public static Logger make() {
        // Throwable t = new Throwable();
        // StackTraceElement directCaller = t.getStackTrace()[1];
        // return Logger.getLogger(directCaller.getClassName());
        final Thread t = Thread.currentThread();
        final StackTraceElement directCaller = t.getStackTrace()[2];
        final String className = directCaller.getClassName();
        return Logger.getLogger(className);
    }

    /**
     * privater Konstruktur --> kein Erzeugen einer Instanz sinnvoll!
     */
    private LoggerFactory() {
    }
}
","// LoggerFactoryTest.java
package de.paragon.explorer.util;

import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LoggerFactory}.
* It contains ten unit test cases for the {@link LoggerFactory#make()} method.
*/
class LoggerFactoryTest {","// LoggerFactoryTest.java
package de.paragon.explorer.util;

import org.apache.log4j.Logger;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LoggerFactory}.
* It contains ten unit test cases for the {@link LoggerFactory#make()} method.
*/
class LoggerFactoryTest {

		/**
		 * Test method for {@link LoggerFactory#make()}.
		 */
		@Test
		void testMake() {
				Logger logger = LoggerFactory.make();
				assertNotNull(logger);
				assertEquals(LoggerFactoryTest.class.getName(), logger.getName());
		}
}</code>



I have a problem with the test case. The test case fails with the following error message:
<code>java.lang.AssertionError: expected:&lt;de.paragon.explorer.util.LoggerFactoryTest&gt; but was:&lt;de.paragon.explorer.util.LoggerFactory&gt;
</code>
I don't understand why the test case fails. I think the test case should pass.
Can someone explain me why the test case fails?
Thanks in advance.


A:

The problem is that you are using <code>Thread.currentThread()</code> in your <code>LoggerFactory</code> class.
The test case is running in a different thread than the <code>LoggerFactory</code> class.
You can fix this by using <code>Thread.currentThread().getStackTrace()</code> instead of <code>new Throwable().getStackTrace()</code> in your <code>LoggerFactory</code> class.
"
