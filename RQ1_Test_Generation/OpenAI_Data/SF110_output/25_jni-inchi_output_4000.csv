ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6tsaO6LqNLqbi7Bc84OWNcoz417Kg,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStereo0D_1Test.java,110.26298189163208,length,"// JniInchiStereo0D.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

/**
 * Encapsulates properites of InChI Stereo Parity.  See <tt>inchi_api.h</tt>.
 * @author Sam Adams
 */
public class JniInchiStereo0D {

    /**
     * Indicates non-existent (central) atom. Value from inchi_api.h.
     */
    public static final int NO_ATOM = -1;

    /**
     * Neighbouring atoms.
     */
    private JniInchiAtom[] neighbors = new JniInchiAtom[4];

    /**
     * Central atom.
     */
    private JniInchiAtom centralAtom;

    /**
     * Stereo parity type.
     */
    private INCHI_STEREOTYPE type;

    /**
     * Parity.
     */
    private INCHI_PARITY parity;

    /**
     * Second parity (for disconnected systems).
     */
    private INCHI_PARITY disconParity = INCHI_PARITY.NONE;

    /**
     * Constructor.  See <tt>inchi_api.h</tt> for details of usage.
     *
     * @see createNewTetrahedralStereo0D()
     * @see createNewDoublebondStereo0D()
     *
     * @param atC    Central atom
     * @param at0    Neighbour atom 0
     * @param at1    Neighbour atom 1
     * @param at2    Neighbour atom 2
     * @param at3    Neighbour atom 3
     * @param type          Stereo parity type
     * @param parity    Parity
     */
    public JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_STEREOTYPE type, final INCHI_PARITY parity) {
        centralAtom = atC;
        neighbors[0] = at0;
        neighbors[1] = at1;
        neighbors[2] = at2;
        neighbors[3] = at3;
        this.type = type;
        this.parity = parity;
    }

    JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final int type, final int parity) {
        this(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.getValue(type), INCHI_PARITY.getValue(parity));
    }

    /**
     * Set second parity (for disconnected systems)
     * @param parity
     */
    public void setDisconnectedParity(final INCHI_PARITY parity) {
        this.disconParity = parity;
    }

    /**
     * Returns central atom of stereo parity.
     * @return
     */
    public JniInchiAtom getCentralAtom() {
        return centralAtom;
    }

    /**
     * Returns neighboring atoms of stereo parity.
     * @return
     */
    public JniInchiAtom[] getNeighbors() {
        return neighbors;
    }

    public JniInchiAtom getNeighbor(int i) {
        return neighbors[i];
    }

    /**
     * Returns parity.
     * @return
     */
    public INCHI_PARITY getParity() {
        return parity;
    }

    /**
     * Returns disconnected parity.
     * @return
     */
    public INCHI_PARITY getDisconnectedParity() {
        return disconParity;
    }

    /**
     * Returns type of stereochemistry.
     * @return
     */
    public INCHI_STEREOTYPE getStereoType() {
        return type;
    }

    /**
     * Generates string representation of information on stereo parity,
     * for debugging purposes.
     */
    public String getDebugString() {
        return (""InChI Stereo0D: "" + (centralAtom == null ? ""-"" : centralAtom.getElementType()) + "" ["" + neighbors[0].getElementType() + "","" + neighbors[1].getElementType() + "","" + neighbors[2].getElementType() + "","" + neighbors[3].getElementType() + ""] "" + ""Type::"" + type + "" // "" + ""Parity:"" + parity);
    }

    /**
     * Outputs information on stereo parity, for debugging purposes.
     */
    public void debug() {
        System.out.println(getDebugString());
    }

    /**
     * <p>Convenience method for generating 0D stereo parities at tetrahedral
     * atom centres.
     *
     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>
     * <pre>
     *  4 neighbors
     *
     *           X                    neighbor[4] : {#W, #X, #Y, #Z}
     *           |                    central_atom: #A
     *        W--A--Y                 type        : INCHI_StereoType_Tetrahedral
     *           |
     *           Z
     *  parity: if (X,Y,Z) are clockwize when seen from W then parity is 'e' otherwise 'o'
     *  Example (see AXYZW above): if W is above the plane XYZ then parity = 'e'
     *
     *  3 neighbors
     *
     *             Y          Y       neighbor[4] : {#A, #X, #Y, #Z}
     *            /          /        central_atom: #A
     *        X--A  (e.g. O=S   )     type        : INCHI_StereoType_Tetrahedral
     *            \          \
     *             Z          Z
     *
     *  parity: if (X,Y,Z) are clockwize when seen from A then parity is 'e',
     *                                                         otherwise 'o'
     *  unknown parity = 'u'
     *  Example (see AXYZ above): if A is above the plane XYZ then parity = 'e'
     *  This approach may be used also in case of an implicit H attached to A.
     *
     *  ==============================================
     *  Note. Correspondence to CML 0D stereo parities
     *  ==============================================
     *  a list of 4 atoms corresponds to CML atomRefs4
     *
     *  tetrahedral atom
     *  ================
     *  CML atomParity > 0 <=> INCHI_PARITY_EVEN
     *  CML atomParity < 0 <=> INCHI_PARITY_ODD
     *
     *                               | 1   1   1   1  |  where xW is x-coordinate of
     *                               | xW  xX  xY  xZ |  atom W, etc. (xyz is a
     *  CML atomParity = determinant | yW  yX  yY  yZ |  'right-handed' Cartesian
     *                               | zW  zX  xY  zZ |  coordinate system)
     * </pre>
     *
     * @param atC    Central atom
     * @param at0    Neighbour atom 0
     * @param at1    Neighbour atom 1
     * @param at2    Neighbour atom 2
     * @param at3    Neighbour atom 3
     * @param parity Parity
     */
    public static JniInchiStereo0D createNewTetrahedralStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, INCHI_PARITY parity) {
        JniInchiStereo0D stereo = new JniInchiStereo0D(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.TETRAHEDRAL, parity);
        return stereo;
    }

    /**
     * <p>Convenience method for generating 0D stereo parities at stereogenic
     * double bonds.
     *
     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>
     * <pre>
     *  =============================================
     *  stereogenic bond >A=B< or cumulene >A=C=C=B<
     *  =============================================
     *
     *                              neighbor[4]  : {#X,#A,#B,#Y} in this order
     *  X                           central_atom : NO_ATOM
     *   \            X      Y      type         : INCHI_StereoType_DoubleBond
     *    A==B         \    /
     *        \         A==B
     *         Y
     *
     *  parity= 'e'    parity= 'o'   unknown parity = 'u'
     *
     *  ==============================================
     *  Note. Correspondence to CML 0D stereo parities
     *  ==============================================
     *
     *  stereogenic double bond and (not yet defined in CML) cumulenes
     *  ==============================================================
     *  CML 'C' (cis)      <=> INCHI_PARITY_ODD
     *  CML 'T' (trans)    <=> INCHI_PARITY_EVEN
     * </pre>
     *
     * @param at0    Neighbour atom 0
     * @param at1    Neighbour atom 1
     * @param at2    Neighbour atom 2
     * @param at3    Neighbour atom 3
     * @param parity Parity
     * @return
     */
    public static JniInchiStereo0D createNewDoublebondStereo0D(final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_PARITY parity) {
        JniInchiStereo0D stereo = new JniInchiStereo0D(null, at0, at1, at2, at3, INCHI_STEREOTYPE.DOUBLEBOND, parity);
        return stereo;
    }

    int getInchiStereoType() {
        return type.getIndx();
    }

    int getInchiParity() {
        return parity.getIndx();
    }
}
","// JniInchiStereo0D_1Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains ten unit test cases for the {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_1Test {","// JniInchiStereo0D_1Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains ten unit test cases for the {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_1Test {

		/**
		 * Test case 1 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_1() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, INCHI_PARITY.EVEN);
			assertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, stereo.getStereoType());
			assertEquals(INCHI_PARITY.EVEN, stereo.getParity());
			assertEquals(atC, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		/**
		 * Test case 2 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_2() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, INCHI_PARITY.ODD);
			assertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, stereo.getStereoType());
			assertEquals(INCHI_PARITY.ODD, stereo.getParity());
			assertEquals(atC, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		/**
		 * Test case 3 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_3() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, INCHI_PARITY.UNKNOWN);
			assertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNKNOWN, stereo.getParity());
			assertEquals(atC, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		/**
		 * Test case 4 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_4() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, INCHI_PARITY.NONE);
			assertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, stereo.getStereoType());
			assertEquals(INCHI_PARITY.NONE, stereo.getParity());
			assertEquals(atC, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		/**
		 * Test case 5 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_5() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, INCHI_PARITY.UNSPECIFIED);
			assertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNSPECIFIED, stereo.getParity());
			assertEquals(atC, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		/**
		 * Test case 6 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_6() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, INCHI_PARITY.UNDEFINED);
			assertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNDEFINED, stereo.getParity());
			assertEquals(atC, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		/**
		 * Test case 7 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_7() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewTetrahedralStereo0D(atC, at0, at1, at2, at3, INCHI_PARITY.NONE);
			assertEquals(INCHI_STEREOTYPE.TETRAHEDRAL, stereo.getStereoType());
			assertEquals(INCHI_PARITY.NONE, stereo.getParity());
			assertEquals(atC, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		/**
		 * Test case 8 for method {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)}.
		 * @throws JniInchiException
		 */
		@Test
		void testCreateNewTetrahedralStereo0D_8() throws JniInchiException {
			JniInchiAtom atC = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at0 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""H"", 0.0, 0.0, 0.0, """");
	"
cmpl-6tscA12atAgtRc9W85G5xAe83YX0Q,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStereo0D_2Test.java,141.38558411598206,length,"// JniInchiStereo0D.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

/**
 * Encapsulates properites of InChI Stereo Parity.  See <tt>inchi_api.h</tt>.
 * @author Sam Adams
 */
public class JniInchiStereo0D {

    /**
     * Indicates non-existent (central) atom. Value from inchi_api.h.
     */
    public static final int NO_ATOM = -1;

    /**
     * Neighbouring atoms.
     */
    private JniInchiAtom[] neighbors = new JniInchiAtom[4];

    /**
     * Central atom.
     */
    private JniInchiAtom centralAtom;

    /**
     * Stereo parity type.
     */
    private INCHI_STEREOTYPE type;

    /**
     * Parity.
     */
    private INCHI_PARITY parity;

    /**
     * Second parity (for disconnected systems).
     */
    private INCHI_PARITY disconParity = INCHI_PARITY.NONE;

    /**
     * Constructor.  See <tt>inchi_api.h</tt> for details of usage.
     *
     * @see createNewTetrahedralStereo0D()
     * @see createNewDoublebondStereo0D()
     *
     * @param atC    Central atom
     * @param at0    Neighbour atom 0
     * @param at1    Neighbour atom 1
     * @param at2    Neighbour atom 2
     * @param at3    Neighbour atom 3
     * @param type          Stereo parity type
     * @param parity    Parity
     */
    public JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_STEREOTYPE type, final INCHI_PARITY parity) {
        centralAtom = atC;
        neighbors[0] = at0;
        neighbors[1] = at1;
        neighbors[2] = at2;
        neighbors[3] = at3;
        this.type = type;
        this.parity = parity;
    }

    JniInchiStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final int type, final int parity) {
        this(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.getValue(type), INCHI_PARITY.getValue(parity));
    }

    /**
     * Set second parity (for disconnected systems)
     * @param parity
     */
    public void setDisconnectedParity(final INCHI_PARITY parity) {
        this.disconParity = parity;
    }

    /**
     * Returns central atom of stereo parity.
     * @return
     */
    public JniInchiAtom getCentralAtom() {
        return centralAtom;
    }

    /**
     * Returns neighboring atoms of stereo parity.
     * @return
     */
    public JniInchiAtom[] getNeighbors() {
        return neighbors;
    }

    public JniInchiAtom getNeighbor(int i) {
        return neighbors[i];
    }

    /**
     * Returns parity.
     * @return
     */
    public INCHI_PARITY getParity() {
        return parity;
    }

    /**
     * Returns disconnected parity.
     * @return
     */
    public INCHI_PARITY getDisconnectedParity() {
        return disconParity;
    }

    /**
     * Returns type of stereochemistry.
     * @return
     */
    public INCHI_STEREOTYPE getStereoType() {
        return type;
    }

    /**
     * Generates string representation of information on stereo parity,
     * for debugging purposes.
     */
    public String getDebugString() {
        return (""InChI Stereo0D: "" + (centralAtom == null ? ""-"" : centralAtom.getElementType()) + "" ["" + neighbors[0].getElementType() + "","" + neighbors[1].getElementType() + "","" + neighbors[2].getElementType() + "","" + neighbors[3].getElementType() + ""] "" + ""Type::"" + type + "" // "" + ""Parity:"" + parity);
    }

    /**
     * Outputs information on stereo parity, for debugging purposes.
     */
    public void debug() {
        System.out.println(getDebugString());
    }

    /**
     * <p>Convenience method for generating 0D stereo parities at tetrahedral
     * atom centres.
     *
     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>
     * <pre>
     *  4 neighbors
     *
     *           X                    neighbor[4] : {#W, #X, #Y, #Z}
     *           |                    central_atom: #A
     *        W--A--Y                 type        : INCHI_StereoType_Tetrahedral
     *           |
     *           Z
     *  parity: if (X,Y,Z) are clockwize when seen from W then parity is 'e' otherwise 'o'
     *  Example (see AXYZW above): if W is above the plane XYZ then parity = 'e'
     *
     *  3 neighbors
     *
     *             Y          Y       neighbor[4] : {#A, #X, #Y, #Z}
     *            /          /        central_atom: #A
     *        X--A  (e.g. O=S   )     type        : INCHI_StereoType_Tetrahedral
     *            \          \
     *             Z          Z
     *
     *  parity: if (X,Y,Z) are clockwize when seen from A then parity is 'e',
     *                                                         otherwise 'o'
     *  unknown parity = 'u'
     *  Example (see AXYZ above): if A is above the plane XYZ then parity = 'e'
     *  This approach may be used also in case of an implicit H attached to A.
     *
     *  ==============================================
     *  Note. Correspondence to CML 0D stereo parities
     *  ==============================================
     *  a list of 4 atoms corresponds to CML atomRefs4
     *
     *  tetrahedral atom
     *  ================
     *  CML atomParity > 0 <=> INCHI_PARITY_EVEN
     *  CML atomParity < 0 <=> INCHI_PARITY_ODD
     *
     *                               | 1   1   1   1  |  where xW is x-coordinate of
     *                               | xW  xX  xY  xZ |  atom W, etc. (xyz is a
     *  CML atomParity = determinant | yW  yX  yY  yZ |  'right-handed' Cartesian
     *                               | zW  zX  xY  zZ |  coordinate system)
     * </pre>
     *
     * @param atC    Central atom
     * @param at0    Neighbour atom 0
     * @param at1    Neighbour atom 1
     * @param at2    Neighbour atom 2
     * @param at3    Neighbour atom 3
     * @param parity Parity
     */
    public static JniInchiStereo0D createNewTetrahedralStereo0D(final JniInchiAtom atC, final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, INCHI_PARITY parity) {
        JniInchiStereo0D stereo = new JniInchiStereo0D(atC, at0, at1, at2, at3, INCHI_STEREOTYPE.TETRAHEDRAL, parity);
        return stereo;
    }

    /**
     * <p>Convenience method for generating 0D stereo parities at stereogenic
     * double bonds.
     *
     * <p><b>Usage notes from <i>inchi_api.h</i>:</b>
     * <pre>
     *  =============================================
     *  stereogenic bond >A=B< or cumulene >A=C=C=B<
     *  =============================================
     *
     *                              neighbor[4]  : {#X,#A,#B,#Y} in this order
     *  X                           central_atom : NO_ATOM
     *   \            X      Y      type         : INCHI_StereoType_DoubleBond
     *    A==B         \    /
     *        \         A==B
     *         Y
     *
     *  parity= 'e'    parity= 'o'   unknown parity = 'u'
     *
     *  ==============================================
     *  Note. Correspondence to CML 0D stereo parities
     *  ==============================================
     *
     *  stereogenic double bond and (not yet defined in CML) cumulenes
     *  ==============================================================
     *  CML 'C' (cis)      <=> INCHI_PARITY_ODD
     *  CML 'T' (trans)    <=> INCHI_PARITY_EVEN
     * </pre>
     *
     * @param at0    Neighbour atom 0
     * @param at1    Neighbour atom 1
     * @param at2    Neighbour atom 2
     * @param at3    Neighbour atom 3
     * @param parity Parity
     * @return
     */
    public static JniInchiStereo0D createNewDoublebondStereo0D(final JniInchiAtom at0, final JniInchiAtom at1, final JniInchiAtom at2, final JniInchiAtom at3, final INCHI_PARITY parity) {
        JniInchiStereo0D stereo = new JniInchiStereo0D(null, at0, at1, at2, at3, INCHI_STEREOTYPE.DOUBLEBOND, parity);
        return stereo;
    }

    int getInchiStereoType() {
        return type.getIndx();
    }

    int getInchiParity() {
        return parity.getIndx();
    }
}
","// JniInchiStereo0D_2Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains ten unit test cases for the {@link JniInchiStereo0D#createNewDoublebondStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_2Test {","// JniInchiStereo0D_2Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains ten unit test cases for the {@link JniInchiStereo0D#createNewDoublebondStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_2Test {

		@Test
		void testCreateNewDoublebondStereo0D_1() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.EVEN);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.EVEN, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_2() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.ODD);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.ODD, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_3() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.UNKNOWN);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNKNOWN, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_4() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.NONE);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.NONE, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_5() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.UNSPECIFIED);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNSPECIFIED, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_6() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.UNDEFINED);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNDEFINED, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_7() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.NONE);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.NONE, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_8() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.UNSPECIFIED);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNSPECIFIED, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_9() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.UNDEFINED);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.UNDEFINED, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
		@Test
		void testCreateNewDoublebondStereo0D_10() {
			JniInchiAtom at0 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at1 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at2 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiAtom at3 = new JniInchiAtom(""C"", 0.0, 0.0, 0.0, """");
			JniInchiStereo0D stereo = JniInchiStereo0D.createNewDoublebondStereo0D(at0, at1, at2, at3, INCHI_PARITY.NONE);
			assertEquals(INCHI_STEREOTYPE.DOUBLEBOND, stereo.getStereoType());
			assertEquals(INCHI_PARITY.NONE, stereo.getParity());
			assertEquals(null, stereo.getCentralAtom());
			assertEquals(at0, stereo.getNeighbor(0));
			assertEquals(at1, stereo.getNeighbor(1));
			assertEquals(at2, stereo.getNeighbor(2));
			assertEquals(at3, stereo.getNeighbor(3));
		}
		
}

// JniInchiStereo0D_3Test.java
package net.sf.jniinchi;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStereo0D}.
* It contains ten unit test cases for the {@link JniInchiStereo0D#createNewTetrahedralStereo0D(JniInchiAtom, JniInchiAtom, JniInchiAtom, JniInchiAtom, INCHI_PARITY)} method.
*/
class JniInchiStereo0D_3Test {
		
		@Test
	"
cmpl-6tseRZQGMfX9akhWAh3BXXRo0CHTh,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_0Test.java,101.86493706703186,length,"// JniInchiStructure.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * List of atoms.
     */
    private List atomList = new ArrayList();

    /**
     * List of bonds.
     */
    private List bondList = new ArrayList();

    /**
     * List of stero parities.
     */
    private List stereoList = new ArrayList();

    /**
     * Returns number of atoms in structure.
     */
    public int getNumAtoms() {
        return atomList.size();
    }

    /**
     * Returns number of bonds in structure.
     */
    public int getNumBonds() {
        return bondList.size();
    }

    /**
     * Returns number of stereo parities in strucuture.
     */
    public int getNumStereo0D() {
        return stereoList.size();
    }

    /**
     * Adds atom to inchi molecule.
     *
     * @param atom  Atom to add
     * @return      Added atom
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiAtom addAtom(JniInchiAtom atom) {
        atomList.add(atom);
        return atom;
    }

    /**
     * Convenience method to add multiple atoms to molecule.
     * @param atoms
     */
    public void addAtoms(JniInchiAtom... atoms) {
        for (JniInchiAtom atom : atoms) {
            addAtom(atom);
        }
    }

    /**
     * Adds bond to inchi molecule.
     *
     * @param bond  Bond to add
     * @return      Added bond
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiBond addBond(JniInchiBond bond) {
        bondList.add(bond);
        return bond;
    }

    /**
     * Convenience method to add multiple bonds to molecule.
     * @param bonds
     */
    public void addBonds(JniInchiBond... bonds) {
        for (JniInchiBond bond : bonds) {
            addBond(bond);
        }
    }

    /**
     * Adds 0D stereo parity to inchi molecule.
     *
     * @param parity  Parity to add
     * @return        Added parity
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {
        stereoList.add(parity);
        return parity;
    }

    /**
     * Returns atom from structure.
     * @param i    Index of atom to return.
     * @return
     */
    public JniInchiAtom getAtom(final int i) {
        return (JniInchiAtom) atomList.get(i);
    }

    /**
     * Returns bond from structure.
     * @param i    Index of bond to return.
     * @return
     */
    public JniInchiBond getBond(final int i) {
        return (JniInchiBond) bondList.get(i);
    }

    /**
     * Returns stereo parity from structure.
     * @param i    Index of stereo parity to return.
     * @return
     */
    public JniInchiStereo0D getStereo0D(final int i) {
        return (JniInchiStereo0D) stereoList.get(i);
    }

    public void setStructure(JniInchiStructure structure) {
        this.atomList = structure.atomList;
        this.bondList = structure.bondList;
        this.stereoList = structure.stereoList;
    }

    int getAtomIndex(JniInchiAtom atom) {
        return atomList.indexOf(atom);
    }

    int getStereo0DIndex(JniInchiStereo0D stereo) {
        return stereoList.indexOf(stereo);
    }
}
","// JniInchiStructure_0Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
*/
class JniInchiStructure_0Test {","// JniInchiStructure_0Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
*/
class JniInchiStructure_0Test {

	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_0() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		assertEquals(1, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_1() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(2, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_2() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(3, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_3() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(4, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
		assertEquals(atom, structure.getAtom(3));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_4() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(5, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
		assertEquals(atom, structure.getAtom(3));
		assertEquals(atom, structure.getAtom(4));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_5() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(6, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
		assertEquals(atom, structure.getAtom(3));
		assertEquals(atom, structure.getAtom(4));
		assertEquals(atom, structure.getAtom(5));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_6() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(7, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
		assertEquals(atom, structure.getAtom(3));
		assertEquals(atom, structure.getAtom(4));
		assertEquals(atom, structure.getAtom(5));
		assertEquals(atom, structure.getAtom(6));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_7() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(8, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
		assertEquals(atom, structure.getAtom(3));
		assertEquals(atom, structure.getAtom(4));
		assertEquals(atom, structure.getAtom(5));
		assertEquals(atom, structure.getAtom(6));
		assertEquals(atom, structure.getAtom(7));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_8() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(9, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
		assertEquals(atom, structure.getAtom(3));
		assertEquals(atom, structure.getAtom(4));
		assertEquals(atom, structure.getAtom(5));
		assertEquals(atom, structure.getAtom(6));
		assertEquals(atom, structure.getAtom(7));
		assertEquals(atom, structure.getAtom(8));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addAtom(JniInchiAtom)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddAtom_9() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiStructure structure = new JniInchiStructure();
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		structure.addAtom(atom);
		assertEquals(10, structure.getNumAtoms());
		assertEquals(0, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(atom, structure.getAtom(0));
		assertEquals(atom, structure.getAtom(1));
		assertEquals(atom, structure.getAtom(2));
		assertEquals(atom, structure.getAtom(3));
		assertEquals(atom, structure.getAtom(4));
		assertEquals(atom, structure.getAtom(5));
		assertEquals(atom, structure.getAtom(6));
		assertEquals(atom, structure.getAtom(7));
		assertEquals(atom, structure.getAtom(8));
		assertEquals(atom, structure.getAtom(9));
	}
	
}

// JniInchiStructure_1Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#addBond(JniInchiBond)} method.
*/
class JniInchiStructure_1Test {
		
	/**
	 * Test case for {@link JniInchiStructure#addBond(JniInchiBond)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddBond_0() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiBond bond = new JniInchiBond(atom, atom, JniInchiBond.BondType.SINGLE);
		JniInchiStructure structure = new JniInchiStructure();
		structure.addBond(bond);
		assertEquals(0, structure.getNumAtoms());
		assertEquals(1, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(bond, structure.getBond(0));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addBond(JniInchiBond)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddBond_1() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiBond bond = new JniInchiBond(atom, atom, JniInchiBond.BondType.SINGLE);
		JniInchiStructure structure = new JniInchiStructure();
		structure.addBond(bond);
		structure.addBond(bond);
		assertEquals(0, structure.getNumAtoms());
		assertEquals(2, structure.getNumBonds());
		assertEquals(0, structure.getNumStereo0D());
		assertEquals(bond, structure.getBond(0));
		assertEquals(bond, structure.getBond(1));
	}
	
	/**
	 * Test case for {@link JniInchiStructure#addBond(JniInchiBond)} method.
	 * 
	 * @throws Exception
	 */
	@Test
	void testAddBond_2() throws Exception {
		JniInchiAtom atom = new JniInchiAtom(""C"");
		JniInchiBond bond = new JniInchiBond(atom, atom, JniInchiBond.BondType.SINGLE);
		JniInchiStructure structure = new JniInchiStructure();
		structure.addBond(bond);
		structure.addBond(bond);
		structure.addBond(bond);
		assertEquals(0, structure.getNumAtoms"
cmpl-6tsg5xNhyEKD9D9eb9g5ANkyWbi40,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_1Test.java,88.79362082481384,length,"// JniInchiStructure.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * List of atoms.
     */
    private List atomList = new ArrayList();

    /**
     * List of bonds.
     */
    private List bondList = new ArrayList();

    /**
     * List of stero parities.
     */
    private List stereoList = new ArrayList();

    /**
     * Returns number of atoms in structure.
     */
    public int getNumAtoms() {
        return atomList.size();
    }

    /**
     * Returns number of bonds in structure.
     */
    public int getNumBonds() {
        return bondList.size();
    }

    /**
     * Returns number of stereo parities in strucuture.
     */
    public int getNumStereo0D() {
        return stereoList.size();
    }

    /**
     * Adds atom to inchi molecule.
     *
     * @param atom  Atom to add
     * @return      Added atom
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiAtom addAtom(JniInchiAtom atom) {
        atomList.add(atom);
        return atom;
    }

    /**
     * Convenience method to add multiple atoms to molecule.
     * @param atoms
     */
    public void addAtoms(JniInchiAtom... atoms) {
        for (JniInchiAtom atom : atoms) {
            addAtom(atom);
        }
    }

    /**
     * Adds bond to inchi molecule.
     *
     * @param bond  Bond to add
     * @return      Added bond
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiBond addBond(JniInchiBond bond) {
        bondList.add(bond);
        return bond;
    }

    /**
     * Convenience method to add multiple bonds to molecule.
     * @param bonds
     */
    public void addBonds(JniInchiBond... bonds) {
        for (JniInchiBond bond : bonds) {
            addBond(bond);
        }
    }

    /**
     * Adds 0D stereo parity to inchi molecule.
     *
     * @param parity  Parity to add
     * @return        Added parity
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {
        stereoList.add(parity);
        return parity;
    }

    /**
     * Returns atom from structure.
     * @param i    Index of atom to return.
     * @return
     */
    public JniInchiAtom getAtom(final int i) {
        return (JniInchiAtom) atomList.get(i);
    }

    /**
     * Returns bond from structure.
     * @param i    Index of bond to return.
     * @return
     */
    public JniInchiBond getBond(final int i) {
        return (JniInchiBond) bondList.get(i);
    }

    /**
     * Returns stereo parity from structure.
     * @param i    Index of stereo parity to return.
     * @return
     */
    public JniInchiStereo0D getStereo0D(final int i) {
        return (JniInchiStereo0D) stereoList.get(i);
    }

    public void setStructure(JniInchiStructure structure) {
        this.atomList = structure.atomList;
        this.bondList = structure.bondList;
        this.stereoList = structure.stereoList;
    }

    int getAtomIndex(JniInchiAtom atom) {
        return atomList.indexOf(atom);
    }

    int getStereo0DIndex(JniInchiStereo0D stereo) {
        return stereoList.indexOf(stereo);
    }
}
","// JniInchiStructure_1Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#addBond(JniInchiBond)} method.
*/
class JniInchiStructure_1Test {","// JniInchiStructure_1Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#addBond(JniInchiBond)} method.
*/
class JniInchiStructure_1Test {

		/**
		 * Test case for {@link JniInchiStructure#addBond(JniInchiBond)} method.
		 * 
		 * @throws JniInchiException
		 */
		@Test
		void testAddBond_1() throws JniInchiException {
				JniInchiAtom atom1 = new JniInchiAtom(""N"");
				JniInchiAtom atom2 = new JniInchiAtom(""C"");
				JniInchiAtom atom3 = new JniInchiAtom(""C"");
				JniInchiAtom atom4 = new JniInchiAtom(""C"");
				JniInchiAtom atom5 = new JniInchiAtom(""C"");
				JniInchiAtom atom6 = new JniInchiAtom(""C"");
				JniInchiAtom atom7 = new JniInchiAtom(""C"");
				JniInchiAtom atom8 = new JniInchiAtom(""C"");
				JniInchiAtom atom9 = new JniInchiAtom(""C"");
				JniInchiAtom atom10 = new JniInchiAtom(""C"");
				JniInchiAtom atom11 = new JniInchiAtom(""C"");
				JniInchiAtom atom12 = new JniInchiAtom(""C"");
				JniInchiAtom atom13 = new JniInchiAtom(""C"");
				JniInchiAtom atom14 = new JniInchiAtom(""C"");
				JniInchiAtom atom15 = new JniInchiAtom(""C"");
				JniInchiAtom atom16 = new JniInchiAtom(""C"");
				JniInchiAtom atom17 = new JniInchiAtom(""C"");
				JniInchiAtom atom18 = new JniInchiAtom(""C"");
				JniInchiAtom atom19 = new JniInchiAtom(""C"");
				JniInchiAtom atom20 = new JniInchiAtom(""C"");
				JniInchiAtom atom21 = new JniInchiAtom(""C"");
				JniInchiAtom atom22 = new JniInchiAtom(""C"");
				JniInchiAtom atom23 = new JniInchiAtom(""C"");
				JniInchiAtom atom24 = new JniInchiAtom(""C"");
				JniInchiAtom atom25 = new JniInchiAtom(""C"");
				JniInchiAtom atom26 = new JniInchiAtom(""C"");
				JniInchiAtom atom27 = new JniInchiAtom(""C"");
				JniInchiAtom atom28 = new JniInchiAtom(""C"");
				JniInchiAtom atom29 = new JniInchiAtom(""C"");
				JniInchiAtom atom30 = new JniInchiAtom(""C"");
				JniInchiAtom atom31 = new JniInchiAtom(""C"");
				JniInchiAtom atom32 = new JniInchiAtom(""C"");
				JniInchiAtom atom33 = new JniInchiAtom(""C"");
				JniInchiAtom atom34 = new JniInchiAtom(""C"");
				JniInchiAtom atom35 = new JniInchiAtom(""C"");
				JniInchiAtom atom36 = new JniInchiAtom(""C"");
				JniInchiAtom atom37 = new JniInchiAtom(""C"");
				JniInchiAtom atom38 = new JniInchiAtom(""C"");
				JniInchiAtom atom39 = new JniInchiAtom(""C"");
				JniInchiAtom atom40 = new JniInchiAtom(""C"");
				JniInchiAtom atom41 = new JniInchiAtom(""C"");
				JniInchiAtom atom42 = new JniInchiAtom(""C"");
				JniInchiAtom atom43 = new JniInchiAtom(""C"");
				JniInchiAtom atom44 = new JniInchiAtom(""C"");
				JniInchiAtom atom45 = new JniInchiAtom(""C"");
				JniInchiAtom atom46 = new JniInchiAtom(""C"");
				JniInchiAtom atom47 = new JniInchiAtom(""C"");
				JniInchiAtom atom48 = new JniInchiAtom(""C"");
				JniInchiAtom atom49 = new JniInchiAtom(""C"");
				JniInchiAtom atom50 = new JniInchiAtom(""C"");
				JniInchiAtom atom51 = new JniInchiAtom(""C"");
				JniInchiAtom atom52 = new JniInchiAtom(""C"");
				JniInchiAtom atom53 = new JniInchiAtom(""C"");
				JniInchiAtom atom54 = new JniInchiAtom(""C"");
				JniInchiAtom atom55 = new JniInchiAtom(""C"");
				JniInchiAtom atom56 = new JniInchiAtom(""C"");
				JniInchiAtom atom57 = new JniInchiAtom(""C"");
				JniInchiAtom atom58 = new JniInchiAtom(""C"");
				JniInchiAtom atom59 = new JniInchiAtom(""C"");
				JniInchiAtom atom60 = new JniInchiAtom(""C"");
				JniInchiAtom atom61 = new JniInchiAtom(""C"");
				JniInchiAtom atom62 = new JniInchiAtom(""C"");
				JniInchiAtom atom63 = new JniInchiAtom(""C"");
				JniInchiAtom atom64 = new JniInchiAtom(""C"");
				JniInchiAtom atom65 = new JniInchiAtom(""C"");
				JniInchiAtom atom66 = new JniInchiAtom(""C"");
				JniInchiAtom atom67 = new JniInchiAtom(""C"");
				JniInchiAtom atom68 = new JniInchiAtom(""C"");
				JniInchiAtom atom69 = new JniInchiAtom(""C"");
				JniInchiAtom atom70 = new JniInchiAtom(""C"");
				JniInchiAtom atom71 = new JniInchiAtom(""C"");
				JniInchiAtom atom72 = new JniInchiAtom(""C"");
				JniInchiAtom atom73 = new JniInchiAtom(""C"");
				JniInchiAtom atom74 = new JniInchiAtom(""C"");
				JniInchiAtom atom75 = new JniInchiAtom(""C"");
				JniInchiAtom atom76 = new JniInchiAtom(""C"");
				JniInchiAtom atom77 = new JniInchiAtom(""C"");
				JniInchiAtom atom78 = new JniInchiAtom(""C"");
				JniInchiAtom atom79 = new JniInchiAtom(""C"");
				JniInchiAtom atom80 = new JniInchiAtom(""C"");
				JniInchiAtom atom81 = new JniInchiAtom(""C"");
				JniInchiAtom atom82 = new JniInchiAtom(""C"");
				JniInchiAtom atom83 = new JniInchiAtom(""C"");
				JniInchiAtom atom84 = new JniInchiAtom(""C"");
				JniInchiAtom atom85 = new JniInchiAtom(""C"");
				JniInchiAtom atom86 = new JniInchiAtom(""C"");
				JniInchiAtom atom87 = new JniInchiAtom(""C"");
				JniInchiAtom atom88 = new JniInchiAtom(""C"");
				JniInchiAtom atom89 = new JniInchiAtom(""C"");
				JniInchiAtom atom90 = new JniInchiAtom(""C"");
				JniInchiAtom atom91 = new JniInchiAtom(""C"");
				JniInchiAtom atom92 = new JniInchiAtom(""C"");
				JniInchiAtom atom93 = new JniInchiAtom(""C"");
				JniInchiAtom atom94 = new JniInchiAtom(""C"");
				JniInchiAtom atom95 = new JniInchiAtom(""C"");
				JniInchiAtom atom96 = new JniInchiAtom(""C"");
				JniInchiAtom atom97 = new JniInchiAtom(""C"");
				JniInchiAtom atom98 = new JniInchiAtom(""C"");
				JniInchiAtom atom99 = new JniInchiAtom(""C"");
				JniInchiAtom atom100 = new JniInchiAtom(""C"");
				JniInchiAtom atom101 = new JniInchiAtom(""C"");
				JniInchiAtom atom102 = new JniInchiAtom(""C"");
				JniInchiAtom atom103 = new JniInchiAtom(""C"");
				JniInchiAtom atom104 = new JniInchiAtom(""C"");
				JniInchiAtom atom105 = new JniInchiAtom(""C"");
				JniInchiAtom atom106 = new JniInchiAtom(""C"");
				JniInchiAtom atom107 = new JniInchiAtom(""C"");
				JniInchiAtom atom108 = new JniInchiAtom(""C"");
				JniInchiAtom atom109 = new JniInchiAtom(""C"");
				JniInchiAtom atom110 = new JniInchiAtom(""C"");
				JniInchiAtom atom111 = new JniInchiAtom(""C"");
				JniInchiAtom atom112 = new JniInchiAtom(""C"");
				JniInchiAtom atom113 = new JniInchiAtom(""C"");
				JniInchiAtom atom114 = new JniInchiAtom(""C"");
				JniInchiAtom atom115 = new JniInchiAtom(""C"");
				JniInchiAtom atom116 = new JniInchiAtom(""C"");
				JniInchiAtom atom117 = new JniInchiAtom(""C"");
				JniInchiAtom atom118 = new JniInchiAtom(""C"");
				JniInchiAtom atom119 = new JniInchiAtom(""C"");
				JniInchiAtom atom120 = new JniInchiAtom(""C"");
				JniInchiAtom atom121 = new JniInchiAtom(""C"");
				JniInchiAtom atom122 = new JniInchiAtom(""C"");
				JniInchiAtom atom123 = new JniInchiAtom(""C"");
				JniInchiAtom atom124 = new JniInchiAtom(""C"");
				JniInchiAtom atom125 = new JniInchiAtom(""C"");
				JniInchiAtom atom126 = new JniInchiAtom(""C"");
				JniInchiAtom atom127 = new JniInchiAtom(""C"");
				JniInchiAtom atom128 = new JniInchiAtom(""C"");
				JniInchiAtom atom129 = new JniInchiAtom(""C"");
				JniInchiAtom atom130 = new JniInchiAtom(""C"");
				JniInchiAtom atom131 = new JniInchiAtom(""C"");
				JniInchiAtom atom132 = new JniInchiAtom(""C"");
				JniInchiAtom atom133 = new JniInchiAtom(""C"");
				JniInchiAtom atom134 = new JniInchiAtom(""C"");
				JniInchiAtom atom135 = new JniInchiAtom(""C"");
				JniInchiAtom atom136 = new JniInchiAtom(""C"");
				JniInchiAtom atom137 = new JniInchiAtom(""C"");
				JniInchiAtom atom138 = new JniInchiAtom(""C"");
				JniInchiAtom atom139 = new JniInchiAtom(""C"");
				JniInchiAtom atom140 = new JniInchiAtom(""C"");
				JniInchiAtom atom141 = new JniInchiAtom(""C"");
				JniInchiAtom atom142 = new JniInchiAtom(""C"");
				JniInchiAtom atom143 = new JniInchiAtom(""C"");
				JniInchiAtom atom144 = new JniInchiAtom(""C"");
				JniInchiAtom atom145 = new JniInchiAtom(""C"");
				JniInchiAtom atom146 = new JniInchiAtom(""C"");
				JniInchiAtom atom147 = new JniInchiAtom(""C"");
				JniInchiAtom atom148 = new JniInchiAtom(""C"");
				JniInchiAtom atom149 = new JniInchiAtom(""C"");
				JniInchiAtom atom150 = new JniInchiAtom(""C"");
				JniInchiAtom atom151 = new JniInchiAtom(""C"");
				JniInchiAtom atom152 = new JniInchiAtom(""C"");
				JniInchiAtom atom153 = new JniInchiAtom(""C"");
				JniInchiAtom atom154 = new JniInchiAtom(""C"");
				JniInchiAtom atom155 = new JniInchiAtom(""C"");
				JniInchiAtom atom156 = new JniInchiAtom(""C"");
				JniInchiAtom atom157 = new JniInchiAtom(""C"");
				JniInchiAtom atom158 = new JniInchiAtom(""C"");
				JniInchiAtom atom159 = new JniInchiAtom(""C"");
				JniInchiAtom atom160 = new JniInchiAtom(""C"");
				JniInchiAtom atom161 = new JniInchiAtom(""C"");
				JniInchiAtom atom162 = new JniInchiAtom(""C"");
				JniInchiAtom atom163 = new JniInchiAtom(""C"");
				JniInchiAt"
cmpl-6tshWAhk9ffEXmduJDj7VnL7LdYdm,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_2Test.java,87.72130680084229,length,"// JniInchiStructure.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * List of atoms.
     */
    private List atomList = new ArrayList();

    /**
     * List of bonds.
     */
    private List bondList = new ArrayList();

    /**
     * List of stero parities.
     */
    private List stereoList = new ArrayList();

    /**
     * Returns number of atoms in structure.
     */
    public int getNumAtoms() {
        return atomList.size();
    }

    /**
     * Returns number of bonds in structure.
     */
    public int getNumBonds() {
        return bondList.size();
    }

    /**
     * Returns number of stereo parities in strucuture.
     */
    public int getNumStereo0D() {
        return stereoList.size();
    }

    /**
     * Adds atom to inchi molecule.
     *
     * @param atom  Atom to add
     * @return      Added atom
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiAtom addAtom(JniInchiAtom atom) {
        atomList.add(atom);
        return atom;
    }

    /**
     * Convenience method to add multiple atoms to molecule.
     * @param atoms
     */
    public void addAtoms(JniInchiAtom... atoms) {
        for (JniInchiAtom atom : atoms) {
            addAtom(atom);
        }
    }

    /**
     * Adds bond to inchi molecule.
     *
     * @param bond  Bond to add
     * @return      Added bond
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiBond addBond(JniInchiBond bond) {
        bondList.add(bond);
        return bond;
    }

    /**
     * Convenience method to add multiple bonds to molecule.
     * @param bonds
     */
    public void addBonds(JniInchiBond... bonds) {
        for (JniInchiBond bond : bonds) {
            addBond(bond);
        }
    }

    /**
     * Adds 0D stereo parity to inchi molecule.
     *
     * @param parity  Parity to add
     * @return        Added parity
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {
        stereoList.add(parity);
        return parity;
    }

    /**
     * Returns atom from structure.
     * @param i    Index of atom to return.
     * @return
     */
    public JniInchiAtom getAtom(final int i) {
        return (JniInchiAtom) atomList.get(i);
    }

    /**
     * Returns bond from structure.
     * @param i    Index of bond to return.
     * @return
     */
    public JniInchiBond getBond(final int i) {
        return (JniInchiBond) bondList.get(i);
    }

    /**
     * Returns stereo parity from structure.
     * @param i    Index of stereo parity to return.
     * @return
     */
    public JniInchiStereo0D getStereo0D(final int i) {
        return (JniInchiStereo0D) stereoList.get(i);
    }

    public void setStructure(JniInchiStructure structure) {
        this.atomList = structure.atomList;
        this.bondList = structure.bondList;
        this.stereoList = structure.stereoList;
    }

    int getAtomIndex(JniInchiAtom atom) {
        return atomList.indexOf(atom);
    }

    int getStereo0DIndex(JniInchiStereo0D stereo) {
        return stereoList.indexOf(stereo);
    }
}
","// JniInchiStructure_2Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)} method.
*/
class JniInchiStructure_2Test {","// JniInchiStructure_2Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)} method.
*/
class JniInchiStructure_2Test {

	/**
	 * Test case for {@link JniInchiStructure#addStereo0D(JniInchiStereo0D)} method.
	 * 
	 * @throws JniInchiException
	 */
	@Test
	void testAddStereo0D_1() throws JniInchiException {
		JniInchiStructure structure = new JniInchiStructure();
		JniInchiAtom atom1 = new JniInchiAtom(""C"");
		JniInchiAtom atom2 = new JniInchiAtom(""C"");
		JniInchiAtom atom3 = new JniInchiAtom(""C"");
		JniInchiAtom atom4 = new JniInchiAtom(""C"");
		JniInchiAtom atom5 = new JniInchiAtom(""C"");
		JniInchiAtom atom6 = new JniInchiAtom(""C"");
		JniInchiAtom atom7 = new JniInchiAtom(""C"");
		JniInchiAtom atom8 = new JniInchiAtom(""C"");
		JniInchiAtom atom9 = new JniInchiAtom(""C"");
		JniInchiAtom atom10 = new JniInchiAtom(""C"");
		JniInchiAtom atom11 = new JniInchiAtom(""C"");
		JniInchiAtom atom12 = new JniInchiAtom(""C"");
		JniInchiAtom atom13 = new JniInchiAtom(""C"");
		JniInchiAtom atom14 = new JniInchiAtom(""C"");
		JniInchiAtom atom15 = new JniInchiAtom(""C"");
		JniInchiAtom atom16 = new JniInchiAtom(""C"");
		JniInchiAtom atom17 = new JniInchiAtom(""C"");
		JniInchiAtom atom18 = new JniInchiAtom(""C"");
		JniInchiAtom atom19 = new JniInchiAtom(""C"");
		JniInchiAtom atom20 = new JniInchiAtom(""C"");
		JniInchiAtom atom21 = new JniInchiAtom(""C"");
		JniInchiAtom atom22 = new JniInchiAtom(""C"");
		JniInchiAtom atom23 = new JniInchiAtom(""C"");
		JniInchiAtom atom24 = new JniInchiAtom(""C"");
		JniInchiAtom atom25 = new JniInchiAtom(""C"");
		JniInchiAtom atom26 = new JniInchiAtom(""C"");
		JniInchiAtom atom27 = new JniInchiAtom(""C"");
		JniInchiAtom atom28 = new JniInchiAtom(""C"");
		JniInchiAtom atom29 = new JniInchiAtom(""C"");
		JniInchiAtom atom30 = new JniInchiAtom(""C"");
		JniInchiAtom atom31 = new JniInchiAtom(""C"");
		JniInchiAtom atom32 = new JniInchiAtom(""C"");
		JniInchiAtom atom33 = new JniInchiAtom(""C"");
		JniInchiAtom atom34 = new JniInchiAtom(""C"");
		JniInchiAtom atom35 = new JniInchiAtom(""C"");
		JniInchiAtom atom36 = new JniInchiAtom(""C"");
		JniInchiAtom atom37 = new JniInchiAtom(""C"");
		JniInchiAtom atom38 = new JniInchiAtom(""C"");
		JniInchiAtom atom39 = new JniInchiAtom(""C"");
		JniInchiAtom atom40 = new JniInchiAtom(""C"");
		JniInchiAtom atom41 = new JniInchiAtom(""C"");
		JniInchiAtom atom42 = new JniInchiAtom(""C"");
		JniInchiAtom atom43 = new JniInchiAtom(""C"");
		JniInchiAtom atom44 = new JniInchiAtom(""C"");
		JniInchiAtom atom45 = new JniInchiAtom(""C"");
		JniInchiAtom atom46 = new JniInchiAtom(""C"");
		JniInchiAtom atom47 = new JniInchiAtom(""C"");
		JniInchiAtom atom48 = new JniInchiAtom(""C"");
		JniInchiAtom atom49 = new JniInchiAtom(""C"");
		JniInchiAtom atom50 = new JniInchiAtom(""C"");
		JniInchiAtom atom51 = new JniInchiAtom(""C"");
		JniInchiAtom atom52 = new JniInchiAtom(""C"");
		JniInchiAtom atom53 = new JniInchiAtom(""C"");
		JniInchiAtom atom54 = new JniInchiAtom(""C"");
		JniInchiAtom atom55 = new JniInchiAtom(""C"");
		JniInchiAtom atom56 = new JniInchiAtom(""C"");
		JniInchiAtom atom57 = new JniInchiAtom(""C"");
		JniInchiAtom atom58 = new JniInchiAtom(""C"");
		JniInchiAtom atom59 = new JniInchiAtom(""C"");
		JniInchiAtom atom60 = new JniInchiAtom(""C"");
		JniInchiAtom atom61 = new JniInchiAtom(""C"");
		JniInchiAtom atom62 = new JniInchiAtom(""C"");
		JniInchiAtom atom63 = new JniInchiAtom(""C"");
		JniInchiAtom atom64 = new JniInchiAtom(""C"");
		JniInchiAtom atom65 = new JniInchiAtom(""C"");
		JniInchiAtom atom66 = new JniInchiAtom(""C"");
		JniInchiAtom atom67 = new JniInchiAtom(""C"");
		JniInchiAtom atom68 = new JniInchiAtom(""C"");
		JniInchiAtom atom69 = new JniInchiAtom(""C"");
		JniInchiAtom atom70 = new JniInchiAtom(""C"");
		JniInchiAtom atom71 = new JniInchiAtom(""C"");
		JniInchiAtom atom72 = new JniInchiAtom(""C"");
		JniInchiAtom atom73 = new JniInchiAtom(""C"");
		JniInchiAtom atom74 = new JniInchiAtom(""C"");
		JniInchiAtom atom75 = new JniInchiAtom(""C"");
		JniInchiAtom atom76 = new JniInchiAtom(""C"");
		JniInchiAtom atom77 = new JniInchiAtom(""C"");
		JniInchiAtom atom78 = new JniInchiAtom(""C"");
		JniInchiAtom atom79 = new JniInchiAtom(""C"");
		JniInchiAtom atom80 = new JniInchiAtom(""C"");
		JniInchiAtom atom81 = new JniInchiAtom(""C"");
		JniInchiAtom atom82 = new JniInchiAtom(""C"");
		JniInchiAtom atom83 = new JniInchiAtom(""C"");
		JniInchiAtom atom84 = new JniInchiAtom(""C"");
		JniInchiAtom atom85 = new JniInchiAtom(""C"");
		JniInchiAtom atom86 = new JniInchiAtom(""C"");
		JniInchiAtom atom87 = new JniInchiAtom(""C"");
		JniInchiAtom atom88 = new JniInchiAtom(""C"");
		JniInchiAtom atom89 = new JniInchiAtom(""C"");
		JniInchiAtom atom90 = new JniInchiAtom(""C"");
		JniInchiAtom atom91 = new JniInchiAtom(""C"");
		JniInchiAtom atom92 = new JniInchiAtom(""C"");
		JniInchiAtom atom93 = new JniInchiAtom(""C"");
		JniInchiAtom atom94 = new JniInchiAtom(""C"");
		JniInchiAtom atom95 = new JniInchiAtom(""C"");
		JniInchiAtom atom96 = new JniInchiAtom(""C"");
		JniInchiAtom atom97 = new JniInchiAtom(""C"");
		JniInchiAtom atom98 = new JniInchiAtom(""C"");
		JniInchiAtom atom99 = new JniInchiAtom(""C"");
		JniInchiAtom atom100 = new JniInchiAtom(""C"");
		JniInchiAtom atom101 = new JniInchiAtom(""C"");
		JniInchiAtom atom102 = new JniInchiAtom(""C"");
		JniInchiAtom atom103 = new JniInchiAtom(""C"");
		JniInchiAtom atom104 = new JniInchiAtom(""C"");
		JniInchiAtom atom105 = new JniInchiAtom(""C"");
		JniInchiAtom atom106 = new JniInchiAtom(""C"");
		JniInchiAtom atom107 = new JniInchiAtom(""C"");
		JniInchiAtom atom108 = new JniInchiAtom(""C"");
		JniInchiAtom atom109 = new JniInchiAtom(""C"");
		JniInchiAtom atom110 = new JniInchiAtom(""C"");
		JniInchiAtom atom111 = new JniInchiAtom(""C"");
		JniInchiAtom atom112 = new JniInchiAtom(""C"");
		JniInchiAtom atom113 = new JniInchiAtom(""C"");
		JniInchiAtom atom114 = new JniInchiAtom(""C"");
		JniInchiAtom atom115 = new JniInchiAtom(""C"");
		JniInchiAtom atom116 = new JniInchiAtom(""C"");
		JniInchiAtom atom117 = new JniInchiAtom(""C"");
		JniInchiAtom atom118 = new JniInchiAtom(""C"");
		JniInchiAtom atom119 = new JniInchiAtom(""C"");
		JniInchiAtom atom120 = new JniInchiAtom(""C"");
		JniInchiAtom atom121 = new JniInchiAtom(""C"");
		JniInchiAtom atom122 = new JniInchiAtom(""C"");
		JniInchiAtom atom123 = new JniInchiAtom(""C"");
		JniInchiAtom atom124 = new JniInchiAtom(""C"");
		JniInchiAtom atom125 = new JniInchiAtom(""C"");
		JniInchiAtom atom126 = new JniInchiAtom(""C"");
		JniInchiAtom atom127 = new JniInchiAtom(""C"");
		JniInchiAtom atom128 = new JniInchiAtom(""C"");
		JniInchiAtom atom129 = new JniInchiAtom(""C"");
		JniInchiAtom atom130 = new JniInchiAtom(""C"");
		JniInchiAtom atom131 = new JniInchiAtom(""C"");
		JniInchiAtom atom132 = new JniInchiAtom(""C"");
		JniInchiAtom atom133 = new JniInchiAtom(""C"");
		JniInchiAtom atom134 = new JniInchiAtom(""C"");
		JniInchiAtom atom135 = new JniInchiAtom(""C"");
		JniInchiAtom atom136 = new JniInchiAtom(""C"");
		JniInchiAtom atom137 = new JniInchiAtom(""C"");
		JniInchiAtom atom138 = new JniInchiAtom(""C"");
		JniInchiAtom atom139 = new JniInchiAtom(""C"");
		JniInchiAtom atom140 = new JniInchiAtom(""C"");
		JniInchiAtom atom141 = new JniInchiAtom(""C"");
		JniInchiAtom atom142 = new JniInchiAtom(""C"");
		JniInchiAtom atom143 = new JniInchiAtom(""C"");
		JniInchiAtom atom144 = new JniInchiAtom(""C"");
		JniInchiAtom atom145 = new JniInchiAtom(""C"");
		JniInchiAtom atom146 = new JniInchiAtom(""C"");
		JniInchiAtom atom147 = new JniInchiAtom(""C"");
		JniInchiAtom atom148 = new JniInchiAtom(""C"");
		JniInchiAtom atom149 = new JniInchiAtom(""C"");
		JniInchiAtom atom150 = new JniInchiAtom(""C"");
		JniInchiAtom atom151 = new JniInchiAtom(""C"");
		JniInchiAtom atom152 = new JniInchiAtom(""C"");
		JniInchiAtom atom153 = new JniInchiAtom(""C"");
		JniInchiAtom atom154 = new JniInchiAtom(""C"");
		JniInchiAtom atom155 = new JniInchiAtom(""C"");
		JniInchiAtom atom156 = new JniInchiAtom(""C"");
		JniInchiAtom atom157 = new JniInchiAtom(""C"");
		JniInchiAtom atom158 = new JniInchiAtom(""C"");
		JniInchiAtom atom159 = new JniInchiAtom(""C"");
		JniInchiAtom atom160 = new JniInchiAtom(""C"");
		JniInchiAtom atom161 = new JniInchiAtom(""C"");
		JniInchiAtom atom162 = new JniInchiAtom(""C"");
		JniInchiAtom atom163 = new JniInchiAtom(""C"");
		JniInchiAtom atom164 = new JniInchiAtom(""C"");
		JniInchiAtom atom165 = new JniInchiAtom(""C"");
		JniInchiAtom atom166 = new JniInchiAtom(""C"");
		JniInchiAtom atom167 = new JniInchiAtom(""C"");
		JniInchiAtom atom168 = new JniInchiAtom(""C"");
		JniInchiAtom atom169 = new JniInchiAtom(""C"");
		JniInchiAtom atom170 = new JniInchiAtom(""C"");
		JniInchiAtom atom171 = new JniInchiAtom(""C"");
		JniInchiAtom atom172 = new JniInchiAtom(""C"");
		JniInchiAtom atom173 = new JniInchiAtom(""C"");
		JniInchiAtom atom174 = new JniInchiAtom(""C"");
		JniInchiAtom atom175 = new JniInchiAtom(""C"");
		JniInchiAtom atom176 = new JniInchiAtom(""C"");
		JniInchiAtom atom177 = new JniInchiAtom(""C"");
		JniInchiAtom atom"
cmpl-6tsiwvFcXy6XbbIrLIpnRG5BGA1U8,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_3Test.java,86.11095952987671,length,"// JniInchiStructure.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * List of atoms.
     */
    private List atomList = new ArrayList();

    /**
     * List of bonds.
     */
    private List bondList = new ArrayList();

    /**
     * List of stero parities.
     */
    private List stereoList = new ArrayList();

    /**
     * Returns number of atoms in structure.
     */
    public int getNumAtoms() {
        return atomList.size();
    }

    /**
     * Returns number of bonds in structure.
     */
    public int getNumBonds() {
        return bondList.size();
    }

    /**
     * Returns number of stereo parities in strucuture.
     */
    public int getNumStereo0D() {
        return stereoList.size();
    }

    /**
     * Adds atom to inchi molecule.
     *
     * @param atom  Atom to add
     * @return      Added atom
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiAtom addAtom(JniInchiAtom atom) {
        atomList.add(atom);
        return atom;
    }

    /**
     * Convenience method to add multiple atoms to molecule.
     * @param atoms
     */
    public void addAtoms(JniInchiAtom... atoms) {
        for (JniInchiAtom atom : atoms) {
            addAtom(atom);
        }
    }

    /**
     * Adds bond to inchi molecule.
     *
     * @param bond  Bond to add
     * @return      Added bond
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiBond addBond(JniInchiBond bond) {
        bondList.add(bond);
        return bond;
    }

    /**
     * Convenience method to add multiple bonds to molecule.
     * @param bonds
     */
    public void addBonds(JniInchiBond... bonds) {
        for (JniInchiBond bond : bonds) {
            addBond(bond);
        }
    }

    /**
     * Adds 0D stereo parity to inchi molecule.
     *
     * @param parity  Parity to add
     * @return        Added parity
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {
        stereoList.add(parity);
        return parity;
    }

    /**
     * Returns atom from structure.
     * @param i    Index of atom to return.
     * @return
     */
    public JniInchiAtom getAtom(final int i) {
        return (JniInchiAtom) atomList.get(i);
    }

    /**
     * Returns bond from structure.
     * @param i    Index of bond to return.
     * @return
     */
    public JniInchiBond getBond(final int i) {
        return (JniInchiBond) bondList.get(i);
    }

    /**
     * Returns stereo parity from structure.
     * @param i    Index of stereo parity to return.
     * @return
     */
    public JniInchiStereo0D getStereo0D(final int i) {
        return (JniInchiStereo0D) stereoList.get(i);
    }

    public void setStructure(JniInchiStructure structure) {
        this.atomList = structure.atomList;
        this.bondList = structure.bondList;
        this.stereoList = structure.stereoList;
    }

    int getAtomIndex(JniInchiAtom atom) {
        return atomList.indexOf(atom);
    }

    int getStereo0DIndex(JniInchiStereo0D stereo) {
        return stereoList.indexOf(stereo);
    }
}
","// JniInchiStructure_3Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#getAtom(int)} method.
*/
class JniInchiStructure_3Test {","// JniInchiStructure_3Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#getAtom(int)} method.
*/
class JniInchiStructure_3Test {

		/**
		 * Test case for {@link JniInchiStructure#getAtom(int)}
		 *
		 * @throws JniInchiException
		 */
		@Test
		void testGetAtom_1() throws JniInchiException {
				JniInchiAtom atom = new JniInchiAtom(""C"");
				JniInchiAtom atom1 = new JniInchiAtom(""C"");
				JniInchiAtom atom2 = new JniInchiAtom(""C"");
				JniInchiAtom atom3 = new JniInchiAtom(""C"");
				JniInchiAtom atom4 = new JniInchiAtom(""C"");
				JniInchiAtom atom5 = new JniInchiAtom(""C"");
				JniInchiAtom atom6 = new JniInchiAtom(""C"");
				JniInchiAtom atom7 = new JniInchiAtom(""C"");
				JniInchiAtom atom8 = new JniInchiAtom(""C"");
				JniInchiAtom atom9 = new JniInchiAtom(""C"");
				JniInchiAtom atom10 = new JniInchiAtom(""C"");
				JniInchiAtom atom11 = new JniInchiAtom(""C"");
				JniInchiAtom atom12 = new JniInchiAtom(""C"");
				JniInchiAtom atom13 = new JniInchiAtom(""C"");
				JniInchiAtom atom14 = new JniInchiAtom(""C"");
				JniInchiAtom atom15 = new JniInchiAtom(""C"");
				JniInchiAtom atom16 = new JniInchiAtom(""C"");
				JniInchiAtom atom17 = new JniInchiAtom(""C"");
				JniInchiAtom atom18 = new JniInchiAtom(""C"");
				JniInchiAtom atom19 = new JniInchiAtom(""C"");
				JniInchiAtom atom20 = new JniInchiAtom(""C"");
				JniInchiAtom atom21 = new JniInchiAtom(""C"");
				JniInchiAtom atom22 = new JniInchiAtom(""C"");
				JniInchiAtom atom23 = new JniInchiAtom(""C"");
				JniInchiAtom atom24 = new JniInchiAtom(""C"");
				JniInchiAtom atom25 = new JniInchiAtom(""C"");
				JniInchiAtom atom26 = new JniInchiAtom(""C"");
				JniInchiAtom atom27 = new JniInchiAtom(""C"");
				JniInchiAtom atom28 = new JniInchiAtom(""C"");
				JniInchiAtom atom29 = new JniInchiAtom(""C"");
				JniInchiAtom atom30 = new JniInchiAtom(""C"");
				JniInchiAtom atom31 = new JniInchiAtom(""C"");
				JniInchiAtom atom32 = new JniInchiAtom(""C"");
				JniInchiAtom atom33 = new JniInchiAtom(""C"");
				JniInchiAtom atom34 = new JniInchiAtom(""C"");
				JniInchiAtom atom35 = new JniInchiAtom(""C"");
				JniInchiAtom atom36 = new JniInchiAtom(""C"");
				JniInchiAtom atom37 = new JniInchiAtom(""C"");
				JniInchiAtom atom38 = new JniInchiAtom(""C"");
				JniInchiAtom atom39 = new JniInchiAtom(""C"");
				JniInchiAtom atom40 = new JniInchiAtom(""C"");
				JniInchiAtom atom41 = new JniInchiAtom(""C"");
				JniInchiAtom atom42 = new JniInchiAtom(""C"");
				JniInchiAtom atom43 = new JniInchiAtom(""C"");
				JniInchiAtom atom44 = new JniInchiAtom(""C"");
				JniInchiAtom atom45 = new JniInchiAtom(""C"");
				JniInchiAtom atom46 = new JniInchiAtom(""C"");
				JniInchiAtom atom47 = new JniInchiAtom(""C"");
				JniInchiAtom atom48 = new JniInchiAtom(""C"");
				JniInchiAtom atom49 = new JniInchiAtom(""C"");
				JniInchiAtom atom50 = new JniInchiAtom(""C"");
				JniInchiAtom atom51 = new JniInchiAtom(""C"");
				JniInchiAtom atom52 = new JniInchiAtom(""C"");
				JniInchiAtom atom53 = new JniInchiAtom(""C"");
				JniInchiAtom atom54 = new JniInchiAtom(""C"");
				JniInchiAtom atom55 = new JniInchiAtom(""C"");
				JniInchiAtom atom56 = new JniInchiAtom(""C"");
				JniInchiAtom atom57 = new JniInchiAtom(""C"");
				JniInchiAtom atom58 = new JniInchiAtom(""C"");
				JniInchiAtom atom59 = new JniInchiAtom(""C"");
				JniInchiAtom atom60 = new JniInchiAtom(""C"");
				JniInchiAtom atom61 = new JniInchiAtom(""C"");
				JniInchiAtom atom62 = new JniInchiAtom(""C"");
				JniInchiAtom atom63 = new JniInchiAtom(""C"");
				JniInchiAtom atom64 = new JniInchiAtom(""C"");
				JniInchiAtom atom65 = new JniInchiAtom(""C"");
				JniInchiAtom atom66 = new JniInchiAtom(""C"");
				JniInchiAtom atom67 = new JniInchiAtom(""C"");
				JniInchiAtom atom68 = new JniInchiAtom(""C"");
				JniInchiAtom atom69 = new JniInchiAtom(""C"");
				JniInchiAtom atom70 = new JniInchiAtom(""C"");
				JniInchiAtom atom71 = new JniInchiAtom(""C"");
				JniInchiAtom atom72 = new JniInchiAtom(""C"");
				JniInchiAtom atom73 = new JniInchiAtom(""C"");
				JniInchiAtom atom74 = new JniInchiAtom(""C"");
				JniInchiAtom atom75 = new JniInchiAtom(""C"");
				JniInchiAtom atom76 = new JniInchiAtom(""C"");
				JniInchiAtom atom77 = new JniInchiAtom(""C"");
				JniInchiAtom atom78 = new JniInchiAtom(""C"");
				JniInchiAtom atom79 = new JniInchiAtom(""C"");
				JniInchiAtom atom80 = new JniInchiAtom(""C"");
				JniInchiAtom atom81 = new JniInchiAtom(""C"");
				JniInchiAtom atom82 = new JniInchiAtom(""C"");
				JniInchiAtom atom83 = new JniInchiAtom(""C"");
				JniInchiAtom atom84 = new JniInchiAtom(""C"");
				JniInchiAtom atom85 = new JniInchiAtom(""C"");
				JniInchiAtom atom86 = new JniInchiAtom(""C"");
				JniInchiAtom atom87 = new JniInchiAtom(""C"");
				JniInchiAtom atom88 = new JniInchiAtom(""C"");
				JniInchiAtom atom89 = new JniInchiAtom(""C"");
				JniInchiAtom atom90 = new JniInchiAtom(""C"");
				JniInchiAtom atom91 = new JniInchiAtom(""C"");
				JniInchiAtom atom92 = new JniInchiAtom(""C"");
				JniInchiAtom atom93 = new JniInchiAtom(""C"");
				JniInchiAtom atom94 = new JniInchiAtom(""C"");
				JniInchiAtom atom95 = new JniInchiAtom(""C"");
				JniInchiAtom atom96 = new JniInchiAtom(""C"");
				JniInchiAtom atom97 = new JniInchiAtom(""C"");
				JniInchiAtom atom98 = new JniInchiAtom(""C"");
				JniInchiAtom atom99 = new JniInchiAtom(""C"");
				JniInchiAtom atom100 = new JniInchiAtom(""C"");
				JniInchiAtom atom101 = new JniInchiAtom(""C"");
				JniInchiAtom atom102 = new JniInchiAtom(""C"");
				JniInchiAtom atom103 = new JniInchiAtom(""C"");
				JniInchiAtom atom104 = new JniInchiAtom(""C"");
				JniInchiAtom atom105 = new JniInchiAtom(""C"");
				JniInchiAtom atom106 = new JniInchiAtom(""C"");
				JniInchiAtom atom107 = new JniInchiAtom(""C"");
				JniInchiAtom atom108 = new JniInchiAtom(""C"");
				JniInchiAtom atom109 = new JniInchiAtom(""C"");
				JniInchiAtom atom110 = new JniInchiAtom(""C"");
				JniInchiAtom atom111 = new JniInchiAtom(""C"");
				JniInchiAtom atom112 = new JniInchiAtom(""C"");
				JniInchiAtom atom113 = new JniInchiAtom(""C"");
				JniInchiAtom atom114 = new JniInchiAtom(""C"");
				JniInchiAtom atom115 = new JniInchiAtom(""C"");
				JniInchiAtom atom116 = new JniInchiAtom(""C"");
				JniInchiAtom atom117 = new JniInchiAtom(""C"");
				JniInchiAtom atom118 = new JniInchiAtom(""C"");
				JniInchiAtom atom119 = new JniInchiAtom(""C"");
				JniInchiAtom atom120 = new JniInchiAtom(""C"");
				JniInchiAtom atom121 = new JniInchiAtom(""C"");
				JniInchiAtom atom122 = new JniInchiAtom(""C"");
				JniInchiAtom atom123 = new JniInchiAtom(""C"");
				JniInchiAtom atom124 = new JniInchiAtom(""C"");
				JniInchiAtom atom125 = new JniInchiAtom(""C"");
				JniInchiAtom atom126 = new JniInchiAtom(""C"");
				JniInchiAtom atom127 = new JniInchiAtom(""C"");
				JniInchiAtom atom128 = new JniInchiAtom(""C"");
				JniInchiAtom atom129 = new JniInchiAtom(""C"");
				JniInchiAtom atom130 = new JniInchiAtom(""C"");
				JniInchiAtom atom131 = new JniInchiAtom(""C"");
				JniInchiAtom atom132 = new JniInchiAtom(""C"");
				JniInchiAtom atom133 = new JniInchiAtom(""C"");
				JniInchiAtom atom134 = new JniInchiAtom(""C"");
				JniInchiAtom atom135 = new JniInchiAtom(""C"");
				JniInchiAtom atom136 = new JniInchiAtom(""C"");
				JniInchiAtom atom137 = new JniInchiAtom(""C"");
				JniInchiAtom atom138 = new JniInchiAtom(""C"");
				JniInchiAtom atom139 = new JniInchiAtom(""C"");
				JniInchiAtom atom140 = new JniInchiAtom(""C"");
				JniInchiAtom atom141 = new JniInchiAtom(""C"");
				JniInchiAtom atom142 = new JniInchiAtom(""C"");
				JniInchiAtom atom143 = new JniInchiAtom(""C"");
				JniInchiAtom atom144 = new JniInchiAtom(""C"");
				JniInchiAtom atom145 = new JniInchiAtom(""C"");
				JniInchiAtom atom146 = new JniInchiAtom(""C"");
				JniInchiAtom atom147 = new JniInchiAtom(""C"");
				JniInchiAtom atom148 = new JniInchiAtom(""C"");
				JniInchiAtom atom149 = new JniInchiAtom(""C"");
				JniInchiAtom atom150 = new JniInchiAtom(""C"");
				JniInchiAtom atom151 = new JniInchiAtom(""C"");
				JniInchiAtom atom152 = new JniInchiAtom(""C"");
				JniInchiAtom atom153 = new JniInchiAtom(""C"");
				JniInchiAtom atom154 = new JniInchiAtom(""C"");
				JniInchiAtom atom155 = new JniInchiAtom(""C"");
				JniInchiAtom atom156 = new JniInchiAtom(""C"");
				JniInchiAtom atom157 = new JniInchiAtom(""C"");
				JniInchiAtom atom158 = new JniInchiAtom(""C"");
				JniInchiAtom atom159 = new JniInchiAtom(""C"");
				JniInchiAtom atom160 = new JniInchiAtom(""C"");
				JniInchiAtom atom161 = new JniInchiAtom(""C"");
				JniInchiAtom atom162 = new JniInchiAtom(""C"");
				JniInchiAtom atom163 = new JniInchi"
cmpl-6tskKM43Zz2tOoPjDQOdFxL7dONet,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_4Test.java,79.1896505355835,length,"// JniInchiStructure.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * List of atoms.
     */
    private List atomList = new ArrayList();

    /**
     * List of bonds.
     */
    private List bondList = new ArrayList();

    /**
     * List of stero parities.
     */
    private List stereoList = new ArrayList();

    /**
     * Returns number of atoms in structure.
     */
    public int getNumAtoms() {
        return atomList.size();
    }

    /**
     * Returns number of bonds in structure.
     */
    public int getNumBonds() {
        return bondList.size();
    }

    /**
     * Returns number of stereo parities in strucuture.
     */
    public int getNumStereo0D() {
        return stereoList.size();
    }

    /**
     * Adds atom to inchi molecule.
     *
     * @param atom  Atom to add
     * @return      Added atom
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiAtom addAtom(JniInchiAtom atom) {
        atomList.add(atom);
        return atom;
    }

    /**
     * Convenience method to add multiple atoms to molecule.
     * @param atoms
     */
    public void addAtoms(JniInchiAtom... atoms) {
        for (JniInchiAtom atom : atoms) {
            addAtom(atom);
        }
    }

    /**
     * Adds bond to inchi molecule.
     *
     * @param bond  Bond to add
     * @return      Added bond
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiBond addBond(JniInchiBond bond) {
        bondList.add(bond);
        return bond;
    }

    /**
     * Convenience method to add multiple bonds to molecule.
     * @param bonds
     */
    public void addBonds(JniInchiBond... bonds) {
        for (JniInchiBond bond : bonds) {
            addBond(bond);
        }
    }

    /**
     * Adds 0D stereo parity to inchi molecule.
     *
     * @param parity  Parity to add
     * @return        Added parity
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {
        stereoList.add(parity);
        return parity;
    }

    /**
     * Returns atom from structure.
     * @param i    Index of atom to return.
     * @return
     */
    public JniInchiAtom getAtom(final int i) {
        return (JniInchiAtom) atomList.get(i);
    }

    /**
     * Returns bond from structure.
     * @param i    Index of bond to return.
     * @return
     */
    public JniInchiBond getBond(final int i) {
        return (JniInchiBond) bondList.get(i);
    }

    /**
     * Returns stereo parity from structure.
     * @param i    Index of stereo parity to return.
     * @return
     */
    public JniInchiStereo0D getStereo0D(final int i) {
        return (JniInchiStereo0D) stereoList.get(i);
    }

    public void setStructure(JniInchiStructure structure) {
        this.atomList = structure.atomList;
        this.bondList = structure.bondList;
        this.stereoList = structure.stereoList;
    }

    int getAtomIndex(JniInchiAtom atom) {
        return atomList.indexOf(atom);
    }

    int getStereo0DIndex(JniInchiStereo0D stereo) {
        return stereoList.indexOf(stereo);
    }
}
","// JniInchiStructure_4Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#getBond(int)} method.
*/
class JniInchiStructure_4Test {","// JniInchiStructure_4Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#getBond(int)} method.
*/
class JniInchiStructure_4Test {

		@Test
		void testGetBond_0() {
				JniInchiStructure structure = new JniInchiStructure();
				JniInchiAtom atom1 = new JniInchiAtom(""C"");
				JniInchiAtom atom2 = new JniInchiAtom(""C"");
				JniInchiAtom atom3 = new JniInchiAtom(""C"");
				JniInchiAtom atom4 = new JniInchiAtom(""C"");
				JniInchiAtom atom5 = new JniInchiAtom(""C"");
				JniInchiAtom atom6 = new JniInchiAtom(""C"");
				JniInchiAtom atom7 = new JniInchiAtom(""C"");
				JniInchiAtom atom8 = new JniInchiAtom(""C"");
				JniInchiAtom atom9 = new JniInchiAtom(""C"");
				JniInchiAtom atom10 = new JniInchiAtom(""C"");
				structure.addAtom(atom1);
				structure.addAtom(atom2);
				structure.addAtom(atom3);
				structure.addAtom(atom4);
				structure.addAtom(atom5);
				structure.addAtom(atom6);
				structure.addAtom(atom7);
				structure.addAtom(atom8);
				structure.addAtom(atom9);
				structure.addAtom(atom10);
				JniInchiBond bond1 = new JniInchiBond(atom1, atom2, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond2 = new JniInchiBond(atom2, atom3, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond3 = new JniInchiBond(atom3, atom4, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond4 = new JniInchiBond(atom4, atom5, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond5 = new JniInchiBond(atom5, atom6, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond6 = new JniInchiBond(atom6, atom7, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond7 = new JniInchiBond(atom7, atom8, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond8 = new JniInchiBond(atom8, atom9, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond9 = new JniInchiBond(atom9, atom10, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond10 = new JniInchiBond(atom10, atom1, JniInchiBond.BondType.SINGLE);
				structure.addBond(bond1);
				structure.addBond(bond2);
				structure.addBond(bond3);
				structure.addBond(bond4);
				structure.addBond(bond5);
				structure.addBond(bond6);
				structure.addBond(bond7);
				structure.addBond(bond8);
				structure.addBond(bond9);
				structure.addBond(bond10);
				JniInchiStereo0D stereo1 = new JniInchiStereo0D(bond1, bond2, bond3, bond4, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo2 = new JniInchiStereo0D(bond2, bond3, bond4, bond5, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo3 = new JniInchiStereo0D(bond3, bond4, bond5, bond6, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo4 = new JniInchiStereo0D(bond4, bond5, bond6, bond7, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo5 = new JniInchiStereo0D(bond5, bond6, bond7, bond8, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo6 = new JniInchiStereo0D(bond6, bond7, bond8, bond9, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo7 = new JniInchiStereo0D(bond7, bond8, bond9, bond10, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo8 = new JniInchiStereo0D(bond8, bond9, bond10, bond1, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo9 = new JniInchiStereo0D(bond9, bond10, bond1, bond2, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo10 = new JniInchiStereo0D(bond10, bond1, bond2, bond3, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				structure.addStereo0D(stereo1);
				structure.addStereo0D(stereo2);
				structure.addStereo0D(stereo3);
				structure.addStereo0D(stereo4);
				structure.addStereo0D(stereo5);
				structure.addStereo0D(stereo6);
				structure.addStereo0D(stereo7);
				structure.addStereo0D(stereo8);
				structure.addStereo0D(stereo9);
				structure.addStereo0D(stereo10);
				assertEquals(structure.getBond(0), bond1);
				assertEquals(structure.getBond(1), bond2);
				assertEquals(structure.getBond(2), bond3);
				assertEquals(structure.getBond(3), bond4);
				assertEquals(structure.getBond(4), bond5);
				assertEquals(structure.getBond(5), bond6);
				assertEquals(structure.getBond(6), bond7);
				assertEquals(structure.getBond(7), bond8);
				assertEquals(structure.getBond(8), bond9);
				assertEquals(structure.getBond(9), bond10);
		}
		
		@Test
		void testGetBond_1() {
				JniInchiStructure structure = new JniInchiStructure();
				JniInchiAtom atom1 = new JniInchiAtom(""C"");
				JniInchiAtom atom2 = new JniInchiAtom(""C"");
				JniInchiAtom atom3 = new JniInchiAtom(""C"");
				JniInchiAtom atom4 = new JniInchiAtom(""C"");
				JniInchiAtom atom5 = new JniInchiAtom(""C"");
				JniInchiAtom atom6 = new JniInchiAtom(""C"");
				JniInchiAtom atom7 = new JniInchiAtom(""C"");
				JniInchiAtom atom8 = new JniInchiAtom(""C"");
				JniInchiAtom atom9 = new JniInchiAtom(""C"");
				JniInchiAtom atom10 = new JniInchiAtom(""C"");
				structure.addAtom(atom1);
				structure.addAtom(atom2);
				structure.addAtom(atom3);
				structure.addAtom(atom4);
				structure.addAtom(atom5);
				structure.addAtom(atom6);
				structure.addAtom(atom7);
				structure.addAtom(atom8);
				structure.addAtom(atom9);
				structure.addAtom(atom10);
				JniInchiBond bond1 = new JniInchiBond(atom1, atom2, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond2 = new JniInchiBond(atom2, atom3, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond3 = new JniInchiBond(atom3, atom4, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond4 = new JniInchiBond(atom4, atom5, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond5 = new JniInchiBond(atom5, atom6, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond6 = new JniInchiBond(atom6, atom7, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond7 = new JniInchiBond(atom7, atom8, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond8 = new JniInchiBond(atom8, atom9, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond9 = new JniInchiBond(atom9, atom10, JniInchiBond.BondType.SINGLE);
				JniInchiBond bond10 = new JniInchiBond(atom10, atom1, JniInchiBond.BondType.SINGLE);
				structure.addBond(bond1);
				structure.addBond(bond2);
				structure.addBond(bond3);
				structure.addBond(bond4);
				structure.addBond(bond5);
				structure.addBond(bond6);
				structure.addBond(bond7);
				structure.addBond(bond8);
				structure.addBond(bond9);
				structure.addBond(bond10);
				JniInchiStereo0D stereo1 = new JniInchiStereo0D(bond1, bond2, bond3, bond4, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo2 = new JniInchiStereo0D(bond2, bond3, bond4, bond5, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo3 = new JniInchiStereo0D(bond3, bond4, bond5, bond6, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo4 = new JniInchiStereo0D(bond4, bond5, bond6, bond7, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo5 = new JniInchiStereo0D(bond5, bond6, bond7, bond8, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo6 = new JniInchiStereo0D(bond6, bond7, bond8, bond9, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo7 = new JniInchiStereo0D(bond7, bond8, bond9, bond10, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo8 = new JniInchiStereo0D(bond8, bond9, bond10, bond1, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo9 = new JniInchiStereo0D(bond9, bond10, bond1, bond2, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				JniInchiStereo0D stereo10 = new JniInchiStereo0D(bond10, bond1, bond2, bond3, JniInchiStereo0D.StereoType.TETRAHEDRAL_CCW);
				structure.addStereo0D(stereo1);
				structure.addStereo0D(stereo2);
				structure.addStereo0D(stereo3);
				structure.addStereo0D(stereo4);
				structure.addStereo0D(stereo5);
				structure.addStereo0D(stereo6);
				structure.addStereo0D(stereo7);
				structure.addStereo0D(stereo8);
				structure.addStereo0D(stereo9);
				structure.addStereo0D(stereo10);
				assertEquals(structure.getBond(0), bond1);
				assertEquals(structure.getBond(1), bond2);
				assertEquals(structure.getBond(2), bond3);
				assertEquals(structure.getBond(3), bond4);
				assertEquals(structure.getBond(4), bond5);
				assertEquals(structure.getBond(5), bond6);
				assertEquals(structure.getBond(6), bond7);"
cmpl-6tslbr8sV9DCiSjaWwnOgeUZCUdvH,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiStructure_5Test.java,122.71790194511414,length,"// JniInchiStructure.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;

/**
 * @author Sam Adams
 */
public class JniInchiStructure {

    /**
     * List of atoms.
     */
    private List atomList = new ArrayList();

    /**
     * List of bonds.
     */
    private List bondList = new ArrayList();

    /**
     * List of stero parities.
     */
    private List stereoList = new ArrayList();

    /**
     * Returns number of atoms in structure.
     */
    public int getNumAtoms() {
        return atomList.size();
    }

    /**
     * Returns number of bonds in structure.
     */
    public int getNumBonds() {
        return bondList.size();
    }

    /**
     * Returns number of stereo parities in strucuture.
     */
    public int getNumStereo0D() {
        return stereoList.size();
    }

    /**
     * Adds atom to inchi molecule.
     *
     * @param atom  Atom to add
     * @return      Added atom
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiAtom addAtom(JniInchiAtom atom) {
        atomList.add(atom);
        return atom;
    }

    /**
     * Convenience method to add multiple atoms to molecule.
     * @param atoms
     */
    public void addAtoms(JniInchiAtom... atoms) {
        for (JniInchiAtom atom : atoms) {
            addAtom(atom);
        }
    }

    /**
     * Adds bond to inchi molecule.
     *
     * @param bond  Bond to add
     * @return      Added bond
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiBond addBond(JniInchiBond bond) {
        bondList.add(bond);
        return bond;
    }

    /**
     * Convenience method to add multiple bonds to molecule.
     * @param bonds
     */
    public void addBonds(JniInchiBond... bonds) {
        for (JniInchiBond bond : bonds) {
            addBond(bond);
        }
    }

    /**
     * Adds 0D stereo parity to inchi molecule.
     *
     * @param parity  Parity to add
     * @return        Added parity
     */
    @SuppressWarnings(""unchecked"")
    public JniInchiStereo0D addStereo0D(JniInchiStereo0D parity) {
        stereoList.add(parity);
        return parity;
    }

    /**
     * Returns atom from structure.
     * @param i    Index of atom to return.
     * @return
     */
    public JniInchiAtom getAtom(final int i) {
        return (JniInchiAtom) atomList.get(i);
    }

    /**
     * Returns bond from structure.
     * @param i    Index of bond to return.
     * @return
     */
    public JniInchiBond getBond(final int i) {
        return (JniInchiBond) bondList.get(i);
    }

    /**
     * Returns stereo parity from structure.
     * @param i    Index of stereo parity to return.
     * @return
     */
    public JniInchiStereo0D getStereo0D(final int i) {
        return (JniInchiStereo0D) stereoList.get(i);
    }

    public void setStructure(JniInchiStructure structure) {
        this.atomList = structure.atomList;
        this.bondList = structure.bondList;
        this.stereoList = structure.stereoList;
    }

    int getAtomIndex(JniInchiAtom atom) {
        return atomList.indexOf(atom);
    }

    int getStereo0DIndex(JniInchiStereo0D stereo) {
        return stereoList.indexOf(stereo);
    }
}
","// JniInchiStructure_5Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#getStereo0D(int)} method.
*/
class JniInchiStructure_5Test {","// JniInchiStructure_5Test.java
package net.sf.jniinchi;

import java.util.ArrayList;
import java.util.List;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiStructure}.
* It contains ten unit test cases for the {@link JniInchiStructure#getStereo0D(int)} method.
*/
class JniInchiStructure_5Test {

	/**
	 * Test case for {@link JniInchiStructure#getStereo0D(int)} method.
	 * 
	 * @throws JniInchiException
	 */
	@Test
	void testGetStereo0D_1() throws JniInchiException {
		JniInchiAtom atom1 = new JniInchiAtom(""N"");
		JniInchiAtom atom2 = new JniInchiAtom(""C"");
		JniInchiAtom atom3 = new JniInchiAtom(""C"");
		JniInchiAtom atom4 = new JniInchiAtom(""C"");
		JniInchiAtom atom5 = new JniInchiAtom(""C"");
		JniInchiAtom atom6 = new JniInchiAtom(""C"");
		JniInchiAtom atom7 = new JniInchiAtom(""C"");
		JniInchiAtom atom8 = new JniInchiAtom(""C"");
		JniInchiAtom atom9 = new JniInchiAtom(""C"");
		JniInchiAtom atom10 = new JniInchiAtom(""C"");
		JniInchiAtom atom11 = new JniInchiAtom(""C"");
		JniInchiAtom atom12 = new JniInchiAtom(""C"");
		JniInchiAtom atom13 = new JniInchiAtom(""C"");
		JniInchiAtom atom14 = new JniInchiAtom(""C"");
		JniInchiAtom atom15 = new JniInchiAtom(""C"");
		JniInchiAtom atom16 = new JniInchiAtom(""C"");
		JniInchiAtom atom17 = new JniInchiAtom(""C"");
		JniInchiAtom atom18 = new JniInchiAtom(""C"");
		JniInchiAtom atom19 = new JniInchiAtom(""C"");
		JniInchiAtom atom20 = new JniInchiAtom(""C"");
		JniInchiAtom atom21 = new JniInchiAtom(""C"");
		JniInchiAtom atom22 = new JniInchiAtom(""C"");
		JniInchiAtom atom23 = new JniInchiAtom(""C"");
		JniInchiAtom atom24 = new JniInchiAtom(""C"");
		JniInchiAtom atom25 = new JniInchiAtom(""C"");
		JniInchiAtom atom26 = new JniInchiAtom(""C"");
		JniInchiAtom atom27 = new JniInchiAtom(""C"");
		JniInchiAtom atom28 = new JniInchiAtom(""C"");
		JniInchiAtom atom29 = new JniInchiAtom(""C"");
		JniInchiAtom atom30 = new JniInchiAtom(""C"");
		JniInchiAtom atom31 = new JniInchiAtom(""C"");
		JniInchiAtom atom32 = new JniInchiAtom(""C"");
		JniInchiAtom atom33 = new JniInchiAtom(""C"");
		JniInchiAtom atom34 = new JniInchiAtom(""C"");
		JniInchiAtom atom35 = new JniInchiAtom(""C"");
		JniInchiAtom atom36 = new JniInchiAtom(""C"");
		JniInchiAtom atom37 = new JniInchiAtom(""C"");
		JniInchiAtom atom38 = new JniInchiAtom(""C"");
		JniInchiAtom atom39 = new JniInchiAtom(""C"");
		JniInchiAtom atom40 = new JniInchiAtom(""C"");
		JniInchiAtom atom41 = new JniInchiAtom(""C"");
		JniInchiAtom atom42 = new JniInchiAtom(""C"");
		JniInchiAtom atom43 = new JniInchiAtom(""C"");
		JniInchiAtom atom44 = new JniInchiAtom(""C"");
		JniInchiAtom atom45 = new JniInchiAtom(""C"");
		JniInchiAtom atom46 = new JniInchiAtom(""C"");
		JniInchiAtom atom47 = new JniInchiAtom(""C"");
		JniInchiAtom atom48 = new JniInchiAtom(""C"");
		JniInchiAtom atom49 = new JniInchiAtom(""C"");
		JniInchiAtom atom50 = new JniInchiAtom(""C"");
		JniInchiAtom atom51 = new JniInchiAtom(""C"");
		JniInchiAtom atom52 = new JniInchiAtom(""C"");
		JniInchiAtom atom53 = new JniInchiAtom(""C"");
		JniInchiAtom atom54 = new JniInchiAtom(""C"");
		JniInchiAtom atom55 = new JniInchiAtom(""C"");
		JniInchiAtom atom56 = new JniInchiAtom(""C"");
		JniInchiAtom atom57 = new JniInchiAtom(""C"");
		JniInchiAtom atom58 = new JniInchiAtom(""C"");
		JniInchiAtom atom59 = new JniInchiAtom(""C"");
		JniInchiAtom atom60 = new JniInchiAtom(""C"");
		JniInchiAtom atom61 = new JniInchiAtom(""C"");
		JniInchiAtom atom62 = new JniInchiAtom(""C"");
		JniInchiAtom atom63 = new JniInchiAtom(""C"");
		JniInchiAtom atom64 = new JniInchiAtom(""C"");
		JniInchiAtom atom65 = new JniInchiAtom(""C"");
		JniInchiAtom atom66 = new JniInchiAtom(""C"");
		JniInchiAtom atom67 = new JniInchiAtom(""C"");
		JniInchiAtom atom68 = new JniInchiAtom(""C"");
		JniInchiAtom atom69 = new JniInchiAtom(""C"");
		JniInchiAtom atom70 = new JniInchiAtom(""C"");
		JniInchiAtom atom71 = new JniInchiAtom(""C"");
		JniInchiAtom atom72 = new JniInchiAtom(""C"");
		JniInchiAtom atom73 = new JniInchiAtom(""C"");
		JniInchiAtom atom74 = new JniInchiAtom(""C"");
		JniInchiAtom atom75 = new JniInchiAtom(""C"");
		JniInchiAtom atom76 = new JniInchiAtom(""C"");
		JniInchiAtom atom77 = new JniInchiAtom(""C"");
		JniInchiAtom atom78 = new JniInchiAtom(""C"");
		JniInchiAtom atom79 = new JniInchiAtom(""C"");
		JniInchiAtom atom80 = new JniInchiAtom(""C"");
		JniInchiAtom atom81 = new JniInchiAtom(""C"");
		JniInchiAtom atom82 = new JniInchiAtom(""C"");
		JniInchiAtom atom83 = new JniInchiAtom(""C"");
		JniInchiAtom atom84 = new JniInchiAtom(""C"");
		JniInchiAtom atom85 = new JniInchiAtom(""C"");
		JniInchiAtom atom86 = new JniInchiAtom(""C"");
		JniInchiAtom atom87 = new JniInchiAtom(""C"");
		JniInchiAtom atom88 = new JniInchiAtom(""C"");
		JniInchiAtom atom89 = new JniInchiAtom(""C"");
		JniInchiAtom atom90 = new JniInchiAtom(""C"");
		JniInchiAtom atom91 = new JniInchiAtom(""C"");
		JniInchiAtom atom92 = new JniInchiAtom(""C"");
		JniInchiAtom atom93 = new JniInchiAtom(""C"");
		JniInchiAtom atom94 = new JniInchiAtom(""C"");
		JniInchiAtom atom95 = new JniInchiAtom(""C"");
		JniInchiAtom atom96 = new JniInchiAtom(""C"");
		JniInchiAtom atom97 = new JniInchiAtom(""C"");
		JniInchiAtom atom98 = new JniInchiAtom(""C"");
		JniInchiAtom atom99 = new JniInchiAtom(""C"");
		JniInchiAtom atom100 = new JniInchiAtom(""C"");
		JniInchiAtom atom101 = new JniInchiAtom(""C"");
		JniInchiAtom atom102 = new JniInchiAtom(""C"");
		JniInchiAtom atom103 = new JniInchiAtom(""C"");
		JniInchiAtom atom104 = new JniInchiAtom(""C"");
		JniInchiAtom atom105 = new JniInchiAtom(""C"");
		JniInchiAtom atom106 = new JniInchiAtom(""C"");
		JniInchiAtom atom107 = new JniInchiAtom(""C"");
		JniInchiAtom atom108 = new JniInchiAtom(""C"");
		JniInchiAtom atom109 = new JniInchiAtom(""C"");
		JniInchiAtom atom110 = new JniInchiAtom(""C"");
		JniInchiAtom atom111 = new JniInchiAtom(""C"");
		JniInchiAtom atom112 = new JniInchiAtom(""C"");
		JniInchiAtom atom113 = new JniInchiAtom(""C"");
		JniInchiAtom atom114 = new JniInchiAtom(""C"");
		JniInchiAtom atom115 = new JniInchiAtom(""C"");
		JniInchiAtom atom116 = new JniInchiAtom(""C"");
		JniInchiAtom atom117 = new JniInchiAtom(""C"");
		JniInchiAtom atom118 = new JniInchiAtom(""C"");
		JniInchiAtom atom119 = new JniInchiAtom(""C"");
		JniInchiAtom atom120 = new JniInchiAtom(""C"");
		JniInchiAtom atom121 = new JniInchiAtom(""C"");
		JniInchiAtom atom122 = new JniInchiAtom(""C"");
		JniInchiAtom atom123 = new JniInchiAtom(""C"");
		JniInchiAtom atom124 = new JniInchiAtom(""C"");
		JniInchiAtom atom125 = new JniInchiAtom(""C"");
		JniInchiAtom atom126 = new JniInchiAtom(""C"");
		JniInchiAtom atom127 = new JniInchiAtom(""C"");
		JniInchiAtom atom128 = new JniInchiAtom(""C"");
		JniInchiAtom atom129 = new JniInchiAtom(""C"");
		JniInchiAtom atom130 = new JniInchiAtom(""C"");
		JniInchiAtom atom131 = new JniInchiAtom(""C"");
		JniInchiAtom atom132 = new JniInchiAtom(""C"");
		JniInchiAtom atom133 = new JniInchiAtom(""C"");
		JniInchiAtom atom134 = new JniInchiAtom(""C"");
		JniInchiAtom atom135 = new JniInchiAtom(""C"");
		JniInchiAtom atom136 = new JniInchiAtom(""C"");
		JniInchiAtom atom137 = new JniInchiAtom(""C"");
		JniInchiAtom atom138 = new JniInchiAtom(""C"");
		JniInchiAtom atom139 = new JniInchiAtom(""C"");
		JniInchiAtom atom140 = new JniInchiAtom(""C"");
		JniInchiAtom atom141 = new JniInchiAtom(""C"");
		JniInchiAtom atom142 = new JniInchiAtom(""C"");
		JniInchiAtom atom143 = new JniInchiAtom(""C"");
		JniInchiAtom atom144 = new JniInchiAtom(""C"");
		JniInchiAtom atom145 = new JniInchiAtom(""C"");
		JniInchiAtom atom146 = new JniInchiAtom(""C"");
		JniInchiAtom atom147 = new JniInchiAtom(""C"");
		JniInchiAtom atom148 = new JniInchiAtom(""C"");
		JniInchiAtom atom149 = new JniInchiAtom(""C"");
		JniInchiAtom atom150 = new JniInchiAtom(""C"");
		JniInchiAtom atom151 = new JniInchiAtom(""C"");
		JniInchiAtom atom152 = new JniInchiAtom(""C"");
		JniInchiAtom atom153 = new JniInchiAtom(""C"");
		JniInchiAtom atom154 = new JniInchiAtom(""C"");
		JniInchiAtom atom155 = new JniInchiAtom(""C"");
		JniInchiAtom atom156 = new JniInchiAtom(""C"");
		JniInchiAtom atom157 = new JniInchiAtom(""C"");
		JniInchiAtom atom158 = new JniInchiAtom(""C"");
		JniInchiAtom atom159 = new JniInchiAtom(""C"");
		JniInchiAtom atom160 = new JniInchiAtom(""C"");
		JniInchiAtom atom161 = new JniInchiAtom(""C"");
		JniInchiAtom atom162 = new JniInchiAtom(""C"");
		JniInchiAtom atom163 = new JniInchiAtom(""C"");
		JniInchiAtom atom164 = new JniInchiAtom(""C"");
		JniInchiAtom atom165 = new JniInchiAtom(""C"");
		JniInchiAtom atom166 = new JniInchiAtom(""C"");
		JniInchiAtom atom167 = new JniInchiAtom(""C"");
		JniInchiAtom atom168 = new JniInchiAtom(""C"");
		JniInchiAtom atom169 = new JniInchiAtom(""C"");
		JniInchiAtom atom170 = new JniInchiAtom(""C"");
		JniInchiAtom atom171 = new JniInchiAtom(""C"");
		JniInchiAtom atom172 = new JniInchiAtom(""C"");
		JniInchiAtom atom173 = new JniInchiAtom(""C"");
		JniInchiAtom atom174 = new JniInchiAtom(""C"");
		JniInchiAtom atom175 = new JniInchiAtom(""C"");
		JniInchiAtom atom176 = new JniInchiAtom(""C"");
		JniInchiAtom atom177 = new JniInchiAtom(""C"");
		JniInchiAtom atom178 = new JniInchiAtom(""C"");
		JniInchiAtom atom179 = new J"
016acd9d-f566-4676-b2a7-6200dd5071ad,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8794 tokens (4794 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JniInchiWrapper.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    private static final String ID = ""jniinchi"";

    private static final String VERSION = ""1.03_1"";

    /**
     * Maximum time to wait for a lock (in seconds).
     */
    private static final int MAX_LOCK_TIMEOUT = 15;

    /**
     * Flag indicating windows or linux.
     */
    private static final boolean IS_WINDOWS = System.getProperty(""os.name"", """").toLowerCase().startsWith(""windows"");

    /**
     * Switch character for passing options. / in windows, - on other systems.
     */
    static final String flagChar = IS_WINDOWS ? ""/"" : ""-"";

    /**
     * Records whether native library has been loaded by system.
     */
    private static boolean libraryLoaded = false;

    private static JniInchiWrapper inchiWrapper;

    private static final Lock lock = new ReentrantLock(true);

    /**
     * Loads native library.
     * @throws JniInchiException Library failed to load
     */
    public static synchronized void loadLibrary() throws LoadNativeLibraryException {
        if (!libraryLoaded) {
            try {
                NativeLibraryLoader.loadLibrary(ID, VERSION);
                // Check expected version of native code loaded
                // Throws NativeCodeException if unable to make call / wrong version
                checkNativeCodeVersion();
                // Everything is set up!
                libraryLoaded = true;
            } catch (NativeCodeException ex) {
                System.err.println();
                System.err.println(""Error loading JNI InChI native code."");
                System.err.println(""You may need to compile the native code for your platform."");
                System.err.println(""See http://jni-inchi.sourceforge.net for instructions."");
                System.err.println();
                throw new LoadNativeLibraryException(ex);
            }
        }
    }

    /**
     * Checks the expected native code version has been loaded.
     * @throws NativeCodeException
     */
    private static void checkNativeCodeVersion() throws NativeCodeException {
        // Get native code version string
        String nativeVersion;
        try {
            nativeVersion = JniInchiWrapper.LibInchiGetVersion();
        } catch (UnsatisfiedLinkError e) {
            throw new NativeCodeException(""Unable get native code version"", e);
        }
        // Compare to expected version
        if (!VERSION.equals(nativeVersion)) {
            throw new NativeCodeException(""JNI InChI native code version mismatch: expected "" + VERSION + "", found "" + nativeVersion);
        }
    }

    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {
        if (inchiWrapper == null) {
            loadLibrary();
            init();
            inchiWrapper = new JniInchiWrapper();
        }
        return inchiWrapper;
    }

    /**
     * Constructor
     */
    private JniInchiWrapper() throws LoadNativeLibraryException {
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops  List of INCHI_OPTION
     */
    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuffer sbOptions = new StringBuffer();
        for (int i = 0; i < ops.size(); i++) {
            Object op = ops.get(i);
            if (op instanceof INCHI_OPTION) {
                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + "" "");
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops          Space delimited string of options to pass to InChI library.
     *                     Each option may optionally be preceded by a command line
     *                     switch (/ or -).
     */
    protected static String checkOptions(final String ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuilder sbOptions = new StringBuilder();
        StringTokenizer tok = new StringTokenizer(ops);
        while (tok.hasMoreTokens()) {
            String op = tok.nextToken();
            if (op.startsWith(""-"") || op.startsWith(""/"")) {
                op = op.substring(1);
            }
            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);
            if (option != null) {
                sbOptions.append(flagChar + option.name());
                if (tok.hasMoreTokens()) {
                    sbOptions.append("" "");
                }
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * <p>Generates the InChI for a chemical structure.</p>
     *
     * <p>If no InChI creation/stereo modification options are specified then a standard
     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>
     *
     * <p><b>Valid options:</b></p>
     * <pre>
     *  Structure perception (compatible with stdInChI):
     *    /NEWPSOFF   /DoNotAddH   /SNon
     *  Stereo interpretation (lead to generation of non-standard InChI)
     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
     *  InChI creation options (lead to generation of non-standard InChI)
     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
     * </pre>
     *
     * <p><b>Other options:</b></p>
     * <pre>
     *  /AuxNone    Omit auxiliary information (default: Include)
     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited
     *              In InChI library the default value is unlimited
     *  /OutputSDF  Output SDfile instead of InChI
     *  /WarnOnEmptyStructure
     *              Warn and produce empty InChI for empty structure
     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)
     * </pre>
     *
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Calculates the Standard InChI string for a chemical structure.</p>
     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
     * perception options are specified then the calculation will fail.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStdINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>
     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the
     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
     * In order to keep all InChI layers use options string ""/FixedH /RecMet""; option /InChI2InChI is not needed.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Generated 0D structure from an InChI string.
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Calculates the InChIKey for an InChI string.
     * @param inchi     source InChI string
     * @return  InChIKey output
     * @throws  JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks whether a string represents valid InChIKey.
     * @param key
     * @return
     * @throws JniInchiException
     */
    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {
        if (key == null) {
            throw new IllegalArgumentException(""Null InChI key"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHIKey(key);
            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi  source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {
        if (auxInfo == null) {
            throw new IllegalArgumentException(""Null AuxInfo"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);
        } finally {
            lock.unlock();
        }
    }

    private static synchronized void getLock() throws JniInchiException {
        try {
            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {
                throw new TimeoutException(""Unable to get lock"");
            }
        } catch (TimeoutException ex) {
            throw new JniInchiException(ex);
        } catch (InterruptedException ex) {
            throw new JniInchiException(ex);
        }
    }

    protected native static String LibInchiGetVersion();

    private native static void init();

    private native JniInchiOutput GetINCHI(JniInchiInput input);

    private native JniInchiOutput GetStdINCHI(JniInchiInput input);

    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);

    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);

    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);

    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);

    private native int CheckINCHIKey(String key);

    private native int CheckINCHI(String inchi, boolean strict);

    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);
}
","// JniInchiWrapper_0Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getInchi(JniInchiInput)} method.
*/
class JniInchiWrapper_0Test {","// JniInchiWrapper_0Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getInchi(JniInchiInput)} method.
*/
class JniInchiWrapper_0Test {
"
d026c176-3fe0-4cf3-adbc-5fc321f19a11,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8796 tokens (4796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JniInchiWrapper.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    private static final String ID = ""jniinchi"";

    private static final String VERSION = ""1.03_1"";

    /**
     * Maximum time to wait for a lock (in seconds).
     */
    private static final int MAX_LOCK_TIMEOUT = 15;

    /**
     * Flag indicating windows or linux.
     */
    private static final boolean IS_WINDOWS = System.getProperty(""os.name"", """").toLowerCase().startsWith(""windows"");

    /**
     * Switch character for passing options. / in windows, - on other systems.
     */
    static final String flagChar = IS_WINDOWS ? ""/"" : ""-"";

    /**
     * Records whether native library has been loaded by system.
     */
    private static boolean libraryLoaded = false;

    private static JniInchiWrapper inchiWrapper;

    private static final Lock lock = new ReentrantLock(true);

    /**
     * Loads native library.
     * @throws JniInchiException Library failed to load
     */
    public static synchronized void loadLibrary() throws LoadNativeLibraryException {
        if (!libraryLoaded) {
            try {
                NativeLibraryLoader.loadLibrary(ID, VERSION);
                // Check expected version of native code loaded
                // Throws NativeCodeException if unable to make call / wrong version
                checkNativeCodeVersion();
                // Everything is set up!
                libraryLoaded = true;
            } catch (NativeCodeException ex) {
                System.err.println();
                System.err.println(""Error loading JNI InChI native code."");
                System.err.println(""You may need to compile the native code for your platform."");
                System.err.println(""See http://jni-inchi.sourceforge.net for instructions."");
                System.err.println();
                throw new LoadNativeLibraryException(ex);
            }
        }
    }

    /**
     * Checks the expected native code version has been loaded.
     * @throws NativeCodeException
     */
    private static void checkNativeCodeVersion() throws NativeCodeException {
        // Get native code version string
        String nativeVersion;
        try {
            nativeVersion = JniInchiWrapper.LibInchiGetVersion();
        } catch (UnsatisfiedLinkError e) {
            throw new NativeCodeException(""Unable get native code version"", e);
        }
        // Compare to expected version
        if (!VERSION.equals(nativeVersion)) {
            throw new NativeCodeException(""JNI InChI native code version mismatch: expected "" + VERSION + "", found "" + nativeVersion);
        }
    }

    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {
        if (inchiWrapper == null) {
            loadLibrary();
            init();
            inchiWrapper = new JniInchiWrapper();
        }
        return inchiWrapper;
    }

    /**
     * Constructor
     */
    private JniInchiWrapper() throws LoadNativeLibraryException {
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops  List of INCHI_OPTION
     */
    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuffer sbOptions = new StringBuffer();
        for (int i = 0; i < ops.size(); i++) {
            Object op = ops.get(i);
            if (op instanceof INCHI_OPTION) {
                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + "" "");
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops          Space delimited string of options to pass to InChI library.
     *                     Each option may optionally be preceded by a command line
     *                     switch (/ or -).
     */
    protected static String checkOptions(final String ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuilder sbOptions = new StringBuilder();
        StringTokenizer tok = new StringTokenizer(ops);
        while (tok.hasMoreTokens()) {
            String op = tok.nextToken();
            if (op.startsWith(""-"") || op.startsWith(""/"")) {
                op = op.substring(1);
            }
            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);
            if (option != null) {
                sbOptions.append(flagChar + option.name());
                if (tok.hasMoreTokens()) {
                    sbOptions.append("" "");
                }
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * <p>Generates the InChI for a chemical structure.</p>
     *
     * <p>If no InChI creation/stereo modification options are specified then a standard
     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>
     *
     * <p><b>Valid options:</b></p>
     * <pre>
     *  Structure perception (compatible with stdInChI):
     *    /NEWPSOFF   /DoNotAddH   /SNon
     *  Stereo interpretation (lead to generation of non-standard InChI)
     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
     *  InChI creation options (lead to generation of non-standard InChI)
     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
     * </pre>
     *
     * <p><b>Other options:</b></p>
     * <pre>
     *  /AuxNone    Omit auxiliary information (default: Include)
     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited
     *              In InChI library the default value is unlimited
     *  /OutputSDF  Output SDfile instead of InChI
     *  /WarnOnEmptyStructure
     *              Warn and produce empty InChI for empty structure
     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)
     * </pre>
     *
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Calculates the Standard InChI string for a chemical structure.</p>
     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
     * perception options are specified then the calculation will fail.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStdINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>
     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the
     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
     * In order to keep all InChI layers use options string ""/FixedH /RecMet""; option /InChI2InChI is not needed.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Generated 0D structure from an InChI string.
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Calculates the InChIKey for an InChI string.
     * @param inchi     source InChI string
     * @return  InChIKey output
     * @throws  JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks whether a string represents valid InChIKey.
     * @param key
     * @return
     * @throws JniInchiException
     */
    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {
        if (key == null) {
            throw new IllegalArgumentException(""Null InChI key"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHIKey(key);
            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi  source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {
        if (auxInfo == null) {
            throw new IllegalArgumentException(""Null AuxInfo"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);
        } finally {
            lock.unlock();
        }
    }

    private static synchronized void getLock() throws JniInchiException {
        try {
            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {
                throw new TimeoutException(""Unable to get lock"");
            }
        } catch (TimeoutException ex) {
            throw new JniInchiException(ex);
        } catch (InterruptedException ex) {
            throw new JniInchiException(ex);
        }
    }

    protected native static String LibInchiGetVersion();

    private native static void init();

    private native JniInchiOutput GetINCHI(JniInchiInput input);

    private native JniInchiOutput GetStdINCHI(JniInchiInput input);

    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);

    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);

    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);

    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);

    private native int CheckINCHIKey(String key);

    private native int CheckINCHI(String inchi, boolean strict);

    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);
}
","// JniInchiWrapper_1Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getStdInchi(JniInchiInput)} method.
*/
class JniInchiWrapper_1Test {","// JniInchiWrapper_1Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getStdInchi(JniInchiInput)} method.
*/
class JniInchiWrapper_1Test {
"
d369c5f0-9b08-4cc5-986a-88a5ebc0bf7d,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8799 tokens (4799 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JniInchiWrapper.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    private static final String ID = ""jniinchi"";

    private static final String VERSION = ""1.03_1"";

    /**
     * Maximum time to wait for a lock (in seconds).
     */
    private static final int MAX_LOCK_TIMEOUT = 15;

    /**
     * Flag indicating windows or linux.
     */
    private static final boolean IS_WINDOWS = System.getProperty(""os.name"", """").toLowerCase().startsWith(""windows"");

    /**
     * Switch character for passing options. / in windows, - on other systems.
     */
    static final String flagChar = IS_WINDOWS ? ""/"" : ""-"";

    /**
     * Records whether native library has been loaded by system.
     */
    private static boolean libraryLoaded = false;

    private static JniInchiWrapper inchiWrapper;

    private static final Lock lock = new ReentrantLock(true);

    /**
     * Loads native library.
     * @throws JniInchiException Library failed to load
     */
    public static synchronized void loadLibrary() throws LoadNativeLibraryException {
        if (!libraryLoaded) {
            try {
                NativeLibraryLoader.loadLibrary(ID, VERSION);
                // Check expected version of native code loaded
                // Throws NativeCodeException if unable to make call / wrong version
                checkNativeCodeVersion();
                // Everything is set up!
                libraryLoaded = true;
            } catch (NativeCodeException ex) {
                System.err.println();
                System.err.println(""Error loading JNI InChI native code."");
                System.err.println(""You may need to compile the native code for your platform."");
                System.err.println(""See http://jni-inchi.sourceforge.net for instructions."");
                System.err.println();
                throw new LoadNativeLibraryException(ex);
            }
        }
    }

    /**
     * Checks the expected native code version has been loaded.
     * @throws NativeCodeException
     */
    private static void checkNativeCodeVersion() throws NativeCodeException {
        // Get native code version string
        String nativeVersion;
        try {
            nativeVersion = JniInchiWrapper.LibInchiGetVersion();
        } catch (UnsatisfiedLinkError e) {
            throw new NativeCodeException(""Unable get native code version"", e);
        }
        // Compare to expected version
        if (!VERSION.equals(nativeVersion)) {
            throw new NativeCodeException(""JNI InChI native code version mismatch: expected "" + VERSION + "", found "" + nativeVersion);
        }
    }

    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {
        if (inchiWrapper == null) {
            loadLibrary();
            init();
            inchiWrapper = new JniInchiWrapper();
        }
        return inchiWrapper;
    }

    /**
     * Constructor
     */
    private JniInchiWrapper() throws LoadNativeLibraryException {
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops  List of INCHI_OPTION
     */
    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuffer sbOptions = new StringBuffer();
        for (int i = 0; i < ops.size(); i++) {
            Object op = ops.get(i);
            if (op instanceof INCHI_OPTION) {
                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + "" "");
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops          Space delimited string of options to pass to InChI library.
     *                     Each option may optionally be preceded by a command line
     *                     switch (/ or -).
     */
    protected static String checkOptions(final String ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuilder sbOptions = new StringBuilder();
        StringTokenizer tok = new StringTokenizer(ops);
        while (tok.hasMoreTokens()) {
            String op = tok.nextToken();
            if (op.startsWith(""-"") || op.startsWith(""/"")) {
                op = op.substring(1);
            }
            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);
            if (option != null) {
                sbOptions.append(flagChar + option.name());
                if (tok.hasMoreTokens()) {
                    sbOptions.append("" "");
                }
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * <p>Generates the InChI for a chemical structure.</p>
     *
     * <p>If no InChI creation/stereo modification options are specified then a standard
     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>
     *
     * <p><b>Valid options:</b></p>
     * <pre>
     *  Structure perception (compatible with stdInChI):
     *    /NEWPSOFF   /DoNotAddH   /SNon
     *  Stereo interpretation (lead to generation of non-standard InChI)
     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
     *  InChI creation options (lead to generation of non-standard InChI)
     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
     * </pre>
     *
     * <p><b>Other options:</b></p>
     * <pre>
     *  /AuxNone    Omit auxiliary information (default: Include)
     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited
     *              In InChI library the default value is unlimited
     *  /OutputSDF  Output SDfile instead of InChI
     *  /WarnOnEmptyStructure
     *              Warn and produce empty InChI for empty structure
     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)
     * </pre>
     *
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Calculates the Standard InChI string for a chemical structure.</p>
     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
     * perception options are specified then the calculation will fail.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStdINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>
     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the
     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
     * In order to keep all InChI layers use options string ""/FixedH /RecMet""; option /InChI2InChI is not needed.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Generated 0D structure from an InChI string.
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Calculates the InChIKey for an InChI string.
     * @param inchi     source InChI string
     * @return  InChIKey output
     * @throws  JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks whether a string represents valid InChIKey.
     * @param key
     * @return
     * @throws JniInchiException
     */
    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {
        if (key == null) {
            throw new IllegalArgumentException(""Null InChI key"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHIKey(key);
            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi  source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {
        if (auxInfo == null) {
            throw new IllegalArgumentException(""Null AuxInfo"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);
        } finally {
            lock.unlock();
        }
    }

    private static synchronized void getLock() throws JniInchiException {
        try {
            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {
                throw new TimeoutException(""Unable to get lock"");
            }
        } catch (TimeoutException ex) {
            throw new JniInchiException(ex);
        } catch (InterruptedException ex) {
            throw new JniInchiException(ex);
        }
    }

    protected native static String LibInchiGetVersion();

    private native static void init();

    private native JniInchiOutput GetINCHI(JniInchiInput input);

    private native JniInchiOutput GetStdINCHI(JniInchiInput input);

    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);

    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);

    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);

    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);

    private native int CheckINCHIKey(String key);

    private native int CheckINCHI(String inchi, boolean strict);

    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);
}
","// JniInchiWrapper_2Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.
*/
class JniInchiWrapper_2Test {","// JniInchiWrapper_2Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getInchiFromInchi(JniInchiInputInchi)} method.
*/
class JniInchiWrapper_2Test {
"
c9c49dab-b920-4d99-b455-203cd31cd816,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8799 tokens (4799 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JniInchiWrapper.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    private static final String ID = ""jniinchi"";

    private static final String VERSION = ""1.03_1"";

    /**
     * Maximum time to wait for a lock (in seconds).
     */
    private static final int MAX_LOCK_TIMEOUT = 15;

    /**
     * Flag indicating windows or linux.
     */
    private static final boolean IS_WINDOWS = System.getProperty(""os.name"", """").toLowerCase().startsWith(""windows"");

    /**
     * Switch character for passing options. / in windows, - on other systems.
     */
    static final String flagChar = IS_WINDOWS ? ""/"" : ""-"";

    /**
     * Records whether native library has been loaded by system.
     */
    private static boolean libraryLoaded = false;

    private static JniInchiWrapper inchiWrapper;

    private static final Lock lock = new ReentrantLock(true);

    /**
     * Loads native library.
     * @throws JniInchiException Library failed to load
     */
    public static synchronized void loadLibrary() throws LoadNativeLibraryException {
        if (!libraryLoaded) {
            try {
                NativeLibraryLoader.loadLibrary(ID, VERSION);
                // Check expected version of native code loaded
                // Throws NativeCodeException if unable to make call / wrong version
                checkNativeCodeVersion();
                // Everything is set up!
                libraryLoaded = true;
            } catch (NativeCodeException ex) {
                System.err.println();
                System.err.println(""Error loading JNI InChI native code."");
                System.err.println(""You may need to compile the native code for your platform."");
                System.err.println(""See http://jni-inchi.sourceforge.net for instructions."");
                System.err.println();
                throw new LoadNativeLibraryException(ex);
            }
        }
    }

    /**
     * Checks the expected native code version has been loaded.
     * @throws NativeCodeException
     */
    private static void checkNativeCodeVersion() throws NativeCodeException {
        // Get native code version string
        String nativeVersion;
        try {
            nativeVersion = JniInchiWrapper.LibInchiGetVersion();
        } catch (UnsatisfiedLinkError e) {
            throw new NativeCodeException(""Unable get native code version"", e);
        }
        // Compare to expected version
        if (!VERSION.equals(nativeVersion)) {
            throw new NativeCodeException(""JNI InChI native code version mismatch: expected "" + VERSION + "", found "" + nativeVersion);
        }
    }

    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {
        if (inchiWrapper == null) {
            loadLibrary();
            init();
            inchiWrapper = new JniInchiWrapper();
        }
        return inchiWrapper;
    }

    /**
     * Constructor
     */
    private JniInchiWrapper() throws LoadNativeLibraryException {
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops  List of INCHI_OPTION
     */
    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuffer sbOptions = new StringBuffer();
        for (int i = 0; i < ops.size(); i++) {
            Object op = ops.get(i);
            if (op instanceof INCHI_OPTION) {
                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + "" "");
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops          Space delimited string of options to pass to InChI library.
     *                     Each option may optionally be preceded by a command line
     *                     switch (/ or -).
     */
    protected static String checkOptions(final String ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuilder sbOptions = new StringBuilder();
        StringTokenizer tok = new StringTokenizer(ops);
        while (tok.hasMoreTokens()) {
            String op = tok.nextToken();
            if (op.startsWith(""-"") || op.startsWith(""/"")) {
                op = op.substring(1);
            }
            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);
            if (option != null) {
                sbOptions.append(flagChar + option.name());
                if (tok.hasMoreTokens()) {
                    sbOptions.append("" "");
                }
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * <p>Generates the InChI for a chemical structure.</p>
     *
     * <p>If no InChI creation/stereo modification options are specified then a standard
     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>
     *
     * <p><b>Valid options:</b></p>
     * <pre>
     *  Structure perception (compatible with stdInChI):
     *    /NEWPSOFF   /DoNotAddH   /SNon
     *  Stereo interpretation (lead to generation of non-standard InChI)
     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
     *  InChI creation options (lead to generation of non-standard InChI)
     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
     * </pre>
     *
     * <p><b>Other options:</b></p>
     * <pre>
     *  /AuxNone    Omit auxiliary information (default: Include)
     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited
     *              In InChI library the default value is unlimited
     *  /OutputSDF  Output SDfile instead of InChI
     *  /WarnOnEmptyStructure
     *              Warn and produce empty InChI for empty structure
     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)
     * </pre>
     *
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Calculates the Standard InChI string for a chemical structure.</p>
     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
     * perception options are specified then the calculation will fail.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStdINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>
     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the
     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
     * In order to keep all InChI layers use options string ""/FixedH /RecMet""; option /InChI2InChI is not needed.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Generated 0D structure from an InChI string.
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Calculates the InChIKey for an InChI string.
     * @param inchi     source InChI string
     * @return  InChIKey output
     * @throws  JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks whether a string represents valid InChIKey.
     * @param key
     * @return
     * @throws JniInchiException
     */
    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {
        if (key == null) {
            throw new IllegalArgumentException(""Null InChI key"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHIKey(key);
            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi  source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {
        if (auxInfo == null) {
            throw new IllegalArgumentException(""Null AuxInfo"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);
        } finally {
            lock.unlock();
        }
    }

    private static synchronized void getLock() throws JniInchiException {
        try {
            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {
                throw new TimeoutException(""Unable to get lock"");
            }
        } catch (TimeoutException ex) {
            throw new JniInchiException(ex);
        } catch (InterruptedException ex) {
            throw new JniInchiException(ex);
        }
    }

    protected native static String LibInchiGetVersion();

    private native static void init();

    private native JniInchiOutput GetINCHI(JniInchiInput input);

    private native JniInchiOutput GetStdINCHI(JniInchiInput input);

    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);

    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);

    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);

    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);

    private native int CheckINCHIKey(String key);

    private native int CheckINCHI(String inchi, boolean strict);

    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);
}
","// JniInchiWrapper_3Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getStructureFromInchi(JniInchiInputInchi)} method.
*/
class JniInchiWrapper_3Test {","// JniInchiWrapper_3Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getStructureFromInchi(JniInchiInputInchi)} method.
*/
class JniInchiWrapper_3Test {
"
05d39f25-1b78-4dff-b1a1-17b047dea519,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8791 tokens (4791 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JniInchiWrapper.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    private static final String ID = ""jniinchi"";

    private static final String VERSION = ""1.03_1"";

    /**
     * Maximum time to wait for a lock (in seconds).
     */
    private static final int MAX_LOCK_TIMEOUT = 15;

    /**
     * Flag indicating windows or linux.
     */
    private static final boolean IS_WINDOWS = System.getProperty(""os.name"", """").toLowerCase().startsWith(""windows"");

    /**
     * Switch character for passing options. / in windows, - on other systems.
     */
    static final String flagChar = IS_WINDOWS ? ""/"" : ""-"";

    /**
     * Records whether native library has been loaded by system.
     */
    private static boolean libraryLoaded = false;

    private static JniInchiWrapper inchiWrapper;

    private static final Lock lock = new ReentrantLock(true);

    /**
     * Loads native library.
     * @throws JniInchiException Library failed to load
     */
    public static synchronized void loadLibrary() throws LoadNativeLibraryException {
        if (!libraryLoaded) {
            try {
                NativeLibraryLoader.loadLibrary(ID, VERSION);
                // Check expected version of native code loaded
                // Throws NativeCodeException if unable to make call / wrong version
                checkNativeCodeVersion();
                // Everything is set up!
                libraryLoaded = true;
            } catch (NativeCodeException ex) {
                System.err.println();
                System.err.println(""Error loading JNI InChI native code."");
                System.err.println(""You may need to compile the native code for your platform."");
                System.err.println(""See http://jni-inchi.sourceforge.net for instructions."");
                System.err.println();
                throw new LoadNativeLibraryException(ex);
            }
        }
    }

    /**
     * Checks the expected native code version has been loaded.
     * @throws NativeCodeException
     */
    private static void checkNativeCodeVersion() throws NativeCodeException {
        // Get native code version string
        String nativeVersion;
        try {
            nativeVersion = JniInchiWrapper.LibInchiGetVersion();
        } catch (UnsatisfiedLinkError e) {
            throw new NativeCodeException(""Unable get native code version"", e);
        }
        // Compare to expected version
        if (!VERSION.equals(nativeVersion)) {
            throw new NativeCodeException(""JNI InChI native code version mismatch: expected "" + VERSION + "", found "" + nativeVersion);
        }
    }

    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {
        if (inchiWrapper == null) {
            loadLibrary();
            init();
            inchiWrapper = new JniInchiWrapper();
        }
        return inchiWrapper;
    }

    /**
     * Constructor
     */
    private JniInchiWrapper() throws LoadNativeLibraryException {
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops  List of INCHI_OPTION
     */
    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuffer sbOptions = new StringBuffer();
        for (int i = 0; i < ops.size(); i++) {
            Object op = ops.get(i);
            if (op instanceof INCHI_OPTION) {
                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + "" "");
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops          Space delimited string of options to pass to InChI library.
     *                     Each option may optionally be preceded by a command line
     *                     switch (/ or -).
     */
    protected static String checkOptions(final String ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuilder sbOptions = new StringBuilder();
        StringTokenizer tok = new StringTokenizer(ops);
        while (tok.hasMoreTokens()) {
            String op = tok.nextToken();
            if (op.startsWith(""-"") || op.startsWith(""/"")) {
                op = op.substring(1);
            }
            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);
            if (option != null) {
                sbOptions.append(flagChar + option.name());
                if (tok.hasMoreTokens()) {
                    sbOptions.append("" "");
                }
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * <p>Generates the InChI for a chemical structure.</p>
     *
     * <p>If no InChI creation/stereo modification options are specified then a standard
     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>
     *
     * <p><b>Valid options:</b></p>
     * <pre>
     *  Structure perception (compatible with stdInChI):
     *    /NEWPSOFF   /DoNotAddH   /SNon
     *  Stereo interpretation (lead to generation of non-standard InChI)
     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
     *  InChI creation options (lead to generation of non-standard InChI)
     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
     * </pre>
     *
     * <p><b>Other options:</b></p>
     * <pre>
     *  /AuxNone    Omit auxiliary information (default: Include)
     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited
     *              In InChI library the default value is unlimited
     *  /OutputSDF  Output SDfile instead of InChI
     *  /WarnOnEmptyStructure
     *              Warn and produce empty InChI for empty structure
     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)
     * </pre>
     *
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Calculates the Standard InChI string for a chemical structure.</p>
     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
     * perception options are specified then the calculation will fail.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStdINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>
     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the
     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
     * In order to keep all InChI layers use options string ""/FixedH /RecMet""; option /InChI2InChI is not needed.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Generated 0D structure from an InChI string.
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Calculates the InChIKey for an InChI string.
     * @param inchi     source InChI string
     * @return  InChIKey output
     * @throws  JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks whether a string represents valid InChIKey.
     * @param key
     * @return
     * @throws JniInchiException
     */
    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {
        if (key == null) {
            throw new IllegalArgumentException(""Null InChI key"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHIKey(key);
            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi  source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {
        if (auxInfo == null) {
            throw new IllegalArgumentException(""Null AuxInfo"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);
        } finally {
            lock.unlock();
        }
    }

    private static synchronized void getLock() throws JniInchiException {
        try {
            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {
                throw new TimeoutException(""Unable to get lock"");
            }
        } catch (TimeoutException ex) {
            throw new JniInchiException(ex);
        } catch (InterruptedException ex) {
            throw new JniInchiException(ex);
        }
    }

    protected native static String LibInchiGetVersion();

    private native static void init();

    private native JniInchiOutput GetINCHI(JniInchiInput input);

    private native JniInchiOutput GetStdINCHI(JniInchiInput input);

    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);

    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);

    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);

    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);

    private native int CheckINCHIKey(String key);

    private native int CheckINCHI(String inchi, boolean strict);

    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);
}
","// JniInchiWrapper_4Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getInchiKey(String)} method.
*/
class JniInchiWrapper_4Test {","// JniInchiWrapper_4Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#getInchiKey(String)} method.
*/
class JniInchiWrapper_4Test {
"
e0758a65-7c76-4ed7-b8d5-1f5bed5113c9,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8791 tokens (4791 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JniInchiWrapper.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    private static final String ID = ""jniinchi"";

    private static final String VERSION = ""1.03_1"";

    /**
     * Maximum time to wait for a lock (in seconds).
     */
    private static final int MAX_LOCK_TIMEOUT = 15;

    /**
     * Flag indicating windows or linux.
     */
    private static final boolean IS_WINDOWS = System.getProperty(""os.name"", """").toLowerCase().startsWith(""windows"");

    /**
     * Switch character for passing options. / in windows, - on other systems.
     */
    static final String flagChar = IS_WINDOWS ? ""/"" : ""-"";

    /**
     * Records whether native library has been loaded by system.
     */
    private static boolean libraryLoaded = false;

    private static JniInchiWrapper inchiWrapper;

    private static final Lock lock = new ReentrantLock(true);

    /**
     * Loads native library.
     * @throws JniInchiException Library failed to load
     */
    public static synchronized void loadLibrary() throws LoadNativeLibraryException {
        if (!libraryLoaded) {
            try {
                NativeLibraryLoader.loadLibrary(ID, VERSION);
                // Check expected version of native code loaded
                // Throws NativeCodeException if unable to make call / wrong version
                checkNativeCodeVersion();
                // Everything is set up!
                libraryLoaded = true;
            } catch (NativeCodeException ex) {
                System.err.println();
                System.err.println(""Error loading JNI InChI native code."");
                System.err.println(""You may need to compile the native code for your platform."");
                System.err.println(""See http://jni-inchi.sourceforge.net for instructions."");
                System.err.println();
                throw new LoadNativeLibraryException(ex);
            }
        }
    }

    /**
     * Checks the expected native code version has been loaded.
     * @throws NativeCodeException
     */
    private static void checkNativeCodeVersion() throws NativeCodeException {
        // Get native code version string
        String nativeVersion;
        try {
            nativeVersion = JniInchiWrapper.LibInchiGetVersion();
        } catch (UnsatisfiedLinkError e) {
            throw new NativeCodeException(""Unable get native code version"", e);
        }
        // Compare to expected version
        if (!VERSION.equals(nativeVersion)) {
            throw new NativeCodeException(""JNI InChI native code version mismatch: expected "" + VERSION + "", found "" + nativeVersion);
        }
    }

    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {
        if (inchiWrapper == null) {
            loadLibrary();
            init();
            inchiWrapper = new JniInchiWrapper();
        }
        return inchiWrapper;
    }

    /**
     * Constructor
     */
    private JniInchiWrapper() throws LoadNativeLibraryException {
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops  List of INCHI_OPTION
     */
    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuffer sbOptions = new StringBuffer();
        for (int i = 0; i < ops.size(); i++) {
            Object op = ops.get(i);
            if (op instanceof INCHI_OPTION) {
                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + "" "");
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops          Space delimited string of options to pass to InChI library.
     *                     Each option may optionally be preceded by a command line
     *                     switch (/ or -).
     */
    protected static String checkOptions(final String ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuilder sbOptions = new StringBuilder();
        StringTokenizer tok = new StringTokenizer(ops);
        while (tok.hasMoreTokens()) {
            String op = tok.nextToken();
            if (op.startsWith(""-"") || op.startsWith(""/"")) {
                op = op.substring(1);
            }
            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);
            if (option != null) {
                sbOptions.append(flagChar + option.name());
                if (tok.hasMoreTokens()) {
                    sbOptions.append("" "");
                }
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * <p>Generates the InChI for a chemical structure.</p>
     *
     * <p>If no InChI creation/stereo modification options are specified then a standard
     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>
     *
     * <p><b>Valid options:</b></p>
     * <pre>
     *  Structure perception (compatible with stdInChI):
     *    /NEWPSOFF   /DoNotAddH   /SNon
     *  Stereo interpretation (lead to generation of non-standard InChI)
     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
     *  InChI creation options (lead to generation of non-standard InChI)
     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
     * </pre>
     *
     * <p><b>Other options:</b></p>
     * <pre>
     *  /AuxNone    Omit auxiliary information (default: Include)
     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited
     *              In InChI library the default value is unlimited
     *  /OutputSDF  Output SDfile instead of InChI
     *  /WarnOnEmptyStructure
     *              Warn and produce empty InChI for empty structure
     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)
     * </pre>
     *
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Calculates the Standard InChI string for a chemical structure.</p>
     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
     * perception options are specified then the calculation will fail.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStdINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>
     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the
     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
     * In order to keep all InChI layers use options string ""/FixedH /RecMet""; option /InChI2InChI is not needed.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Generated 0D structure from an InChI string.
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Calculates the InChIKey for an InChI string.
     * @param inchi     source InChI string
     * @return  InChIKey output
     * @throws  JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks whether a string represents valid InChIKey.
     * @param key
     * @return
     * @throws JniInchiException
     */
    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {
        if (key == null) {
            throw new IllegalArgumentException(""Null InChI key"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHIKey(key);
            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi  source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {
        if (auxInfo == null) {
            throw new IllegalArgumentException(""Null AuxInfo"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);
        } finally {
            lock.unlock();
        }
    }

    private static synchronized void getLock() throws JniInchiException {
        try {
            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {
                throw new TimeoutException(""Unable to get lock"");
            }
        } catch (TimeoutException ex) {
            throw new JniInchiException(ex);
        } catch (InterruptedException ex) {
            throw new JniInchiException(ex);
        }
    }

    protected native static String LibInchiGetVersion();

    private native static void init();

    private native JniInchiOutput GetINCHI(JniInchiInput input);

    private native JniInchiOutput GetStdINCHI(JniInchiInput input);

    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);

    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);

    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);

    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);

    private native int CheckINCHIKey(String key);

    private native int CheckINCHI(String inchi, boolean strict);

    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);
}
","// JniInchiWrapper_5Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#checkInchiKey(String)} method.
*/
class JniInchiWrapper_5Test {","// JniInchiWrapper_5Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#checkInchiKey(String)} method.
*/
class JniInchiWrapper_5Test {
"
703d328e-26c0-4d90-abd6-ca2f5ce5efe9,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/JniInchiWrapper_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8792 tokens (4792 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JniInchiWrapper.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * <p>JNI Wrapper for International Chemical Identifier (InChI) C++ library.
 *
 * <p>This class is not intended to be used directly, but should be accessed
 * through subclasses that read data formats and load them into the InChI
 * data structures.
 *
 * <p>Subclasses should load data through the addAtom, addBond and addParity
 * methods. Once the molecule is fully loaded then the generateInchi method
 * should be called. Ideally this should all take place within the subclass's
 * constructor. The public get methods will all return null until this has
 * happened.
 *
 * <p>See <tt>inchi_api.h</tt>.
 *
 * @author Sam Adams
 */
public class JniInchiWrapper {

    private static final String ID = ""jniinchi"";

    private static final String VERSION = ""1.03_1"";

    /**
     * Maximum time to wait for a lock (in seconds).
     */
    private static final int MAX_LOCK_TIMEOUT = 15;

    /**
     * Flag indicating windows or linux.
     */
    private static final boolean IS_WINDOWS = System.getProperty(""os.name"", """").toLowerCase().startsWith(""windows"");

    /**
     * Switch character for passing options. / in windows, - on other systems.
     */
    static final String flagChar = IS_WINDOWS ? ""/"" : ""-"";

    /**
     * Records whether native library has been loaded by system.
     */
    private static boolean libraryLoaded = false;

    private static JniInchiWrapper inchiWrapper;

    private static final Lock lock = new ReentrantLock(true);

    /**
     * Loads native library.
     * @throws JniInchiException Library failed to load
     */
    public static synchronized void loadLibrary() throws LoadNativeLibraryException {
        if (!libraryLoaded) {
            try {
                NativeLibraryLoader.loadLibrary(ID, VERSION);
                // Check expected version of native code loaded
                // Throws NativeCodeException if unable to make call / wrong version
                checkNativeCodeVersion();
                // Everything is set up!
                libraryLoaded = true;
            } catch (NativeCodeException ex) {
                System.err.println();
                System.err.println(""Error loading JNI InChI native code."");
                System.err.println(""You may need to compile the native code for your platform."");
                System.err.println(""See http://jni-inchi.sourceforge.net for instructions."");
                System.err.println();
                throw new LoadNativeLibraryException(ex);
            }
        }
    }

    /**
     * Checks the expected native code version has been loaded.
     * @throws NativeCodeException
     */
    private static void checkNativeCodeVersion() throws NativeCodeException {
        // Get native code version string
        String nativeVersion;
        try {
            nativeVersion = JniInchiWrapper.LibInchiGetVersion();
        } catch (UnsatisfiedLinkError e) {
            throw new NativeCodeException(""Unable get native code version"", e);
        }
        // Compare to expected version
        if (!VERSION.equals(nativeVersion)) {
            throw new NativeCodeException(""JNI InChI native code version mismatch: expected "" + VERSION + "", found "" + nativeVersion);
        }
    }

    private static synchronized JniInchiWrapper getWrapper() throws LoadNativeLibraryException {
        if (inchiWrapper == null) {
            loadLibrary();
            init();
            inchiWrapper = new JniInchiWrapper();
        }
        return inchiWrapper;
    }

    /**
     * Constructor
     */
    private JniInchiWrapper() throws LoadNativeLibraryException {
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops  List of INCHI_OPTION
     */
    protected static String checkOptions(List<INCHI_OPTION> ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuffer sbOptions = new StringBuffer();
        for (int i = 0; i < ops.size(); i++) {
            Object op = ops.get(i);
            if (op instanceof INCHI_OPTION) {
                sbOptions.append(flagChar + ((INCHI_OPTION) op).name() + "" "");
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * Checks and canonicalises options.
     *
     * @param ops          Space delimited string of options to pass to InChI library.
     *                     Each option may optionally be preceded by a command line
     *                     switch (/ or -).
     */
    protected static String checkOptions(final String ops) throws JniInchiException {
        if (ops == null) {
            throw new IllegalArgumentException(""Null options"");
        }
        StringBuilder sbOptions = new StringBuilder();
        StringTokenizer tok = new StringTokenizer(ops);
        while (tok.hasMoreTokens()) {
            String op = tok.nextToken();
            if (op.startsWith(""-"") || op.startsWith(""/"")) {
                op = op.substring(1);
            }
            INCHI_OPTION option = INCHI_OPTION.valueOfIgnoreCase(op);
            if (option != null) {
                sbOptions.append(flagChar + option.name());
                if (tok.hasMoreTokens()) {
                    sbOptions.append("" "");
                }
            } else {
                throw new JniInchiException(""Unrecognised InChI option"");
            }
        }
        return sbOptions.toString();
    }

    /**
     * <p>Generates the InChI for a chemical structure.</p>
     *
     * <p>If no InChI creation/stereo modification options are specified then a standard
     * InChI is produced, otherwise the generated InChI will be a non-standard one.</p>
     *
     * <p><b>Valid options:</b></p>
     * <pre>
     *  Structure perception (compatible with stdInChI):
     *    /NEWPSOFF   /DoNotAddH   /SNon
     *  Stereo interpretation (lead to generation of non-standard InChI)
     *    /SRel /SRac /SUCF /ChiralFlagON /ChiralFlagOFF
     *  InChI creation options (lead to generation of non-standard InChI)
     *    /SUU /SLUUD   /FixedH  /RecMet  /KET /15T
     * </pre>
     *
     * <p><b>Other options:</b></p>
     * <pre>
     *  /AuxNone    Omit auxiliary information (default: Include)
     *  /Wnumber    Set time-out per structure in seconds; W0 means unlimited
     *              In InChI library the default value is unlimited
     *  /OutputSDF  Output SDfile instead of InChI
     *  /WarnOnEmptyStructure
     *              Warn and produce empty InChI for empty structure
     *  /SaveOpt    Save custom InChI creation options (non-standard InChI)
     * </pre>
     *
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Calculates the Standard InChI string for a chemical structure.</p>
     * <p>The only valid structure perception options are NEWPSOFF/DoNotAddH/SNon. In any other structural
     * perception options are specified then the calculation will fail.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    @SuppressWarnings(""unchecked"")
    public static JniInchiOutput getStdInchi(JniInchiInput input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStdINCHI(input);
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Converts an InChI into an InChI for validation purposes (the same as the -InChI2InChI option).</p>
     * <p>This method may also be used to filter out specific layers. For instance, /Snon would remove the
     * stereochemical layer; Omitting /FixedH and/or /RecMet would remove Fixed-H or Reconnected layers.
     * In order to keep all InChI layers use options string ""/FixedH /RecMet""; option /InChI2InChI is not needed.</p>
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutput getInchiFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIfromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Generated 0D structure from an InChI string.
     * @param input
     * @return
     * @throws JniInchiException
     */
    public static JniInchiOutputStructure getStructureFromInchi(JniInchiInputInchi input) throws JniInchiException {
        if (input == null) {
            throw new IllegalArgumentException(""Null input"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetStructFromINCHI(input.getInchi(), input.getOptions());
        } finally {
            lock.unlock();
        }
    }

    /**
     * Calculates the InChIKey for an InChI string.
     * @param inchi     source InChI string
     * @return  InChIKey output
     * @throws  JniInchiException
     */
    public static JniInchiOutputKey getInchiKey(final String inchi) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIKeyFromINCHI(inchi);
        } finally {
            lock.unlock();
        }
    }

    /**
     * Checks whether a string represents valid InChIKey.
     * @param key
     * @return
     * @throws JniInchiException
     */
    public static INCHI_KEY_STATUS checkInchiKey(final String key) throws JniInchiException {
        if (key == null) {
            throw new IllegalArgumentException(""Null InChI key"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHIKey(key);
            INCHI_KEY_STATUS retStatus = INCHI_KEY_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    /**
     * <p>Checks if the string represents valid InChI/standard InChI.</p>
     *
     * @param inchi  source InChI
     * @param strict if <code>false</code>, just briefly check for proper layout (prefix, version, etc.) The result
     *               may not be strict.
     *               If <code>true</code>, try to perform InChI2InChI conversion and returns success if a resulting
     *               InChI string exactly match source. The result may be 'false alarm' due to imperfectness of
     */
    public static INCHI_STATUS checkInchi(final String inchi, final boolean strict) throws JniInchiException {
        if (inchi == null) {
            throw new IllegalArgumentException(""Null InChI"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            int ret = wrapper.CheckINCHI(inchi, strict);
            INCHI_STATUS retStatus = INCHI_STATUS.getValue(ret);
            if (retStatus == null) {
                throw new JniInchiException(""Unknown return status: "" + ret);
            }
            return retStatus;
        } finally {
            lock.unlock();
        }
    }

    public static JniInchiInputData getInputFromAuxInfo(String auxInfo) throws JniInchiException {
        if (auxInfo == null) {
            throw new IllegalArgumentException(""Null AuxInfo"");
        }
        JniInchiWrapper wrapper = getWrapper();
        wrapper.getLock();
        try {
            return wrapper.GetINCHIInputFromAuxInfo(auxInfo, false, false);
        } finally {
            lock.unlock();
        }
    }

    private static synchronized void getLock() throws JniInchiException {
        try {
            if (!lock.tryLock(MAX_LOCK_TIMEOUT, TimeUnit.SECONDS)) {
                throw new TimeoutException(""Unable to get lock"");
            }
        } catch (TimeoutException ex) {
            throw new JniInchiException(ex);
        } catch (InterruptedException ex) {
            throw new JniInchiException(ex);
        }
    }

    protected native static String LibInchiGetVersion();

    private native static void init();

    private native JniInchiOutput GetINCHI(JniInchiInput input);

    private native JniInchiOutput GetStdINCHI(JniInchiInput input);

    private native JniInchiOutput GetINCHIfromINCHI(String inchi, String options);

    private native JniInchiOutputStructure GetStructFromINCHI(String inchi, String options);

    private native JniInchiOutputKey GetINCHIKeyFromINCHI(String inchi);

    private native JniInchiOutputKey GetStdINCHIKeyFromStdINCHI(String inchi);

    private native int CheckINCHIKey(String key);

    private native int CheckINCHI(String inchi, boolean strict);

    private native JniInchiInputData GetINCHIInputFromAuxInfo(String auxInfo, boolean bDoNotAddH, boolean bDiffUnkUndfStereo);
}
","// JniInchiWrapper_6Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#checkInchi(String, boolean)} method.
*/
class JniInchiWrapper_6Test {","// JniInchiWrapper_6Test.java
package net.sf.jniinchi;

import net.sf.jnati.NativeCodeException;
import net.sf.jnati.deploy.NativeLibraryLoader;
import java.util.List;
import java.util.StringTokenizer;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JniInchiWrapper}.
* It contains ten unit test cases for the {@link JniInchiWrapper#checkInchi(String, boolean)} method.
*/
class JniInchiWrapper_6Test {
"
cmpl-6tsuNXxeL5YbfWR89L8xkHN8S0IkT,/EvoSuiteBenchmark/25_jni-inchi/src/main/java/net/sf/jniinchi/Main.java,10.686943531036377,stop,"// Main.java
/*
 * Copyright 2006-2011 Sam Adams <sea36 at users.sourceforge.net>
 *
 * This file is part of JNI-InChI.
 *
 * JNI-InChI is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JNI-InChI is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with JNI-InChI.  If not, see <http://www.gnu.org/licenses/>.
 */
package net.sf.jniinchi;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;

/**
 * Simple test class, for debugging purposes.
 * @author sea36
 */
public class Main {

    /**
     * Provide test structure.
     * @return
     */
    public static JniInchiStructure getTestMolecule() {
        JniInchiStructure struct = new JniInchiStructure();
        JniInchiAtom a1 = struct.addAtom(new JniInchiAtom(264.0, 968.0, 0.0, ""C""));
        JniInchiAtom a2 = struct.addAtom(new JniInchiAtom(295.0, 985.0, 0.0, ""C""));
        JniInchiAtom a3 = struct.addAtom(new JniInchiAtom(233.0, 986.0, 0.0, ""N""));
        JniInchiAtom a4 = struct.addAtom(new JniInchiAtom(264.0, 932.0, 0.0, ""C""));
        JniInchiAtom a5 = struct.addAtom(new JniInchiAtom(326.0, 967.0, 0.0, ""O""));
        JniInchiAtom a6 = struct.addAtom(new JniInchiAtom(295.0, 1021.0, 0.0, ""O""));
        a1.setImplicitH(1);
        a3.setImplicitH(2);
        a4.setImplicitH(3);
        a5.setImplicitH(1);
        struct.addBond(new JniInchiBond(a1, a2, INCHI_BOND_TYPE.SINGLE));
        struct.addBond(new JniInchiBond(a1, a3, INCHI_BOND_TYPE.SINGLE)).setStereoDefinition(INCHI_BOND_STEREO.SINGLE_1DOWN);
        struct.addBond(new JniInchiBond(a1, a4, INCHI_BOND_TYPE.SINGLE));
        struct.addBond(new JniInchiBond(a2, a5, INCHI_BOND_TYPE.SINGLE));
        struct.addBond(new JniInchiBond(a2, a6, INCHI_BOND_TYPE.DOUBLE));
        return struct;
    }

    public static void runChecks() throws JniInchiException {
        System.err.println(""Loading native code"");
        System.err.println();
        try {
            JniInchiWrapper.loadLibrary();
            System.err.println();
            System.err.println(""Native code version: "" + JniInchiWrapper.LibInchiGetVersion());
            System.err.println();
            System.err.println(""Running checks"");
            System.err.println();
            System.err.println(""Generating InChI from structure"");
            JniInchiStructure mol = getTestMolecule();
            JniInchiOutput out1 = JniInchiWrapper.getInchi(new JniInchiInput(mol));
            if (""InChI=1S/C3H7NO2/c1-2(4)3(5)6/h2H,4H2,1H3,(H,5,6)/t2-/m0/s1"".equals(out1.getInchi())) {
                System.err.println("" - OKAY"");
            } else {
                System.err.println("" - ERROR"");
                System.err.println(out1.getInchi());
            }
            System.err.println(""Generating structure from InChI"");
            JniInchiOutputStructure out2 = JniInchiWrapper.getStructureFromInchi(new JniInchiInputInchi(""InChI=1/C3H7NO2/c1-2(4)3(5)6/h2H,4H2,1H3,(H,5,6)""));
            if (out2.getNumAtoms() == 6 && out2.getNumBonds() == 5) {
                System.err.println("" - OKAY"");
            } else {
                System.err.println("" - ERROR"");
            }
            System.err.println(""Converting structure back to InChI"");
            JniInchiOutput out3 = JniInchiWrapper.getInchi(new JniInchiInput(out2));
            if (""InChI=1S/C3H7NO2/c1-2(4)3(5)6/h2H,4H2,1H3,(H,5,6)"".equals(out3.getInchi())) {
                System.err.println("" - OKAY"");
            } else {
                System.err.println("" - ERROR"");
                System.err.println(out3.getInchi());
            }
        } catch (Exception e) {
            System.err.println("" - ERROR"");
            e.printStackTrace();
        }
        //        System.err.println(""Running memtest"");
        //        for (int i = 0; i < 1000000; i++) {
        //            if (i % 1000 == 0) {
        //                System.err.println(i+""\t""+((int)(Runtime.getRuntime().totalMemory()/1024)));
        //            }
        //            JniInchiStructure mol = getTestMolecule();
        //            JniInchiWrapper.getInchi(new JniInchiInput(mol));
        //        }
        System.err.println();
        System.err.println(""Checks done."");
        System.err.println();
    }

    public static void main(final String[] args) throws Exception {
        // Output header message
        System.err.println();
        System.err.println(""** JniInchi debugger **"");
        System.err.println();
        // Set up logging
        Logger root = Logger.getRootLogger();
        if (args.length == 1 && ""-debug"".equals(args[0])) {
            root.setLevel(Level.ALL);
        } else {
            root.setLevel(Level.INFO);
        }
        root.removeAllAppenders();
        PatternLayout layout = new PatternLayout(""%-5p %c - %m%n"");
        // Create console appender
        ConsoleAppender aconn = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_ERR);
        aconn.setThreshold(Level.ALL);
        root.addAppender(aconn);
        runChecks();
    }
}
","// MainTest.java
package net.sf.jniinchi;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Main}.
* It contains ten unit test cases for the {@link Main#getTestMolecule()} method.
*/
class MainTest {","// MainTest.java
package net.sf.jniinchi;

import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Main}.
* It contains ten unit test cases for the {@link Main#getTestMolecule()} method.
*/
class MainTest {

		/**
		 * Test method for {@link Main#getTestMolecule()}.
		 */
		@Test
		void testGetTestMolecule() {
				// Set up logging
				Logger root = Logger.getRootLogger();
				root.setLevel(Level.INFO);
				root.removeAllAppenders();
				PatternLayout layout = new PatternLayout(""%-5p %c - %m%n"");
				// Create console appender
				ConsoleAppender aconn = new ConsoleAppender(layout, ConsoleAppender.SYSTEM_ERR);
				aconn.setThreshold(Level.ALL);
				root.addAppender(aconn);
				
				// Test
				JniInchiStructure struct = Main.getTestMolecule();
				assertEquals(6, struct.getNumAtoms());
				assertEquals(5, struct.getNumBonds());
				assertEquals(1, struct.getAtom(0).getImplicitH());
				assertEquals(2, struct.getAtom(2).getImplicitH());
				assertEquals(3, struct.getAtom(3).getImplicitH());
				assertEquals(1, struct.getAtom(4).getImplicitH());
				assertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(0).getBondType());
				assertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(1).getBondType());
				assertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(2).getBondType());
				assertEquals(INCHI_BOND_TYPE.SINGLE, struct.getBond(3).getBondType());
				assertEquals(INCHI_BOND_TYPE.DOUBLE, struct.getBond(4).getBondType());
				assertEquals(INCHI_BOND_STEREO.SINGLE_1DOWN, struct.getBond(1).getStereoDefinition());
		}
}</code>





A:

I have found the solution.
The problem was that the JUnit test class was not in the same package as the class under test.
"
