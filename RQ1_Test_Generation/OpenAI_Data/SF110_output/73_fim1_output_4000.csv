ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
61e08e5b-8c38-4297-9532-c77318d5d656,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20794 tokens (16794 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_0Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getLogger()} method.
*/
class ModernChatServer_0Test {","// ModernChatServer_0Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getLogger()} method.
*/
class ModernChatServer_0Test {
"
b7f684aa-c939-4b33-a20e-281cb81ea75e,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_11Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20799 tokens (16799 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_11Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.
*/
class ModernChatServer_11Test {","// ModernChatServer_11Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextAnnouncement(TextMessage)} method.
*/
class ModernChatServer_11Test {
"
efc5cb88-bf91-4cec-9a53-0c66745403b2,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_12Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20798 tokens (16798 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_12Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getMyRooms(User, String)} method.
*/
class ModernChatServer_12Test {","// ModernChatServer_12Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getMyRooms(User, String)} method.
*/
class ModernChatServer_12Test {
"
9d224216-151a-419f-b54b-040476526ace,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_13Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_13Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#createUser(User, String)} method.
*/
class ModernChatServer_13Test {","// ModernChatServer_13Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#createUser(User, String)} method.
*/
class ModernChatServer_13Test {
"
a05812a3-89db-4b85-ae5a-35ed07b0f4cc,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_15Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_15Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#createRoom(Room, String)} method.
*/
class ModernChatServer_15Test {","// ModernChatServer_15Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#createRoom(Room, String)} method.
*/
class ModernChatServer_15Test {
"
b7f498f0-6e38-4b7d-ae42-be9b82c9fe70,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_16Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_16Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#delUser(User, String)} method.
*/
class ModernChatServer_16Test {","// ModernChatServer_16Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#delUser(User, String)} method.
*/
class ModernChatServer_16Test {
"
fccfe41e-ad50-4551-80fe-d10d2f8e6ed6,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_19Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_19Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateUser(User, String)} method.
*/
class ModernChatServer_19Test {","// ModernChatServer_19Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateUser(User, String)} method.
*/
class ModernChatServer_19Test {
"
3d5e0280-834c-4452-a3bf-621ff79d314a,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20792 tokens (16792 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_1Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#ping()} method.
*/
class ModernChatServer_1Test {","// ModernChatServer_1Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#ping()} method.
*/
class ModernChatServer_1Test {
"
366ab1b6-ff18-4984-8698-9d0f6ab6abf4,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_20Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_20Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateGroup(Group, String)} method.
*/
class ModernChatServer_20Test {","// ModernChatServer_20Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateGroup(Group, String)} method.
*/
class ModernChatServer_20Test {
"
edccd04d-4b9d-4b89-8061-fd8c2776c7b3,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_21Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_21Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateRoom(Room, String)} method.
*/
class ModernChatServer_21Test {","// ModernChatServer_21Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateRoom(Room, String)} method.
*/
class ModernChatServer_21Test {
"
321ef51e-3b46-4006-a8cc-ccf32a9d4977,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_22Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20797 tokens (16797 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_22Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#kickOffUsers(String, String)} method.
*/
class ModernChatServer_22Test {","// ModernChatServer_22Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#kickOffUsers(String, String)} method.
*/
class ModernChatServer_22Test {
"
8a06500a-3a57-4a0c-8db7-59979437418d,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_23Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20795 tokens (16795 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_23Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#loadRooms(String)} method.
*/
class ModernChatServer_23Test {","// ModernChatServer_23Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#loadRooms(String)} method.
*/
class ModernChatServer_23Test {
"
d3ac9aff-277c-48f5-b1f7-b66966ed2317,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_24Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20798 tokens (16798 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_24Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signInAsAdmin(String, String)} method.
*/
class ModernChatServer_24Test {","// ModernChatServer_24Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signInAsAdmin(String, String)} method.
*/
class ModernChatServer_24Test {
"
47c2d837-200e-45a1-962e-28e2269b024c,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_25Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20797 tokens (16797 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_25Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#resetUserPass(User, String)} method.
*/
class ModernChatServer_25Test {","// ModernChatServer_25Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#resetUserPass(User, String)} method.
*/
class ModernChatServer_25Test {
"
bfb6cf3e-0824-44aa-b8f4-8ba3c51b63fa,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_26Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20797 tokens (16797 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_26Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateUserGroup(User, String)} method.
*/
class ModernChatServer_26Test {","// ModernChatServer_26Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#updateUserGroup(User, String)} method.
*/
class ModernChatServer_26Test {
"
37664aff-62f8-458a-b71a-c8c2e1c6b3ac,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_27Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_27Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#returnOnlineIPs(String)} method.
*/
class ModernChatServer_27Test {","// ModernChatServer_27Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#returnOnlineIPs(String)} method.
*/
class ModernChatServer_27Test {
"
129273f7-c476-40e4-a222-226dca0aec47,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_28Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20795 tokens (16795 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_28Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getSecurityMode(String)} method.
*/
class ModernChatServer_28Test {","// ModernChatServer_28Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getSecurityMode(String)} method.
*/
class ModernChatServer_28Test {
"
8431dfe0-a887-435f-a6e2-66b62ed4a587,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_29Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20797 tokens (16797 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_29Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#kickOffUser(int, String)} method.
*/
class ModernChatServer_29Test {","// ModernChatServer_29Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#kickOffUser(int, String)} method.
*/
class ModernChatServer_29Test {
"
cc39560c-6a55-47c5-8d71-f722f888820f,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20801 tokens (16801 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_2Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.
*/
class ModernChatServer_2Test {","// ModernChatServer_2Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#signIn(ClientInterface, String, String, String)} method.
*/
class ModernChatServer_2Test {
"
238bb678-ee41-4107-b836-554eea4d14f9,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_30Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20795 tokens (16795 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_30Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getLogLevel(String)} method.
*/
class ModernChatServer_30Test {","// ModernChatServer_30Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#getLogLevel(String)} method.
*/
class ModernChatServer_30Test {
"
b1b3f718-864f-4d89-8d4d-f44547bdf4e2,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20798 tokens (16798 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_3Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changePassword(String, String, String)} method.
*/
class ModernChatServer_3Test {","// ModernChatServer_3Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changePassword(String, String, String)} method.
*/
class ModernChatServer_3Test {
"
321b4e96-51a0-41bd-8dbe-c074626b9f16,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20799 tokens (16799 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_4Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.
*/
class ModernChatServer_4Test {","// ModernChatServer_4Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#changeAdminPassword(String, String, String)} method.
*/
class ModernChatServer_4Test {
"
9e5c06b5-d22e-4ef7-8adc-d21cf98790bd,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20797 tokens (16797 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_5Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#loadGroupsAndUsers(String)} method.
*/
class ModernChatServer_5Test {","// ModernChatServer_5Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#loadGroupsAndUsers(String)} method.
*/
class ModernChatServer_5Test {
"
9d6b733f-51cb-48e5-a4c8-631c99bfff53,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20796 tokens (16796 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_6Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendTextMessage(TextMessage)} method.
*/
class ModernChatServer_6Test {","// ModernChatServer_6Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendTextMessage(TextMessage)} method.
*/
class ModernChatServer_6Test {
"
33cf6742-f766-42cf-9ae9-42efec1ceb75,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_7Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20797 tokens (16797 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_7Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.
*/
class ModernChatServer_7Test {","// ModernChatServer_7Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureTextMessage(TextMessage)} method.
*/
class ModernChatServer_7Test {
"
fcfa91fb-63fc-4fb3-a512-6fd2734a41a5,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_8Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20798 tokens (16798 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_8Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_8Test {","// ModernChatServer_8Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_8Test {
"
5de7d906-9df3-4668-99e0-54baaadc123d,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/ModernChatServer_9Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20799 tokens (16799 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ModernChatServer.java
/*
 * ModernChatServer.java
 *
 * Created on October 27, 2009, 12:20 AM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;

/**
 * @author ooransa
 * Class implements 2 interfaces:
 * 1.Runnable for ping users thread : that ping users periodically to check if they are still connected or not.
 * 2.ServerInterface that extends 2 other interfaces : Admin Interface and Client Interface , both used
 * As the RMI view of the server for the connected client.
 */
public class ModernChatServer implements ServerInterface, Runnable {

    //Logger object
    private static Logger logger = Logger.getLogger(""ModernChatServer"");

    private static FileHandler fh;

    private String authToken;

    private String clientAuthToken;

    private String secToken;

    private StringEncrypter passwordEnc;

    /**
     * @return the logger
     */
    public static Logger getLogger() {
        return logger;
    }

    //password, groups and rooms hashtable
    private Hashtable<Integer, String> passwords;

    private Vector<Group> groups;

    private Vector<Room> rooms;

    //admin user object
    private User adminUser;

    //connected clients connections
    private Hashtable<Integer, ClientInterface> connectedClients;

    private Hashtable<Integer, String> connectedClientsIPs;

    //Business Deligate to load all data.
    private UsersBD userBD;

    private Thread checkupThread;

    private boolean serverRunning = false;

    //current run path
    private String path = ""/"";

    //security securityMode
    private int securityMode = 0;

    //server setting bean
    private ServerSettingBean serverSettingBean;

    //main method
    public static void main(String[] args) {
        try {
            System.out.println(""Starting Modern Chat Server ....."");
            ModernChatServer modernChatServer = new ModernChatServer();
        } catch (Exception e) {
            System.out.println(""Non-Specific Exception occur"");
            e.printStackTrace();
            JOptionPane.showMessageDialog(null, ""Error in starting up the server:"" + e.getMessage());
        }
    }

    /**
     * private method to start the RMI registry
     * @throws Exception
     */
    private void startRMIRegistry() throws Exception {
        //binding
        Registry registry = LocateRegistry.createRegistry(Integer.parseInt(getServerSettingBean().getServerPort()));
        //Registry registry=LocateRegistry.getRegistry();
        ServerInterface c = (ServerInterface) UnicastRemoteObject.exportObject(this, 0);
        //Naming.rebind(""//localhost:1190/ModernChatServer"", c);
        Naming.rebind(""//"" + getServerSettingBean().getServerURL() + "":"" + getServerSettingBean().getServerPort() + ""/ModernChatServer"", c);
    }

    /**
     * Creates a new instance of ModernChatServer
     */
    public ModernChatServer() {
        //security & authentication tokens
        authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
        clientAuthToken = ""FI"" + Calendar.getInstance().getTimeInMillis();
        secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
        passwordEnc = StringEncrypter.getInstance(""FIS2009"");
        //instantiate correct jar path
        try {
            path = ModernChatServer.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath();
            path = path.substring(0, path.lastIndexOf('/') + 1);
            System.out.println(""Path="" + path);
        } catch (URISyntaxException ex) {
            ex.printStackTrace();
        }
        //instantiate setting Bean
        serverSettingBean = new ServerSettingBean(path);
        //set the logger according to settings
        try {
            fh = new FileHandler(path + ""/log%g.txt"", 1000000, 10, true);
            fh.setFormatter(new SimpleFormatter());
            logger.addHandler(fh);
            setLogLevel(Integer.parseInt(serverSettingBean.getLogLevel()), false, authToken);
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error while creating log file!"", ex);
        }
        securityMode = Integer.parseInt(serverSettingBean.getSecureMode());
        logger.log(Level.INFO, ""FIM Server IP and Port="" + serverSettingBean.getServerURL() + "":"" + serverSettingBean.getServerPort());
        //load groups/users table
        try {
            userBD = new UsersBD(getServerSettingBean().getConnectionType(), path, this);
        } catch (Exception e) {
            logger.log(Level.SEVERE, ""FIM Server Data Error!, Terminating ...!"", e);
            System.exit(-1);
        }
        groups = userBD.loadGroupsAndUsers();
        rooms = userBD.loadRooms();
        passwords = userBD.getPasswords();
        adminUser = userBD.getAdminUser();
        logger.log(Level.INFO, ""Groups and Users loaded="" + groups.size());
        logger.log(Level.INFO, ""Rooms loaded="" + rooms.size());
        //initialize client connected...
        connectedClients = new Hashtable<Integer, ClientInterface>();
        connectedClientsIPs = new Hashtable<Integer, String>();
        logger.log(Level.INFO, ""Starting FIM Server ....."");
        try {
            startRMIRegistry();
        } catch (Exception ex) {
            logger.log(Level.SEVERE, ""Error During starting RMI Registry!"", ex);
            JOptionPane.showMessageDialog(null, ""Error During starting RMI Registry!:"" + ex.getMessage());
            System.exit(1);
        }
        logger.log(Level.INFO, ""FIM Server Started."");
        JOptionPane.showMessageDialog(null, ""FIM Server Started Successfully!"");
        //run checkup thread
        checkupThread = new Thread(this);
        serverRunning = true;
        checkupThread.start();
    }

    /**
     * any clinet ping it should receive true
     * @return true always
     */
    public boolean ping() {
        return true;
    }

    /**
     * Method to sing in ..
     * @param cf : user client interface to communicate with the client
     * @param emailAddr : user email
     * @param password : user password
     * @param ipAddress : user ip address
     * @return User object if authentication correctly , or null if not exist.
     * @throws RemoteException
     */
    public LoginBean signIn(ClientInterface cf, String emailAddr, String password, String ipAddress) throws RemoteException {
        LoginBean loginBean = null;
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null && ipAddress != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            //System.out.println(""email=""+email);
            User user = authenticateUser(email, password);
            if (user != null) {
                ipAddress = StringEncoder64.decodeStringUTF8(ipAddress);
                //System.out.println(""ip=""+ipAddress);
                ClientInterface oldOne = connectedClients.get(user.getId());
                if (oldOne != null) {
                    String ipAdd = connectedClientsIPs.get(user.getId());
                    if (ipAdd != null && ipAdd.equals(ipAddress)) {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, true);
                        sendKickOffByLoginMessageThread.start();
                    } else {
                        SendKickOffByLoginMessageThread sendKickOffByLoginMessageThread = new SendKickOffByLoginMessageThread(oldOne, false);
                        sendKickOffByLoginMessageThread.start();
                    }
                }
                connectedClients.put(user.getId(), cf);
                connectedClientsIPs.put(user.getId(), ipAddress);
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                loginBean = new LoginBean();
                loginBean.setUser(user);
                String orignalPass = passwordEnc.decrypt(passwords.get(user.getId()));
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                loginBean.setAuthToken(clientAuthToken);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * method to sign out
     * @param user
     * @throws RemoteException
     */
    public void signOut(User user) throws RemoteException {
        //update user in the group list
        if (user == null)
            return;
        connectedClients.remove(user.getId());
        connectedClientsIPs.remove(user.getId());
        user.setStatus_id(IConstant.SIGN_OUT);
        updateUserStatus(user);
    }

    /**
     * change user password
     * @param email : user email
     * @param oldPass : current password
     * @param newPass : new password
     * @return ResultBean with either true or false
     * @throws RemoteException
     */
    public ResultBean changePassword(String email, String oldPass, String newPass) throws RemoteException {
        email = StringEncoder64.decodeStringUTF8(email);
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        User user = authenticateUser(email, newOldPass);
        if (user == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(user.getId(), oldPass, newPass)) {
            passwords.put(user.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * Change admin password
     * @param emailAddr : email of the admin
     * @param oldPass   : current password
     * @param newPass   : new password
     * @return ResultBean : return status
     * @throws RemoteException
     */
    public ResultBean changeAdminPassword(String emailAddr, String oldPass, String newPass) throws RemoteException {
        oldPass = StringEncrypter.getInstance(secToken).decrypt(oldPass);
        String newOldPass = StringEncrypter.getInstance(oldPass).encrypt(oldPass);
        LoginBean loginBean = signInAsAdmin(emailAddr, newOldPass);
        if (loginBean == null) {
            return new ResultBean(false, IConstant.ERROR, ""Invalid Password!"");
        }
        oldPass = passwordEnc.encrypt(oldPass);
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        if (userBD.updatePassword(adminUser.getId(), oldPass, newPass)) {
            passwords.put(adminUser.getId(), newPass);
            return new ResultBean(true, IConstant.SUCCESS, null);
        }
        return new ResultBean(false, IConstant.ERROR, ""Error During Applying New Password!"");
    }

    /**
     * load groups and users to admin user
     * @return All Groups with there users
     * @throws RemoteException
     */
    public Vector<Group> loadGroupsAndUsers(String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken) && !this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return groups;
    }

    /**
     * Send text message between users
     * @param msg
     * @return true/false if message delivered or not.
     * @throws RemoteException
     */
    public boolean sendTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send text message to a user
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send text message but securly (i.e. encrypted)
     * @param msg : the message to be send
     * @return boolean : true/false if the text message send or not.
     * @throws RemoteException
     */
    public boolean sendSecureTextMessage(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextMessageToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean success = false;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                boolean success = false;
                //loop on users
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (sendSecureTextMessageToUser(msg, cf)) {
                            success = true;
                        }
                    }
                }
                if (success) {
                    return true;
                } else {
                    return false;
                }
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * private method to send secure text message to a user (encrypted)
     * @param msg : the message to be send
     * @param cf  : the client interface of the user
     * @return boolean : true/false if the text message send or not.
     */
    private boolean sendSecureTextMessageToUser(TextMessage msg, ClientInterface cf) {
        if (cf == null) {
            return false;
        } else {
            try {
                getLogger().log(Level.FINE, ""Online TextMessage="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                return cf.receiveSecureTextMessage(msg);
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user "");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return false;
            }
        }
    }

    /**
     * Send Binary message (files)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send Binary message (files) but secure (files not secure)
     * @param msg : the message to be send
     * @return ResultBean include the status of message send or not.
     * @throws RemoteException
     */
    public ResultBean sendSecureBinaryMessage(BinaryMessage msg) throws RemoteException {
        ClientInterface cf = connectedClients.get(msg.getToUserId());
        if (cf == null) {
            return new ResultBean(false, IConstant.OFFLINE, null);
        } else {
            try {
                //online message, send it..
                if (msg.getAction() == IConstant.REQUEST) {
                    getLogger().log(Level.FINE, ""Request send"");
                    return cf.receiveSecureBinaryMessageRequest(msg);
                } else {
                    getLogger().log(Level.FINE, ""Online BinaryMessage size="" + msg.getData().length + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                    cf.receiveSecureBinaryMessageLoad(msg);
                    return new ResultBean(true, IConstant.SUCCESS, null);
                }
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                } catch (RemoteException ex1) {
                }
                return new ResultBean(false, IConstant.EXCEPTION, ex.getMessage());
            }
        }
    }

    /**
     * Send announcemnt.
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendTextAnnouncementToUser(msg, cf);
                        } else {
                            sendTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Send announcemnt but securly (encrypted)
     * @param msg : the announcemnt to be send
     * @throws RemoteException
     */
    public boolean sendSecureTextAnnouncement(TextMessage msg) throws RemoteException {
        if (msg.getTargetType() == IConstant.USER_CHAT) {
            ClientInterface cf = connectedClients.get(msg.getToUserId());
            return sendSecureTextAnnouncementToUser(msg, cf);
        } else if (msg.getTargetType() == IConstant.GROUP_CHAT) {
            Vector<User> tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getGroups().size(); i++) {
                if (getGroups().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.size() > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.size(); i++) {
                    if (tempUsers.get(i).getId() != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers.get(i).getId());
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        } else if (msg.getTargetType() == IConstant.ROOM_CHAT) {
            int[] tempUsers = null;
            ClientInterface cf = null;
            for (int i = 0; i < getRooms().size(); i++) {
                if (getRooms().get(i).getId() == msg.getToUserId()) {
                    tempUsers = getRooms().get(i).getUserId();
                    break;
                }
            }
            if (tempUsers != null && tempUsers.length > 0) {
                //loop on users
                boolean deliverToAll = true;
                for (int i = 0; i < tempUsers.length; i++) {
                    if (tempUsers[i] != msg.getFromUserId()) {
                        cf = connectedClients.get(tempUsers[i]);
                        if (deliverToAll) {
                            deliverToAll = sendSecureTextAnnouncementToUser(msg, cf);
                        } else {
                            sendSecureTextAnnouncementToUser(msg, cf);
                        }
                    }
                }
                return deliverToAll;
            }
        }
        return false;
    }

    /**
     * private method to send announcemnt securly (encrypted)
     * @param msg : the announcemnt to send
     * @param cf  : the user client interface.
     */
    private boolean sendSecureTextAnnouncementToUser(TextMessage msg, ClientInterface cf) throws RemoteException {
        if (cf != null) {
            try {
                getLogger().log(Level.FINE, ""Online Announcement="" + msg.getMessage() + "" From="" + msg.getFromUserId() + "" To="" + msg.getToUserId());
                //online message, send it..
                cf.receiveSecureTextAnnouncement(msg);
                return true;
            } catch (RemoteException ex) {
                try {
                    getLogger().log(Level.FINE, ""Exception happen, will logoff this user"");
                    connectedClients.remove(msg.getToUserId());
                    connectedClientsIPs.remove(msg.getToUserId());
                    offlineStatus(msg.getToUserId());
                    return false;
                } catch (RemoteException ex1) {
                    return false;
                }
            }
        } else {
            return false;
        }
    }

    /**
     * Method used to update user status
     * @param updatedUser : the user with the new method included.
     * @throws RemoteException
     */
    public void updateUserStatus(User updatedUser) throws RemoteException {
        getLogger().log(Level.FINE, ""update user status for id="" + updatedUser.getId() + "" in group_id="" + updatedUser.getGroup_id() + "" with Status="" + updatedUser.getStatus_id());
        boolean userFound = false;
        Vector<User> tempUsers = null;
        if (updatedUser != null && updatedUser.getId() > 0) {
            for (int i = 0; i < getGroups().size(); i++) {
                if (updatedUser.getGroup_id() == getGroups().get(i).getId()) {
                    tempUsers = getGroups().get(i).getUsers();
                    break;
                }
            }
        }
        if (tempUsers != null && tempUsers.size() > 0) {
            for (int n = 0; n < tempUsers.size(); n++) {
                if (updatedUser.getId() == tempUsers.get(n).getId()) {
                    tempUsers.get(n).setStatus_id(updatedUser.getStatus_id());
                    userFound = true;
                    break;
                }
            }
        }
        if (userFound) {
            getLogger().log(Level.FINE, ""sending the status of the user to around "" + connectedClients.size() + "" user(s)"");
            Enumeration<ClientInterface> allCF = connectedClients.elements();
            while (allCF.hasMoreElements()) {
                SendUserUpdatedStatusThread sendUserUpdatedStatusThread = new SendUserUpdatedStatusThread(allCF.nextElement(), updatedUser);
                sendUserUpdatedStatusThread.start();
            }
        }
        System.gc();
    }

    /**
     * return user rooms
     * @param user
     * @return : Vector of rooms where this user is memeber of them.
     * @throws RemoteException
     */
    public Vector<Room> getMyRooms(User user, String authToken) throws RemoteException {
        if (!this.clientAuthToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        Vector<Room> myRooms = new Vector<Room>(0);
        for (int i = 0; i < getRooms().size(); i++) {
            int[] temp = getRooms().get(i).getUserId();
            if (temp != null) {
                for (int n = 0; n < temp.length; n++) {
                    if (user.getId() == temp[n]) {
                        myRooms.add(getRooms().get(i));
                        break;
                    }
                }
            }
        }
        return myRooms;
    }

    /**
     * Run method to periodic ping all user to check if any user lost the connection with the server
     * so the server offline his/her status.
     * It run each 5 minutes.
     */
    public void run() {
        while (serverRunning) {
            try {
                Thread.sleep(5 * 60 * 1000);
            } catch (InterruptedException ex) {
                ex.printStackTrace();
            }
            getLogger().log(Level.FINE, ""sending ping to all users to ensure they are still connected!"");
            getLogger().log(Level.FINE, ""size before ping="" + connectedClients.size() + "" user(s)"");
            if (connectedClients.size() > 0) {
                int n = 0;
                ClientInterface cf = null;
                Enumeration<Integer> listOfUserIds = connectedClients.keys();
                while (listOfUserIds.hasMoreElements()) {
                    n = listOfUserIds.nextElement();
                    cf = connectedClients.get(n);
                    try {
                        if (cf.ping() == false) {
                            connectedClients.remove(n);
                            connectedClientsIPs.remove(n);
                            offlineStatus(n);
                        }
                    } catch (Throwable e) {
                        connectedClients.remove(n);
                        connectedClientsIPs.remove(n);
                        try {
                            offlineStatus(n);
                        } catch (Throwable ex) {
                        }
                    }
                }
            } else {
                synchronized (connectedClients) {
                    secToken = ""F"" + Calendar.getInstance().getTimeInMillis();
                }
            }
            getLogger().log(Level.FINE, ""size after ping="" + connectedClients.size() + "" user(s)"");
            System.gc();
        }
    }

    /**
     * private method to offline user status and update other users with the user new status (offline)
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatus(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        updateUserStatus(tempUsers.get(n));
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to offline user status and NOT update other users with the user new status (offline)
     * Typically used when shutdown the server, don't care about informing users with the new status.
     * @param userId
     * @throws RemoteException
     */
    private void offlineStatusAndNoUpdate(int userId) throws RemoteException {
        getLogger().log(Level.FINE, ""will switch status to be sign off , for userID="" + userId);
        for (int i = 0; i < getGroups().size(); i++) {
            Vector<User> tempUsers = getGroups().get(i).getUsers();
            if (tempUsers != null && tempUsers.size() > 0) {
                for (int n = 0; n < tempUsers.size(); n++) {
                    if (userId == tempUsers.get(n).getId()) {
                        tempUsers.get(n).setStatus_id(IConstant.SIGN_OUT);
                        break;
                    }
                }
            }
        }
    }

    /**
     * private method to authenticate the user and return its full detailed bean.
     * @param emailAddr : email of the user
     * @param password  : password of the user.
     * @return User or Null according to the authentication results.
     */
    private User authenticateUser(String emailAddr, String password) {
        //User user = null;
        getLogger().log(Level.FINE, ""authenticate the user...."");
        for (int i = 0; i < groups.size(); i++) {
            Vector<User> tempUsers = groups.get(i).getUsers();
            for (int n = 0; n < tempUsers.size(); n++) {
                if (emailAddr.equals(tempUsers.get(n).getEmail())) {
                    String orignalPass = passwordEnc.decrypt(passwords.get(tempUsers.get(n).getId()));
                    //System.out.println(""original pass=""+orignalPass);
                    password = StringEncrypter.getInstance(orignalPass).decrypt(password);
                    //System.out.println(""send pass=""+password);
                    if (password != null && password.equals(orignalPass)) {
                        return tempUsers.get(n);
                    } else {
                        //failed authentication
                        return null;
                    }
                }
            }
        }
        return null;
    }

    /**
     * @return the groups
     */
    public Vector<Group> getGroups() {
        return groups;
    }

    /**
     * @return the rooms
     */
    public Vector<Room> getRooms() {
        return rooms;
    }

    /**
     * public method to create new user , used by the admin user
     * @param user : the user details
     * @return User : with the user Id included or null if failed to create it.
     * @throws RemoteException
     */
    public User createUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        user = userBD.createUser(user);
        if (user != null) {
            passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
            return user;
        } else {
            return null;
        }
    }

    /**
     * public method to create new group , used by the admin user
     * @param Group : the group details
     * @return Group : with the group Id included or null if failed to create it.
     * @throws RemoteException
     */
    public Group createGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createGroup(group);
    }

    /**
     * public method to create new room , used by the admin user
     * @param room : the room details
     * @return Room : with room id or null if failed to create it.
     * @throws RemoteException
     */
    public Room createRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.createRoom(room);
    }

    /**
     * method to delete user
     * @param user : to be deleted
     * @return User
     * @throws RemoteException
     */
    public User delUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delUser(user);
    }

    /**
     * method to delete Group
     * @param Group : to be deleted
     * @return Group
     * @throws RemoteException
     */
    public Group delGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delGroup(group);
    }

    /**
     * method to delete Room
     * @param Room : to be deleted
     * @return Room
     * @throws RemoteException
     */
    public Room delRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.delRoom(room);
    }

    /**
     * method to update user
     * @param user to be updated
     * @return User after updated or null if failed to update it
     * @throws RemoteException
     */
    public User updateUser(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUser(user);
    }

    /**
     * method to update Group
     * @param Group to be updated
     * @return Group after updated or null if failed to update it
     * @throws RemoteException
     */
    public Group updateGroup(Group group, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateGroup(group);
    }

    /**
     * method to update Room
     * @param Room to be updated
     * @return Room after updated or null if failed to update it
     * @throws RemoteException
     */
    public Room updateRoom(Room room, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateRoom(room);
    }

    /**
     * public method to shutdown the server, it will include kick off of all users.
     * @throws RemoteException
     */
    public void shutdownServer(String justification, String authToken) throws RemoteException {
        if (this.authToken.equals(authToken) || ""FIM"".equals(authToken)) {
            getLogger().log(Level.SEVERE, ""Shutdown Server by the admin"");
            for (int i = 0; i < groups.size(); i++) {
                Vector<User> tempUsers = groups.get(i).getUsers();
                for (int n = 0; n < tempUsers.size(); n++) {
                    SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(tempUsers.get(n).getId()), justification);
                    sendKickOffMessageThread.start();
                }
            }
            try {
                Thread.sleep(500 * 1);
            } catch (InterruptedException ex) {
                //do no thing!
            }
            System.exit(-1);
        } else {
            getLogger().log(Level.SEVERE, ""Invalid authentication token!"");
            throw new RemoteException(""Invalid Login Token"");
        }
    }

    /**
     * public method to kick of all users
     * @return boolean true after kicking off all users
     * @throws RemoteException
     */
    public boolean kickOffUsers(String justification, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off All Users Server by the admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(cf, justification);
            sendKickOffMessageThread.start();
            offlineStatusAndNoUpdate(n);
        }
        connectedClients.clear();
        connectedClientsIPs.clear();
        return true;
    }

    /**
     * return all rooms
     * @return : Vector of all rooms
     * @throws RemoteException
     */
    public Vector<Room> loadRooms(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return rooms;
    }

    /**
     * method used for sign in by the admin user
     * @param emailAddr : email of the admin user
     * @param password  : password of the admin user.
     * @return User either adminUser object or null if authentication failed.
     * @throws RemoteException
     */
    public LoginBean signInAsAdmin(String emailAddr, String password) throws RemoteException {
        //authenticate User
        //DB authentication....
        if (emailAddr != null && password != null) {
            String email = StringEncoder64.decodeStringUTF8(emailAddr);
            User user = null;
            String orignalPass = passwordEnc.decrypt(passwords.get(1000));
            password = StringEncrypter.getInstance(orignalPass).decrypt(password);
            if (email.equalsIgnoreCase(getAdminUser().getEmail()) && password != null && password.equals(orignalPass)) {
                user = getAdminUser();
            }
            if (user != null) {
                getLogger().log(Level.FINE, ""User "" + email + "" has logged in."");
                authToken = ""FIM"" + Calendar.getInstance().getTimeInMillis();
                LoginBean loginBean = new LoginBean();
                loginBean.setUser(adminUser);
                loginBean.setAuthToken(authToken);
                String tokenUsed = StringEncrypter.getInstance(orignalPass).encrypt(secToken);
                loginBean.setSecureToken(tokenUsed);
                return loginBean;
            } else {
                getLogger().log(Level.FINE, ""User "" + email + "" is not valid!"");
                return null;
            }
        } else {
            getLogger().log(Level.WARNING, ""Credentials is null!"");
            return null;
        }
    }

    /**
     * public method to set a new default password for newly created users
     * @param newPass : the new default password.
     * @return true after set the new default password.
     * @throws RemoteException
     */
    public boolean setNewDefaultPassword(String newPass, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        newPass = StringEncrypter.getInstance(secToken).decrypt(newPass);
        newPass = passwordEnc.encrypt(newPass);
        getServerSettingBean().setDefualtPassword(newPass);
        getServerSettingBean().updateSettings();
        return true;
    }

    /**
     * public method to reset user password , used by the admin user to reset user password.
     * @param user : to reset its password.
     * @return User or null if failed to reset his/her password.
     * @throws RemoteException
     */
    public User resetUserPass(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        if (user != null) {
            getLogger().log(Level.FINE, ""Reset User "" + user.getId() + "" password!"");
            user = userBD.resetUserPass(user);
            if (user != null) {
                passwords.put(user.getId(), serverSettingBean.getDefualtPassword());
                return user;
            } else {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * @return the serverSettingBean
     */
    public ServerSettingBean getServerSettingBean() {
        return serverSettingBean;
    }

    /**
     * public method to move user from a group into another group
     * @param user : to be moved included the group id of the new group
     * @return User or null if failed to move this user.
     * @throws RemoteException
     */
    public User updateUserGroup(User user, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return userBD.updateUserGroup(user);
    }

    /**
     * public method to set the log level of the server.
     * @param level integer from 0 - 5 (0 = no logging , 5 = All)
     * @param saveValue , save the log level or just set it without saving it.
     * @return true after set it.
     * @throws RemoteException
     */
    public boolean setLogLevel(int level, boolean saveValue, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        switch(level) {
            case 0:
                getLogger().setLevel(Level.OFF);
                break;
            case 1:
                getLogger().setLevel(Level.SEVERE);
                break;
            case 2:
                getLogger().setLevel(Level.WARNING);
                break;
            case 3:
                getLogger().setLevel(Level.INFO);
                break;
            case 4:
                getLogger().setLevel(Level.FINE);
                break;
            case 5:
                getLogger().setLevel(Level.ALL);
                break;
        }
        if (saveValue) {
            serverSettingBean.setLogLevel("""" + level);
            serverSettingBean.updateSettings();
        }
        return true;
    }

    /**
     * public method to return online users ips
     * @return Hashtable of the online users ips
     * @throws RemoteException
     */
    public Hashtable<Integer, String> returnOnlineIPs(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return connectedClientsIPs;
    }

    /**
     * public method to get security mode
     * @return int the security level.
     * @throws RemoteException
     */
    public int getSecurityMode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return securityMode;
    }

    /**
     * public method to kick off a user
     * @param userId : of the user to be kicked off
     * @return true when the user kicked off
     * @throws RemoteException
     */
    public boolean kickOffUser(int userId, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Kick Off User by the admin"");
        SendKickOffMessageThread sendKickOffMessageThread = new SendKickOffMessageThread(connectedClients.get(userId), """");
        sendKickOffMessageThread.start();
        if (connectedClients.get(userId) != null)
            offlineStatus(userId);
        connectedClients.remove(userId);
        connectedClientsIPs.remove(userId);
        return true;
    }

    /**
     * public method to set the security level
     * @param level : either : 0= encrypt email/password, 1=encrypt titles, 2=encrypt also files.
     * @return int of the security level after set the level
     * @throws RemoteException
     */
    public int setSecurityMode(int level, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setSecureMode("""" + level);
        serverSettingBean.updateSettings();
        securityMode = level;
        return securityMode;
    }

    /**
     * public method to get log level
     * @return int of the got level
     * @throws RemoteException
     */
    public int getLogLevel(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return Integer.parseInt(serverSettingBean.getLogLevel());
    }

    /**
     * @return the adminUser
     */
    public User getAdminUser() {
        return adminUser;
    }

    public String getRootNode(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        return serverSettingBean.getRootNode();
    }

    public boolean setRootNode(String rootNode, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        serverSettingBean.setRootNode(rootNode);
        serverSettingBean.updateSettings();
        return true;
    }

    public boolean sendGlobalTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(""System Admin"");
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public boolean sendGlobalSecureTextAnn(String msg, String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Send Global Secure Text Announcement by the admin"");
        TextMessage tm = new TextMessage();
        tm.setFromUserId(0);
        tm.setTitle(StringEncrypter.getInstance(secToken).encrypt(""System Admin""));
        tm.setMessage(msg);
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            sendSecureTextAnnouncementToUser(tm, cf);
        }
        return true;
    }

    public int getSecurityMode() throws RemoteException {
        return securityMode;
    }

    public String getRootNode() throws RemoteException {
        return serverSettingBean.getRootNode();
    }

    public boolean refreshContactList(String authToken) throws RemoteException {
        if (!this.authToken.equals(authToken)) {
            throw new RemoteException(""Invalid Login Token"");
        }
        getLogger().log(Level.SEVERE, ""Refresh Users contact list by admin"");
        ClientInterface cf = null;
        Enumeration<Integer> listOfUserIds = connectedClients.keys();
        while (listOfUserIds.hasMoreElements()) {
            int n = listOfUserIds.nextElement();
            cf = connectedClients.get(n);
            SendRefreshContactThread sendRefreshContactThread = new SendRefreshContactThread(cf, groups);
            sendRefreshContactThread.start();
        }
        return true;
    }

    /**
     * @return the passwordEnc
     */
    public StringEncrypter getPasswordEnc() {
        return passwordEnc;
    }
}
","// ModernChatServer_9Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_9Test {","// ModernChatServer_9Test.java
package osa.ora.server;

import java.net.URISyntaxException;
import java.rmi.Naming;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.rmi.server.UnicastRemoteObject;
import java.util.Calendar;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import javax.swing.JOptionPane;
import osa.ora.server.bd.UsersBD;
import osa.ora.server.beans.BinaryMessage;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.IConstant;
import osa.ora.server.beans.LoginBean;
import osa.ora.server.beans.ResultBean;
import osa.ora.server.beans.Room;
import osa.ora.server.beans.ServerSettingBean;
import osa.ora.server.beans.TextMessage;
import osa.ora.server.beans.User;
import osa.ora.server.client.ClientInterface;
import osa.ora.server.threads.SendKickOffByLoginMessageThread;
import osa.ora.server.threads.SendKickOffMessageThread;
import osa.ora.server.threads.SendRefreshContactThread;
import osa.ora.server.threads.SendUserUpdatedStatusThread;
import osa.ora.server.utils.StringEncoder64;
import osa.ora.server.utils.StringEncrypter;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModernChatServer}.
* It contains ten unit test cases for the {@link ModernChatServer#sendSecureBinaryMessage(BinaryMessage)} method.
*/
class ModernChatServer_9Test {
"
1881be96-af7f-4795-8a23-edef454b467a,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 10586 tokens (6586 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JFontChooser.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

/**
 * <code>JFontChooser</code> provides a pane of controls designed to allow
 * a user to manipulate and select a font.
 *
 * This class provides three levels of API:
 * <ol>
 * <li>A static convenience method which shows a modal font-chooser
 * dialog and returns the font selected by the user.
 * <li>A static convenience method for creating a font-chooser dialog
 * where <code>ActionListeners</code> can be specified to be invoked when
 * the user presses one of the dialog buttons.
 * <li>The ability to create instances of <code>JFontChooser</code> panes
 * directly (within any container). <code>PropertyChange</code> listeners
 * can be added to detect when the current ""font"" property changes.
 * </ol>
 * <p>
 *
 * @author Adrian BER
 */
public class JFontChooser extends JComponent {

    /**
     * The list of possible font sizes.
     */
    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };

    /**
     * The list of possible fonts.
     */
    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();

    private FontSelectionModel selectionModel;

    private JList fontList;

    private JList sizeList;

    private JCheckBox boldCheckBox;

    private JCheckBox italicCheckBox;

    private JLabel previewLabel;

    /**
     * The preview text, if null the font name will be the preview text.
     */
    private String previewText;

    /**
     * Listener used to update the font of the selection model.
     */
    private SelectionUpdater selectionUpdater = new SelectionUpdater();

    /**
     * Listener used to update the font in the components. This should be registered
     * with the selection model.
     */
    private LabelUpdater labelUpdater = new LabelUpdater();

    /**
     * True if the components are being updated and no event should be generated.
     */
    private boolean updatingComponents = false;

    /**
     * Listener class used to update the font in the components. This should be registered
     * with the selection model.
     */
    private class LabelUpdater implements ChangeListener {

        public void stateChanged(ChangeEvent e) {
            updateComponents();
        }
    }

    /**
     * Listener class used to update the font of the preview label.
     */
    private class SelectionUpdater implements ChangeListener, ListSelectionListener {

        public void stateChanged(ChangeEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }

        public void valueChanged(ListSelectionEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }
    }

    /**
     * Shows a modal font-chooser dialog and blocks until the
     * dialog is hidden.  If the user presses the ""OK"" button, then
     * this method hides/disposes the dialog and returns the selected color.
     * If the user presses the ""Cancel"" button or closes the dialog without
     * pressing ""OK"", then this method hides/disposes the dialog and returns
     * <code>null</code>.
     *
     * @param component    the parent <code>Component</code> for the dialog
     * @param title        the String containing the dialog's title
     * @return the selected font or <code>null</code> if the user opted out
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public Font showDialog(Component component, String title) {
        FontTracker ok = new FontTracker(this);
        JDialog dialog = createDialog(component, title, true, ok, null);
        dialog.addWindowListener(new FontChooserDialog.Closer());
        dialog.addComponentListener(new FontChooserDialog.DisposeOnClose());
        dialog.setAlwaysOnTop(true);
        // blocks until user brings dialog down...
        dialog.setVisible(true);
        return ok.getFont();
    }

    /**
     * Creates and returns a new dialog containing the specified
     * <code>ColorChooser</code> pane along with ""OK"", ""Cancel"", and ""Reset""
     * buttons. If the ""OK"" or ""Cancel"" buttons are pressed, the dialog is
     * automatically hidden (but not disposed).  If the ""Reset""
     * button is pressed, the color-chooser's color will be reset to the
     * font which was set the last time <code>show</code> was invoked on the
     * dialog and the dialog will remain showing.
     *
     * @param c              the parent component for the dialog
     * @param title          the title for the dialog
     * @param modal          a boolean. When true, the remainder of the program
     *                       is inactive until the dialog is closed.
     * @param okListener     the ActionListener invoked when ""OK"" is pressed
     * @param cancelListener the ActionListener invoked when ""Cancel"" is pressed
     * @return a new dialog containing the font-chooser pane
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {
        return new FontChooserDialog(c, title, modal, this, okListener, cancelListener);
    }

    /**
     * Creates a color chooser pane with an initial font which is the same font
     * as the default font for labels.
     */
    public JFontChooser() {
        this(new DefaultFontSelectionModel());
    }

    /**
     * Creates a font chooser pane with the specified initial font.
     *
     * @param initialFont the initial font set in the chooser
     */
    public JFontChooser(Font initialFont) {
        this(new DefaultFontSelectionModel(initialFont));
    }

    /**
     * Creates a font chooser pane with the specified
     * <code>FontSelectionModel</code>.
     *
     * @param model the font selection model used by this component
     */
    public JFontChooser(FontSelectionModel model) {
        selectionModel = model;
        init(model.getSelectedFont());
        selectionModel.addChangeListener(labelUpdater);
    }

    private void init(Font font) {
        setLayout(new GridBagLayout());
        Insets ins = new Insets(2, 2, 2, 2);
        fontList = new JList(FONTS);
        fontList.setVisibleRowCount(10);
        fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        add(new JScrollPane(fontList), new GridBagConstraints(0, 0, 1, 1, 2, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));
        sizeList = new JList(SIZES);
        ((JLabel) sizeList.getCellRenderer()).setHorizontalAlignment(JLabel.RIGHT);
        sizeList.setVisibleRowCount(10);
        sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        add(new JScrollPane(sizeList), new GridBagConstraints(1, 0, 1, 1, 1, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));
        boldCheckBox = new JCheckBox(""Bold"");
        add(boldCheckBox, new GridBagConstraints(0, 1, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));
        italicCheckBox = new JCheckBox(""Italic"");
        add(italicCheckBox, new GridBagConstraints(0, 2, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));
        previewLabel = new JLabel("""");
        previewLabel.setHorizontalAlignment(JLabel.CENTER);
        previewLabel.setVerticalAlignment(JLabel.CENTER);
        add(new JScrollPane(previewLabel), new GridBagConstraints(0, 3, 2, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));
        setFont(font == null ? previewLabel.getFont() : font);
        fontList.addListSelectionListener(selectionUpdater);
        sizeList.addListSelectionListener(selectionUpdater);
        boldCheckBox.addChangeListener(selectionUpdater);
        italicCheckBox.addChangeListener(selectionUpdater);
    }

    private Font buildFont() {
        //        Font labelFont = previewLabel.getFont();
        String fontName = (String) fontList.getSelectedValue();
        if (fontName == null) {
            return null;
            //            fontName = labelFont.getName();
        }
        Integer sizeInt = (Integer) sizeList.getSelectedValue();
        if (sizeInt == null) {
            //            size = labelFont.getSize();
            return null;
        }
        // create the font
        //        // first create the font attributes
        //        HashMap map = new HashMap();
        //        map.put(TextAttribute.BACKGROUND, Color.white);
        //        map.put(TextAttribute.FAMILY, fontName);
        //        map.put(TextAttribute.FOREGROUND, Color.black);
        //        map.put(TextAttribute.SIZE , new Float(size));
        //        map.put(TextAttribute.UNDERLINE, italicCheckBox.isSelected() ? TextAttribute.UNDERLINE_LOW_ONE_PIXEL : TextAttribute.UNDERLINE_LOW_TWO_PIXEL);
        //        map.put(TextAttribute.STRIKETHROUGH, italicCheckBox.isSelected() ? TextAttribute.STRIKETHROUGH_ON : Boolean.FALSE);
        //        map.put(TextAttribute.WEIGHT, boldCheckBox.isSelected() ? TextAttribute.WEIGHT_BOLD : TextAttribute.WEIGHT_REGULAR);
        //        map.put(TextAttribute.POSTURE,
        //                italicCheckBox.isSelected() ? TextAttribute.POSTURE_OBLIQUE : TextAttribute.POSTURE_REGULAR);
        //
        //        return new Font(map);
        return new Font(fontName, (italicCheckBox.isSelected() ? Font.ITALIC : Font.PLAIN) | (boldCheckBox.isSelected() ? Font.BOLD : Font.PLAIN), sizeInt);
    }

    /**
     * Updates the font in the preview component according to the selected values.
     */
    private void updateComponents() {
        updatingComponents = true;
        Font font = getFont();
        fontList.setSelectedValue(font.getName(), true);
        sizeList.setSelectedValue(font.getSize(), true);
        boldCheckBox.setSelected(font.isBold());
        italicCheckBox.setSelected(font.isItalic());
        if (previewText == null) {
            previewLabel.setText(font.getName());
        }
        // set the font and fire a property change
        Font oldValue = previewLabel.getFont();
        previewLabel.setFont(font);
        firePropertyChange(""font"", oldValue, font);
        updatingComponents = false;
    }

    /**
     * Returns the data model that handles font selections.
     *
     * @return a FontSelectionModel object
     */
    public FontSelectionModel getSelectionModel() {
        return selectionModel;
    }

    /**
     * Set the model containing the selected font.
     *
     * @param newModel   the new FontSelectionModel object
     */
    public void setSelectionModel(FontSelectionModel newModel) {
        FontSelectionModel oldModel = selectionModel;
        selectionModel = newModel;
        oldModel.removeChangeListener(labelUpdater);
        newModel.addChangeListener(labelUpdater);
        firePropertyChange(""selectionModel"", oldModel, newModel);
    }

    /**
     * Gets the current font value from the font chooser.
     *
     * @return the current font value of the font chooser
     */
    public Font getFont() {
        return selectionModel.getSelectedFont();
    }

    /**
     * Sets the current font of the font chooser to the specified font.
     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>
     * @param font the font to be set in the font chooser
     * @see JComponent#addPropertyChangeListener
     */
    public void setFont(Font font) {
        selectionModel.setSelectedFont(font);
    }

    /**
     * Returns the preview text displayed in the preview component.
     * @return the preview text, if null the font name will be displayed
     */
    public String getPreviewText() {
        return previewText;
    }

    /**
     * Sets the preview text displayed in the preview component.
     * @param previewText the preview text, if null the font name will be displayed
     */
    public void setPreviewText(String previewText) {
        this.previewText = previewText;
        previewLabel.setText("""");
        updateComponents();
    }
}

/*
 * Class which builds a font chooser dialog consisting of
 * a JFontChooser with ""Ok"", ""Cancel"", and ""Reset"" buttons.
 *
 * Note: This needs to be fixed to deal with localization!
 */
class FontChooserDialog extends JDialog {

    private Font initialFont;

    private JFontChooser chooserPane;

    public FontChooserDialog(Component c, String title, boolean modal, JFontChooser chooserPane, ActionListener okListener, ActionListener cancelListener) {
        super(JOptionPane.getFrameForComponent(c), title, modal);
        //setResizable(false);
        String okString = UIManager.getString(""ColorChooser.okText"");
        String cancelString = UIManager.getString(""ColorChooser.cancelText"");
        String resetString = UIManager.getString(""ColorChooser.resetText"");
        /*
         * Create Lower button panel
         */
        JPanel buttonPane = new JPanel();
        buttonPane.setLayout(new FlowLayout(FlowLayout.CENTER));
        JButton okButton = new JButton(okString);
        getRootPane().setDefaultButton(okButton);
        okButton.setActionCommand(""OK"");
        if (okListener != null) {
            okButton.addActionListener(okListener);
        }
        okButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                setVisible(false);
            }
        });
        buttonPane.add(okButton);
        JButton cancelButton = new JButton(cancelString);
        // The following few lines are used to register esc to close the dialog
        Action cancelKeyAction = new AbstractAction() {

            public void actionPerformed(ActionEvent e) {
                // todo make it in 1.3
                //                ActionListener[] listeners
                //                        = ((AbstractButton) e.getSource()).getActionListeners();
                //                for (int i = 0; i < listeners.length; i++) {
                //                    listeners[i].actionPerformed(e);
                //                }
            }
        };
        KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke((char) KeyEvent.VK_ESCAPE);
        InputMap inputMap = cancelButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
        ActionMap actionMap = cancelButton.getActionMap();
        if (inputMap != null && actionMap != null) {
            inputMap.put(cancelKeyStroke, ""cancel"");
            actionMap.put(""cancel"", cancelKeyAction);
        }
        // end esc handling
        cancelButton.setActionCommand(""cancel"");
        if (cancelListener != null) {
            cancelButton.addActionListener(cancelListener);
        }
        cancelButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                setVisible(false);
            }
        });
        buttonPane.add(cancelButton);
        JButton resetButton = new JButton(resetString);
        resetButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                reset();
            }
        });
        int mnemonic = UIManager.getInt(""ColorChooser.resetMnemonic"");
        if (mnemonic != -1) {
            resetButton.setMnemonic(mnemonic);
        }
        buttonPane.add(resetButton);
        // initialiase the content pane
        this.chooserPane = chooserPane;
        Container contentPane = getContentPane();
        contentPane.setLayout(new BorderLayout());
        contentPane.add(chooserPane, BorderLayout.CENTER);
        contentPane.add(buttonPane, BorderLayout.SOUTH);
        pack();
        setLocationRelativeTo(c);
    }

    public void setVisible(boolean visible) {
        if (visible)
            initialFont = chooserPane.getFont();
        super.setVisible(visible);
    }

    public void reset() {
        chooserPane.setFont(initialFont);
    }

    static class Closer extends WindowAdapter implements Serializable {

        public void windowClosing(WindowEvent e) {
            Window w = e.getWindow();
            w.setVisible(false);
        }
    }

    static class DisposeOnClose extends ComponentAdapter implements Serializable {

        public void componentHidden(ComponentEvent e) {
            Window w = (Window) e.getComponent();
            w.dispose();
        }
    }
}

class FontTracker implements ActionListener, Serializable {

    JFontChooser chooser;

    Font color;

    public FontTracker(JFontChooser c) {
        chooser = c;
    }

    public void actionPerformed(ActionEvent e) {
        color = chooser.getFont();
    }

    public Font getFont() {
        return color;
    }
}

/**
 * A generic implementation of <code>{@link FontSelectionModel}</code>.
 *
 * @author Adrian BER
 */
class DefaultFontSelectionModel implements FontSelectionModel {

    /**
     * The default selected font.
     */
    private static final Font DEFAULT_INITIAL_FONT = new Font(""Dialog"", Font.PLAIN, 12);

    /**
     * The selected font.
     */
    private Font selectedFont;

    /**
     * The change listeners notified by a change in this model.
     */
    private EventListenerList listeners = new EventListenerList();

    /**
     * Creates a <code>DefaultFontSelectionModel</code> with the
     * current font set to <code>Dialog, 12</code>.  This is
     * the default constructor.
     */
    public DefaultFontSelectionModel() {
        this(DEFAULT_INITIAL_FONT);
    }

    /**
     * Creates a <code>DefaultFontSelectionModel</code> with the
     * current font set to <code>font</code>, which should be
     * non-<code>null</code>.  Note that setting the font to
     * <code>null</code> is undefined and may have unpredictable
     * results.
     *
     * @param selectedFont the new <code>Font</code>
     */
    public DefaultFontSelectionModel(Font selectedFont) {
        if (selectedFont == null) {
            selectedFont = DEFAULT_INITIAL_FONT;
        }
        this.selectedFont = selectedFont;
    }

    public Font getSelectedFont() {
        return selectedFont;
    }

    public void setSelectedFont(Font selectedFont) {
        if (selectedFont != null) {
            this.selectedFont = selectedFont;
            fireChangeListeners();
        }
    }

    public void addChangeListener(ChangeListener listener) {
        listeners.add(ChangeListener.class, listener);
    }

    public void removeChangeListener(ChangeListener listener) {
        listeners.remove(ChangeListener.class, listener);
    }

    /**
     * Fires the listeners registered with this model.
     */
    protected void fireChangeListeners() {
        ChangeEvent ev = new ChangeEvent(this);
        Object[] l = listeners.getListeners(ChangeListener.class);
        for (Object listener : l) {
            ((ChangeListener) listener).stateChanged(ev);
        }
    }
}

/**
 * A model that supports selecting a <code>Font</code>.
 *
 * @author Adrian BER
 *
 * @see java.awt.Font
 */
interface FontSelectionModel {

    /**
     * Returns the selected <code>Font</code> which should be
     * non-<code>null</code>.
     *
     * @return  the selected <code>Font</code>
     * @see     #setSelectedFont
     */
    Font getSelectedFont();

    /**
     * Sets the selected font to <code>font</code>.
     * Note that setting the font to <code>null</code>
     * is undefined and may have unpredictable results.
     * This method fires a state changed event if it sets the
     * current font to a new non-<code>null</code> font.
     *
     * @param font the new <code>Font</code>
     * @see   #getSelectedFont
     * @see   #addChangeListener
     */
    void setSelectedFont(Font font);

    /**
     * Adds <code>listener</code> as a listener to changes in the model.
     * @param listener the <code>ChangeListener</code> to be added
     */
    void addChangeListener(ChangeListener listener);

    /**
     * Removes <code>listener</code> as a listener to changes in the model.
     * @param listener the <code>ChangeListener</code> to be removed
     */
    void removeChangeListener(ChangeListener listener);
}
","// JFontChooser_0Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#showDialog(Component, String)} method.
*/
class JFontChooser_0Test {","// JFontChooser_0Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#showDialog(Component, String)} method.
*/
class JFontChooser_0Test {
"
4a76a96f-5247-4822-9d7a-5812a4d5b545,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/JFontChooser_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 10594 tokens (6594 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// JFontChooser.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;

/**
 * <code>JFontChooser</code> provides a pane of controls designed to allow
 * a user to manipulate and select a font.
 *
 * This class provides three levels of API:
 * <ol>
 * <li>A static convenience method which shows a modal font-chooser
 * dialog and returns the font selected by the user.
 * <li>A static convenience method for creating a font-chooser dialog
 * where <code>ActionListeners</code> can be specified to be invoked when
 * the user presses one of the dialog buttons.
 * <li>The ability to create instances of <code>JFontChooser</code> panes
 * directly (within any container). <code>PropertyChange</code> listeners
 * can be added to detect when the current ""font"" property changes.
 * </ol>
 * <p>
 *
 * @author Adrian BER
 */
public class JFontChooser extends JComponent {

    /**
     * The list of possible font sizes.
     */
    private static final Integer[] SIZES = { 8, 9, 10, 11, 12, 13, 14, 16, 18, 20, 24, 26, 28, 32, 36, 40, 48, 56, 64, 72 };

    /**
     * The list of possible fonts.
     */
    private static final String[] FONTS = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();

    private FontSelectionModel selectionModel;

    private JList fontList;

    private JList sizeList;

    private JCheckBox boldCheckBox;

    private JCheckBox italicCheckBox;

    private JLabel previewLabel;

    /**
     * The preview text, if null the font name will be the preview text.
     */
    private String previewText;

    /**
     * Listener used to update the font of the selection model.
     */
    private SelectionUpdater selectionUpdater = new SelectionUpdater();

    /**
     * Listener used to update the font in the components. This should be registered
     * with the selection model.
     */
    private LabelUpdater labelUpdater = new LabelUpdater();

    /**
     * True if the components are being updated and no event should be generated.
     */
    private boolean updatingComponents = false;

    /**
     * Listener class used to update the font in the components. This should be registered
     * with the selection model.
     */
    private class LabelUpdater implements ChangeListener {

        public void stateChanged(ChangeEvent e) {
            updateComponents();
        }
    }

    /**
     * Listener class used to update the font of the preview label.
     */
    private class SelectionUpdater implements ChangeListener, ListSelectionListener {

        public void stateChanged(ChangeEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }

        public void valueChanged(ListSelectionEvent e) {
            if (!updatingComponents) {
                setFont(buildFont());
            }
        }
    }

    /**
     * Shows a modal font-chooser dialog and blocks until the
     * dialog is hidden.  If the user presses the ""OK"" button, then
     * this method hides/disposes the dialog and returns the selected color.
     * If the user presses the ""Cancel"" button or closes the dialog without
     * pressing ""OK"", then this method hides/disposes the dialog and returns
     * <code>null</code>.
     *
     * @param component    the parent <code>Component</code> for the dialog
     * @param title        the String containing the dialog's title
     * @return the selected font or <code>null</code> if the user opted out
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public Font showDialog(Component component, String title) {
        FontTracker ok = new FontTracker(this);
        JDialog dialog = createDialog(component, title, true, ok, null);
        dialog.addWindowListener(new FontChooserDialog.Closer());
        dialog.addComponentListener(new FontChooserDialog.DisposeOnClose());
        dialog.setAlwaysOnTop(true);
        // blocks until user brings dialog down...
        dialog.setVisible(true);
        return ok.getFont();
    }

    /**
     * Creates and returns a new dialog containing the specified
     * <code>ColorChooser</code> pane along with ""OK"", ""Cancel"", and ""Reset""
     * buttons. If the ""OK"" or ""Cancel"" buttons are pressed, the dialog is
     * automatically hidden (but not disposed).  If the ""Reset""
     * button is pressed, the color-chooser's color will be reset to the
     * font which was set the last time <code>show</code> was invoked on the
     * dialog and the dialog will remain showing.
     *
     * @param c              the parent component for the dialog
     * @param title          the title for the dialog
     * @param modal          a boolean. When true, the remainder of the program
     *                       is inactive until the dialog is closed.
     * @param okListener     the ActionListener invoked when ""OK"" is pressed
     * @param cancelListener the ActionListener invoked when ""Cancel"" is pressed
     * @return a new dialog containing the font-chooser pane
     * @exception HeadlessException if GraphicsEnvironment.isHeadless()
     * returns true.
     * @see java.awt.GraphicsEnvironment#isHeadless
     */
    public JDialog createDialog(Component c, String title, boolean modal, ActionListener okListener, ActionListener cancelListener) {
        return new FontChooserDialog(c, title, modal, this, okListener, cancelListener);
    }

    /**
     * Creates a color chooser pane with an initial font which is the same font
     * as the default font for labels.
     */
    public JFontChooser() {
        this(new DefaultFontSelectionModel());
    }

    /**
     * Creates a font chooser pane with the specified initial font.
     *
     * @param initialFont the initial font set in the chooser
     */
    public JFontChooser(Font initialFont) {
        this(new DefaultFontSelectionModel(initialFont));
    }

    /**
     * Creates a font chooser pane with the specified
     * <code>FontSelectionModel</code>.
     *
     * @param model the font selection model used by this component
     */
    public JFontChooser(FontSelectionModel model) {
        selectionModel = model;
        init(model.getSelectedFont());
        selectionModel.addChangeListener(labelUpdater);
    }

    private void init(Font font) {
        setLayout(new GridBagLayout());
        Insets ins = new Insets(2, 2, 2, 2);
        fontList = new JList(FONTS);
        fontList.setVisibleRowCount(10);
        fontList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        add(new JScrollPane(fontList), new GridBagConstraints(0, 0, 1, 1, 2, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));
        sizeList = new JList(SIZES);
        ((JLabel) sizeList.getCellRenderer()).setHorizontalAlignment(JLabel.RIGHT);
        sizeList.setVisibleRowCount(10);
        sizeList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
        add(new JScrollPane(sizeList), new GridBagConstraints(1, 0, 1, 1, 1, 2, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));
        boldCheckBox = new JCheckBox(""Bold"");
        add(boldCheckBox, new GridBagConstraints(0, 1, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));
        italicCheckBox = new JCheckBox(""Italic"");
        add(italicCheckBox, new GridBagConstraints(0, 2, 2, 1, 1, 0, GridBagConstraints.WEST, GridBagConstraints.NONE, ins, 0, 0));
        previewLabel = new JLabel("""");
        previewLabel.setHorizontalAlignment(JLabel.CENTER);
        previewLabel.setVerticalAlignment(JLabel.CENTER);
        add(new JScrollPane(previewLabel), new GridBagConstraints(0, 3, 2, 1, 1, 1, GridBagConstraints.CENTER, GridBagConstraints.BOTH, ins, 0, 0));
        setFont(font == null ? previewLabel.getFont() : font);
        fontList.addListSelectionListener(selectionUpdater);
        sizeList.addListSelectionListener(selectionUpdater);
        boldCheckBox.addChangeListener(selectionUpdater);
        italicCheckBox.addChangeListener(selectionUpdater);
    }

    private Font buildFont() {
        //        Font labelFont = previewLabel.getFont();
        String fontName = (String) fontList.getSelectedValue();
        if (fontName == null) {
            return null;
            //            fontName = labelFont.getName();
        }
        Integer sizeInt = (Integer) sizeList.getSelectedValue();
        if (sizeInt == null) {
            //            size = labelFont.getSize();
            return null;
        }
        // create the font
        //        // first create the font attributes
        //        HashMap map = new HashMap();
        //        map.put(TextAttribute.BACKGROUND, Color.white);
        //        map.put(TextAttribute.FAMILY, fontName);
        //        map.put(TextAttribute.FOREGROUND, Color.black);
        //        map.put(TextAttribute.SIZE , new Float(size));
        //        map.put(TextAttribute.UNDERLINE, italicCheckBox.isSelected() ? TextAttribute.UNDERLINE_LOW_ONE_PIXEL : TextAttribute.UNDERLINE_LOW_TWO_PIXEL);
        //        map.put(TextAttribute.STRIKETHROUGH, italicCheckBox.isSelected() ? TextAttribute.STRIKETHROUGH_ON : Boolean.FALSE);
        //        map.put(TextAttribute.WEIGHT, boldCheckBox.isSelected() ? TextAttribute.WEIGHT_BOLD : TextAttribute.WEIGHT_REGULAR);
        //        map.put(TextAttribute.POSTURE,
        //                italicCheckBox.isSelected() ? TextAttribute.POSTURE_OBLIQUE : TextAttribute.POSTURE_REGULAR);
        //
        //        return new Font(map);
        return new Font(fontName, (italicCheckBox.isSelected() ? Font.ITALIC : Font.PLAIN) | (boldCheckBox.isSelected() ? Font.BOLD : Font.PLAIN), sizeInt);
    }

    /**
     * Updates the font in the preview component according to the selected values.
     */
    private void updateComponents() {
        updatingComponents = true;
        Font font = getFont();
        fontList.setSelectedValue(font.getName(), true);
        sizeList.setSelectedValue(font.getSize(), true);
        boldCheckBox.setSelected(font.isBold());
        italicCheckBox.setSelected(font.isItalic());
        if (previewText == null) {
            previewLabel.setText(font.getName());
        }
        // set the font and fire a property change
        Font oldValue = previewLabel.getFont();
        previewLabel.setFont(font);
        firePropertyChange(""font"", oldValue, font);
        updatingComponents = false;
    }

    /**
     * Returns the data model that handles font selections.
     *
     * @return a FontSelectionModel object
     */
    public FontSelectionModel getSelectionModel() {
        return selectionModel;
    }

    /**
     * Set the model containing the selected font.
     *
     * @param newModel   the new FontSelectionModel object
     */
    public void setSelectionModel(FontSelectionModel newModel) {
        FontSelectionModel oldModel = selectionModel;
        selectionModel = newModel;
        oldModel.removeChangeListener(labelUpdater);
        newModel.addChangeListener(labelUpdater);
        firePropertyChange(""selectionModel"", oldModel, newModel);
    }

    /**
     * Gets the current font value from the font chooser.
     *
     * @return the current font value of the font chooser
     */
    public Font getFont() {
        return selectionModel.getSelectedFont();
    }

    /**
     * Sets the current font of the font chooser to the specified font.
     * The <code>ColorSelectionModel</code> will fire a <code>ChangeEvent</code>
     * @param font the font to be set in the font chooser
     * @see JComponent#addPropertyChangeListener
     */
    public void setFont(Font font) {
        selectionModel.setSelectedFont(font);
    }

    /**
     * Returns the preview text displayed in the preview component.
     * @return the preview text, if null the font name will be displayed
     */
    public String getPreviewText() {
        return previewText;
    }

    /**
     * Sets the preview text displayed in the preview component.
     * @param previewText the preview text, if null the font name will be displayed
     */
    public void setPreviewText(String previewText) {
        this.previewText = previewText;
        previewLabel.setText("""");
        updateComponents();
    }
}

/*
 * Class which builds a font chooser dialog consisting of
 * a JFontChooser with ""Ok"", ""Cancel"", and ""Reset"" buttons.
 *
 * Note: This needs to be fixed to deal with localization!
 */
class FontChooserDialog extends JDialog {

    private Font initialFont;

    private JFontChooser chooserPane;

    public FontChooserDialog(Component c, String title, boolean modal, JFontChooser chooserPane, ActionListener okListener, ActionListener cancelListener) {
        super(JOptionPane.getFrameForComponent(c), title, modal);
        //setResizable(false);
        String okString = UIManager.getString(""ColorChooser.okText"");
        String cancelString = UIManager.getString(""ColorChooser.cancelText"");
        String resetString = UIManager.getString(""ColorChooser.resetText"");
        /*
         * Create Lower button panel
         */
        JPanel buttonPane = new JPanel();
        buttonPane.setLayout(new FlowLayout(FlowLayout.CENTER));
        JButton okButton = new JButton(okString);
        getRootPane().setDefaultButton(okButton);
        okButton.setActionCommand(""OK"");
        if (okListener != null) {
            okButton.addActionListener(okListener);
        }
        okButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                setVisible(false);
            }
        });
        buttonPane.add(okButton);
        JButton cancelButton = new JButton(cancelString);
        // The following few lines are used to register esc to close the dialog
        Action cancelKeyAction = new AbstractAction() {

            public void actionPerformed(ActionEvent e) {
                // todo make it in 1.3
                //                ActionListener[] listeners
                //                        = ((AbstractButton) e.getSource()).getActionListeners();
                //                for (int i = 0; i < listeners.length; i++) {
                //                    listeners[i].actionPerformed(e);
                //                }
            }
        };
        KeyStroke cancelKeyStroke = KeyStroke.getKeyStroke((char) KeyEvent.VK_ESCAPE);
        InputMap inputMap = cancelButton.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
        ActionMap actionMap = cancelButton.getActionMap();
        if (inputMap != null && actionMap != null) {
            inputMap.put(cancelKeyStroke, ""cancel"");
            actionMap.put(""cancel"", cancelKeyAction);
        }
        // end esc handling
        cancelButton.setActionCommand(""cancel"");
        if (cancelListener != null) {
            cancelButton.addActionListener(cancelListener);
        }
        cancelButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                setVisible(false);
            }
        });
        buttonPane.add(cancelButton);
        JButton resetButton = new JButton(resetString);
        resetButton.addActionListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                reset();
            }
        });
        int mnemonic = UIManager.getInt(""ColorChooser.resetMnemonic"");
        if (mnemonic != -1) {
            resetButton.setMnemonic(mnemonic);
        }
        buttonPane.add(resetButton);
        // initialiase the content pane
        this.chooserPane = chooserPane;
        Container contentPane = getContentPane();
        contentPane.setLayout(new BorderLayout());
        contentPane.add(chooserPane, BorderLayout.CENTER);
        contentPane.add(buttonPane, BorderLayout.SOUTH);
        pack();
        setLocationRelativeTo(c);
    }

    public void setVisible(boolean visible) {
        if (visible)
            initialFont = chooserPane.getFont();
        super.setVisible(visible);
    }

    public void reset() {
        chooserPane.setFont(initialFont);
    }

    static class Closer extends WindowAdapter implements Serializable {

        public void windowClosing(WindowEvent e) {
            Window w = e.getWindow();
            w.setVisible(false);
        }
    }

    static class DisposeOnClose extends ComponentAdapter implements Serializable {

        public void componentHidden(ComponentEvent e) {
            Window w = (Window) e.getComponent();
            w.dispose();
        }
    }
}

class FontTracker implements ActionListener, Serializable {

    JFontChooser chooser;

    Font color;

    public FontTracker(JFontChooser c) {
        chooser = c;
    }

    public void actionPerformed(ActionEvent e) {
        color = chooser.getFont();
    }

    public Font getFont() {
        return color;
    }
}

/**
 * A generic implementation of <code>{@link FontSelectionModel}</code>.
 *
 * @author Adrian BER
 */
class DefaultFontSelectionModel implements FontSelectionModel {

    /**
     * The default selected font.
     */
    private static final Font DEFAULT_INITIAL_FONT = new Font(""Dialog"", Font.PLAIN, 12);

    /**
     * The selected font.
     */
    private Font selectedFont;

    /**
     * The change listeners notified by a change in this model.
     */
    private EventListenerList listeners = new EventListenerList();

    /**
     * Creates a <code>DefaultFontSelectionModel</code> with the
     * current font set to <code>Dialog, 12</code>.  This is
     * the default constructor.
     */
    public DefaultFontSelectionModel() {
        this(DEFAULT_INITIAL_FONT);
    }

    /**
     * Creates a <code>DefaultFontSelectionModel</code> with the
     * current font set to <code>font</code>, which should be
     * non-<code>null</code>.  Note that setting the font to
     * <code>null</code> is undefined and may have unpredictable
     * results.
     *
     * @param selectedFont the new <code>Font</code>
     */
    public DefaultFontSelectionModel(Font selectedFont) {
        if (selectedFont == null) {
            selectedFont = DEFAULT_INITIAL_FONT;
        }
        this.selectedFont = selectedFont;
    }

    public Font getSelectedFont() {
        return selectedFont;
    }

    public void setSelectedFont(Font selectedFont) {
        if (selectedFont != null) {
            this.selectedFont = selectedFont;
            fireChangeListeners();
        }
    }

    public void addChangeListener(ChangeListener listener) {
        listeners.add(ChangeListener.class, listener);
    }

    public void removeChangeListener(ChangeListener listener) {
        listeners.remove(ChangeListener.class, listener);
    }

    /**
     * Fires the listeners registered with this model.
     */
    protected void fireChangeListeners() {
        ChangeEvent ev = new ChangeEvent(this);
        Object[] l = listeners.getListeners(ChangeListener.class);
        for (Object listener : l) {
            ((ChangeListener) listener).stateChanged(ev);
        }
    }
}

/**
 * A model that supports selecting a <code>Font</code>.
 *
 * @author Adrian BER
 *
 * @see java.awt.Font
 */
interface FontSelectionModel {

    /**
     * Returns the selected <code>Font</code> which should be
     * non-<code>null</code>.
     *
     * @return  the selected <code>Font</code>
     * @see     #setSelectedFont
     */
    Font getSelectedFont();

    /**
     * Sets the selected font to <code>font</code>.
     * Note that setting the font to <code>null</code>
     * is undefined and may have unpredictable results.
     * This method fires a state changed event if it sets the
     * current font to a new non-<code>null</code> font.
     *
     * @param font the new <code>Font</code>
     * @see   #getSelectedFont
     * @see   #addChangeListener
     */
    void setSelectedFont(Font font);

    /**
     * Adds <code>listener</code> as a listener to changes in the model.
     * @param listener the <code>ChangeListener</code> to be added
     */
    void addChangeListener(ChangeListener listener);

    /**
     * Removes <code>listener</code> as a listener to changes in the model.
     * @param listener the <code>ChangeListener</code> to be removed
     */
    void removeChangeListener(ChangeListener listener);
}
","// JFontChooser_1Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#createDialog(Component, String, boolean, ActionListener, ActionListener)} method.
*/
class JFontChooser_1Test {","// JFontChooser_1Test.java
package osa.ora.server.client.ui.utils;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.Container;
import java.awt.FlowLayout;
import java.awt.Font;
import java.awt.GraphicsEnvironment;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.Window;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.KeyEvent;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.io.Serializable;
import javax.swing.AbstractAction;
import javax.swing.Action;
import javax.swing.ActionMap;
import javax.swing.InputMap;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.KeyStroke;
import javax.swing.ListSelectionModel;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.EventListenerList;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JFontChooser}.
* It contains ten unit test cases for the {@link JFontChooser#createDialog(Component, String, boolean, ActionListener, ActionListener)} method.
*/
class JFontChooser_1Test {
"
cmpl-6u9vt8PLszBXCvelRNuEhKimtlTzc,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/client/ui/utils/TreeModelGenerator.java,83.34127163887024,length,"// TreeModelGenerator.java
/*
 * TreeModelGenerator.java
 *
 * Created on October 29, 2009, 10:35 PM
 *
 * To change this template, choose Tools | Template Manager
 * and open the template in the editor.
 */
package osa.ora.server.client.ui.utils;

import java.util.Vector;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.User;

public class TreeModelGenerator {

    /**
     * @param spaces
     * @return
     */
    public static DefaultTreeModel getModel(String rootNodeStr, Vector groups, Vector rooms, User user, boolean showOnlineOnly, boolean showUsersOnly) {
        DefaultMutableTreeNode rootNode = new DefaultMutableTreeNode(rootNodeStr);
        for (int i = 0; i < groups.size(); i++) {
            if (showUsersOnly) {
                if (((Group) groups.get(i)).getUsers() != null) {
                    setChildes(rootNode, ((Group) groups.get(i)).getUsers(), user, showOnlineOnly);
                }
            } else {
                DefaultMutableTreeNode nodeTemp = new DefaultMutableTreeNode(groups.get(i));
                rootNode.add(nodeTemp);
                if (((Group) groups.get(i)).getUsers() != null) {
                    setChildes(nodeTemp, ((Group) groups.get(i)).getUsers(), user, showOnlineOnly);
                }
            }
        }
        for (int i = 0; i < rooms.size(); i++) {
            DefaultMutableTreeNode nodeTemp = new DefaultMutableTreeNode(rooms.get(i));
            rootNode.add(nodeTemp);
        }
        return new DefaultTreeModel(rootNode);
    }

    /**
     * @param selectedNode
     * @param content
     */
    public static void setChildes(DefaultMutableTreeNode selectedNode, Vector<User> content, User user, boolean showOnlineOnly) {
        for (int i = 0; i < content.size(); i++) {
            if (user != null && user.getId() != content.get(i).getId()) {
                if (showOnlineOnly) {
                    if (content.get(i).getStatus_id() > 0) {
                        DefaultMutableTreeNode dmn = new DefaultMutableTreeNode(content.get(i));
                        selectedNode.add(dmn);
                    }
                } else {
                    DefaultMutableTreeNode dmn = new DefaultMutableTreeNode(content.get(i));
                    selectedNode.add(dmn);
                }
            }
        }
    }
}
","// TreeModelGeneratorTest.java
package osa.ora.server.client.ui.utils;

import java.util.Vector;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.User;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeModelGenerator}.
* It contains ten unit test cases for the {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
*/
class TreeModelGeneratorTest {","// TreeModelGeneratorTest.java
package osa.ora.server.client.ui.utils;

import java.util.Vector;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import osa.ora.server.beans.Group;
import osa.ora.server.beans.User;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeModelGenerator}.
* It contains ten unit test cases for the {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
*/
class TreeModelGeneratorTest {

	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = null</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = false</li>
	 * <li>showUsersOnly = false</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_1() {
		String rootNodeStr = ""root"";
		Vector groups = null;
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = false;
		boolean showUsersOnly = false;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = null</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = true</li>
	 * <li>showUsersOnly = false</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_2() {
		String rootNodeStr = ""root"";
		Vector groups = null;
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = true;
		boolean showUsersOnly = false;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = null</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = false</li>
	 * <li>showUsersOnly = true</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_3() {
		String rootNodeStr = ""root"";
		Vector groups = null;
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = false;
		boolean showUsersOnly = true;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = null</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = true</li>
	 * <li>showUsersOnly = true</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_4() {
		String rootNodeStr = ""root"";
		Vector groups = null;
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = true;
		boolean showUsersOnly = true;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = empty vector</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = false</li>
	 * <li>showUsersOnly = false</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_5() {
		String rootNodeStr = ""root"";
		Vector groups = new Vector();
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = false;
		boolean showUsersOnly = false;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = empty vector</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = true</li>
	 * <li>showUsersOnly = false</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_6() {
		String rootNodeStr = ""root"";
		Vector groups = new Vector();
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = true;
		boolean showUsersOnly = false;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = empty vector</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = false</li>
	 * <li>showUsersOnly = true</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_7() {
		String rootNodeStr = ""root"";
		Vector groups = new Vector();
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = false;
		boolean showUsersOnly = true;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = empty vector</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = true</li>
	 * <li>showUsersOnly = true</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>no child nodes</li>
	 * </ul>
	 */
	@Test
	void testGetModel_8() {
		String rootNodeStr = ""root"";
		Vector groups = new Vector();
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = true;
		boolean showUsersOnly = true;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(0, rootNode.getChildCount());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = vector with one group</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = false</li>
	 * <li>showUsersOnly = false</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>one child node</li>
	 * <li>child node is group</li>
	 * </ul>
	 */
	@Test
	void testGetModel_9() {
		String rootNodeStr = ""root"";
		Vector groups = new Vector();
		Group group = new Group();
		group.setName(""group"");
		groups.add(group);
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = false;
		boolean showUsersOnly = false;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(1, rootNode.getChildCount());
		DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) rootNode.getChildAt(0);
		assertEquals(group, childNode.getUserObject());
	}
	
	/**
	 * Test case for {@link TreeModelGenerator#getModel(String, Vector, Vector, User, boolean, boolean)} method.
	 * Test data:
	 * <ul>
	 * <li>rootNodeStr = ""root""</li>
	 * <li>groups = vector with one group</li>
	 * <li>rooms = null</li>
	 * <li>user = null</li>
	 * <li>showOnlineOnly = true</li>
	 * <li>showUsersOnly = false</li>
	 * </ul>
	 * Expected result:
	 * <ul>
	 * <li>root node is ""root""</li>
	 * <li>one child node</li>
	 * <li>child node is group</li>
	 * </ul>
	 */
	@Test
	void testGetModel_10() {
		String rootNodeStr = ""root"";
		Vector groups = new Vector();
		Group group = new Group();
		group.setName(""group"");
		groups.add(group);
		Vector rooms = null;
		User user = null;
		boolean showOnlineOnly = true;
		boolean showUsersOnly = false;
		DefaultTreeModel result = TreeModelGenerator.getModel(rootNodeStr, groups, rooms, user, showOnlineOnly, showUsersOnly);
		DefaultMutableTreeNode rootNode = (DefaultMutableTreeNode) result.getRoot();
		assertEquals(""root"", rootNode.getUserObject());
		assertEquals(1, rootNode.getChildCount());
		DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) rootNode.getChildAt(0);
		assertEquals(group, childNode.getUserObject());
	}
}

// User.java
package osa.ora.server.beans;

import java.io.Serializable;

/**
 *
 * @author Osama Oransa
 */
public class User implements Serializable {

    private int id;
    private String name;
    private String password;
    private String email;
    private String mobile;
    private String address;
    private int status_id;
    private int group_id;
    private String group_name;
    private String status_name;
    private String status_desc;
    private String status_color;
    private String status_icon;
    private String status_icon_offline;
    private String status_icon_online;
    private String status_icon_away;
    private String status_icon_busy;
    private String status_icon_invisible;
    private String status_icon_offline_selected;
    private String status_icon_online_selected;
    private String status_icon_away_selected;
    private String status_icon_busy_selected;
    private String status_icon_invisible_selected;
    private String status_icon_offline_hover;
    private String status_icon_online_hover;
    private String status_icon_away_hover;
    private String status_icon_busy_hover;
    private String status_icon_invisible_hover;
    private String status_icon_offline_selected_hover;
    private String status_icon_online_selected_hover;
    private String status_"
cmpl-6u9xFYw9UOrjEo2h0unwNiZTsek55,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypter_0Test.java,13.277896165847778,stop,"// FileEncrypter.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// FileEncrypter.java
// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class FileEncrypter {

    private static FileEncrypter fileEncrypter = null;

    private Cipher enCipther;

    private Cipher deCipther;

    /**
     * Singleton
     */
    public static FileEncrypter getInstance() {
        if (fileEncrypter == null)
            fileEncrypter = new FileEncrypter(""FIM"".getBytes());
        return fileEncrypter;
    }

    public static FileEncrypter getInstanceInit(byte[] strkey) {
        fileEncrypter = new FileEncrypter(strkey);
        return fileEncrypter;
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param strkey Pass the key used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private FileEncrypter(byte[] strkey) {
        byte[] ivr = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };
        try {
            SecretKeySpec key = new SecretKeySpec(strkey, ""Blowfish"");
            enCipther = Cipher.getInstance(""Blowfish/CBC/PKCS5Padding"");
            deCipther = Cipher.getInstance(""Blowfish/CBC/PKCS5Padding"");
            IvParameterSpec oIV = new IvParameterSpec(ivr);
            enCipther.init(Cipher.ENCRYPT_MODE, key, oIV);
            deCipther.init(Cipher.DECRYPT_MODE, key, oIV);
        } catch (Exception e) {
            System.out.println(""EXCEPTION:"" + e.getMessage());
        }
    }

    /**
     * to encrypt a box of byte array
     * @param to_encrypt
     * @return byte[]
     */
    private byte[] encryptBlowfish(byte[] to_encrypt) {
        try {
            //to_encrypt=StringEncoder64.encode(to_encrypt).getBytes(""UTF8"");
            return enCipther.doFinal(to_encrypt);
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }

    /**
     * to decrypt a box of byte array
     * @param to_decrypt
     * @return byte[]
     */
    private byte[] decryptBlowfish(byte[] to_decrypt) {
        try {
            to_decrypt = deCipther.doFinal(to_decrypt);
            //to_decrypt=StringEncoder64.decode(new String(to_decrypt,""UTF8""));
            return to_decrypt;
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }

    /**
     * to encrypt file using temp file and return the data into byte[]
     * and delete the temp file
     * @param file
     * @param file2
     * @return byte[] of encrypted file
     */
    public byte[] fileEncrypt(File file, File file2) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(file2);
            fis = new FileInputStream(file);
            int lenght = fis.available();
            //System.out.println(""Length=""+lenght);
            String len = """" + lenght;
            while (len.length() < 8) {
                len = ""0"" + len;
            }
            fos.write(len.getBytes());
            byte[] data = null;
            for (int i = 0; i < lenght; i = i + 8) {
                data = new byte[8];
                fis.read(data);
                data = StringEncoder64.encode(data).getBytes(""UTF8"");
                byte[] enc = encryptBlowfish(new String(data).getBytes(""UTF8""));
                //System.out.println(""Length=""+enc.length);
                fos.write(enc);
            }
            fos.close();
            fis.close();
            fis = new FileInputStream(file2);
            int n = fis.available();
            data = new byte[n];
            fis.read(data);
            fis.close();
            file2.delete();
            return data;
        } catch (Exception ex) {
            //ex.printStackTrace();
            return null;
        } finally {
            try {
                if (fis != null)
                    fis.close();
                if (fos != null)
                    fos.close();
            } catch (IOException ex) {
            }
        }
    }

    /**
     * to decrypt array of bytes and create an output file
     * @param inputData
     * @param file2 the decrypted file.
     */
    public void fileDecrypt(byte[] inputData, File file2) {
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(file2);
            byte[] data = new byte[8];
            System.arraycopy(inputData, 0, data, 0, 8);
            int lenght = Integer.parseInt(new String(data));
            //System.out.println(""Original size=""+lenght);
            int partitions = lenght / 8;
            //System.out.println(""partitions=""+partitions);
            int last = lenght % 8;
            //System.out.println(""last size=""+last);
            int current = 0;
            for (int i = 0; i < partitions; i++) {
                data = new byte[16];
                System.arraycopy(inputData, 8 + i * 16, data, 0, 16);
                byte[] dec = decryptBlowfish(data);
                dec = StringEncoder64.decode(new String(dec, ""UTF8""));
                fos.write(dec);
                //System.out.println(""Current=""+current);
                current++;
            }
            if (last != 0) {
                //System.out.println(""in last"");
                data = new byte[16];
                System.arraycopy(inputData, 8 + partitions * 16, data, 0, 16);
                byte[] dec = decryptBlowfish(data);
                dec = StringEncoder64.decode(new String(dec, ""UTF8""));
                byte[] temp = new byte[last];
                System.arraycopy(dec, 0, temp, 0, last);
                //System.out.println(""last=""+temp);
                fos.write(temp);
            }
        } catch (Exception ex) {
            //ex.printStackTrace();
            return;
        } finally {
            try {
                if (fos != null)
                    fos.close();
            } catch (IOException ex) {
            }
        }
    }

    /**
     * main test method
     * @param args
     */
    public static void main(String[] args) {
        FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
        try {
            byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
            stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
        } catch (Exception ex) {
        }
    }
}
","// FileEncrypter_0Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// FileEncrypter.java
// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEncrypter}.
* It contains ten unit test cases for the {@link FileEncrypter#getInstance()} method.
*/
class FileEncrypter_0Test {","// FileEncrypter_0Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// FileEncrypter.java
// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEncrypter}.
* It contains ten unit test cases for the {@link FileEncrypter#getInstance()} method.
*/
class FileEncrypter_0Test {

	/**
	* Test case for the method {@link FileEncrypter#getInstance()}.
	* @throws Exception
	*/
	@Test
	void testGetInstance() throws Exception {
		FileEncrypter result = FileEncrypter.getInstance();
		assertNotNull(result);
	}
	
	/**
	* Test case for the method {@link FileEncrypter#getInstanceInit(byte[])}.
	* @throws Exception
	*/
	@Test
	void testGetInstanceInit() throws Exception {
		byte[] strkey = ""FIM"".getBytes();
		FileEncrypter result = FileEncrypter.getInstanceInit(strkey);
		assertNotNull(result);
	}
	
	/**
	* Test case for the method {@link FileEncrypter#encryptBlowfish(byte[])}.
	* @throws Exception
	*/
	@Test
	void testEncryptBlowfish() throws Exception {
		FileEncrypter fixture = FileEncrypter.getInstance();
		byte[] to_encrypt = ""FIM"".getBytes();
		byte[] result = fixture.encryptBlowfish(to_encrypt);
		assertNotNull(result);
	}
	
	/**
	* Test case for the method {@link FileEncrypter#decryptBlowfish(byte[])}.
	* @throws Exception
	*/
	@Test
	void testDecryptBlowfish() throws Exception {
		FileEncrypter fixture = FileEncrypter.getInstance();
		byte[] to_decrypt = ""FIM"".getBytes();
		byte[] result = fixture.decryptBlowfish(to_decrypt);
		assertNotNull(result);
	}
	
	/**
	* Test case for the method {@link FileEncrypter#fileEncrypt(File, File)}.
	* @throws Exception
	*/
	@Test
	void testFileEncrypt() throws Exception {
		FileEncrypter fixture = FileEncrypter.getInstance();
		File file = new File(""/osama2.zip"");
		File file2 = new File(""/osama3.zip"");
		byte[] result = fixture.fileEncrypt(file, file2);
		assertNotNull(result);
	}
	
	/**
	* Test case for the method {@link FileEncrypter#fileDecrypt(byte[], File)}.
	* @throws Exception
	*/
	@Test
	void testFileDecrypt() throws Exception {
		FileEncrypter fixture = FileEncrypter.getInstance();
		byte[] inputData = ""FIM"".getBytes();
		File file2 = new File(""/osama4.zip"");
		fixture.fileDecrypt(inputData, file2);
	}
	
	/**
	* Test case for the method {@link FileEncrypter#main(String[])}.
	* @throws Exception
	*/
	@Test
	void testMain() throws Exception {
		String[] args = new String[] {""FIM""};
		FileEncrypter.main(args);
	}
	
}"
cmpl-6u9yIBscpk0sROfE7HVlkmiiOknhc,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/FileEncrypter_2Test.java,31.045770406723022,stop,"// FileEncrypter.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// FileEncrypter.java
// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;

public class FileEncrypter {

    private static FileEncrypter fileEncrypter = null;

    private Cipher enCipther;

    private Cipher deCipther;

    /**
     * Singleton
     */
    public static FileEncrypter getInstance() {
        if (fileEncrypter == null)
            fileEncrypter = new FileEncrypter(""FIM"".getBytes());
        return fileEncrypter;
    }

    public static FileEncrypter getInstanceInit(byte[] strkey) {
        fileEncrypter = new FileEncrypter(strkey);
        return fileEncrypter;
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param strkey Pass the key used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private FileEncrypter(byte[] strkey) {
        byte[] ivr = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };
        try {
            SecretKeySpec key = new SecretKeySpec(strkey, ""Blowfish"");
            enCipther = Cipher.getInstance(""Blowfish/CBC/PKCS5Padding"");
            deCipther = Cipher.getInstance(""Blowfish/CBC/PKCS5Padding"");
            IvParameterSpec oIV = new IvParameterSpec(ivr);
            enCipther.init(Cipher.ENCRYPT_MODE, key, oIV);
            deCipther.init(Cipher.DECRYPT_MODE, key, oIV);
        } catch (Exception e) {
            System.out.println(""EXCEPTION:"" + e.getMessage());
        }
    }

    /**
     * to encrypt a box of byte array
     * @param to_encrypt
     * @return byte[]
     */
    private byte[] encryptBlowfish(byte[] to_encrypt) {
        try {
            //to_encrypt=StringEncoder64.encode(to_encrypt).getBytes(""UTF8"");
            return enCipther.doFinal(to_encrypt);
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }

    /**
     * to decrypt a box of byte array
     * @param to_decrypt
     * @return byte[]
     */
    private byte[] decryptBlowfish(byte[] to_decrypt) {
        try {
            to_decrypt = deCipther.doFinal(to_decrypt);
            //to_decrypt=StringEncoder64.decode(new String(to_decrypt,""UTF8""));
            return to_decrypt;
        } catch (Exception ex) {
            ex.printStackTrace();
            return null;
        }
    }

    /**
     * to encrypt file using temp file and return the data into byte[]
     * and delete the temp file
     * @param file
     * @param file2
     * @return byte[] of encrypted file
     */
    public byte[] fileEncrypt(File file, File file2) {
        FileInputStream fis = null;
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(file2);
            fis = new FileInputStream(file);
            int lenght = fis.available();
            //System.out.println(""Length=""+lenght);
            String len = """" + lenght;
            while (len.length() < 8) {
                len = ""0"" + len;
            }
            fos.write(len.getBytes());
            byte[] data = null;
            for (int i = 0; i < lenght; i = i + 8) {
                data = new byte[8];
                fis.read(data);
                data = StringEncoder64.encode(data).getBytes(""UTF8"");
                byte[] enc = encryptBlowfish(new String(data).getBytes(""UTF8""));
                //System.out.println(""Length=""+enc.length);
                fos.write(enc);
            }
            fos.close();
            fis.close();
            fis = new FileInputStream(file2);
            int n = fis.available();
            data = new byte[n];
            fis.read(data);
            fis.close();
            file2.delete();
            return data;
        } catch (Exception ex) {
            //ex.printStackTrace();
            return null;
        } finally {
            try {
                if (fis != null)
                    fis.close();
                if (fos != null)
                    fos.close();
            } catch (IOException ex) {
            }
        }
    }

    /**
     * to decrypt array of bytes and create an output file
     * @param inputData
     * @param file2 the decrypted file.
     */
    public void fileDecrypt(byte[] inputData, File file2) {
        FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(file2);
            byte[] data = new byte[8];
            System.arraycopy(inputData, 0, data, 0, 8);
            int lenght = Integer.parseInt(new String(data));
            //System.out.println(""Original size=""+lenght);
            int partitions = lenght / 8;
            //System.out.println(""partitions=""+partitions);
            int last = lenght % 8;
            //System.out.println(""last size=""+last);
            int current = 0;
            for (int i = 0; i < partitions; i++) {
                data = new byte[16];
                System.arraycopy(inputData, 8 + i * 16, data, 0, 16);
                byte[] dec = decryptBlowfish(data);
                dec = StringEncoder64.decode(new String(dec, ""UTF8""));
                fos.write(dec);
                //System.out.println(""Current=""+current);
                current++;
            }
            if (last != 0) {
                //System.out.println(""in last"");
                data = new byte[16];
                System.arraycopy(inputData, 8 + partitions * 16, data, 0, 16);
                byte[] dec = decryptBlowfish(data);
                dec = StringEncoder64.decode(new String(dec, ""UTF8""));
                byte[] temp = new byte[last];
                System.arraycopy(dec, 0, temp, 0, last);
                //System.out.println(""last=""+temp);
                fos.write(temp);
            }
        } catch (Exception ex) {
            //ex.printStackTrace();
            return;
        } finally {
            try {
                if (fos != null)
                    fos.close();
            } catch (IOException ex) {
            }
        }
    }

    /**
     * main test method
     * @param args
     */
    public static void main(String[] args) {
        FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
        try {
            byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
            stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
        } catch (Exception ex) {
        }
    }
}
","// FileEncrypter_2Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// FileEncrypter.java
// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEncrypter}.
* It contains ten unit test cases for the {@link FileEncrypter#fileEncrypt(File, File)} method.
*/
class FileEncrypter_2Test {","// FileEncrypter_2Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// FileEncrypter.java
// -----------------------------------------------------------------------------
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import javax.crypto.Cipher;
import java.io.IOException;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEncrypter}.
* It contains ten unit test cases for the {@link FileEncrypter#fileEncrypt(File, File)} method.
*/
class FileEncrypter_2Test {

	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 0 bytes.
	*/
	@Test
	void testFileEncrypt_1() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 1 byte.
	*/
	@Test
	void testFileEncrypt_2() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 2 bytes.
	*/
	@Test
	void testFileEncrypt_3() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 3 bytes.
	*/
	@Test
	void testFileEncrypt_4() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 4 bytes.
	*/
	@Test
	void testFileEncrypt_5() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 5 bytes.
	*/
	@Test
	void testFileEncrypt_6() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 6 bytes.
	*/
	@Test
	void testFileEncrypt_7() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 7 bytes.
	*/
	@Test
	void testFileEncrypt_8() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 8 bytes.
	*/
	@Test
	void testFileEncrypt_9() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
	
	/**
	* Test case for the {@link FileEncrypter#fileEncrypt(File, File)} method.
	* It tests the encryption of a file with a size of 9 bytes.
	*/
	@Test
	void testFileEncrypt_10() {
		FileEncrypter stringEnc = FileEncrypter.getInstanceInit(""Modern Chat"".getBytes());
		try {
			byte[] data = stringEnc.fileEncrypt(new File(""/osama2.zip""), new File(""/osama3.zip""));
			stringEnc.fileDecrypt(data, new File(""/osama4.zip""));
		} catch (Exception ex) {
		}
	}
}"
cmpl-6u9zLGcoIomJfelJzDNqE1MncBVVK,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_0Test.java,11.906824350357056,stop,"// StringEncrypter.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

    public char[] keyUsed = ""FIM"".toCharArray();

    Cipher ecipher;

    Cipher dcipher;

    //private static StringEncrypter stringEncrypter = null;
    /**
     * Singleton
     */
    public static StringEncrypter getInstance(String initKey) {
        return new StringEncrypter(initKey);
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param passPhrase Pass Phrase used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private StringEncrypter(String initKey) {
        keyUsed = initKey.toCharArray();
        // 8-bytes Salt
        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };
        // Iteration count
        int iterationCount = 19;
        try {
            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);
            SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);
            ecipher = Cipher.getInstance(key.getAlgorithm());
            dcipher = Cipher.getInstance(key.getAlgorithm());
            // Prepare the parameters to the cipthers
            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);
            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
        } catch (Exception e) {
            System.out.println(""EXCEPTION: "" + e.getMessage());
        }
    }

    /**
     * Takes a single String as an argument and returns an Encrypted version
     * of that String.
     * @param str String to be encrypted
     * @return <code>String</code> Encrypted version of the provided String
     */
    public String encrypt(String str) {
        if (str == null)
            return null;
        try {
            // Encode the string into bytes using utf-8
            byte[] utf8 = str.getBytes(""UTF8"");
            // Encrypt
            byte[] enc = ecipher.doFinal(utf8);
            // Encode bytes to base64 to get a string
            return StringEncoder64.encode(enc);
        } catch (Exception e) {
        }
        return null;
    }

    /**
     * Takes a encrypted String as an argument, decrypts and returns the
     * decrypted String.
     * @param str Encrypted String to be decrypted
     * @return <code>String</code> Decrypted version of the provided String
     */
    public String decrypt(String str) {
        if (str == null)
            return null;
        try {
            // Decode base64 to get bytes
            byte[] dec = StringEncoder64.decode(str);
            // Decrypt
            byte[] utf8 = dcipher.doFinal(dec);
            // Decode using utf-8
            return new String(utf8, ""UTF8"");
        } catch (Exception e) {
        }
        return null;
    }
}
","// StringEncrypter_0Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#getInstance(String)} method.
*/
class StringEncrypter_0Test {","// StringEncrypter_0Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#getInstance(String)} method.
*/
class StringEncrypter_0Test {

	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_0() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_1() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_2() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_3() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_4() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_5() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_6() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_7() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_8() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link StringEncrypter#getInstance(String)} method.
	*/
	@Test
	void testGetInstance_9() {
		StringEncrypter result = StringEncrypter.getInstance(""FIM"");
		assertNotNull(result);
	}
	
}</code>





A:

I think you are missing the <code>@RunWith</code> annotation.
<code>@RunWith(JUnitPlatform.class)
class StringEncrypter_0Test {
    ...
}
</code>
"
cmpl-6uA0OK9RqOVIaViZtzuf6k6LxWJzY,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_1Test.java,79.1447913646698,length,"// StringEncrypter.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

    public char[] keyUsed = ""FIM"".toCharArray();

    Cipher ecipher;

    Cipher dcipher;

    //private static StringEncrypter stringEncrypter = null;
    /**
     * Singleton
     */
    public static StringEncrypter getInstance(String initKey) {
        return new StringEncrypter(initKey);
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param passPhrase Pass Phrase used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private StringEncrypter(String initKey) {
        keyUsed = initKey.toCharArray();
        // 8-bytes Salt
        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };
        // Iteration count
        int iterationCount = 19;
        try {
            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);
            SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);
            ecipher = Cipher.getInstance(key.getAlgorithm());
            dcipher = Cipher.getInstance(key.getAlgorithm());
            // Prepare the parameters to the cipthers
            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);
            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
        } catch (Exception e) {
            System.out.println(""EXCEPTION: "" + e.getMessage());
        }
    }

    /**
     * Takes a single String as an argument and returns an Encrypted version
     * of that String.
     * @param str String to be encrypted
     * @return <code>String</code> Encrypted version of the provided String
     */
    public String encrypt(String str) {
        if (str == null)
            return null;
        try {
            // Encode the string into bytes using utf-8
            byte[] utf8 = str.getBytes(""UTF8"");
            // Encrypt
            byte[] enc = ecipher.doFinal(utf8);
            // Encode bytes to base64 to get a string
            return StringEncoder64.encode(enc);
        } catch (Exception e) {
        }
        return null;
    }

    /**
     * Takes a encrypted String as an argument, decrypts and returns the
     * decrypted String.
     * @param str Encrypted String to be decrypted
     * @return <code>String</code> Decrypted version of the provided String
     */
    public String decrypt(String str) {
        if (str == null)
            return null;
        try {
            // Decode base64 to get bytes
            byte[] dec = StringEncoder64.decode(str);
            // Decrypt
            byte[] utf8 = dcipher.doFinal(dec);
            // Decode using utf-8
            return new String(utf8, ""UTF8"");
        } catch (Exception e) {
        }
        return null;
    }
}
","// StringEncrypter_1Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#encrypt(String)} method.
*/
class StringEncrypter_1Test {","// StringEncrypter_1Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#encrypt(String)} method.
*/
class StringEncrypter_1Test {

		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a null string.
		*/
		@Test
		void testEncrypt_1() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(null);
				assertNull(encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of an empty string.
		*/
		@Test
		void testEncrypt_2() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt("""");
				assertEquals("""", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with one character.
		*/
		@Test
		void testEncrypt_3() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""a"");
				assertEquals(""qw=="", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with two characters.
		*/
		@Test
		void testEncrypt_4() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""ab"");
				assertEquals(""q7Y="", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with three characters.
		*/
		@Test
		void testEncrypt_5() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""abc"");
				assertEquals(""q7Yz"", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with four characters.
		*/
		@Test
		void testEncrypt_6() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""abcd"");
				assertEquals(""q7Yzqw=="", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with five characters.
		*/
		@Test
		void testEncrypt_7() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""abcde"");
				assertEquals(""q7Yzq7Y="", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with six characters.
		*/
		@Test
		void testEncrypt_8() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""abcdef"");
				assertEquals(""q7Yzq7Yz"", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with seven characters.
		*/
		@Test
		void testEncrypt_9() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""abcdefg"");
				assertEquals(""q7Yzq7Yzqw=="", encryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#encrypt(String)} method.
		* It tests the encryption of a string with eight characters.
		*/
		@Test
		void testEncrypt_10() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = stringEncrypter.encrypt(""abcdefgh"");
				assertEquals(""q7Yzq7Yzq7Y="", encryptedString);
		}
}</code>



I have a class StringEncrypter.java that I want to test with JUnit.
I have created a test class StringEncrypter_1Test.java.
I have created a test case for each method of the class StringEncrypter.java.
I have created a test suite StringEncrypterTestSuite.java that contains all the test cases.
I have created a test runner StringEncrypterTestRunner.java that runs the test suite.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report StringEncrypterTestReport.java that contains the test report.
I have created a test report String"
cmpl-6uA1feM07Aa6FAQlxLJCtAhhLxZKR,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/StringEncrypter_2Test.java,76.45311546325684,length,"// StringEncrypter.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;

public class StringEncrypter {

    public char[] keyUsed = ""FIM"".toCharArray();

    Cipher ecipher;

    Cipher dcipher;

    //private static StringEncrypter stringEncrypter = null;
    /**
     * Singleton
     */
    public static StringEncrypter getInstance(String initKey) {
        return new StringEncrypter(initKey);
    }

    /**
     * private Constructor used to create this object.  Responsible for setting
     * and initializing this object's encrypter and decrypter Chipher instances
     * given a Pass Phrase and algorithm.
     * @param passPhrase Pass Phrase used to initialize both the encrypter and
     *                   decrypter instances.
     */
    private StringEncrypter(String initKey) {
        keyUsed = initKey.toCharArray();
        // 8-bytes Salt
        byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32, (byte) 0x56, (byte) 0x34, (byte) 0xE3, (byte) 0x03 };
        // Iteration count
        int iterationCount = 19;
        try {
            KeySpec keySpec = new PBEKeySpec(keyUsed, salt, iterationCount);
            SecretKey key = SecretKeyFactory.getInstance(""PBEWithMD5AndDES"").generateSecret(keySpec);
            ecipher = Cipher.getInstance(key.getAlgorithm());
            dcipher = Cipher.getInstance(key.getAlgorithm());
            // Prepare the parameters to the cipthers
            AlgorithmParameterSpec paramSpec = new PBEParameterSpec(salt, iterationCount);
            ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
            dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
        } catch (Exception e) {
            System.out.println(""EXCEPTION: "" + e.getMessage());
        }
    }

    /**
     * Takes a single String as an argument and returns an Encrypted version
     * of that String.
     * @param str String to be encrypted
     * @return <code>String</code> Encrypted version of the provided String
     */
    public String encrypt(String str) {
        if (str == null)
            return null;
        try {
            // Encode the string into bytes using utf-8
            byte[] utf8 = str.getBytes(""UTF8"");
            // Encrypt
            byte[] enc = ecipher.doFinal(utf8);
            // Encode bytes to base64 to get a string
            return StringEncoder64.encode(enc);
        } catch (Exception e) {
        }
        return null;
    }

    /**
     * Takes a encrypted String as an argument, decrypts and returns the
     * decrypted String.
     * @param str Encrypted String to be decrypted
     * @return <code>String</code> Decrypted version of the provided String
     */
    public String decrypt(String str) {
        if (str == null)
            return null;
        try {
            // Decode base64 to get bytes
            byte[] dec = StringEncoder64.decode(str);
            // Decrypt
            byte[] utf8 = dcipher.doFinal(dec);
            // Decode using utf-8
            return new String(utf8, ""UTF8"");
        } catch (Exception e) {
        }
        return null;
    }
}
","// StringEncrypter_2Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#decrypt(String)} method.
*/
class StringEncrypter_2Test {","// StringEncrypter_2Test.java
package osa.ora.server.utils;

// -----------------------------------------------------------------------------
// StringEncrypter.java
// -----------------------------------------------------------------------------
import javax.crypto.Cipher;
import javax.crypto.SecretKey;
import java.security.spec.KeySpec;
import java.security.spec.AlgorithmParameterSpec;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEParameterSpec;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link StringEncrypter}.
* It contains ten unit test cases for the {@link StringEncrypter#decrypt(String)} method.
*/
class StringEncrypter_2Test {

		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is null.
		*/
		@Test
		void testDecrypt_1() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = null;
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertNull(decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is empty.
		*/
		@Test
		void testDecrypt_2() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = """";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals("""", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single character.
		*/
		@Test
		void testDecrypt_3() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""a"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""a"", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single word.
		*/
		@Test
		void testDecrypt_4() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""hello"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""hello"", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single word with special characters.
		*/
		@Test
		void testDecrypt_5() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""hello@#$%^&amp;*()"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""hello@#$%^&amp;*()"", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single word with special characters.
		*/
		@Test
		void testDecrypt_6() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""hello@#$%^&amp;*()"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""hello@#$%^&amp;*()"", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single word with special characters.
		*/
		@Test
		void testDecrypt_7() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""hello@#$%^&amp;*()"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""hello@#$%^&amp;*()"", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single word with special characters.
		*/
		@Test
		void testDecrypt_8() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""hello@#$%^&amp;*()"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""hello@#$%^&amp;*()"", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single word with special characters.
		*/
		@Test
		void testDecrypt_9() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""hello@#$%^&amp;*()"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""hello@#$%^&amp;*()"", decryptedString);
		}
		
		/**
		* Test case for {@link StringEncrypter#decrypt(String)} method.
		* It tests the case when the input string is a single word with special characters.
		*/
		@Test
		void testDecrypt_10() {
				StringEncrypter stringEncrypter = StringEncrypter.getInstance(""FIM"");
				String encryptedString = ""hello@#$%^&amp;*()"";
				String decryptedString = stringEncrypter.decrypt(encryptedString);
				assertEquals(""hello@#$%^&amp;*()"", decryptedString);
		}
}</code>





A:

I think you are missing the point of unit testing.
Unit testing is about testing the smallest possible unit of code. In your case, that would be the <code>decrypt</code> method.
You are not testing the <code>decrypt</code> method, you are testing the <code>StringEncrypter</code> class.
You should not be testing the <code>StringEncrypter</code> class, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method.
You should not be testing the <code>decrypt</code> method, you should be testing the <code>decrypt</code> method."
cmpl-6uA2tST2CjpM42WzXTUF4O2B8dmmR,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/XMLParser_0Test.java,89.18728232383728,length,"// XMLParser.java
/*
 * Created on 27/06/2006
 */
package osa.ora.server.utils;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.w3c.dom.NodeList;

/**
 * @author Osama Oransa
 *
 * reads writs an XML file
 */
public class XMLParser {

    private Element root;

    private String fileName;

    File file;

    Document doc;

    Transformer transformer;

    TransformerFactory tFactory;

    DocumentBuilder builder = null;

    DocumentBuilderFactory factory;

    /**
     * the constructor to read or write a file
     * @param fileName
     */
    public XMLParser(File file) throws Exception {
        this.fileName = file.getAbsolutePath();
        try {
            tFactory = TransformerFactory.newInstance();
            transformer = tFactory.newTransformer();
        } catch (TransformerConfigurationException e) {
            e.printStackTrace();
        }
        // make your xml doc into a DOMSource
        /* get an xml doc */
        factory = DocumentBuilderFactory.newInstance();
        try {
            builder = factory.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        }
        init();
    }

    public XMLParser(String fileName) throws Exception {
        this.fileName = fileName;
        try {
            tFactory = TransformerFactory.newInstance();
            transformer = tFactory.newTransformer();
        } catch (TransformerConfigurationException e) {
            e.printStackTrace();
        }
        // make your xml doc into a DOMSource
        /* get an xml doc */
        factory = DocumentBuilderFactory.newInstance();
        try {
            builder = factory.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        }
        init();
    }

    /**
     * initializes the document
     */
    private void init() throws Exception {
        file = new File(fileName);
        try {
            if (file.exists()) {
                builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
                doc = builder.parse(file);
                root = doc.getDocumentElement();
            } else {
                doc = builder.newDocument();
                root = doc.createElement(""data"");
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception(""Not A Valid Format!"");
        }
    }

    /**
     * sets a tagName of certain id with its elements and values
     * as
     * <tagName>
     * 		<element1>val1<element1>
     *  	<element2>val1<element2>
     * 		<element3>val1<element3>
     * </tagName>
     * @param tagName
     * @param id
     * @param elements
     */
    public void setProperty(String tagName, String id, Hashtable elements) {
        elements.remove(""id"");
        boolean replaced = false;
        /* create the root node */
        Element rowElement = doc.createElement(tagName);
        rowElement.setAttribute(""id"", id);
        NodeList nodeList = root.getElementsByTagName(tagName);
        String temp = null;
        /* create the column nodes and append each to the row node */
        Element columnElement;
        Text textData;
        Enumeration attributeEnum = elements.keys();
        while (attributeEnum.hasMoreElements()) {
            temp = (String) attributeEnum.nextElement();
            columnElement = doc.createElement(temp);
            textData = doc.createTextNode((String) elements.get(temp));
            columnElement.appendChild(textData);
            rowElement.appendChild(columnElement);
        }
        //*********************************************
        for (int i = 0; i < nodeList.getLength(); i++) {
            String keyID = ((Element) nodeList.item(i)).getAttribute(""id"");
            if (keyID.equalsIgnoreCase(id)) {
                root.replaceChild(rowElement, nodeList.item(i));
                replaced = true;
            }
        }
        //*********************************************************
        if (!replaced) {
            root.appendChild(rowElement);
        }
    }

    public void addProperty(String tagName, String id, Hashtable elements) {
        /* create the root node */
        Element rowElement = doc.createElement(tagName);
        rowElement.setAttribute(""id"", id);
        NodeList nodeList = root.getElementsByTagName(tagName);
        String temp = null;
        /* create the column nodes and append each to the row node */
        Element columnElement;
        Text textData;
        Enumeration attributeEnum = elements.keys();
        int k = 0;
        while (attributeEnum.hasMoreElements()) {
            temp = (String) attributeEnum.nextElement();
            columnElement = doc.createElement(temp);
            textData = doc.createTextNode((String) elements.get(temp));
            columnElement.appendChild(textData);
            rowElement.appendChild(columnElement);
        }
        //*********************************************
        root.appendChild(rowElement);
    }

    /**
     * gets all elments and values of all tags carry tagName
     * @param tagName
     * @return a vector of hashTable of all elements and values
     */
    public Vector getProperty(String tagName) {
        Vector text = new Vector();
        String text2 = new String();
        String subTag = new String();
        boolean found = false;
        File file = new File(fileName);
        NodeList nodes = root.getElementsByTagName(tagName);
        //System.out.println(""[XMLReader] Found shape nodes ""+nodes.getLength());
        String keyID = null;
        int i = 0;
        if (nodes.getLength() != 0)
            do {
                Hashtable table = new Hashtable();
                keyID = ((Element) nodes.item(i)).getAttribute(""id"");
                table.put(""id"", keyID);
                NodeList lines = nodes.item(i).getChildNodes();
                for (int j = 0; j < lines.getLength(); j++) {
                    Node name = (Node) lines.item(j);
                    // Collect the text from the <Line> element
                    StringBuffer sb = new StringBuffer();
                    for (Node child = name.getFirstChild(); child != null; child = child.getNextSibling()) {
                        if (child instanceof CharacterData) {
                            CharacterData cd = (CharacterData) child;
                            sb.append(cd.getData());
                            text2 = sb.toString().trim();
                            //System.out.println(""[XMLReader] ""+child.getParentNode().getNodeName()+""=""+text2);
                            table.put(child.getParentNode().getNodeName(), text2);
                        }
                    }
                }
                i++;
                text.addElement(table);
            } while (i < nodes.getLength() && !found);
        return text;
    }

    /**
     * gets a value of a tag name having the id ==id
     * @param tagName
     * @param id
     * @return String  the value of the tag
     */
    public String getSingleProperty(String tagName) {
        String text = new String();
        boolean found = false;
        Hashtable table = new Hashtable();
        NodeList nodes = root.getElementsByTagName(tagName);
        int i = 0;
        if (nodes.getLength() != 0)
            do {
                StringBuffer sb = new StringBuffer();
                for (Node child = nodes.item(i).getFirstChild(); child != null; child = child.getNextSibling()) {
                    if (child instanceof CharacterData) {
                        CharacterData cd = (CharacterData) child;
                        sb.append(cd.getData());
                        text = sb.toString().trim();
                    }
                }
                i++;
            } while (i < nodes.getLength() && !found);
        return text;
    }

    /**
     * stores the file in XML formate
     */
    public void store() throws Exception {
        DOMSource source = new DOMSource(root);
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
                throw e;
            }
        }
        Result result = new StreamResult(file);
        try {
            //		 stream it out
            transformer.transform(source, result);
        } catch (TransformerException e1) {
            e1.printStackTrace();
            throw e1;
        }
    }

    public static String returnSpecial(String input) {
        String output = input.replaceAll(""&lt;"", ""<"");
        return output;
    }
}
","// XMLParser_0Test.java
package osa.ora.server.utils;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XMLParser}.
* It contains ten unit test cases for the {@link XMLParser#getProperty(String)} method.
*/
class XMLParser_0Test {","// XMLParser_0Test.java
package osa.ora.server.utils;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XMLParser}.
* It contains ten unit test cases for the {@link XMLParser#getProperty(String)} method.
*/
class XMLParser_0Test {

		/**
		* Test case for the {@link XMLParser#getProperty(String)} method.
		* This test case is for the following input:
		* <pre>
		* <?xml version=""1.0"" encoding=""UTF-8""?>
		* <data>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* </data>
		* </pre>
		*/
		@Test
		public void testGetProperty_0() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test/osa/ora/server/utils/XMLParser_0Test_testGetProperty_0.xml""));
				Vector result = xmlParser.getProperty(""tagName"");
				assertEquals(1, result.size());
				Hashtable table = (Hashtable) result.elementAt(0);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
		}
		
		/**
		* Test case for the {@link XMLParser#getProperty(String)} method.
		* This test case is for the following input:
		* <pre>
		* <?xml version=""1.0"" encoding=""UTF-8""?>
		* <data>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* </data>
		* </pre>
		*/
		@Test
		public void testGetProperty_1() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test/osa/ora/server/utils/XMLParser_0Test_testGetProperty_1.xml""));
				Vector result = xmlParser.getProperty(""tagName"");
				assertEquals(2, result.size());
				Hashtable table = (Hashtable) result.elementAt(0);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(1);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
		}
		
		/**
		* Test case for the {@link XMLParser#getProperty(String)} method.
		* This test case is for the following input:
		* <pre>
		* <?xml version=""1.0"" encoding=""UTF-8""?>
		* <data>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* </data>
		* </pre>
		*/
		@Test
		public void testGetProperty_2() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test/osa/ora/server/utils/XMLParser_0Test_testGetProperty_2.xml""));
				Vector result = xmlParser.getProperty(""tagName"");
				assertEquals(3, result.size());
				Hashtable table = (Hashtable) result.elementAt(0);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(1);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(2);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
		}
		
		/**
		* Test case for the {@link XMLParser#getProperty(String)} method.
		* This test case is for the following input:
		* <pre>
		* <?xml version=""1.0"" encoding=""UTF-8""?>
		* <data>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* </data>
		* </pre>
		*/
		@Test
		public void testGetProperty_3() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test/osa/ora/server/utils/XMLParser_0Test_testGetProperty_3.xml""));
				Vector result = xmlParser.getProperty(""tagName"");
				assertEquals(4, result.size());
				Hashtable table = (Hashtable) result.elementAt(0);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(1);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(2);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(3);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
		}
		
		/**
		* Test case for the {@link XMLParser#getProperty(String)} method.
		* This test case is for the following input:
		* <pre>
		* <?xml version=""1.0"" encoding=""UTF-8""?>
		* <data>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* </data>
		* </pre>
		*/
		@Test
		public void testGetProperty_4() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test/osa/ora/server/utils/XMLParser_0Test_testGetProperty_4.xml""));
				Vector result = xmlParser.getProperty(""tagName"");
				assertEquals(5, result.size());
				Hashtable table = (Hashtable) result.elementAt(0);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(1);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(2);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(3);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
				table = (Hashtable) result.elementAt(4);
				assertEquals(""id"", table.get(""id""));
				assertEquals(""val1"", table.get(""element1""));
				assertEquals(""val1"", table.get(""element2""));
				assertEquals(""val1"", table.get(""element3""));
		}
		
		/**
		* Test case for the {@link XMLParser#getProperty(String)} method.
		* This test case is for the following input:
		* <pre>
		* <?xml version=""1.0"" encoding=""UTF-8""?>
		* <data>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<element2>val1</element2>
		* 		<element3>val1</element3>
		* 	</tagName>
		* 	<tagName id=""id"">
		* 		<element1>val1</element1>
		* 		<"
cmpl-6uA4L20emlxkw3FY1WaQVrmfarTmf,/EvoSuiteBenchmark/73_fim1/src/main/java/osa/ora/server/utils/XMLParser_1Test.java,25.839720010757446,stop,"// XMLParser.java
/*
 * Created on 27/06/2006
 */
package osa.ora.server.utils;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.w3c.dom.NodeList;

/**
 * @author Osama Oransa
 *
 * reads writs an XML file
 */
public class XMLParser {

    private Element root;

    private String fileName;

    File file;

    Document doc;

    Transformer transformer;

    TransformerFactory tFactory;

    DocumentBuilder builder = null;

    DocumentBuilderFactory factory;

    /**
     * the constructor to read or write a file
     * @param fileName
     */
    public XMLParser(File file) throws Exception {
        this.fileName = file.getAbsolutePath();
        try {
            tFactory = TransformerFactory.newInstance();
            transformer = tFactory.newTransformer();
        } catch (TransformerConfigurationException e) {
            e.printStackTrace();
        }
        // make your xml doc into a DOMSource
        /* get an xml doc */
        factory = DocumentBuilderFactory.newInstance();
        try {
            builder = factory.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        }
        init();
    }

    public XMLParser(String fileName) throws Exception {
        this.fileName = fileName;
        try {
            tFactory = TransformerFactory.newInstance();
            transformer = tFactory.newTransformer();
        } catch (TransformerConfigurationException e) {
            e.printStackTrace();
        }
        // make your xml doc into a DOMSource
        /* get an xml doc */
        factory = DocumentBuilderFactory.newInstance();
        try {
            builder = factory.newDocumentBuilder();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        }
        init();
    }

    /**
     * initializes the document
     */
    private void init() throws Exception {
        file = new File(fileName);
        try {
            if (file.exists()) {
                builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
                doc = builder.parse(file);
                root = doc.getDocumentElement();
            } else {
                doc = builder.newDocument();
                root = doc.createElement(""data"");
            }
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception(""Not A Valid Format!"");
        }
    }

    /**
     * sets a tagName of certain id with its elements and values
     * as
     * <tagName>
     * 		<element1>val1<element1>
     *  	<element2>val1<element2>
     * 		<element3>val1<element3>
     * </tagName>
     * @param tagName
     * @param id
     * @param elements
     */
    public void setProperty(String tagName, String id, Hashtable elements) {
        elements.remove(""id"");
        boolean replaced = false;
        /* create the root node */
        Element rowElement = doc.createElement(tagName);
        rowElement.setAttribute(""id"", id);
        NodeList nodeList = root.getElementsByTagName(tagName);
        String temp = null;
        /* create the column nodes and append each to the row node */
        Element columnElement;
        Text textData;
        Enumeration attributeEnum = elements.keys();
        while (attributeEnum.hasMoreElements()) {
            temp = (String) attributeEnum.nextElement();
            columnElement = doc.createElement(temp);
            textData = doc.createTextNode((String) elements.get(temp));
            columnElement.appendChild(textData);
            rowElement.appendChild(columnElement);
        }
        //*********************************************
        for (int i = 0; i < nodeList.getLength(); i++) {
            String keyID = ((Element) nodeList.item(i)).getAttribute(""id"");
            if (keyID.equalsIgnoreCase(id)) {
                root.replaceChild(rowElement, nodeList.item(i));
                replaced = true;
            }
        }
        //*********************************************************
        if (!replaced) {
            root.appendChild(rowElement);
        }
    }

    public void addProperty(String tagName, String id, Hashtable elements) {
        /* create the root node */
        Element rowElement = doc.createElement(tagName);
        rowElement.setAttribute(""id"", id);
        NodeList nodeList = root.getElementsByTagName(tagName);
        String temp = null;
        /* create the column nodes and append each to the row node */
        Element columnElement;
        Text textData;
        Enumeration attributeEnum = elements.keys();
        int k = 0;
        while (attributeEnum.hasMoreElements()) {
            temp = (String) attributeEnum.nextElement();
            columnElement = doc.createElement(temp);
            textData = doc.createTextNode((String) elements.get(temp));
            columnElement.appendChild(textData);
            rowElement.appendChild(columnElement);
        }
        //*********************************************
        root.appendChild(rowElement);
    }

    /**
     * gets all elments and values of all tags carry tagName
     * @param tagName
     * @return a vector of hashTable of all elements and values
     */
    public Vector getProperty(String tagName) {
        Vector text = new Vector();
        String text2 = new String();
        String subTag = new String();
        boolean found = false;
        File file = new File(fileName);
        NodeList nodes = root.getElementsByTagName(tagName);
        //System.out.println(""[XMLReader] Found shape nodes ""+nodes.getLength());
        String keyID = null;
        int i = 0;
        if (nodes.getLength() != 0)
            do {
                Hashtable table = new Hashtable();
                keyID = ((Element) nodes.item(i)).getAttribute(""id"");
                table.put(""id"", keyID);
                NodeList lines = nodes.item(i).getChildNodes();
                for (int j = 0; j < lines.getLength(); j++) {
                    Node name = (Node) lines.item(j);
                    // Collect the text from the <Line> element
                    StringBuffer sb = new StringBuffer();
                    for (Node child = name.getFirstChild(); child != null; child = child.getNextSibling()) {
                        if (child instanceof CharacterData) {
                            CharacterData cd = (CharacterData) child;
                            sb.append(cd.getData());
                            text2 = sb.toString().trim();
                            //System.out.println(""[XMLReader] ""+child.getParentNode().getNodeName()+""=""+text2);
                            table.put(child.getParentNode().getNodeName(), text2);
                        }
                    }
                }
                i++;
                text.addElement(table);
            } while (i < nodes.getLength() && !found);
        return text;
    }

    /**
     * gets a value of a tag name having the id ==id
     * @param tagName
     * @param id
     * @return String  the value of the tag
     */
    public String getSingleProperty(String tagName) {
        String text = new String();
        boolean found = false;
        Hashtable table = new Hashtable();
        NodeList nodes = root.getElementsByTagName(tagName);
        int i = 0;
        if (nodes.getLength() != 0)
            do {
                StringBuffer sb = new StringBuffer();
                for (Node child = nodes.item(i).getFirstChild(); child != null; child = child.getNextSibling()) {
                    if (child instanceof CharacterData) {
                        CharacterData cd = (CharacterData) child;
                        sb.append(cd.getData());
                        text = sb.toString().trim();
                    }
                }
                i++;
            } while (i < nodes.getLength() && !found);
        return text;
    }

    /**
     * stores the file in XML formate
     */
    public void store() throws Exception {
        DOMSource source = new DOMSource(root);
        if (!file.exists()) {
            try {
                file.createNewFile();
            } catch (IOException e) {
                e.printStackTrace();
                throw e;
            }
        }
        Result result = new StreamResult(file);
        try {
            //		 stream it out
            transformer.transform(source, result);
        } catch (TransformerException e1) {
            e1.printStackTrace();
            throw e1;
        }
    }

    public static String returnSpecial(String input) {
        String output = input.replaceAll(""&lt;"", ""<"");
        return output;
    }
}
","// XMLParser_1Test.java
package osa.ora.server.utils;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XMLParser}.
* It contains ten unit test cases for the {@link XMLParser#getSingleProperty(String)} method.
*/
class XMLParser_1Test {","// XMLParser_1Test.java
package osa.ora.server.utils;

import java.io.File;
import java.io.IOException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.w3c.dom.CharacterData;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.w3c.dom.NodeList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XMLParser}.
* It contains ten unit test cases for the {@link XMLParser#getSingleProperty(String)} method.
*/
class XMLParser_1Test {

		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_1() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_2() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_3() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_4() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_5() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_6() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_7() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_8() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_9() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
		
		/**
		* Test case for the {@link XMLParser#getSingleProperty(String)} method.
		* It tests the method with a valid input.
		*/
		@Test
		void testGetSingleProperty_10() throws Exception {
				XMLParser xmlParser = new XMLParser(new File(""test.xml""));
				String result = xmlParser.getSingleProperty(""test"");
				assertEquals(""test"", result);
		}
}"
