ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6twbIm0xoneiwYzt3vGieacXOKoXM,/EvoSuiteBenchmark/29_apbsmem/src/main/java/apbs_mem_gui/EFileFilter_0Test.java,77.55711650848389,length,"// EFileFilter.java
/*
 * @(#)src/demo/jfc/FileChooserDemo/src/ExampleFileFilter.java, swing, dsdev, 20051008 1.13
 * ===========================================================================
 * Licensed Materials - Property of IBM
 * ""Restricted Materials of IBM""
 *
 * IBM SDK, Java(tm) 2 Technology Edition, v5.0
 * (C) Copyright IBM Corp. 1998, 2005. All Rights Reserved
 * ===========================================================================
 */
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;

/**
 * A convenience implementation of FileFilter that filters out
 * all files except for those type extensions that it knows about.
 *
 * Extensions are of the type "".foo"", which is typically found on
 * Windows and Unix boxes, but not on Macinthosh. Case is ignored.
 *
 * Example - create a new filter that filerts out all files
 * but gif and jpg image files:
 *
 *     JFileChooser chooser = new JFileChooser();
 *     ExampleFileFilter filter = new ExampleFileFilter(
 *                   new String{""gif"", ""jpg""}, ""JPEG & GIF Images"")
 *     chooser.addChoosableFileFilter(filter);
 *     chooser.showOpenDialog(this);
 *
 * @version 1.13 06/13/02
 * @author Jeff Dinkins
 */
public class EFileFilter extends FileFilter {

    private static String TYPE_UNKNOWN = ""Type Unknown"";

    private static String HIDDEN_FILE = ""Hidden File"";

    private Hashtable filters = null;

    private String description = null;

    private String fullDescription = null;

    private boolean useExtensionsInDescription = true;

    /**
     * Creates a file filter. If no filters are added, then all
     * files are accepted.
     *
     * @see #addExtension
     */
    public EFileFilter() {
        this.filters = new Hashtable();
    }

    /**
     * Creates a file filter that accepts files with the given extension.
     * Example: new ExampleFileFilter(""jpg"");
     *
     * @see #addExtension
     */
    public EFileFilter(String extension) {
        this(extension, null);
    }

    /**
     * Creates a file filter that accepts the given file type.
     * Example: new ExampleFileFilter(""jpg"", ""JPEG Image Images"");
     *
     * Note that the ""."" before the extension is not needed. If
     * provided, it will be ignored.
     *
     * @see #addExtension
     */
    public EFileFilter(String extension, String description) {
        this();
        if (extension != null)
            addExtension(extension);
        if (description != null)
            setDescription(description);
    }

    /**
     * Creates a file filter from the given string array.
     * Example: new ExampleFileFilter(String {""gif"", ""jpg""});
     *
     * Note that the ""."" before the extension is not needed adn
     * will be ignored.
     *
     * @see #addExtension
     */
    public EFileFilter(String[] filters) {
        this(filters, null);
    }

    /**
     * Creates a file filter from the given string array and description.
     * Example: new ExampleFileFilter(String {""gif"", ""jpg""}, ""Gif and JPG Images"");
     *
     * Note that the ""."" before the extension is not needed and will be ignored.
     *
     * @see #addExtension
     */
    public EFileFilter(String[] filters, String description) {
        this();
        for (int i = 0; i < filters.length; i++) {
            // add filters one by one
            addExtension(filters[i]);
        }
        if (description != null)
            setDescription(description);
    }

    /**
     * Return true if this file should be shown in the directory pane,
     * false if it shouldn't.
     *
     * Files that begin with ""."" are ignored.
     *
     * @see #getExtension
     * @see FileFilter#accepts
     */
    public boolean accept(File f) {
        if (f != null) {
            if (f.isDirectory()) {
                return true;
            }
            String extension = getExtension(f);
            if (extension != null && filters.get(getExtension(f)) != null) {
                return true;
            }
            ;
        }
        return false;
    }

    /**
     * Return the extension portion of the file's name .
     *
     * @see #getExtension
     * @see FileFilter#accept
     */
    public String getExtension(File f) {
        if (f != null) {
            String filename = f.getName();
            int i = filename.lastIndexOf('.');
            if (i > 0 && i < filename.length() - 1) {
                return filename.substring(i + 1).toLowerCase();
            }
            ;
        }
        return null;
    }

    /**
     * Adds a filetype ""dot"" extension to filter against.
     *
     * For example: the following code will create a filter that filters
     * out all files except those that end in "".jpg"" and "".tif"":
     *
     *   ExampleFileFilter filter = new ExampleFileFilter();
     *   filter.addExtension(""jpg"");
     *   filter.addExtension(""tif"");
     *
     * Note that the ""."" before the extension is not needed and will be ignored.
     */
    public void addExtension(String extension) {
        if (filters == null) {
            filters = new Hashtable(5);
        }
        filters.put(extension.toLowerCase(), this);
        fullDescription = null;
    }

    /**
     * Returns the human readable description of this filter. For
     * example: ""JPEG and GIF Image Files (*.jpg, *.gif)""
     *
     * @see setDescription
     * @see setExtensionListInDescription
     * @see isExtensionListInDescription
     * @see FileFilter#getDescription
     */
    public String getDescription() {
        if (fullDescription == null) {
            if (description == null || isExtensionListInDescription()) {
                fullDescription = description == null ? ""("" : description + "" ("";
                // build the description from the extension list
                Enumeration extensions = filters.keys();
                if (extensions != null) {
                    fullDescription += ""."" + (String) extensions.nextElement();
                    while (extensions.hasMoreElements()) {
                        fullDescription += "", ."" + (String) extensions.nextElement();
                    }
                }
                fullDescription += "")"";
            } else {
                fullDescription = description;
            }
        }
        return fullDescription;
    }

    /**
     * Sets the human readable description of this filter. For
     * example: filter.setDescription(""Gif and JPG Images"");
     *
     * @see setDescription
     * @see setExtensionListInDescription
     * @see isExtensionListInDescription
     */
    public void setDescription(String description) {
        this.description = description;
        fullDescription = null;
    }

    /**
     * Determines whether the extension list (.jpg, .gif, etc) should
     * show up in the human readable description.
     *
     * Only relevent if a description was provided in the constructor
     * or using setDescription();
     *
     * @see getDescription
     * @see setDescription
     * @see isExtensionListInDescription
     */
    public void setExtensionListInDescription(boolean b) {
        useExtensionsInDescription = b;
        fullDescription = null;
    }

    /**
     * Returns whether the extension list (.jpg, .gif, etc) should
     * show up in the human readable description.
     *
     * Only relevent if a description was provided in the constructor
     * or using setDescription();
     *
     * @see getDescription
     * @see setDescription
     * @see setExtensionListInDescription
     */
    public boolean isExtensionListInDescription() {
        return useExtensionsInDescription;
    }
}
","// EFileFilter_0Test.java
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EFileFilter}.
* It contains ten unit test cases for the {@link EFileFilter#accept(File)} method.
*/
class EFileFilter_0Test {","// EFileFilter_0Test.java
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EFileFilter}.
* It contains ten unit test cases for the {@link EFileFilter#accept(File)} method.
*/
class EFileFilter_0Test {

	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is null.
	 */
	@Test
	void testAccept_0() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = null;
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is a directory.
	 */
	@Test
	void testAccept_1() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""."");
		assertTrue(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is null.
	 */
	@Test
	void testAccept_2() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is not null.
	 */
	@Test
	void testAccept_3() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is not null.
	 */
	@Test
	void testAccept_4() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is not null.
	 */
	@Test
	void testAccept_5() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is not null.
	 */
	@Test
	void testAccept_6() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is not null.
	 */
	@Test
	void testAccept_7() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is not null.
	 */
	@Test
	void testAccept_8() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#accept(File)}.
	 * It tests the case that the given file is not a directory and its extension is not null.
	 */
	@Test
	void testAccept_9() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertFalse(eFileFilter.accept(file));
	}
	
}

// EFileFilter_1Test.java
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EFileFilter}.
* It contains ten unit test cases for the {@link EFileFilter#getExtension(File)} method.
*/
class EFileFilter_1Test {
		
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is null.
	 */
	@Test
	void testGetExtension_0() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = null;
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is null.
	 */
	@Test
	void testGetExtension_1() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_2() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_3() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_4() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_5() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_6() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_7() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_8() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
	/**
	 * Test case for {@link EFileFilter#getExtension(File)}.
	 * It tests the case that the given file is not null and its extension is not null.
	 */
	@Test
	void testGetExtension_9() {
		EFileFilter eFileFilter = new EFileFilter();
		File file = new File(""test.txt"");
		assertNull(eFileFilter.getExtension(file));
	}
	
}

// EFileFilter_2Test.java
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EFileFilter}.
* It contains ten unit test cases for the {@link EFileFilter#addExtension(String)} method.
*/
class EFileFilter_2Test {
		
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is null.
	 */
	@Test
	void testAddExtension_0() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = null;
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_1() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_2() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_3() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_4() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_5() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_6() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_7() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_8() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
	/**
	 * Test case for {@link EFileFilter#addExtension(String)}.
	 * It tests the case that the given extension is not null.
	 */
	@Test
	void testAddExtension_9() {
		EFileFilter eFileFilter = new EFileFilter();
		String extension = ""txt"";
		eFileFilter.addExtension(extension);
	}
	
}

// EFileFilter_3Test.java
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EFileFilter}.
* It contains ten unit test cases for the {@link EFileFilter#getDescription()} method.
*/
class EFileFilter_3Test {
		
	/**
	 * Test case for {@link EFileFilter#getDescription()}.
	 * It tests the case that the description is null.
	 */
	@Test
	void testGetDescription_0() {
		EFileFilter eFileFilter = new EFileFilter();
		assertNull(eFileFilter.getDescription());
	}
	
	/**
	 * Test case for {@link EFileFilter#getDescription()}.
	 * It tests the case that the description is not null.
	 */
	@Test
	void testGetDescription_1() {
		EFileFilter eFileFilter = new EFileFilter();
		assertNull(eFileFilter.getDescription());
	}
	
	/**
	 * Test case for {@link EFileFilter#getDescription()}.
	 * It tests the case that the description is not null.
	 */
	@Test
	void testGetDescription_2() {
		EFileFilter eFileFilter = new EFileFilter();
		assertNull(eFileFilter.getDescription());
	}
	
	/**
	 * Test case for {@link EFileFilter#getDescription()}.
	 * It tests the case that the description is not null.
	 */
	@Test
	void testGetDescription_3() {
		EFile"
cmpl-6twcXYyiGfZOTkQdw01Bjn1hO3aaD,/EvoSuiteBenchmark/29_apbsmem/src/main/java/apbs_mem_gui/EFileFilter_1Test.java,82.85997223854065,length,"// EFileFilter.java
/*
 * @(#)src/demo/jfc/FileChooserDemo/src/ExampleFileFilter.java, swing, dsdev, 20051008 1.13
 * ===========================================================================
 * Licensed Materials - Property of IBM
 * ""Restricted Materials of IBM""
 *
 * IBM SDK, Java(tm) 2 Technology Edition, v5.0
 * (C) Copyright IBM Corp. 1998, 2005. All Rights Reserved
 * ===========================================================================
 */
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;

/**
 * A convenience implementation of FileFilter that filters out
 * all files except for those type extensions that it knows about.
 *
 * Extensions are of the type "".foo"", which is typically found on
 * Windows and Unix boxes, but not on Macinthosh. Case is ignored.
 *
 * Example - create a new filter that filerts out all files
 * but gif and jpg image files:
 *
 *     JFileChooser chooser = new JFileChooser();
 *     ExampleFileFilter filter = new ExampleFileFilter(
 *                   new String{""gif"", ""jpg""}, ""JPEG & GIF Images"")
 *     chooser.addChoosableFileFilter(filter);
 *     chooser.showOpenDialog(this);
 *
 * @version 1.13 06/13/02
 * @author Jeff Dinkins
 */
public class EFileFilter extends FileFilter {

    private static String TYPE_UNKNOWN = ""Type Unknown"";

    private static String HIDDEN_FILE = ""Hidden File"";

    private Hashtable filters = null;

    private String description = null;

    private String fullDescription = null;

    private boolean useExtensionsInDescription = true;

    /**
     * Creates a file filter. If no filters are added, then all
     * files are accepted.
     *
     * @see #addExtension
     */
    public EFileFilter() {
        this.filters = new Hashtable();
    }

    /**
     * Creates a file filter that accepts files with the given extension.
     * Example: new ExampleFileFilter(""jpg"");
     *
     * @see #addExtension
     */
    public EFileFilter(String extension) {
        this(extension, null);
    }

    /**
     * Creates a file filter that accepts the given file type.
     * Example: new ExampleFileFilter(""jpg"", ""JPEG Image Images"");
     *
     * Note that the ""."" before the extension is not needed. If
     * provided, it will be ignored.
     *
     * @see #addExtension
     */
    public EFileFilter(String extension, String description) {
        this();
        if (extension != null)
            addExtension(extension);
        if (description != null)
            setDescription(description);
    }

    /**
     * Creates a file filter from the given string array.
     * Example: new ExampleFileFilter(String {""gif"", ""jpg""});
     *
     * Note that the ""."" before the extension is not needed adn
     * will be ignored.
     *
     * @see #addExtension
     */
    public EFileFilter(String[] filters) {
        this(filters, null);
    }

    /**
     * Creates a file filter from the given string array and description.
     * Example: new ExampleFileFilter(String {""gif"", ""jpg""}, ""Gif and JPG Images"");
     *
     * Note that the ""."" before the extension is not needed and will be ignored.
     *
     * @see #addExtension
     */
    public EFileFilter(String[] filters, String description) {
        this();
        for (int i = 0; i < filters.length; i++) {
            // add filters one by one
            addExtension(filters[i]);
        }
        if (description != null)
            setDescription(description);
    }

    /**
     * Return true if this file should be shown in the directory pane,
     * false if it shouldn't.
     *
     * Files that begin with ""."" are ignored.
     *
     * @see #getExtension
     * @see FileFilter#accepts
     */
    public boolean accept(File f) {
        if (f != null) {
            if (f.isDirectory()) {
                return true;
            }
            String extension = getExtension(f);
            if (extension != null && filters.get(getExtension(f)) != null) {
                return true;
            }
            ;
        }
        return false;
    }

    /**
     * Return the extension portion of the file's name .
     *
     * @see #getExtension
     * @see FileFilter#accept
     */
    public String getExtension(File f) {
        if (f != null) {
            String filename = f.getName();
            int i = filename.lastIndexOf('.');
            if (i > 0 && i < filename.length() - 1) {
                return filename.substring(i + 1).toLowerCase();
            }
            ;
        }
        return null;
    }

    /**
     * Adds a filetype ""dot"" extension to filter against.
     *
     * For example: the following code will create a filter that filters
     * out all files except those that end in "".jpg"" and "".tif"":
     *
     *   ExampleFileFilter filter = new ExampleFileFilter();
     *   filter.addExtension(""jpg"");
     *   filter.addExtension(""tif"");
     *
     * Note that the ""."" before the extension is not needed and will be ignored.
     */
    public void addExtension(String extension) {
        if (filters == null) {
            filters = new Hashtable(5);
        }
        filters.put(extension.toLowerCase(), this);
        fullDescription = null;
    }

    /**
     * Returns the human readable description of this filter. For
     * example: ""JPEG and GIF Image Files (*.jpg, *.gif)""
     *
     * @see setDescription
     * @see setExtensionListInDescription
     * @see isExtensionListInDescription
     * @see FileFilter#getDescription
     */
    public String getDescription() {
        if (fullDescription == null) {
            if (description == null || isExtensionListInDescription()) {
                fullDescription = description == null ? ""("" : description + "" ("";
                // build the description from the extension list
                Enumeration extensions = filters.keys();
                if (extensions != null) {
                    fullDescription += ""."" + (String) extensions.nextElement();
                    while (extensions.hasMoreElements()) {
                        fullDescription += "", ."" + (String) extensions.nextElement();
                    }
                }
                fullDescription += "")"";
            } else {
                fullDescription = description;
            }
        }
        return fullDescription;
    }

    /**
     * Sets the human readable description of this filter. For
     * example: filter.setDescription(""Gif and JPG Images"");
     *
     * @see setDescription
     * @see setExtensionListInDescription
     * @see isExtensionListInDescription
     */
    public void setDescription(String description) {
        this.description = description;
        fullDescription = null;
    }

    /**
     * Determines whether the extension list (.jpg, .gif, etc) should
     * show up in the human readable description.
     *
     * Only relevent if a description was provided in the constructor
     * or using setDescription();
     *
     * @see getDescription
     * @see setDescription
     * @see isExtensionListInDescription
     */
    public void setExtensionListInDescription(boolean b) {
        useExtensionsInDescription = b;
        fullDescription = null;
    }

    /**
     * Returns whether the extension list (.jpg, .gif, etc) should
     * show up in the human readable description.
     *
     * Only relevent if a description was provided in the constructor
     * or using setDescription();
     *
     * @see getDescription
     * @see setDescription
     * @see setExtensionListInDescription
     */
    public boolean isExtensionListInDescription() {
        return useExtensionsInDescription;
    }
}
","// EFileFilter_1Test.java
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EFileFilter}.
* It contains ten unit test cases for the {@link EFileFilter#getExtension(File)} method.
*/
class EFileFilter_1Test {","// EFileFilter_1Test.java
/*
 * ===========================================================================
 (C) Copyright Sun Microsystems Inc, 1992, 2004. All rights reserved.
 * ===========================================================================
 */
package apbs_mem_gui;

import java.io.File;
import java.util.Hashtable;
import java.util.Enumeration;
import javax.swing.*;
import javax.swing.filechooser.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link EFileFilter}.
* It contains ten unit test cases for the {@link EFileFilter#getExtension(File)} method.
*/
class EFileFilter_1Test {

	/**
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#getExtension(File)}.
	* Test case 1 for method {@link EFileFilter#"
cmpl-6twdsmJ59KvJZtjNs8ULbUOiKS5Ke,/EvoSuiteBenchmark/29_apbsmem/src/main/java/apbs_mem_gui/FileEditor_0Test.java,3.055665969848633,stop,"// FileEditor.java
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package apbs_mem_gui;

/**
 * @author keithc
 */
import java.io.*;
import java.util.Scanner;
import java.text.*;

public class FileEditor {

    /**
     * Extract energy from the final APBS output file.
     * @param filename Path to APBS output file.
     * @return String array of total energies in kilojoules, kilocalories and k_BT
     */
    public String[] getEnergy(String filename) {
        //returns [0] energy in kJ/mol, then [1] is in kcal/mol
        File temp = new File(filename);
        String[] energies = new String[3];
        if (!temp.exists())
            return null;
        else {
            NumberFormat formatter = new DecimalFormat(""0.####E0"");
            double finalenergy = 0;
            try {
                Scanner fScan = new Scanner(new FileInputStream(filename));
                String nextline;
                //tells whether solvated or reference
                boolean solvated = true;
                while (fScan.hasNextLine()) {
                    nextline = fScan.nextLine();
                    if (nextline.contains(""elec name solvated"")) {
                        solvated = true;
                    } else if (nextline.contains(""elec name reference"")) {
                        solvated = false;
                    } else if (nextline.contains(""Global net ELEC energy "") && solvated) {
                        //if found energy and its in solvated
                        System.out.println(nextline);
                        if (nextline.contains(""+"")) {
                            //if its time 10^positive int
                            finalenergy = toDoublePos(nextline);
                        } else {
                            //if its time 10^negative int
                            finalenergy = toDoubleNeg(nextline);
                        }
                    }
                }
            } catch (Exception e1) {
                e1.printStackTrace();
            }
            energies[0] = formatter.format(finalenergy) + "" kJ/mol"";
            energies[1] = formatter.format(finalenergy * 0.239) + "" kcal/mol"";
            energies[2] = formatter.format(finalenergy * 0.4035) + "" kT"";
            return energies;
        }
    }

    /**
     * Extract the energy from a calculation that has summed the component atom energies
     * rather than simply taking the total. (pull_comps.c)
     * @param filename Path to the file written by pull_comps with the energy sum.
     * @return a double array of the total energy of each calculation (up to 6 calculations if there are 3 focus levels).
     */
    public double[] getCompEnergy(String filename) {
        File temp = new File(filename);
        if (!temp.exists())
            return null;
        else {
            double[] finalenergy = new double[6];
            int i = 0;
            try {
                Scanner fScan = new Scanner(new FileInputStream(filename));
                String nextline;
                double D;
                while (fScan.hasNextLine()) {
                    nextline = fScan.nextLine();
                    System.out.println(nextline);
                    if (!nextline.equals("""")) {
                        if (nextline.contains(""+"")) {
                            //if its time 10^positive int
                            D = Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(""+"") - 1)));
                            D *= Math.pow(10, Double.parseDouble(nextline.substring(nextline.indexOf(""+"") + 1)));
                            //  /(temperature*0.008314472); // convert to kT
                            finalenergy[i] = D;
                        } else {
                            //if its time 10^negative int
                            D = Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(""-"") - 1)));
                            D *= Math.pow(10, Double.parseDouble(nextline.substring(nextline.lastIndexOf(""-""))));
                            //  /(temperature*0.008314472);
                            finalenergy[i] = D;
                        }
                        i++;
                    }
                }
            } catch (Exception e1) {
                e1.printStackTrace();
            }
            return finalenergy;
        }
    }

    private double toDoublePos(String theDouble) {
        double D;
        D = Double.parseDouble(theDouble.substring((theDouble.indexOf(""Global net ELEC energy "") + 25), (theDouble.lastIndexOf(""+"") - 1)));
        return (D *= Math.pow(10, Double.parseDouble(theDouble.substring((theDouble.indexOf(""+"") + 1), theDouble.indexOf("" kJ"")))));
    }

    private double toDoubleNeg(String theDouble) {
        double D;
        D = Double.parseDouble(theDouble.substring((theDouble.indexOf(""Global net ELEC energy "") + 25), (theDouble.lastIndexOf(""-"") - 1)));
        return (D *= Math.pow(10, Double.parseDouble(theDouble.substring(theDouble.lastIndexOf(""-""), theDouble.indexOf("" kJ"")))));
    }
}
","// FileEditor_0Test.java
package apbs_mem_gui;

/**
 * @author keithc
 */
import java.io.*;
import java.util.Scanner;
import java.text.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEditor}.
* It contains ten unit test cases for the {@link FileEditor#getEnergy(String)} method.
*/
class FileEditor_0Test {","// FileEditor_0Test.java
package apbs_mem_gui;

/**
 * @author keithc
 */
import java.io.*;
import java.util.Scanner;
import java.text.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEditor}.
* It contains ten unit test cases for the {@link FileEditor#getEnergy(String)} method.
*/
class FileEditor_0Test {

	/**
	 * Test of getEnergy method, of class FileEditor.
	 * @throws java.lang.Exception
	 */
	@Test
	void testGetEnergy() throws Exception {
		System.out.println(""getEnergy"");
		String filename = """";
		FileEditor instance = new FileEditor();
		String[] expResult = null;
		String[] result = instance.getEnergy(filename);
		assertArrayEquals(expResult, result);
		// TODO review the generated test code and remove the default call to fail.
		fail(""The test case is a prototype."");
	}
	
}"
cmpl-6twevhqyUAgrq85SbCN6QKHq5689m,/EvoSuiteBenchmark/29_apbsmem/src/main/java/apbs_mem_gui/FileEditor_1Test.java,26.682224988937378,stop,"// FileEditor.java
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package apbs_mem_gui;

/**
 * @author keithc
 */
import java.io.*;
import java.util.Scanner;
import java.text.*;

public class FileEditor {

    /**
     * Extract energy from the final APBS output file.
     * @param filename Path to APBS output file.
     * @return String array of total energies in kilojoules, kilocalories and k_BT
     */
    public String[] getEnergy(String filename) {
        //returns [0] energy in kJ/mol, then [1] is in kcal/mol
        File temp = new File(filename);
        String[] energies = new String[3];
        if (!temp.exists())
            return null;
        else {
            NumberFormat formatter = new DecimalFormat(""0.####E0"");
            double finalenergy = 0;
            try {
                Scanner fScan = new Scanner(new FileInputStream(filename));
                String nextline;
                //tells whether solvated or reference
                boolean solvated = true;
                while (fScan.hasNextLine()) {
                    nextline = fScan.nextLine();
                    if (nextline.contains(""elec name solvated"")) {
                        solvated = true;
                    } else if (nextline.contains(""elec name reference"")) {
                        solvated = false;
                    } else if (nextline.contains(""Global net ELEC energy "") && solvated) {
                        //if found energy and its in solvated
                        System.out.println(nextline);
                        if (nextline.contains(""+"")) {
                            //if its time 10^positive int
                            finalenergy = toDoublePos(nextline);
                        } else {
                            //if its time 10^negative int
                            finalenergy = toDoubleNeg(nextline);
                        }
                    }
                }
            } catch (Exception e1) {
                e1.printStackTrace();
            }
            energies[0] = formatter.format(finalenergy) + "" kJ/mol"";
            energies[1] = formatter.format(finalenergy * 0.239) + "" kcal/mol"";
            energies[2] = formatter.format(finalenergy * 0.4035) + "" kT"";
            return energies;
        }
    }

    /**
     * Extract the energy from a calculation that has summed the component atom energies
     * rather than simply taking the total. (pull_comps.c)
     * @param filename Path to the file written by pull_comps with the energy sum.
     * @return a double array of the total energy of each calculation (up to 6 calculations if there are 3 focus levels).
     */
    public double[] getCompEnergy(String filename) {
        File temp = new File(filename);
        if (!temp.exists())
            return null;
        else {
            double[] finalenergy = new double[6];
            int i = 0;
            try {
                Scanner fScan = new Scanner(new FileInputStream(filename));
                String nextline;
                double D;
                while (fScan.hasNextLine()) {
                    nextline = fScan.nextLine();
                    System.out.println(nextline);
                    if (!nextline.equals("""")) {
                        if (nextline.contains(""+"")) {
                            //if its time 10^positive int
                            D = Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(""+"") - 1)));
                            D *= Math.pow(10, Double.parseDouble(nextline.substring(nextline.indexOf(""+"") + 1)));
                            //  /(temperature*0.008314472); // convert to kT
                            finalenergy[i] = D;
                        } else {
                            //if its time 10^negative int
                            D = Double.parseDouble(nextline.substring(0, (nextline.lastIndexOf(""-"") - 1)));
                            D *= Math.pow(10, Double.parseDouble(nextline.substring(nextline.lastIndexOf(""-""))));
                            //  /(temperature*0.008314472);
                            finalenergy[i] = D;
                        }
                        i++;
                    }
                }
            } catch (Exception e1) {
                e1.printStackTrace();
            }
            return finalenergy;
        }
    }

    private double toDoublePos(String theDouble) {
        double D;
        D = Double.parseDouble(theDouble.substring((theDouble.indexOf(""Global net ELEC energy "") + 25), (theDouble.lastIndexOf(""+"") - 1)));
        return (D *= Math.pow(10, Double.parseDouble(theDouble.substring((theDouble.indexOf(""+"") + 1), theDouble.indexOf("" kJ"")))));
    }

    private double toDoubleNeg(String theDouble) {
        double D;
        D = Double.parseDouble(theDouble.substring((theDouble.indexOf(""Global net ELEC energy "") + 25), (theDouble.lastIndexOf(""-"") - 1)));
        return (D *= Math.pow(10, Double.parseDouble(theDouble.substring(theDouble.lastIndexOf(""-""), theDouble.indexOf("" kJ"")))));
    }
}
","// FileEditor_1Test.java
package apbs_mem_gui;

/**
 * @author keithc
 */
import java.io.*;
import java.util.Scanner;
import java.text.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEditor}.
* It contains ten unit test cases for the {@link FileEditor#getCompEnergy(String)} method.
*/
class FileEditor_1Test {","// FileEditor_1Test.java
package apbs_mem_gui;

/**
 * @author keithc
 */
import java.io.*;
import java.util.Scanner;
import java.text.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FileEditor}.
* It contains ten unit test cases for the {@link FileEditor#getCompEnergy(String)} method.
*/
class FileEditor_1Test {

	/**
	 * Test of getCompEnergy method, of class FileEditor.
	 * @throws java.io.FileNotFoundException
	 */
	@Test
	void testGetCompEnergy() throws FileNotFoundException {
		System.out.println(""getCompEnergy"");
		FileEditor instance = new FileEditor();
		double[] expResult = new double[6];
		double[] result = new double[6];
		
		// Test case 1
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_1.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 2
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_2.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 3
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_3.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 4
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_4.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 5
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_5.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 6
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_6.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 7
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_7.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 8
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_8.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 9
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_9.txt"");
		assertArrayEquals(expResult, result, 0.0001);
		
		// Test case 10
		expResult[0] = -0.0012;
		expResult[1] = -0.0012;
		expResult[2] = -0.0012;
		expResult[3] = -0.0012;
		expResult[4] = -0.0012;
		expResult[5] = -0.0012;
		result = instance.getCompEnergy(""test/test_files/test_10.txt"");
		assertArrayEquals(expResult, result, 0.0001);
	}
}"
30adef9e-ea00-4db5-8ea2-c80b4e6c6098,/EvoSuiteBenchmark/29_apbsmem/src/main/java/apbs_mem_gui/Main.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 20646 tokens (16646 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Main.java
package apbs_mem_gui;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.io.*;
import com.jgoodies.forms.layout.*;
import com.jgoodies.forms.builder.*;
import org.jmol.api.JmolViewer;
import org.jmol.api.JmolAdapter;
import org.jmol.popup.JmolPopup;

/**
 * @author Keith Callenberg, Gabriel de Forest
 */
public class Main {

    private JMenuBar mainBar;

    private JMenu fileMenu, focusMenu, helpMenu;

    private JMenuItem save, open, exit, about, readme;

    private ButtonGroup focusbuttons;

    private JRadioButtonMenuItem setFocus0, setFocus1, setFocus2;

    protected int maxfocus = 0, pb = 0;

    private JPanel lpane, rpane;

    private Container mainPane;

    GridBagConstraints gbc = new GridBagConstraints();

    private JButton Run, PQRBrowse1, PQRBrowse2, Preview, RedrawPot;

    protected JCheckBox drawPot;

    protected JFormattedTextField pqrFile1, pqrFile2, gridDimx, gridDimy, gridDimz, gridLen1a, gridLen2a, gridLen3a, gridLen1b, gridLen2b, gridLen3b, gridLen1c, gridLen2c, gridLen3c, countIon1Charge, countIon1Con, countIon1Sz, countIon2Charge, countIon2Con, countIon2Sz, proteinDi, solventDi, membraneDi, srad, sdens, temp, zmem, Lmem, idie, geoFactor1, geoFactor2, geoFactor3, potential, potcontour;

    protected javax.swing.JProgressBar pBar;

    protected javax.swing.JComboBox solMethodCombo, boundaryCondCombo, calcTypeCombo, centerCombo, contourCombo;

    InFile inFile;

    Exec exec = new Exec();

    FileEditor file = new FileEditor();

    //keeps track of whether or not file has been changed
    boolean hasbeenchanged = true;

    //is file already loaded/saved?
    boolean file_loaded = false;

    double[] finalenergy, memv;

    File ofile;

    String outfilename;

    String[] theEnergy, ctypes;

    Scanner fScan;

    PrintWriter outFile;

    private JFrame theWindow = new JFrame();

    protected JmolViewer viewer;

    private JmolAdapter adapter;

    private JmolPopup jmolPopup;

    private static double version = 1.04;

    private JDialog aboutdialog, helpdialog;

    private static Main m;

    /**
     * Main class that includes the GUI components
     */
    public Main() {
        inFile = new InFile();
        theWindow = new JFrame(""APBSmem "" + version);
        theWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        mainPane = theWindow.getContentPane();
        Run = new JButton(""Run"");
        PQRBrowse1 = new JButton(""Browse"");
        PQRBrowse2 = new JButton(""Browse"");
        PQRBrowse2.setEnabled(false);
        Preview = new JButton(""Preview"");
        mainBar = new JMenuBar();
        theWindow.setJMenuBar(mainBar);
        RedrawPot = new JButton(""Redraw"");
        RedrawPot.setEnabled(false);
        fileMenu = new JMenu(""File"");
        open = new JMenuItem(""Open"");
        save = new JMenuItem(""Save"");
        exit = new JMenuItem(""Exit"");
        helpMenu = new JMenu(""Help"");
        readme = new JMenuItem(""Readme"");
        about = new JMenuItem(""About"");
        //helpMenu.add(readme);
        helpMenu.add(about);
        fileMenu.add(open);
        fileMenu.add(save);
        fileMenu.add(exit);
        focusMenu = new JMenu(""Focus"");
        setFocus0 = new JRadioButtonMenuItem(""No focus"");
        setFocus1 = new JRadioButtonMenuItem(""1 focus level"");
        setFocus2 = new JRadioButtonMenuItem(""2 focus levels"");
        setFocus0.setSelected(true);
        focusbuttons = new ButtonGroup();
        focusbuttons.add(setFocus0);
        focusbuttons.add(setFocus1);
        focusbuttons.add(setFocus2);
        focusMenu.add(setFocus0);
        focusMenu.add(setFocus1);
        focusMenu.add(setFocus2);
        mainBar.add(fileMenu);
        mainBar.add(focusMenu);
        mainBar.add(helpMenu);
        ctypes = new String[] { ""Protein solvation"", ""Ion solvation"", ""Gating charge"" };
        pBar = new javax.swing.JProgressBar();
        pBar.setStringPainted(true);
        pb = 0;
        gridDimx = new JFormattedTextField(new Integer(97));
        gridDimx.setToolTipText(""Grid dimension X"");
        gridDimy = new JFormattedTextField(new Integer(97));
        gridDimy.setToolTipText(""Grid dimension Y"");
        gridDimz = new JFormattedTextField(new Integer(97));
        gridDimz.setToolTipText(""Grid dimension Z"");
        gridLen1a = new JFormattedTextField(new Double(300));
        gridLen1a.setToolTipText(""Grid length X"");
        gridLen2a = new JFormattedTextField(new Double(300));
        gridLen2a.setToolTipText(""Grid length Y"");
        gridLen3a = new JFormattedTextField(new Double(300));
        gridLen3a.setToolTipText(""Grid length Z"");
        gridLen1b = new JFormattedTextField(new Double(200));
        gridLen1b.setToolTipText(""Grid length X"");
        gridLen2b = new JFormattedTextField(new Double(200));
        gridLen2b.setToolTipText(""Grid length Y"");
        gridLen3b = new JFormattedTextField(new Double(200));
        gridLen3b.setToolTipText(""Grid length Z"");
        gridLen1c = new JFormattedTextField(new Double(100));
        gridLen1c.setToolTipText(""Grid length X"");
        gridLen2c = new JFormattedTextField(new Double(100));
        gridLen2c.setToolTipText(""Grid length Y"");
        gridLen3c = new JFormattedTextField(new Double(100));
        gridLen3c.setToolTipText(""Grid length Z"");
        setFocus1Enable(false);
        setFocus2Enable(false);
        countIon1Charge = new JFormattedTextField(new Double(1.0));
        countIon1Charge.setToolTipText(""Ion 1 CHARGE"");
        countIon1Con = new JFormattedTextField(new Double(0.1));
        countIon1Con.setToolTipText(""Ion 1 CONCENTRATION"");
        countIon1Sz = new JFormattedTextField(new Double(2.0));
        countIon1Sz.setToolTipText(""Ion 1 RADIUS"");
        countIon2Charge = new JFormattedTextField(new Double(-1.0));
        countIon2Charge.setToolTipText(""Ion 2 CHARGE"");
        countIon2Con = new JFormattedTextField(new Double(0.1));
        countIon2Con.setToolTipText(""Ion 2 CONCENTRATION"");
        countIon2Sz = new JFormattedTextField(new Double(2.0));
        countIon2Sz.setToolTipText(""Ion 2 RADIUS"");
        proteinDi = new JFormattedTextField(new Double(2.0));
        solventDi = new JFormattedTextField(new Double(80.0));
        membraneDi = new JFormattedTextField(new Double(2.0));
        pqrFile1 = new JFormattedTextField(new String(""""));
        pqrFile1.setColumns(16);
        pqrFile2 = new JFormattedTextField(new String(""""));
        pqrFile2.setColumns(16);
        pqrFile2.setEnabled(false);
        srad = new JFormattedTextField(new Double(1.4));
        sdens = new JFormattedTextField(new Double(10.0));
        temp = new JFormattedTextField(new Double(298.15));
        temp.setToolTipText(""Temperature in Kelvin"");
        zmem = new JFormattedTextField(new Double(-20.0));
        zmem.setToolTipText(""Protein position in membrane in Angstroms"");
        Lmem = new JFormattedTextField(new Double(40));
        Lmem.setToolTipText(""Membrane length in Angstroms"");
        idie = new JFormattedTextField(new Double(80));
        geoFactor1 = new JFormattedTextField(new Double(0.0));
        geoFactor1.setToolTipText(""Exclusion radius in Angstroms"");
        geoFactor2 = new JFormattedTextField(new Double(0.0));
        geoFactor2.setToolTipText(""Exclusion radius in Angstroms"");
        geoFactor3 = new JFormattedTextField(new Double(0.0));
        geoFactor3.setToolTipText(""Thickness in Angstroms"");
        drawPot = new JCheckBox(""Draw potential"");
        potcontour = new JFormattedTextField(""2"");
        potcontour.setToolTipText(""Isocontour to draw electrostatic potential (+/-)"");
        potcontour.setEnabled(false);
        potential = new JFormattedTextField(""50"");
        potential.setColumns(5);
        potential.setToolTipText(""Membrane potential in mV"");
        potential.setEnabled(false);
        solMethodCombo = new javax.swing.JComboBox();
        solMethodCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""lpbe"", ""npbe"" }));
        solMethodCombo.setToolTipText(""Linearized or Non-linearized Poisson Boltzmann"");
        calcTypeCombo = new javax.swing.JComboBox();
        calcTypeCombo.setModel(new javax.swing.DefaultComboBoxModel(ctypes));
        boundaryCondCombo = new javax.swing.JComboBox();
        boundaryCondCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""Zero"", ""SDH"", ""MDH"", ""Focus"", ""Membrane potential"" }));
        centerCombo = new javax.swing.JComboBox();
        centerCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""Origin"", ""Molecule 1"" }));
        contourCombo = new javax.swing.JComboBox();
        contourCombo.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""Membrane-Protein"", ""Protein-Solvent"" }));
        fileInHandler fhandler = new fileInHandler();
        menuHandler menuhandler = new menuHandler();
        boundaryCondCombo.addActionListener(fhandler);
        centerCombo.addActionListener(fhandler);
        calcTypeCombo.addActionListener(fhandler);
        pqrFile1.addActionListener(fhandler);
        pqrFile2.addActionListener(fhandler);
        gridDimx.addActionListener(fhandler);
        gridDimy.addActionListener(fhandler);
        gridDimz.addActionListener(fhandler);
        gridLen1a.addActionListener(fhandler);
        gridLen2a.addActionListener(fhandler);
        gridLen3a.addActionListener(fhandler);
        countIon1Charge.addActionListener(fhandler);
        countIon1Con.addActionListener(fhandler);
        countIon1Sz.addActionListener(fhandler);
        countIon2Charge.addActionListener(fhandler);
        countIon2Con.addActionListener(fhandler);
        countIon2Sz.addActionListener(fhandler);
        proteinDi.addActionListener(fhandler);
        solventDi.addActionListener(fhandler);
        membraneDi.addActionListener(fhandler);
        Run.addActionListener(fhandler);
        PQRBrowse1.addActionListener(fhandler);
        PQRBrowse2.addActionListener(fhandler);
        Preview.addActionListener(fhandler);
        drawPot.addActionListener(fhandler);
        RedrawPot.addActionListener(fhandler);
        setFocus0.addActionListener(menuhandler);
        setFocus1.addActionListener(menuhandler);
        setFocus2.addActionListener(menuhandler);
        open.addActionListener(menuhandler);
        save.addActionListener(menuhandler);
        exit.addActionListener(menuhandler);
        about.addActionListener(menuhandler);
        readme.addActionListener(menuhandler);
        lpane = new JPanel();
        JmolPanel jmolPanel = new JmolPanel();
        aboutdialog = new SimpleAboutDialog(new JFrame());
        helpdialog = new SimpleHelpDialog(new JFrame());
        FormLayout layout = new FormLayout(//columns
        ""right:pref, 4dlu, pref, 4dlu, pref, 4dlu, pref, 4dlu, pref"", ""pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,"" + ""pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,"" + ""pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,"" + ""pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu,"" + //rows
        ""pref, 2dlu, pref, 2dlu, pref, 2dlu, pref, 2dlu, pref"");
        PanelBuilder builder = new PanelBuilder(layout);
        builder.setDefaultDialogBorder();
        lpane.setLayout(layout);
        CellConstraints cc = new CellConstraints();
        builder.add(new JLabel(""Calculation type""), cc.xy(1, 1));
        builder.add(calcTypeCombo, cc.xyw(3, 1, 5));
        builder.add(new JLabel(""PQR File 1""), cc.xy(1, 3));
        builder.add(pqrFile1, cc.xyw(3, 3, 3));
        builder.add(PQRBrowse1, cc.xy(7, 3));
        builder.add(new JLabel(""PQR File 2""), cc.xy(1, 5));
        builder.add(pqrFile2, cc.xyw(3, 5, 3));
        builder.add(PQRBrowse2, cc.xy(7, 5));
        builder.add(new JLabel(""Grid dimensions""), cc.xy(1, 7));
        builder.add(gridDimx, cc.xy(3, 7));
        builder.add(gridDimy, cc.xy(5, 7));
        builder.add(gridDimz, cc.xy(7, 7));
        builder.add(new JLabel(""Grid lengths""), cc.xy(1, 9));
        builder.add(gridLen1a, cc.xy(3, 9));
        builder.add(gridLen2a, cc.xy(5, 9));
        builder.add(gridLen3a, cc.xy(7, 9));
        builder.add(new JLabel(""""), cc.xy(1, 11));
        builder.add(gridLen1b, cc.xy(3, 11));
        builder.add(gridLen2b, cc.xy(5, 11));
        builder.add(gridLen3b, cc.xy(7, 11));
        builder.add(new JLabel(""""), cc.xy(1, 13));
        builder.add(gridLen1c, cc.xy(3, 13));
        builder.add(gridLen2c, cc.xy(5, 13));
        builder.add(gridLen3c, cc.xy(7, 13));
        builder.add(new JLabel(""Counter-ions""), cc.xy(1, 15));
        builder.add(countIon1Charge, cc.xy(3, 15));
        builder.add(countIon1Con, cc.xy(5, 15));
        builder.add(countIon1Sz, cc.xy(7, 15));
        builder.add(countIon2Charge, cc.xy(3, 17));
        builder.add(countIon2Con, cc.xy(5, 17));
        builder.add(countIon2Sz, cc.xy(7, 17));
        builder.addSeparator(""Dielectric constants"", cc.xyw(1, 21, 7));
        builder.add(new JLabel(""Protein""), cc.xy(1, 23));
        builder.add(proteinDi, cc.xy(3, 23));
        builder.add(new JLabel(""Solvent""), cc.xy(5, 23));
        builder.add(solventDi, cc.xy(7, 23));
        builder.add(new JLabel(""Membrane""), cc.xy(1, 25));
        builder.add(membraneDi, cc.xy(3, 25));
        builder.add(new JLabel(""Head group""), cc.xy(5, 25));
        builder.add(idie, cc.xy(7, 25));
        builder.addSeparator(""Geometry settings"", cc.xyw(1, 27, 7));
        builder.add(new JLabel(""Membrane thickness""), cc.xy(1, 29));
        builder.add(Lmem, cc.xy(3, 29));
        builder.add(new JLabel(""Upper exclusion""), cc.xy(5, 29));
        builder.add(geoFactor1, cc.xy(7, 29));
        builder.add(new JLabel(""Head group thickness""), cc.xy(1, 31));
        builder.add(geoFactor3, cc.xy(3, 31));
        builder.add(new JLabel(""Lower exclusion""), cc.xy(5, 31));
        builder.add(geoFactor2, cc.xy(7, 31));
        builder.add(new JLabel(""Membrane bottom z-pos""), cc.xy(1, 33));
        builder.add(zmem, cc.xy(3, 33));
        builder.addSeparator(""Other parameters"", cc.xyw(1, 35, 7));
        builder.add(new JLabel(""Solution method""), cc.xy(1, 37));
        builder.add(solMethodCombo, cc.xy(3, 37));
        builder.add(new JLabel(""Temperature""), cc.xy(5, 37));
        builder.add(temp, cc.xy(7, 37));
        builder.add(new JLabel(""Boundary conditions""), cc.xy(1, 39));
        builder.add(boundaryCondCombo, cc.xy(3, 39));
        builder.add(new JLabel(""Membrane potential""), cc.xy(5, 39));
        builder.add(potential, cc.xy(7, 39));
        builder.add(new JLabel(""Solvent radius""), cc.xy(1, 41));
        builder.add(srad, cc.xy(3, 41));
        builder.add(new JLabel(""Sphere density""), cc.xy(5, 41));
        builder.add(sdens, cc.xy(7, 41));
        builder.add(new JLabel(""Isosurface contour""), cc.xy(1, 43));
        builder.add(contourCombo, cc.xy(3, 43));
        builder.add(new JLabel(""Grid center""), cc.xy(5, 43));
        builder.add(centerCombo, cc.xy(7, 43));
        builder.add(drawPot, cc.xy(3, 45));
        builder.add(potcontour, cc.xy(5, 45));
        builder.add(RedrawPot, cc.xy(7, 45));
        builder.add(new JLabel(""""), cc.xy(1, 47));
        builder.add(Preview, cc.xy(3, 47));
        builder.add(Run, cc.xy(5, 47));
        JSplitPane sp = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, builder.getPanel(), null);
        sp.setOneTouchExpandable(true);
        sp.setBorder(null);
        mainPane.add(sp, BorderLayout.CENTER);
        JPanel bottom = new JPanel();
        bottom.setLayout(new BorderLayout());
        bottom.add(pBar, BorderLayout.WEST);
        mainPane.add(bottom, BorderLayout.SOUTH);
        viewer = jmolPanel.getViewer();
        viewer.evalString(""zap;frank off;"");
        File logo = new File(""apbsmem.jvxl"");
        if (logo.exists())
            viewer.evalString(""isoSurface \""apbsmem.jvxl\"";zoom 200;"");
        theWindow.pack();
        jmolPanel.setPreferredSize(new Dimension(300, 300));
        sp.setRightComponent(jmolPanel);
        theWindow.pack();
        theWindow.setVisible(true);
        dependencyCheck();
    }

    /**
     * Driver method
     * @param args No command-line arguments are necessary
     */
    public static void main(String[] args) {
        m = new Main();
    }

    private class menuHandler implements ActionListener {

        public void actionPerformed(ActionEvent e) {
            if (e.getSource() == setFocus0) {
                setMaxFocus(0);
            }
            if (e.getSource() == setFocus1) {
                setMaxFocus(1);
            }
            if (e.getSource() == setFocus2) {
                setMaxFocus(2);
            } else if (e.getSource() == about) {
                aboutdialog.show();
            } else if (e.getSource() == readme) {
                helpdialog.show();
            } else //opens a *.in file that has between 0 and 2 focus
            if (e.getSource() == open) {
                if (OpenFile()) {
                    //if got the file successfully and (dont save)
                    try {
                        fScan = new Scanner(new FileInputStream(ofile));
                    } catch (Exception e1) {
                        System.out.println(e1.getMessage());
                    }
                    //assume protein solvation unless we see >1 pqr or memv parameters
                    calcTypeCombo.setSelectedIndex(0);
                    StringBuffer theData = new StringBuffer();
                    int loadfocus = -1;
                    String nextline;
                    while (fScan.hasNextLine()) {
                        nextline = fScan.nextLine();
                        if (nextline.contains(""elec name"")) {
                            if (loadfocus > -1 && nextline.endsWith(""0""))
                                // we only want to load one section so we stop if we see a new section
                                break;
                            else
                                loadfocus++;
                        } else if (nextline.contains(""end"")) {
                            //if done with loading a focus level
                            //save current data regardless. first focus it wont really do anything
                            SaveData();
                            maxfocus = loadfocus;
                            String temp = theData.toString();
                            String[] data = temp.split(""\n"");
                            //then load up data to the new focus
                            LoadData(data, loadfocus);
                            //finally, reset the data for the next focus
                            theData = new StringBuffer();
                        } else {
                            theData.append(nextline + ""\n"");
                        }
                    }
                    fScan.close();
                    setMaxFocus(maxfocus);
                }
            } else if (e.getSource() == save) {
                if (SaveData() && SaveDialog(""Save settings to file"")) {
                    //if it was able to save the data
                    //save all data to file (true = first run)
                    SaveToFile(true);
                    //file has not been changed since
                    hasbeenchanged = false;
                }
            } else if (e.getSource() == exit) {
                if (hasbeenchanged) {
                    int answer;
                    if (file_loaded) {
                        answer = JOptionPane.showConfirmDialog(null, ""Do you want to save changes to "" + ofile.getName() + ""?"", """", JOptionPane.YES_NO_OPTION);
                    } else {
                        answer = JOptionPane.showConfirmDialog(null, ""Do you want to save your settings?"", """", JOptionPane.YES_NO_OPTION);
                    }
                    if (answer == JOptionPane.YES_OPTION) {
                        if (!file_loaded) {
                            SaveDialog(""Save settings to file"");
                        }
                        SaveToFile(true);
                    }
                }
                File curdir = new File(""."");
                deleteFiles(curdir.getPath(), "".dx"");
                System.exit(0);
            }
        }
    }

    private class fileInHandler implements ActionListener {

        public void actionPerformed(ActionEvent e) {
            if (e.getSource() == Preview) {
                if (pqrFile1.getText() == """") {
                    JOptionPane.showMessageDialog(null, ""Please select the PQR file"", ""Error"", JOptionPane.PLAIN_MESSAGE);
                    return;
                } else {
                    File tfile = new File(pqrFile1.getText());
                    if (!tfile.exists()) {
                        JOptionPane.showMessageDialog(null, ""PQR file not found"", ""Error"", JOptionPane.PLAIN_MESSAGE);
                        return;
                    }
                }
                Integer t1 = Integer.parseInt(gridDimx.getText());
                Integer t2 = Integer.parseInt(gridDimy.getText());
                Integer t3 = Integer.parseInt(gridDimz.getText());
                gridDimx.setText(""65"");
                gridDimy.setText(""65"");
                gridDimz.setText(""65"");
                SaveData();
                ofile = new File(""./preview_temp"");
                if (calcTypeCombo.getSelectedIndex() == 1) {
                    //ION SOLVATION
                    if (!pqrFile2.getText().equals("""")) {
                        //Load the ION too!
                        viewer.evalString(""load APPEND \"""" + pqrFile2.getText() + ""\"""");
                        viewer.evalString(""frame *;cpk off;wireframe off;cartoon on;color green;select 2.0;color purple;spacefill 100%"");
                    }
                }
                Thread pT = new Thread(new Run(m, inFile, ofile, viewer, pBar, drawPot.isSelected(), potcontour.getText(), true));
                pT.start();
                ofile.delete();
                gridDimx.setText(t1.toString());
                gridDimy.setText(t2.toString());
                gridDimz.setText(t3.toString());
                pBar.setValue(0);
            } else if (e.getSource() == Run) {
                if (pqrFile1.getText().equals("""")) {
                    JOptionPane.showMessageDialog(null, ""Please select the PQR file for the protein."", ""Error"", JOptionPane.PLAIN_MESSAGE);
                    return;
                } else {
                    File tfile1 = new File(pqrFile1.getText());
                    if (!tfile1.exists()) {
                        System.out.println(""Protein PQR file not found."");
                        return;
                    }
                }
                System.out.println(""Focus: "" + maxfocus + "" "" + inFile.getMaxfocus());
                //clean up files from a previous run - this should not be needed at some point
                File curdir = new File(""."");
                deleteFiles(curdir.getPath(), "".dx"");
                if (SaveData() && SaveDialog(""Enter a name for the output directory before running"")) {
                    if (calcTypeCombo.getSelectedIndex() == 1) {
                        //ION SOLVATION - create concatenation file of ion + protein
                        //Load the ION too!
                        viewer.evalString(""load FILES \"""" + pqrFile1.getText() + ""\"" \"""" + pqrFile2.getText() + ""\"""");
                        try {
                            BufferedWriter prot1 = new BufferedWriter(new FileWriter(pqrFile1.getText() + "".withion.pqr"", false));
                            BufferedReader in1 = new BufferedReader(new FileReader(pqrFile1.getText()));
                            BufferedReader in2 = new BufferedReader(new FileReader(pqrFile2.getText()));
                            String inputline;
                            while ((inputline = in1.readLine()) != null) {
                                prot1.write(inputline);
                                prot1.newLine();
                            }
                            while ((inputline = in2.readLine()) != null) {
                                prot1.write(inputline);
                                prot1.newLine();
                            }
                            prot1.flush();
                            prot1.close();
                            in1.close();
                            in2.close();
                        } catch (Exception e1) {
                            System.out.println(e1);
                        }
                        inFile.setMol3(pqrFile1.getText() + "".withion.pqr"");
                        //Load the ION too!
                        viewer.evalString(""load APPEND \"""" + pqrFile2.getText() + ""\"""");
                        viewer.evalString(""frame *;cpk off;wireframe off;cartoons on;color green;select 2.0;color purple;spacefill 100%"");
                    } else if (calcTypeCombo.getSelectedIndex() == 2) {
                        //GATING CHARGE - turn charges off for dummy calculation
                        exec.callChargeOff(pqrFile1.getText());
                        exec.callChargeOff(pqrFile2.getText());
                    }
                    Thread t1 = new Thread(new Run(m, inFile, ofile, viewer, pBar, drawPot.isSelected(), potcontour.getText(), false));
                    t1.start();
                    if (drawPot.isEnabled()) {
                        RedrawPot.setEnabled(true);
                    }
                }
                pBar.setValue(0);
            } else if (e.getSource() == PQRBrowse1) {
                final JFileChooser fc = new JFileChooser(new File("".""));
                fc.setAcceptAllFileFilterUsed(false);
                EFileFilter filter = new EFileFilter(""pqr"");
                filter.setDescription(""PQR files"");
                fc.addChoosableFileFilter(filter);
                int returnVal = fc.showOpenDialog(theWindow);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    pqrFile1.setText(fc.getSelectedFile().getPath());
                    viewer.openFile(pqrFile1.getText());
                }
            } else if (e.getSource() == PQRBrowse2) {
                final JFileChooser fc = new JFileChooser(new File("".""));
                fc.setAcceptAllFileFilterUsed(false);
                EFileFilter filter = new EFileFilter(""pqr"");
                filter.setDescription(""PQR files"");
                fc.addChoosableFileFilter(filter);
                int returnVal = fc.showOpenDialog(theWindow);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    pqrFile2.setText(fc.getSelectedFile().getPath());
                    // viewer.openFile(pqrFile2.getText());
                }
            } else if (e.getSource() == boundaryCondCombo) {
                if (calcTypeCombo.getSelectedIndex() == 2) {
                    boundaryCondCombo.setSelectedIndex(4);
                    potential.setEnabled(true);
                } else {
                    if (boundaryCondCombo.getSelectedIndex() == 4) {
                        boundaryCondCombo.setSelectedIndex(0);
                        potential.setEnabled(false);
                    }
                    if (boundaryCondCombo.getSelectedIndex() == 3 && maxfocus == 0) {
                        String temp;
                        Object[] choices = { ""0"", ""1"", ""2"" };
                        temp = (String) JOptionPane.showInputDialog(null, ""How many focus levels do you want to set?"", ""Focus levels"", JOptionPane.QUESTION_MESSAGE, null, choices, choices[0]);
                        setMaxFocus(Integer.parseInt(temp));
                    }
                }
            } else if (e.getSource() == calcTypeCombo) {
                if (calcTypeCombo.getSelectedIndex() == 0) {
                    //PROTEIN SOLVATION
                    pqrFile2.setEnabled(false);
                    PQRBrowse2.setEnabled(false);
                    pqrFile1.setToolTipText(""PQR file of protein in membrane"");
                    if (boundaryCondCombo.getSelectedIndex() == 4) {
                        boundaryCondCombo.setSelectedIndex(0);
                    }
                } else if (calcTypeCombo.getSelectedIndex() == 1) {
                    //ION SOLVATION
                    pqrFile2.setEnabled(true);
                    PQRBrowse2.setEnabled(true);
                    pqrFile1.setToolTipText(""PQR file of protein"");
                    pqrFile2.setToolTipText(""PQR file of ion only"");
                    if (boundaryCondCombo.getSelectedIndex() == 4) {
                        boundaryCondCombo.setSelectedIndex(0);
                    }
                } else {
                    //GATING CHARGE
                    pqrFile2.setEnabled(true);
                    PQRBrowse2.setEnabled(true);
                    pqrFile1.setToolTipText(""PQR file of gating conformation 1"");
                    pqrFile2.setToolTipText(""PQR file of gating conformation 2"");
                    boundaryCondCombo.setSelectedIndex(4);
                    potential.setEnabled(true);
                }
            } else if (e.getSource() == drawPot) {
                potcontour.setEnabled(drawPot.isSelected());
            } else if (e.getSource() == RedrawPot) {
                viewer.evalString(""isosurface delete"");
                if (drawPot.isSelected()) {
                    viewer.evalString(""isosurface "" + getIsocontour() + "" \""dielx_"" + (maxfocus + 1) + ""m.dx\""; color isosurface white translucent"");
                    viewer.evalString(""isosurface potpos "" + potcontour.getText() + "" \""pot_1.dx\""; color isoSurface red translucent"");
                    viewer.evalString(""isosurface potneg -"" + potcontour.getText() + "" \""pot_1.dx\""; color isoSurface blue translucent"");
                }
            }
        }
    }

    ///end fileInHandler
    public Double getIsocontour() {
        //protein-membrane dielectric
        if (contourCombo.getSelectedIndex() == 0) {
            if (Double.valueOf(inFile.getMdie()) < Double.valueOf(inFile.getProteinDi())) {
                return Double.valueOf(inFile.getMdie()) + 0.001;
            } else {
                return Double.valueOf(inFile.getProteinDi()) + 0.001;
            }
        } else //protein-solvent boundary
        {
            if (Double.valueOf(inFile.getProteinDi()) < Double.valueOf(inFile.getSolventDi())) {
                return Double.valueOf(inFile.getProteinDi()) + 0.001;
            } else {
                return Double.valueOf(inFile.getSolventDi()) + 0.001;
            }
        }
    }

    /**
     * Change the number of focus levels to use in the calculation
     * @param mf The new number of focus levels. Current options are 0, 1, or 2.
     */
    public void setMaxFocus(int mf) {
        maxfocus = mf;
        inFile.setMaxFocus(mf);
        if (maxfocus == 0) {
            if (boundaryCondCombo.getSelectedIndex() == 3)
                boundaryCondCombo.setSelectedIndex(0);
            setFocus1Enable(false);
            setFocus2Enable(false);
            setFocus0.setSelected(true);
        } else if (maxfocus == 1) {
            boundaryCondCombo.setSelectedIndex(3);
            setFocus1Enable(true);
            setFocus2Enable(false);
            setFocus1.setSelected(true);
        } else {
            boundaryCondCombo.setSelectedIndex(3);
            setFocus1Enable(true);
            setFocus2Enable(true);
            setFocus2.setSelected(true);
        }
    }

    /**
     * Enable or disable text input fields for the level 1 focusing.
     * @param v flag to enable (if true) or disable (if false) the focus level 1.
     */
    public void setFocus1Enable(boolean v) {
        gridLen1b.setEnabled(v);
        gridLen2b.setEnabled(v);
        gridLen3b.setEnabled(v);
    }

    /**
     * Enable or disable text input fields for the level 2 focusing.
     * @param v flag to enable (if true) or disable (if false) the focus level 2.
     */
    public void setFocus2Enable(boolean v) {
        gridLen1c.setEnabled(v);
        gridLen2c.setEnabled(v);
        gridLen3c.setEnabled(v);
    }

    /**
     * Save the parameters stored in the inFile object to a file.
     * @param firstcall True if the file to be written is the ""dummy"" file
     * before the real calculation, otherwise false.
     */
    public void SaveToFile(boolean firstcall) {
        if (ofile != null) {
            try {
                if (firstcall) {
                    File outFile2 = new File(ofile.getPath() + "".dummy.in"");
                    outFile2.delete();
                    outFile = new PrintWriter(new FileOutputStream(outFile2));
                    System.out.println(""HEY: "" + outFile2.getPath());
                } else {
                    File outFile2 = new File(ofile.getPath() + "".solv.in"");
                    outFile2.delete();
                    outFile = new PrintWriter(new FileOutputStream(outFile2));
                }
            } catch (Exception e1) {
                System.out.println(""SaveToFile exception: "" + e1.toString());
            }
            //store data in temporary string
            String tempIn = inFile.toString(firstcall);
            //split data by each new line
            String[] tempInSplit = tempIn.split(""\n"");
            for (int i = 0; i < tempInSplit.length; i++) {
                //print data one line at a time
                outFile.println(tempInSplit[i]);
            }
            outFile.close();
        }
    }

    /**
     * Store the current GUI text field values in the inFile object.
     * @return True if the operation was succesful, false otherwise.
     */
    public boolean SaveData() {
        if (pqrFile1.getText().equals("""") || pqrFile1.getText() == null || gridDimx.getText().equals("""") || gridDimx.getText() == null || gridDimy.getText().equals("""") || gridDimy.getText() == null || gridDimz.getText().equals("""") || gridDimz.getText() == null || gridLen1a.getText().equals("""") || gridLen1a.getText() == null || gridLen2a.getText().equals("""") || gridLen2a.getText() == null || gridLen3a.getText().equals("""") || gridLen3a.getText() == null || countIon1Charge.getText().equals("""") || countIon1Charge.getText() == null || countIon1Con.getText().equals("""") || countIon1Con.getText() == null || countIon1Sz.getText().equals("""") || countIon1Sz.getText() == null || countIon2Charge.getText().equals("""") || countIon2Charge.getText() == null || countIon2Con.getText().equals("""") || countIon2Con.getText() == null || countIon2Sz.getText().equals("""") || countIon2Sz.getText() == null || proteinDi.getText().equals("""") || proteinDi.getText() == null || solventDi.getText().equals("""") || solventDi.getText() == null || srad.getText().equals("""") || srad.getText() == null || sdens.getText().equals("""") || sdens.getText() == null || temp.getText().equals("""") || temp.getText() == null) {
            if (maxfocus > 0 && (gridLen1b.getText().equals("""") || gridLen1b.getText() == null || gridLen2b.getText().equals("""") || gridLen2b.getText() == null || gridLen3b.getText().equals("""") || gridLen3b.getText() == null)) {
                if (maxfocus > 1 && (gridLen1c.getText().equals("""") || gridLen1c.getText() == null || gridLen2c.getText().equals("""") || gridLen2c.getText() == null || gridLen3c.getText().equals("""") || gridLen3c.getText() == null)) {
                    if (file_loaded) {
                        //if you arent opening it and it fails then fail
                        JOptionPane.showMessageDialog(null, ""Fill in all values first"", """", JOptionPane.ERROR_MESSAGE);
                        return false;
                    }
                }
            }
        }
        //otherwise save data
        inFile.setMol1(pqrFile1.getText());
        inFile.setMol2(pqrFile2.getText());
        inFile.setDime(new String(gridDimx.getText() + "" "" + gridDimy.getText() + "" "" + gridDimz.getText()));
        inFile.setGlen(new String(gridLen1a.getText() + "" "" + gridLen2a.getText() + "" "" + gridLen3a.getText()), 0);
        if (maxfocus > 0) {
            inFile.setGlen(new String(gridLen1b.getText() + "" "" + gridLen2b.getText() + "" "" + gridLen3b.getText()), 1);
        }
        if (maxfocus == 2) {
            inFile.setGlen(new String(gridLen1c.getText() + "" "" + gridLen2c.getText() + "" "" + gridLen3c.getText()), 2);
        }
        inFile.setIon1Charge(countIon1Charge.getText());
        inFile.setIon1Conc(countIon1Con.getText());
        inFile.setIon1Radius(countIon1Sz.getText());
        inFile.setIon2Charge(countIon2Charge.getText());
        inFile.setIon2Conc(countIon2Con.getText());
        inFile.setIon2Radius(countIon2Sz.getText());
        inFile.setProteinDi(new String(proteinDi.getText()));
        inFile.setSolventDi(new String(solventDi.getText()));
        inFile.setSrad(srad.getText());
        inFile.setSdens(sdens.getText());
        inFile.setTemp(temp.getText());
        inFile.setType(calcTypeCombo.getSelectedIndex());
        inFile.setPotential(potential.getText());
        inFile.setLmem(Lmem.getText());
        inFile.setZmem(zmem.getText());
        inFile.setMdie(membraneDi.getText());
        inFile.setIdie(idie.getText());
        inFile.setGeo1(geoFactor1.getText());
        inFile.setGeo2(geoFactor2.getText());
        inFile.setGeo3(geoFactor3.getText());
        inFile.setDrawPot(drawPot.isSelected());
        if (boundaryCondCombo.getSelectedIndex() == 2) {
            inFile.setBoundCond(new String(""mdh""));
        } else if (boundaryCondCombo.getSelectedIndex() == 1) {
            inFile.setBoundCond(new String(""sdh""));
        } else if (boundaryCondCombo.getSelectedIndex() == 0) {
            inFile.setBoundCond(new String(""zero""));
        }
        if (solMethodCombo.getSelectedIndex() == 1) {
            inFile.setSolMethod(new String(""npbe""));
        } else if (solMethodCombo.getSelectedIndex() == 0) {
            inFile.setSolMethod(new String(""lpbe""));
        }
        if (centerCombo.getSelectedIndex() == 0) {
            inFile.setCenter(new String(""0 0 0""));
        } else if (centerCombo.getSelectedIndex() == 1) {
            inFile.setCenter(new String(""mol 1""));
        }
        return true;
    }

    /**
     * Load parameters from an APBS input file into the GUI.
     * @param thedata APBS input file read into a string array by lines.
     * @param loadfocus the focus level for which to load the parameters.
     */
    private void LoadData(String[] thedata, int loadfocus) {
        //take in the first ion as #1
        boolean countion1 = true;
        for (int i = 0; i < thedata.length; i++) {
            if (thedata[i].contains(""mol pqr "")) {
                if (thedata[i - 1].contains(""mol pqr "")) {
                    if (thedata[i - 2].contains(""mol pqr "")) {
                        // there are 3 files so it must be ion solvation
                        calcTypeCombo.setSelectedIndex(1);
                    } else {
                        // there are 2 files so it must be gating charge
                        String f_temp = thedata[i].substring((thedata[i].indexOf(""mol pqr "") + 8), thedata[i].length());
                        if (f_temp.startsWith(""\""""))
                            f_temp = f_temp.substring(1, f_temp.length() - 1);
                        pqrFile2.setText(f_temp);
                        calcTypeCombo.setSelectedIndex(2);
                    }
                } else {
                    String f_temp = thedata[i].substring((thedata[i].indexOf(""mol pqr "") + 8), thedata[i].length());
                    if (f_temp.startsWith(""\""""))
                        f_temp = f_temp.substring(1, f_temp.length() - 1);
                    pqrFile1.setText(f_temp);
                    viewer.openFile(pqrFile1.getText());
                }
            } else if (thedata[i].contains(""dime "")) {
                String[] tempdime = thedata[i].substring((thedata[i].indexOf(""dime "") + 5), thedata[i].length()).split("" "");
                //if data isnt empty, set the data, else set it to blank
                if (tempdime.length > 0) {
                    gridDimx.setText(tempdime[0]);
                } else {
                    gridDimx.setText("""");
                }
                if (tempdime.length > 1) {
                    gridDimy.setText(tempdime[1]);
                } else {
                    gridDimy.setText("""");
                }
                if (tempdime.length > 2) {
                    gridDimz.setText(tempdime[2]);
                } else {
                    gridDimz.setText("""");
                }
            } else if (thedata[i].contains(""glen "")) {
                String[] tempglen = thedata[i].substring((thedata[i].indexOf(""glen "") + 5), thedata[i].length()).split("" "");
                //if data isnt empty     set the data                  else  set it to blank
                if (loadfocus == 0) {
                    if (tempglen.length > 0) {
                        gridLen1a.setText(tempglen[0]);
                    } else {
                        gridLen1a.setText("""");
                    }
                    if (tempglen.length > 1) {
                        gridLen2a.setText(tempglen[1]);
                    } else {
                        gridLen2a.setText("""");
                    }
                    if (tempglen.length > 2) {
                        gridLen3a.setText(tempglen[2]);
                    } else {
                        gridLen3a.setText("""");
                    }
                } else if (loadfocus == 1) {
                    if (tempglen.length > 0) {
                        gridLen1b.setText(tempglen[0]);
                    } else {
                        gridLen1b.setText("""");
                    }
                    if (tempglen.length > 1) {
                        gridLen2b.setText(tempglen[1]);
                    } else {
                        gridLen2b.setText("""");
                    }
                    if (tempglen.length > 2) {
                        gridLen3b.setText(tempglen[2]);
                    } else {
                        gridLen3b.setText("""");
                    }
                } else {
                    if (tempglen.length > 0) {
                        gridLen1c.setText(tempglen[0]);
                    } else {
                        gridLen1c.setText("""");
                    }
                    if (tempglen.length > 1) {
                        gridLen2c.setText(tempglen[1]);
                    } else {
                        gridLen2c.setText("""");
                    }
                    if (tempglen.length > 2) {
                        gridLen3c.setText(tempglen[2]);
                    } else {
                        gridLen3c.setText("""");
                    }
                }
            } else if (thedata[i].contains(""ion "")) {
                String[] tempion = thedata[i].substring((thedata[i].indexOf(""ion "") + 4), thedata[i].length()).split("" "");
                if (countion1) {
                    if (tempion.length > 0) {
                        countIon1Charge.setText(tempion[0]);
                    } else {
                        countIon1Charge.setText("""");
                    }
                    if (tempion.length > 1) {
                        countIon1Con.setText(tempion[1]);
                    } else {
                        countIon1Con.setText("""");
                    }
                    if (tempion.length > 2) {
                        countIon1Sz.setText(tempion[2]);
                    } else {
                        countIon1Sz.setText("""");
                    }
                    countion1 = false;
                } else {
                    if (tempion.length > 0) {
                        countIon2Charge.setText(tempion[0]);
                    } else {
                        countIon2Charge.setText("""");
                    }
                    if (tempion.length > 1) {
                        countIon2Con.setText(tempion[1]);
                    } else {
                        countIon2Con.setText("""");
                    }
                    if (tempion.length > 2) {
                        countIon2Sz.setText(tempion[2]);
                    } else {
                        countIon2Sz.setText("""");
                    }
                }
            } else if (thedata[i].contains(""pdie "")) {
                proteinDi.setText(thedata[i].substring((thedata[i].indexOf(""pdie "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""sdie "")) {
                solventDi.setText(thedata[i].substring((thedata[i].indexOf(""sdie "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""srad "")) {
                srad.setText(thedata[i].substring((thedata[i].indexOf(""srad "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""sdens "")) {
                sdens.setText(thedata[i].substring((thedata[i].indexOf(""sdens "") + 6), thedata[i].length()));
            } else if (thedata[i].contains(""temp "")) {
                temp.setText(thedata[i].substring((thedata[i].indexOf(""temp "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""mdie "")) {
                membraneDi.setText(thedata[i].substring((thedata[i].indexOf(""mdie "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""zmem "")) {
                zmem.setText(thedata[i].substring((thedata[i].indexOf(""zmem "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""lmem "")) {
                Lmem.setText(thedata[i].substring((thedata[i].indexOf(""lmem "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""memv "")) {
                potential.setText(thedata[i].substring((thedata[i].indexOf(""memv "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""idie "")) {
                idie.setText(thedata[i].substring((thedata[i].indexOf(""idie "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""geo1 "")) {
                System.out.println(thedata[i]);
                geoFactor1.setText(thedata[i].substring((thedata[i].indexOf(""geo1 "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""geo2 "")) {
                geoFactor2.setText(thedata[i].substring((thedata[i].indexOf(""geo2 "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""geo3 "")) {
                geoFactor3.setText(thedata[i].substring((thedata[i].indexOf(""geo3 "") + 5), thedata[i].length()));
            } else if (thedata[i].contains(""gcent "")) {
                String loadctr = (thedata[i].substring((thedata[i].indexOf(""gcent "") + 6), thedata[i].length()));
                if (loadctr.equals(""0 0 0"")) {
                    centerCombo.setSelectedIndex(0);
                } else if (loadctr.equals(""mol 1"")) {
                    centerCombo.setSelectedIndex(1);
                }
            } else if (thedata[i].contains(""lpbe"")) {
                solMethodCombo.setSelectedIndex(0);
            } else if (thedata[i].contains(""npbe"")) {
                solMethodCombo.setSelectedIndex(1);
            } else if (thedata[i].contains(""bcfl "")) {
                String loadbcfl = thedata[i].substring((thedata[i].indexOf(""bcfl "") + 5), thedata[i].length());
                if (loadbcfl.equals(""zero"")) {
                    boundaryCondCombo.setSelectedIndex(0);
                } else if (loadbcfl.equals(""sdh"")) {
                    boundaryCondCombo.setSelectedIndex(1);
                } else if (loadbcfl.equals(""mdh"")) {
                    boundaryCondCombo.setSelectedIndex(2);
                } else if (loadbcfl.equals(""focus"")) {
                    boundaryCondCombo.setSelectedIndex(3);
                } else if (loadbcfl.equals(""memv"")) {
                    boundaryCondCombo.setSelectedIndex(4);
                }
            }
        }
    }

    /**
     * Simple method for logging debug output to file.
     * @param msg String to write to file for debug purposes.
     */
    protected void log(String msg) {
        if (true) {
            try {
                outFile = new PrintWriter(new FileOutputStream(new File(ofile.getPath() + "".log""), true));
            } catch (Exception e1) {
                System.out.print(e1.toString());
            }
            outFile.println(msg);
            outFile.close();
        }
    }

    /**
     * Locate a file from the filesystem via the JFileChooser.
     * @return True if the file was successfully selected, otherwise false.
     */
    private boolean OpenFile() {
        File currentDir = new File(""."");
        final JFileChooser fc = new JFileChooser(currentDir);
        int returnVal = fc.showOpenDialog(theWindow);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            ofile = fc.getSelectedFile();
            //we now have a familiar file
            file_loaded = true;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Select a location and name for saving a file.
     * @param savetitle title for the JFileChooser window.
     * @return True if a file path was successfully chosen, otherwise false.
     */
    private boolean SaveDialog(String savetitle) {
        File currentDir = new File(""."");
        final JFileChooser fc = new JFileChooser(currentDir);
        fc.setDialogTitle(savetitle);
        int returnVal = fc.showSaveDialog(theWindow);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            ofile = fc.getSelectedFile();
            ofile.mkdir();
            log(ofile.getParent() + ""/"" + ofile.getName() + ""/"" + ofile.getName());
            ofile = new File(ofile.getParent() + ""/"" + ofile.getName() + ""/"" + ofile.getName());
            file_loaded = true;
            return true;
        } else {
            return false;
        }
    }

    /**
     * Delete a list of temporary files based on extension.
     * @param directory Path to the directory that contains the files.
     * @param extension File extension of the files that will be deleted.
     */
    private void deleteFiles(String directory, String extension) {
        ExtensionFilter filter = new ExtensionFilter(extension);
        File dir = new File(directory);
        String[] list = dir.list(filter);
        File todelete;
        if (list.length == 0)
            return;
        System.out.println(""Cleaning up current working directory..."");
        for (int i = 0; i < list.length; i++) {
            todelete = new File(directory, list[i]);
            System.out.println(todelete + ""  deleted: "" + todelete.delete());
        }
    }

    /**
     * Copy files based on extension
     * @param src Path to source directory.
     * @param dst Path to destination directory.
     * @param extension Extension of files to be copied.
     */
    public void copyFiles(String src, String dst, String extension) {
        ExtensionFilter filter = new ExtensionFilter(extension);
        File dir = new File(src);
        File[] list = dir.listFiles(filter);
        if (list.length == 0)
            return;
        try {
            for (int i = 0; i < list.length; i++) {
                InputStream in = new FileInputStream(list[i]);
                OutputStream out = new FileOutputStream(new File(dst + ""/"" + list[i].getName()));
                byte[] buf = new byte[1024];
                int len = 0;
                while ((len = in.read(buf)) > 0) {
                    out.write(buf, 0, len);
                }
                in.close();
                out.close();
                System.out.print(list[i].getPath() + "" copied to "" + dst);
            }
        } catch (Exception fe) {
            System.out.println(fe);
        }
    }

    private void dependencyCheck() {
        String dependencyError = """";
        //First check to make sure the commandline utilities are available
        File[] requiredFiles = new File[3];
        String osExt = """";
        //Add the .exe extension when running on windows
        if (System.getProperty(""os.name"").startsWith(""Windows"")) {
            osExt = "".exe"";
        }
        requiredFiles[0] = new File(""draw_membrane4"" + osExt);
        requiredFiles[1] = new File(""pull_comps"" + osExt);
        requiredFiles[2] = new File(""total_charge_off_2"" + osExt);
        //make sure the commandline util files exist
        for (File i : requiredFiles) {
            if (!i.exists()) {
                dependencyError += i.getName() + "" was not found in your APBSmem directory.\n"";
            }
        }
        //Now check to make sure APBS is installed and available
        try {
            ProcessBuilder pb = new ProcessBuilder();
            if (System.getProperty(""os.name"").startsWith(""Windows"")) {
                pb = new ProcessBuilder(""apbs.exe"", ""--version"");
            } else {
                pb = new ProcessBuilder(""apbs"", ""--version"");
            }
            Process pp = pb.start();
            int exitVal = pp.waitFor();
        } catch (Exception e) {
            e.printStackTrace();
            System.out.println(e.getMessage());
            dependencyError += ""Could not run APBS. Make sure it is installed and located on your path.\n"";
        }
        if (!dependencyError.equals("""")) {
            JOptionPane.showMessageDialog(null, ""One or more errors were found during startup:\n"" + dependencyError + ""\nFor more information please see the APBSmem manual."", ""Error"", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     */
    public class ExtensionFilter implements FilenameFilter {

        private String extension;

        /**
         * @param extension
         */
        public ExtensionFilter(String extension) {
            this.extension = extension;
        }

        public boolean accept(File dir, String name) {
            return (name.endsWith(extension));
        }
    }

    /**
     */
    public class SimpleAboutDialog extends JDialog {

        /**
         * A basic dialog for describing details of the software and providing contact information.
         * @param parent The APBSmem main JFrame window.
         */
        public SimpleAboutDialog(JFrame parent) {
            super(parent, ""About APBSmem"", true);
            Box b = Box.createVerticalBox();
            b.add(Box.createGlue());
            b.add(new JLabel(""APBSmem v"" + version));
            b.add(new JLabel(""Grabe Lab""));
            b.add(new JLabel(""University of Pittsburgh""));
            b.add(new JLabel(""http://mgrabe1.bio.pitt.edu/apbsmem/""));
            b.add(Box.createGlue());
            getContentPane().add(b, ""Center"");
            JPanel p2 = new JPanel();
            JButton ok = new JButton(""OK"");
            p2.add(ok);
            getContentPane().add(p2, ""South"");
            ok.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent evt) {
                    setVisible(false);
                }
            });
            setSize(300, 200);
        }
    }

    public class SimpleHelpDialog extends JDialog {

        /**
         * A basic dialog for describing details of the software and providing contact information.
         * @param parent The APBSmem main JFrame window.
         */
        public SimpleHelpDialog(JFrame parent) {
            super(parent, ""APBSmem Help"", true);
            JScrollPane jsp = new JScrollPane();
            try {
                JEditorPane jep = new JEditorPane(""http://mgrabe1.bio.pitt.edu/apbsmem/"");
                jep.setEditable(false);
                jsp.getViewport().add(jep, BorderLayout.CENTER);
            } catch (Exception e) {
                System.out.println(""couldnt load editorpane"");
            }
            JButton ok = new JButton(""OK"");
            jsp.validate();
            jsp.add(ok);
            getContentPane().add(jsp, ""South"");
            ok.addActionListener(new ActionListener() {

                public void actionPerformed(ActionEvent evt) {
                    setVisible(false);
                }
            });
            setSize(300, 200);
        }
    }
}
","// MainTest.java
package apbs_mem_gui;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.io.*;
import com.jgoodies.forms.layout.*;
import com.jgoodies.forms.builder.*;
import org.jmol.api.JmolViewer;
import org.jmol.api.JmolAdapter;
import org.jmol.popup.JmolPopup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Main}.
* It contains ten unit test cases for the {@link Main#SaveData()} method.
*/
class MainTest {","// MainTest.java
package apbs_mem_gui;

import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import java.io.*;
import com.jgoodies.forms.layout.*;
import com.jgoodies.forms.builder.*;
import org.jmol.api.JmolViewer;
import org.jmol.api.JmolAdapter;
import org.jmol.popup.JmolPopup;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Main}.
* It contains ten unit test cases for the {@link Main#SaveData()} method.
*/
class MainTest {
"
cmpl-6twgx4zMnvB6qAMfIqUS4Us2MsPQl,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/ContourAttrib.java,2.398709535598755,stop,"// ContourAttrib.java
/*
*   ContourAttrib  -- Represents attributes that may be assigned to contour paths.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This object represents the attributes assigned to a
 *      contour path.  Typically, the same attributes are
 *      assigned to all the contour paths of a given contour
 *      level.
 *  </p>
 *
 *  <p> Right now, the only attribute used is ""level"", but
 *      in the future I may add more.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  November 11, 2000
 *  @version November 17, 2000
 */
public class ContourAttrib implements Cloneable, java.io.Serializable {

    //	The level (altitude) of a contour path.
    private double level;

    /**
     *  Create a contour attribute object where only
     *  the contour level is specified.
     */
    public ContourAttrib(double level) {
        this.level = level;
    }

    /**
     *  Return the level stored in this contour attribute.
     */
    public double getLevel() {
        return level;
    }

    /**
     *  Set or change the level stored in this contour attribute.
     */
    public void setLevel(double level) {
        this.level = level;
    }

    /**
     *  Make a copy of this ContourAttrib object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        ContourAttrib newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (ContourAttrib) super.clone();
            // There is no ""deep"" data to be cloned.
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// ContourAttribTest.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourAttrib}.
* It contains ten unit test cases for the {@link ContourAttrib#clone()} method.
*/
class ContourAttribTest {","// ContourAttribTest.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourAttrib}.
* It contains ten unit test cases for the {@link ContourAttrib#clone()} method.
*/
class ContourAttribTest {

	/**
	* Test method for {@link ContourAttrib#clone()}.
	*/
	@Test
	void testClone() {
		ContourAttrib attrib = new ContourAttrib(1.0);
		ContourAttrib clone = (ContourAttrib) attrib.clone();
		assertEquals(attrib.getLevel(), clone.getLevel());
	}
	
}"
80f0db64-9257-4539-8d9e-2dc227f99bd4,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/ContourGenerator.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 13044 tokens (9044 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// ContourGenerator.java
/*
*   ContourGenerator  -- Used to generate 2D contour paths from gridded 3D data.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.util.*;

/**
 *  <p> An object used to generate a list of contour lines
 *      or paths from a set of gridded three dimensional data.
 *  </p>
 *
 *  <p> Based on contour_plot.c from NeXTcontour1.4 by Thomas H. Pulliam,
 *      pulliam@rft29.nas.nasa.gov, MS 202A-1 NASA Ames Research Center,
 *      Moffett Field, CA 94035.
 *      I don't know how the original Fortran code looked like or where it came from,
 *      other than that NeXTcontour1.4 is based on Pieter Bunings' PLOT3D package
 *      for Computational Fluid Dynamics.
 *  </p>
 *
 *  <p> Ported from C to Java by Joseph A. Huwaldt, November 16, 2000.  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  November 11, 2000
 *  @version November 23, 2000
 */
public class ContourGenerator {

    //	Debug flag.
    private static final boolean DEBUG = false;

    //	Error messages.
    private static final String kCancelMsg = ""Method ContourGenerator.getContours() canceled by user."";

    private static final String kInconsistantArrMsg = ""Inconsistant array sizes."";

    private static final String kArrSizeMsg = ""Data arrays must have more than one row or column."";

    private static final String kNegLogDataMsg = ""Function data must be > 0 for logarithmic intervals."";

    //	Path buffer size.
    private static final int kBufSize = 1000;

    //	The minimum number of points allowed in a contour path.
    private static final int kMinNumPoints = 3;

    //	A list of contour paths.
    private List pathList = new ArrayList();

    //	A flag to indicate that the contours have been computed or not.
    private boolean cCalculated = false;

    //	Data arrays used for generating the contours.
    private double[][] xArray, yArray, funcArray;

    //	Data arrays used when generating contours for 1D X & Y arrays.
    private double[] xArr1D, yArr1D;

    //	Array of contour attributes, one for each contour level.
    private ContourAttrib[] cAttr;

    //	The fraction of the task that is completed.
    private float fracComplete = 0;

    /**
     *  Used to indicate that the user wishes to cancel the calculation
     *  of contours.
     */
    private boolean isCanceled = false;

    //	Variables in the original FORTRAN program.
    private double[] pathbufxt, pathbufyt;

    private int[] pathbufia;

    //	lnstrt=1 indicates starting a new line.
    private int lnstrt;

    private int ignext;

    //	Current contour level index.
    private int icont;

    //	The current contour level.
    private double cont;

    //	i & j start and end index values.
    private int iss, iee, jss, jee;

    //	ima tells which boundary region we are on.
    private int ima;

    //	Index to last element in the IA list.
    private int iae;

    private int ibeg, jbeg;

    //	Indexes into data arrays.
    private int gi, gj;

    //	Data value at i,j in data array.
    private double fij;

    //	Indicates current direction.
    private int idir;

    //	Number of points in current contour line.
    private int np = 0;

    //	Starting point of a contour line.
    private double wx = 0, wy = 0;

    /**
     *  Construct a ContourGenerator object using the specified data arrays
     *  and the specified attribute array.  This constructor allows you
     *  to use data on an uneven X, Y grid.
     *
     *  @param  xArr   2D array containing the grid x coordinate data.
     *  @param  yArr   2D array containing the grid y coordinate data.
     *  @param  fArr   2D array containing the grid function (z) data.
     *  @param  cAttr  Array containing attributes of the contour levels.
     */
    public ContourGenerator(double[][] xArr, double[][] yArr, double[][] fArr, ContourAttrib[] cAttr) {
        //	Make sure input data is reasonable.
        if (yArr.length != xArr.length || yArr.length != fArr.length)
            throw new IllegalArgumentException(kInconsistantArrMsg);
        if (yArr[0].length != xArr[0].length || yArr[0].length != fArr[0].length)
            throw new IllegalArgumentException(kInconsistantArrMsg);
        if (xArr.length <= 1 || xArr[0].length <= 1)
            throw new IllegalArgumentException(kArrSizeMsg);
        this.cAttr = cAttr;
        xArray = xArr;
        yArray = yArr;
        funcArray = fArr;
    }

    /**
     *  Construct a ContourGenerator object using the specified data arrays
     *  and the specified attribute array.  This constructor allows you
     *  to use data on an evenly spaced grid where ""X"" values are invarient
     *  with ""Y"" and ""Y"" values are invarient with ""X"".  This often occures
     *  where the data is on an evenly spaced cartesian grid.
     *
     *  @param  xArr   1D array containing the grid x coordinate data.
     *  @param  yArr   1D array containing the grid y coordinate data.
     *  @param  fArr   2D array containing the grid function (z) data.
     *  @param  cAttr  Array containing attributes of the contour levels.
     */
    public ContourGenerator(double[] xArr, double[] yArr, double[][] fArr, ContourAttrib[] cAttr) {
        //	Make sure input data is reasonable.
        if (yArr.length != fArr.length || xArr.length != fArr[0].length)
            throw new IllegalArgumentException(kInconsistantArrMsg);
        if (xArr.length <= 1)
            throw new IllegalArgumentException(kArrSizeMsg);
        this.cAttr = cAttr;
        xArr1D = xArr;
        yArr1D = yArr;
        funcArray = fArr;
    }

    /**
     *  Construct a ContourGenerator object using the specified data arrays.
     *  Contour attributes, including the interval, are generated
     *  automatically.  This constructor allows you to use data on an
     *  uneven X, Y grid.
     *
     *  @param  xArr   2D array containing the grid x coordinate data.
     *  @param  yArr   2D array containing the grid y coordinate data.
     *  @param  fArr   2D array containing the grid function (z) data.
     *  @param  nc     The number of contour levels to generate.
     *  @param  logInterval  Uses a logarithmic contour interval if true, and
     *                       uses a linear interval if false.
     */
    public ContourGenerator(double[][] xArr, double[][] yArr, double[][] fArr, int nc, boolean logInterval) {
        //	Make sure input data is reasonable.
        if (yArr.length != xArr.length || yArr.length != fArr.length)
            throw new IllegalArgumentException(kInconsistantArrMsg);
        if (yArr[0].length != xArr[0].length || yArr[0].length != fArr[0].length)
            throw new IllegalArgumentException(kInconsistantArrMsg);
        if (xArr.length <= 1 || xArr[0].length <= 1)
            throw new IllegalArgumentException(kArrSizeMsg);
        xArray = xArr;
        yArray = yArr;
        funcArray = fArr;
        if (logInterval)
            findLogIntervals(nc);
        else
            findLinearIntervals(nc);
    }

    /**
     *  Construct a ContourGenerator object using the specified data arrays.
     *  Contour attributes, including the interval, are generated
     *  automatically.  This constructor allows you
     *  to use data on an evenly spaced grid where ""X"" values are invarient
     *  with ""Y"" and ""Y"" values are invarient with ""X"".  This often occures
     *  where the data is on an evenly spaced cartesian grid.
     *
     *  @param  xArr   1D array containing the grid x coordinate data.
     *  @param  yArr   1D array containing the grid y coordinate data.
     *  @param  fArr   2D array containing the grid function (z) data.
     *  @param  nc     The number of contour levels to generate.
     *  @param  logInterval  Uses a logarithmic contour interval if true, and
     *                       uses a linear interval if false.
     */
    public ContourGenerator(double[] xArr, double[] yArr, double[][] fArr, int nc, boolean logInterval) {
        //	Make sure input data is reasonable.
        if (yArr.length != fArr.length || xArr.length != fArr[0].length)
            throw new IllegalArgumentException(kInconsistantArrMsg);
        if (xArr.length <= 1)
            throw new IllegalArgumentException(kArrSizeMsg);
        xArr1D = xArr;
        yArr1D = yArr;
        funcArray = fArr;
        if (logInterval)
            findLogIntervals(nc);
        else
            findLinearIntervals(nc);
    }

    /**
     *  Generate the contour paths and return them as an array
     *  of ContourPath objects. If there is a lot of data, this method
     *  method may take a long time, so be patient.  Progress can be
     *  checked from another thread by calling ""getProgress()"".
     *
     *  @return An array of contour path objects.
     *  @throws InterruptedException if the user cancels this process
     *          (by calling ""cancel()"" from another thread).
     */
    public ContourPath[] getContours() throws InterruptedException {
        if (!cCalculated) {
            isCanceled = false;
            pathList.clear();
            //	Go off an compute the contour paths.
            computeContours();
            //	Now turn loose all our data arrays to be garbage collected.
            cAttr = null;
            xArray = yArray = funcArray = null;
            xArr1D = yArr1D = null;
            //	Set our ""done"" flags.
            cCalculated = true;
            fracComplete = 1;
        }
        //	Turn our pathList into an array and return the array.
        int size = pathList.size();
        ContourPath[] arr = new ContourPath[size];
        for (int i = 0; i < size; ++i) arr[i] = (ContourPath) pathList.get(i);
        return arr;
    }

    /**
     *  Returns true if the contour generation process is done.  False if it is not.
     */
    public boolean done() {
        return cCalculated;
    }

    /**
     *  Call this method to cancel the generation of contours.
     */
    public void cancel() {
        isCanceled = true;
    }

    /**
     *  Returns the progress of the currently executing contour generation
     *  process: 0.0 (just starting) to 1.0 (done).
     */
    public float getProgress() {
        return fracComplete;
    }

    /**
     *  Find contour intervals that are linearly spaced through the data.
     */
    private void findLinearIntervals(int nc) {
        //	Find min and max Z values.
        double zMin = Double.MAX_VALUE;
        double zMax = -zMin;
        int ni = funcArray.length;
        for (int i = 0; i < ni; ++i) {
            int nj = funcArray[i].length;
            for (int j = 0; j < nj; ++j) {
                double zVal = funcArray[i][j];
                zMin = Math.min(zMin, zVal);
                zMax = Math.max(zMax, zVal);
            }
        }
        //	Allocate memory for contour attribute array.
        cAttr = new ContourAttrib[nc];
        //	Determine contour levels.
        double delta = (zMax - zMin) / (nc + 1);
        for (int i = 0; i < nc; i++) {
            cAttr[i] = new ContourAttrib(zMin + (i + 1) * delta);
            if (DEBUG)
                System.out.println(""level["" + i + ""] = "" + (zMin + (i + 1) * delta));
        }
    }

    /**
     *  Find contour intervals that are logarithmically spaced through the data.
     */
    private void findLogIntervals(int nc) {
        //	Find min and max Z values.
        double zMin = Double.MAX_VALUE;
        double zMax = -zMin;
        int ni = funcArray.length;
        for (int i = 0; i < ni; ++i) {
            int nj = funcArray[i].length;
            for (int j = 0; j < nj; ++j) {
                double zVal = funcArray[i][j];
                zMin = Math.min(zMin, zVal);
                zMax = Math.max(zMax, zVal);
            }
        }
        if (zMin < 0)
            throw new IllegalArgumentException(kNegLogDataMsg);
        //	Allocate memory for contour attribute array.
        cAttr = new ContourAttrib[nc];
        //	Determine contour levels.
        double temp = Math.log(zMin);
        double delta = (Math.log(zMax) - temp) / (nc + 1);
        for (int i = 0; i < nc; i++) cAttr[i] = new ContourAttrib(Math.exp(temp + (i + 1) * delta));
    }

    /**
     *  Computes contour lines for gridded data and stores information about
     *  those contours.  The result of this routine is a list of contour lines
     *  or paths.
     */
    private void computeContours() throws InterruptedException {
        //	Number of contour levels.
        int ncont = cAttr.length;
        //	Find the number of data points in ""I"" and ""J"" directions.
        int nx = 0, ny = 0;
        if (xArray != null) {
            ny = xArray.length;
            nx = xArray[0].length;
        } else {
            nx = xArr1D.length;
            ny = yArr1D.length;
        }
        //	Allocate temporary storage space for path buffers.
        pathbufxt = new double[kBufSize];
        pathbufyt = new double[kBufSize];
        pathbufia = new int[kBufSize * 3];
        //	lnstrt=1 (line start) means we're starting a new line.
        lnstrt = 1;
        ignext = 0;
        //	Loop through each contour level.
        for (icont = 0; icont < ncont; ++icont) {
            //	Check to see if the user has canceled.
            if (isCanceled)
                throw new InterruptedException(kCancelMsg);
            //	Begin working on this contour level.
            cont = cAttr[icont].getLevel();
            iss = 1;
            iee = nx;
            jss = 1;
            jee = ny;
            boolean subDivFlg = false;
            /*L110*/
            do {
                //	Find where function increases through the contour level.
                FlagContourPassings();
                boolean L10flg = false;
                /*L210*/
                do {
                    if (!L10flg) {
                        /*	Search along the boundaries for contour line starts.
						*	IMA tells which boundary of the region we're on.
						*/
                        ima = 1;
                        ibeg = iss - 1;
                        jbeg = jss;
                    }
                    /*L6*/
                    imaLoop: do {
                        if (!L10flg) {
                            boolean imb = false;
                            boolean doneFlg = false;
                            do {
                                switch(ima) {
                                    case 1:
                                        ++ibeg;
                                        if (ibeg == iee)
                                            ima = 2;
                                        break;
                                    case 2:
                                        ++jbeg;
                                        if (jbeg == jee)
                                            ima = 3;
                                        break;
                                    case 3:
                                        --ibeg;
                                        if (ibeg == iss)
                                            ima = 4;
                                        break;
                                    case 4:
                                        --jbeg;
                                        if (jbeg == jss)
                                            ima = 5;
                                        break;
                                    case 5:
                                        continue imaLoop;
                                }
                                if (funcArray[jbeg - 1][ibeg - 1] <= cont) {
                                    imb = true;
                                    doneFlg = false;
                                } else if (imb == true)
                                    doneFlg = true;
                            } while (!doneFlg);
                            //	Got a start point.
                            //	x index of starting point.
                            gi = ibeg;
                            //	y index of starting point.
                            gj = jbeg;
                            //	z value of starting point.
                            fij = funcArray[jbeg - 1][ibeg - 1];
                            //	Round the corner if necessary.
                            /*	Look different directions to see which way the contour line
							*	went:
							*			  4
							*			1-|-3
							*			  2
							*/
                            switch(ima) {
                                case 1:
                                    Routine_L21();
                                    break;
                                case 2:
                                    if (gj != jss) {
                                        if (!Routine_L31())
                                            Routine_L21();
                                    } else
                                        Routine_L21();
                                    break;
                                case 3:
                                    if (gi != iee) {
                                        if (!Routine_L41())
                                            Routine_L21();
                                    } else {
                                        if (!Routine_L31())
                                            Routine_L21();
                                    }
                                    break;
                                case 4:
                                    if (gj != jee) {
                                        if (!Routine_L51())
                                            Routine_L21();
                                    } else {
                                        if (!Routine_L41())
                                            Routine_L21();
                                    }
                                    break;
                                case 5:
                                    if (!Routine_L51())
                                        Routine_L21();
                                    break;
                            }
                        }
                        //	end if(!L10flg)
                        //	This is the end of a contour line.  After this, we'll start a
                        //	new line.
                        L10flg = false;
                        //	Contour line start flag.
                        lnstrt = 1;
                        /*L90*/
                        ignext = 0;
                        accumContour(np, icont, pathbufxt, pathbufyt, cAttr[icont]);
                        //	If we're not done looking along the boundaries,
                        //	go look there some more.
                    } while (ima != 5);
                    //	Otherwise, get the next start out of IA.
                    /*L91*/
                    if (iae != 0) {
                        int ntmp3 = iae;
                        for (int iia = 1; iia <= ntmp3; ++iia) {
                            if (pathbufia[iia - 1] != 0) {
                                //	This is how we start in the middle of the region, using IA.
                                gi = pathbufia[iia - 1] / 1000;
                                gj = pathbufia[iia - 1] - gi * 1000;
                                fij = funcArray[gj - 1][gi - 1];
                                pathbufia[iia - 1] = 0;
                                Routine_L21();
                                L10flg = true;
                                break;
                            }
                        }
                    }
                } while (L10flg);
                /*	And if there are no more of these, we're done with this region.
				*   If we've subdivided, update the region pointers and go back for more.
				*/
                subDivFlg = false;
                if (iee == nx) {
                    if (jee != ny) {
                        jss = jee;
                        jee = ny;
                        subDivFlg = true;
                    }
                } else {
                    iss = iee;
                    iee = nx;
                    subDivFlg = true;
                }
            } while (subDivFlg);
            //	Update progress information.
            fracComplete = (float) (icont + 1) / (float) (ncont);
            //	Loop back for the next contour level.
        }
        // Next icont
        //	Turn loose temporary arrays used to generate contours.
        pathbufxt = null;
        pathbufyt = null;
        pathbufia = null;
    }

    /**
     *  Flag points in IA where the the function increases through the contour
     *  level, not including the boundaries.  This is so we have a list of at least
     *  one point on each contour line that doesn't intersect a boundary.
     */
    private void FlagContourPassings() {
        iae = 0;
        int ntmp2 = jee - 1;
        for (int j = jss + 1; j <= ntmp2; ++j) {
            boolean imb = false;
            int iaend = iae;
            int ntmp3 = iee;
            for (int i = iss; i <= ntmp3; ++i) {
                if (funcArray[j - 1][i - 1] <= cont)
                    imb = true;
                else if (imb == true) {
                    ++iae;
                    pathbufia[iae - 1] = i * 1000 + j;
                    imb = false;
                    /*  Check if the IA array is full.  If so, the subdividing
					*   algorithm goes like this:  if we've marked at least one
					*   J row, drop back to the last completed J and call that
					*   the region.  If we haven't even finished one J row, our
					*   region just extends to this I location.
					*/
                    if (iae == kBufSize * 3) {
                        if (j > jss + 1) {
                            iae = iaend;
                            jee = j;
                        } else {
                            //	Compute minimum.
                            jee = Math.min(j + 1, jee);
                            iee = i;
                        }
                        //	Break out of i & j loops.
                        return;
                    }
                }
            }
            //	Next i
        }
        //	Next j
    }

    /**
     *  This function represents the block of code in the original
     *  FORTRAN program that comes after line 21.
     */
    private void Routine_L21() {
        while (true) {
            --gi;
            if (gi < iss)
                //	Goto L90.
                return;
            idir = 1;
            if (funcArray[gj - 1][gi - 1] <= cont) {
                //	Wipe this point out of IA if it's in the list.
                /*L52*/
                if (iae != 0) {
                    int ij = gi * 1000 + gj + 1000;
                    int ntmp3 = iae;
                    for (int iia = 1; iia <= ntmp3; ++iia) {
                        if (pathbufia[iia - 1] == ij) {
                            pathbufia[iia - 1] = 0;
                            break;
                        }
                    }
                }
                doInterpolation();
                //	Goto L90.
                return;
            }
            fij = funcArray[gj - 1][gi - 1];
            //	Goto L90
            if (Routine_L31())
                return;
        }
    }

    /**
     *  This function represents the block of code in the original
     *  FORTRAN program that comes after line 31.
     */
    private boolean Routine_L31() {
        --gj;
        if (gj < jss)
            return true;
        idir = 2;
        if (funcArray[gj - 1][gi - 1] <= cont) {
            doInterpolation();
            return true;
        }
        fij = funcArray[gj - 1][gi - 1];
        return (Routine_L41());
    }

    /**
     *  This function represents the block of code in the original
     *  FORTRAN program that comes after line 41.
     */
    private boolean Routine_L41() {
        ++gi;
        if (gi > iee)
            return true;
        idir = 3;
        if (funcArray[gj - 1][gi - 1] <= cont) {
            doInterpolation();
            return true;
        }
        fij = funcArray[gj - 1][gi - 1];
        return (Routine_L51());
    }

    /**
     *  This function represents the block of code in the original
     *  FORTRAN program that comes after line 51.
     */
    private boolean Routine_L51() {
        ++gj;
        idir = 4;
        if (gj > jee)
            return true;
        if (funcArray[gj - 1][gi - 1] <= cont) {
            doInterpolation();
            return true;
        }
        fij = funcArray[gj - 1][gi - 1];
        return false;
    }

    /**
     *  Do interpolation for X, Y coordinates.
     *
     *  This function represents the block of code in the original
     *  FORTRAN program that comes after line 60.
     */
    private void doInterpolation() {
        //	Do interpolation for X,Y coordinates.
        double func = funcArray[gj - 1][gi - 1];
        double xyf = (cont - func) / (fij - func);
        /*  This tests for a contour point coinciding with a grid point.  In this case
		 *  the contour routine comes up with the same physical coordinate twice.  If
		 *  If we don't trap it, it can (in some cases significantly) increase the
		 *  number of points in a contour line.  Also, if this happens on the first
		 *  point in a line, the second point could be misinterpreted as the end of a
		 *   (circling) contour line.
		 */
        if (xyf == 0)
            ++ignext;
        double wxx = 0, wyy = 0;
        double xVal = 0, yVal = 0;
        if (xArray != null) {
            //	We have 2D arrays for the X & Y grid points.
            xVal = xArray[gj - 1][gi - 1];
            yVal = yArray[gj - 1][gi - 1];
            switch(idir) {
                case //	East
                1:
                    wxx = xVal + xyf * (xArray[gj - 1][gi + 1 - 1] - xVal);
                    wyy = yVal + xyf * (yArray[gj - 1][gi + 1 - 1] - yVal);
                    break;
                case //	North
                2:
                    wxx = xVal + xyf * (xArray[gj + 1 - 1][gi - 1] - xVal);
                    wyy = yVal + xyf * (yArray[gj + 1 - 1][gi - 1] - yVal);
                    break;
                case //	West
                3:
                    wxx = xVal + xyf * (xArray[gj - 1][gi - 1 - 1] - xVal);
                    wyy = yVal + xyf * (yArray[gj - 1][gi - 1 - 1] - yVal);
                    break;
                case //	South
                4:
                    wxx = xVal + xyf * (xArray[gj - 1 - 1][gi - 1] - xVal);
                    wyy = yVal + xyf * (yArray[gj - 1 - 1][gi - 1] - yVal);
                    break;
            }
        } else {
            //	We have 1D arrays for the X & Y grid points.
            xVal = xArr1D[gi - 1];
            yVal = yArr1D[gj - 1];
            switch(idir) {
                case //	East
                1:
                    wxx = xVal + xyf * (xArr1D[gi + 1 - 1] - xVal);
                    wyy = yVal;
                    break;
                case //	North
                2:
                    wxx = xVal;
                    wyy = yVal + xyf * (yArr1D[gj + 1 - 1] - yVal);
                    break;
                case //	West
                3:
                    wxx = xVal + xyf * (xArr1D[gi - 1 - 1] - xVal);
                    wyy = yVal;
                    break;
                case //	South
                4:
                    wxx = xVal;
                    wyy = yVal + xyf * (yArr1D[gj - 1 - 1] - yVal);
                    break;
            }
        }
        if (DEBUG) {
            System.out.println(""i, j = "" + gi + "","" + gj);
            System.out.println(""cont = "" + (float) cont + "",  fij = "" + (float) fij + "",  func = "" + (float) func + "",  xyf = "" + (float) xyf);
            System.out.println(""xVal = "" + (float) xVal + "",  yVal = "" + (float) yVal);
            System.out.println(""wxx = "" + (float) wxx + "",  wyy = "" + (float) wyy);
        }
        //	Figure out what to do with this point.
        if (lnstrt == 1) {
            //	This is the 1st point in the contour line.
            np = 1;
            pathbufxt[np - 1] = wxx;
            pathbufyt[np - 1] = wyy;
            //	Save starting point as wx, wy.
            wx = wxx;
            wy = wyy;
            //	Clear the first point flag, we've got one now.
            lnstrt = 0;
        } else {
            boolean skipFlg = false;
            //	Second point and after comes here.
            //	Add a point to this line.  Check for duplicate point first.
            if (ignext == 2) {
                if (wxx == pathbufxt[np - 1] && wyy == pathbufyt[np - 1]) {
                    ignext = 0;
                    skipFlg = true;
                } else
                    ignext = 1;
            }
            if (!skipFlg) {
                //	Increment # of points in contour.
                ++np;
                pathbufxt[np - 1] = wxx;
                pathbufyt[np - 1] = wyy;
                //	See if the temporary array xt, yt are full.
                if (np == kBufSize) {
                    accumContour(np, icont, pathbufxt, pathbufyt, cAttr[icont]);
                    //	Last point becomes 1st point to continue.
                    pathbufxt[0] = pathbufxt[np - 1];
                    pathbufyt[0] = pathbufyt[np - 1];
                    np = 1;
                }
                //	Check to see if we're back to the intial point.
                if (wxx == wx && wyy == wy)
                    return;
            }
        }
        //	Search for the next point on this line.
        /*L67*/
        switch(idir) {
            case 1:
                ++gi;
                if (!Routine_L51())
                    Routine_L21();
                break;
            case 2:
                ++gj;
                Routine_L21();
                break;
            case 3:
                --gi;
                if (!Routine_L31())
                    Routine_L21();
                break;
            case 4:
                --gj;
                if (!Routine_L41())
                    Routine_L21();
                break;
        }
        return;
    }

    /**
     *  Accumulate contour paths, as they are generated, into
     *  an overall list of contours.
     *
     *  @param  np      The number of points in the contour path buffers.
     *  @param  icont   The index to the current contour level.
     *  @param  x,y     Buffers containing x & y coordinates of contour points.
     *  @param  cAttr   The attributes for this particular contour level.
     */
    private void accumContour(int np, int icont, double[] x, double[] y, ContourAttrib cAttr) {
        //	To few points for a contour line.
        if (np < kMinNumPoints)
            return;
        //	Copy over coordinate points from buffers to their own arrays.
        double[] xArr = new double[np];
        double[] yArr = new double[np];
        System.arraycopy(x, 0, xArr, 0, np);
        System.arraycopy(y, 0, yArr, 0, np);
        //	Create a new contour path and add it to the list.
        ContourPath path = new ContourPath(cAttr, icont, xArr, yArr);
        pathList.add(path);
    }
}
","// ContourGeneratorTest.java
package jahuwaldt.plot;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourGenerator}.
* It contains ten unit test cases for the {@link ContourGenerator#done()} method.
*/
class ContourGeneratorTest {","// ContourGeneratorTest.java
package jahuwaldt.plot;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourGenerator}.
* It contains ten unit test cases for the {@link ContourGenerator#done()} method.
*/
class ContourGeneratorTest {
"
cmpl-6twiyzDnQ2xyGKPoD6FU2TpHwdCdD,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/ContourPath.java,4.429589509963989,stop,"// ContourPath.java
/*
*   ContourPath  -- Represents a single 2D contour line or path.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This object represents a single contour line or
 *      path and all the data that is associated with
 *      it.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  November 11, 2000
 *  @version November 17, 2000
 */
public class ContourPath implements Cloneable, java.io.Serializable {

    //	Tolerance for path closure.
    private static final double kSmallX = 0.001;

    private static final double kSmallY = kSmallX;

    //	X & Y coordinate arrays.
    private double[] xArr, yArr;

    //	The level index for this contour path.
    private int levelIndex;

    //	Indicates if this path is open or closed.
    private boolean closed = false;

    //	The attributes assigned to this contour level.
    private ContourAttrib attributes;

    /**
     *  Construct a contour path or line using the given arrays
     *  of X & Y values.
     *
     *  @param  attr       Attributes assigned to this contour path.
     *  @param  levelIndex The index to then level this path belongs to.
     *  @param  x          Array of X coordinate values.
     *  @param  y          Array of Y coordinate values.
     */
    public ContourPath(ContourAttrib attr, int levelIndex, double[] x, double[] y) {
        xArr = x;
        yArr = y;
        this.levelIndex = levelIndex;
        attributes = attr;
        int np = xArr.length;
        //	Determine if the contour path is open or closed.
        if (Math.abs(x[0] - x[np - 1]) < kSmallX && Math.abs(y[0] - y[np - 1]) < kSmallY) {
            closed = true;
            //	Guarantee closure.
            x[np - 1] = x[0];
            //	Guarantee closure.
            y[np - 1] = y[0];
        } else
            //	Contour not closed.
            closed = false;
    }

    /**
     *  Return the X coordinate values for this contour path.
     */
    public double[] getAllX() {
        return xArr;
    }

    /**
     *  Return the Y coordinate values for this contour path.
     */
    public double[] getAllY() {
        return yArr;
    }

    /**
     *  Return the level index for this contour path.  The level index
     *  is an index to the level that this path belongs to:  the i'th level.
     */
    public int getLevelIndex() {
        return levelIndex;
    }

    /**
     *  Return the attributes assigned to this contour path.
     */
    public ContourAttrib getAttributes() {
        return attributes;
    }

    /**
     *  Returns true if this contour path is closed (loops back
     *  on itself) or false if it is not.
     */
    public boolean isClosed() {
        return closed;
    }

    /**
     *  Make a copy of this ContourPath object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        ContourPath newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (ContourPath) super.clone();
            // There is no ""deep"" data to be cloned.
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// ContourPathTest.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourPath}.
* It contains ten unit test cases for the {@link ContourPath#clone()} method.
*/
class ContourPathTest {","// ContourPathTest.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourPath}.
* It contains ten unit test cases for the {@link ContourPath#clone()} method.
*/
class ContourPathTest {

	/**
	* Test method for {@link ContourPath#clone()}.
	*/
	@Test
	void testClone() {
		ContourPath path = new ContourPath(new ContourAttrib(), 0, new double[] {1.0, 2.0, 3.0}, new double[] {4.0, 5.0, 6.0});
		ContourPath clone = (ContourPath) path.clone();
		assertNotSame(path, clone);
		assertArrayEquals(path.getAllX(), clone.getAllX());
		assertArrayEquals(path.getAllY(), clone.getAllY());
		assertEquals(path.getLevelIndex(), clone.getLevelIndex());
		assertEquals(path.isClosed(), clone.isClosed());
		assertEquals(path.getAttributes(), clone.getAttributes());
	}
	
}"
cmpl-6twk1YTRxWY4MvhrQQNSJivLtgKm5,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/ContourPlot.java,88.47604632377625,length,"// ContourPlot.java
/*
*   ContourPlot  -- A simple 2D contour plot of gridded 3D data.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.text.NumberFormat;

/**
 *  <p> An object that represents a simple 2D contour plot
 *      of 3D data.
 *  </p>
 *  <p> Grid styles, axis formats, and axis labels can
 *      be changed by accessing this object's axes and
 *      making the changes there.  Then call repaint()
 *      on the component containing this plot.
 *  </p>
 *  <p> This object's run list contains the contour lines
 *      being plotted.  Each run represents a contour level.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  November 12, 2000
 *  @version November 20, 2000
 */
public class ContourPlot extends SimplePlotXY {

    //	Debug flag.
    private static final boolean DEBUG = false;

    //	The contour paths displayed in this plot.
    private ContourPath[] paths = null;

    //-------------------------------------------------------------------------
    /**
     *  Only subclasses can access the default constructor.
     */
    protected ContourPlot() {
    }

    /**
     *  Creates an contour plot of the specified gridded, 3D, data.
     *
     *  @param  xArr     A 2D array of X coordinate values.
     *  @param  yArr     A 2D array of Y coordinate values.
     *  @param  zArr     A 2D array of Z coordinate values.
     *  @param  nc       The number of contour levels to plot.
     *  @param  intType  Indicates if the intervals should be log (true),
     *                   or linear (false).
     *  @param  title    The title to be displayed across the top
     *                   of the plot.
     *  @param  xLabel   The label to be displayed along the X-axis.
     *  @param  yLabel   The label to be displayed along the Y-axis.
     *  @param  xFormat  The number format to be used for the X axis
     *                   tick mark labels.
     *  @param  yFormat  The number format to be used for the Y axis
     *                   tick mark labels.
     */
    public ContourPlot(double[][] xArr, double[][] yArr, double[][] zArr, int nc, boolean intType, String title, String xLabel, String yLabel, NumberFormat xFormat, NumberFormat yFormat) {
        this.setTitle(title);
        createPlot(xArr, yArr, zArr, xLabel, yLabel, xFormat, yFormat, nc, intType);
    }

    private void createPlot(double[][] xArr, double[][] yArr, double[][] zArr, String xLabel, String yLabel, NumberFormat xFormat, NumberFormat yFormat, int nc, boolean logIntervals) {
        try {
            //	Generate the contours.
            ContourGenerator cg = new ContourGenerator(xArr, yArr, zArr, nc, logIntervals);
            paths = cg.getContours();
            int npaths = paths.length;
            if (DEBUG) {
                System.out.println(""Number of contours = "" + nc);
                System.out.println(""Number of contour paths = "" + npaths);
            }
            //	Get this plots list of runs.
            PlotRunList runs = this.getRuns();
            runs.clear();
            //	Create an empty run for each contour level.
            for (int i = 0; i < nc; ++i) runs.add(new PlotRun());
            //	Loop over all the contour paths, adding them to the appropriate
            //	contour level.
            for (int j = 0; j < npaths; ++j) {
                //	Retrieve the contour path data.
                double[] xData = paths[j].getAllX();
                double[] yData = paths[j].getAllY();
                int levelIndex = paths[j].getLevelIndex();
                if (DEBUG) {
                    System.out.println();
                    System.out.println(""LevelIdx = "" + levelIndex);
                }
                //	Retrieve the appropriate run.
                PlotRun run = (PlotRun) runs.get(levelIndex);
                //	Add this path the the retrieved run, one data point at a time.
                int numPoints = xData.length;
                for (int i = 0; i < numPoints; ++i) {
                    run.add(new PlotDatum(xData[i], yData[i], i != 0));
                    if (DEBUG)
                        System.out.println(""X = "" + (float) xData[i] + "",  Y = "" + (float) yData[i]);
                }
            }
        } catch (InterruptedException e) {
            //	Shouldn't be possible here.
            e.printStackTrace();
        }
        //	Create our plot axes and add them to this plot.
        PlotAxis axis = new PlotXAxis(xLabel, null, xFormat, PlotAxis.kMajorGrid);
        this.setHorizontalAxis(axis);
        axis = new PlotYAxis(yLabel, null, yFormat, PlotAxis.kMajorGrid);
        this.setVerticalAxis(axis);
    }

    /**
     *  Colorize the contours by linearly interpolating between
     *  the specified colors for this plot's range of contour levels.
     */
    public void colorizeContours(Color lowColor, Color highColor) {
        //	Find the range of levels in the contours.
        double minLevel = Double.MAX_VALUE;
        double maxLevel = -minLevel;
        int npaths = paths.length;
        for (int i = 0; i < npaths; ++i) {
            double level = paths[i].getAttributes().getLevel();
            minLevel = Math.min(minLevel, level);
            maxLevel = Math.max(maxLevel, level);
        }
        //	Now assign the colors.
        PlotRunList runs = getRuns();
        for (int i = 0; i < npaths; ++i) {
            //	Extract contour path information.
            double level = paths[i].getAttributes().getLevel();
            int levelIndex = paths[i].getLevelIndex();
            //	Retrieve the appropriate run.
            PlotRun run = (PlotRun) runs.get(levelIndex);
            //	Colorize the run.
            run.setLineColor(interpColors(lowColor, highColor, minLevel, maxLevel, level));
        }
    }

    /**
     *  Interpolate the colors for the contour level.
     */
    private Color interpColors(Color lowColor, Color highColor, double minLevel, double maxLevel, double level) {
        level -= minLevel;
        double range = maxLevel - minLevel;
        double temp = range - level;
        Color color = new Color((int) ((temp * lowColor.getRed() + level * highColor.getRed()) / range), (int) ((temp * lowColor.getGreen() + level * highColor.getGreen()) / range), (int) ((temp * lowColor.getBlue() + level * highColor.getBlue()) / range));
        return color;
    }

    /**
     *  Make a copy of this ContourPlot object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        ContourPlot newObject = null;
        // Make a shallow copy of this object.
        newObject = (ContourPlot) super.clone();
        // Make a copy of this object's data structures.
        int length = this.paths.length;
        newObject.paths = new ContourPath[length];
        for (int i = 0; i < length; ++i) newObject.paths[i] = (ContourPath) this.paths[i].clone();
        // Output the newly cloned object.
        return newObject;
    }
}
","// ContourPlotTest.java
package jahuwaldt.plot;

import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.text.NumberFormat;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourPlot}.
* It contains ten unit test cases for the {@link ContourPlot#clone()} method.
*/
class ContourPlotTest {","// ContourPlotTest.java
package jahuwaldt.plot;

import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.text.NumberFormat;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ContourPlot}.
* It contains ten unit test cases for the {@link ContourPlot#clone()} method.
*/
class ContourPlotTest {

	/**
	* Test method for {@link ContourPlot#clone()}.
	*/
	@Test
	public void testClone() {
		ContourPlot plot = new ContourPlot();
		ContourPlot clone = (ContourPlot) plot.clone();
		assertNotSame(plot, clone);
		assertEquals(plot.getTitle(), clone.getTitle());
		assertEquals(plot.getHorizontalAxis().getLabel(), clone.getHorizontalAxis().getLabel());
		assertEquals(plot.getVerticalAxis().getLabel(), clone.getVerticalAxis().getLabel());
		assertEquals(plot.getRuns().size(), clone.getRuns().size());
		assertEquals(plot.getRuns().get(0).getLineColor(), clone.getRuns().get(0).getLineColor());
		assertEquals(plot.getRuns().get(0).getLineStyle(), clone.getRuns().get(0).getLineStyle());
		assertEquals(plot.getRuns().get(0).getLineWidth(), clone.getRuns().get(0).getLineWidth());
		assertEquals(plot.getRuns().get(0).getMarker(), clone.getRuns().get(0).getMarker());
		assertEquals(plot.getRuns().get(0).getMarkerColor(), clone.getRuns().get(0).getMarkerColor());
		assertEquals(plot.getRuns().get(0).getMarkerSize(), clone.getRuns().get(0).getMarkerSize());
		assertEquals(plot.getRuns().get(0).getMarkerStyle(), clone.getRuns().get(0).getMarkerStyle());
		assertEquals(plot.getRuns().get(0).getMarkerStroke(), clone.getRuns().get(0).getMarkerStroke());
		assertEquals(plot.getRuns().get(0).getMarkerStrokeColor(), clone.getRuns().get(0).getMarkerStrokeColor());
		assertEquals(plot.getRuns().get(0).getMarkerStrokeWidth(), clone.getRuns().get(0).getMarkerStrokeWidth());
		assertEquals(plot.getRuns().get(0).getMarkerStrokeDash(), clone.getRuns().get(0).getMarkerStrokeDash());
		assertEquals(plot.getRuns().get(0).getMarkerStrokeDashPhase(), clone.getRuns().get(0).getMarkerStrokeDashPhase());
		assertEquals(plot.getRuns().get(0).getMarkerFill(), clone.getRuns().get(0).getMarkerFill());
		assertEquals(plot.getRuns().get(0).getMarkerFillColor(), clone.getRuns().get(0).getMarkerFillColor());
		assertEquals(plot.getRuns().get(0).getMarkerFillGradient(), clone.getRuns().get(0).getMarkerFillGradient());
		assertEquals(plot.getRuns().get(0).getMarkerFillGradientColor(), clone.getRuns().get(0).getMarkerFillGradientColor());
		assertEquals(plot.getRuns().get(0).getMarkerFillGradientOffset(), clone.getRuns().get(0).getMarkerFillGradientOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillGradientFractions(), clone.getRuns().get(0).getMarkerFillGradientFractions());
		assertEquals(plot.getRuns().get(0).getMarkerFillGradientCycleMethod(), clone.getRuns().get(0).getMarkerFillGradientCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillGradientTransform(), clone.getRuns().get(0).getMarkerFillGradientTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImage(), clone.getRuns().get(0).getMarkerFillImage());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageOpacity(), clone.getRuns().get(0).getMarkerFillImageOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageTransform(), clone.getRuns().get(0).getMarkerFillImageTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageAnchor(), clone.getRuns().get(0).getMarkerFillImageAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageRotation(), clone.getRuns().get(0).getMarkerFillImageRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageScale(), clone.getRuns().get(0).getMarkerFillImageScale());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageOffset(), clone.getRuns().get(0).getMarkerFillImageOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageCycleMethod(), clone.getRuns().get(0).getMarkerFillImageCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColor(), clone.getRuns().get(0).getMarkerFillImageColor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorOpacity(), clone.getRuns().get(0).getMarkerFillImageColorOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorTransform(), clone.getRuns().get(0).getMarkerFillImageColorTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorAnchor(), clone.getRuns().get(0).getMarkerFillImageColorAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorRotation(), clone.getRuns().get(0).getMarkerFillImageColorRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorScale(), clone.getRuns().get(0).getMarkerFillImageColorScale());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorOffset(), clone.getRuns().get(0).getMarkerFillImageColorOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorCycleMethod(), clone.getRuns().get(0).getMarkerFillImageColorCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImage(), clone.getRuns().get(0).getMarkerFillImageColorImage());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageOpacity(), clone.getRuns().get(0).getMarkerFillImageColorImageOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageTransform(), clone.getRuns().get(0).getMarkerFillImageColorImageTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageAnchor(), clone.getRuns().get(0).getMarkerFillImageColorImageAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageRotation(), clone.getRuns().get(0).getMarkerFillImageColorImageRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageScale(), clone.getRuns().get(0).getMarkerFillImageColorImageScale());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageOffset(), clone.getRuns().get(0).getMarkerFillImageColorImageOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageCycleMethod(), clone.getRuns().get(0).getMarkerFillImageColorImageCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColor(), clone.getRuns().get(0).getMarkerFillImageColorImageColor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorOpacity(), clone.getRuns().get(0).getMarkerFillImageColorImageColorOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorTransform(), clone.getRuns().get(0).getMarkerFillImageColorImageColorTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorAnchor(), clone.getRuns().get(0).getMarkerFillImageColorImageColorAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorRotation(), clone.getRuns().get(0).getMarkerFillImageColorImageColorRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorScale(), clone.getRuns().get(0).getMarkerFillImageColorImageColorScale());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorOffset(), clone.getRuns().get(0).getMarkerFillImageColorImageColorOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorCycleMethod(), clone.getRuns().get(0).getMarkerFillImageColorImageColorCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImage(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImage());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageOpacity(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageTransform(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageAnchor(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageRotation(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageScale(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageScale());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageOffset(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageCycleMethod(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColor(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorOpacity(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorTransform(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorAnchor(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorRotation(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorScale(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorScale());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorOffset(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorCycleMethod(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImage(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImage());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageOpacity(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageTransform(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageAnchor(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageRotation(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageScale(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageScale());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageOffset(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageOffset());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageCycleMethod(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageCycleMethod());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColor(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorOpacity(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorOpacity());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorTransform(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorTransform());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorAnchor(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorAnchor());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorRotation(), clone.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorRotation());
		assertEquals(plot.getRuns().get(0).getMarkerFillImageColorImageColorImageColorImageColorScale(), clone.getRuns().get("
cmpl-6twlRvbCE3SnL7iJEQAxrBMMhG4Qj,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_0Test.java,90.43878507614136,length,"// LinearAxisScale.java
/*
*   LinearAxisScale  -- Provides linear axis scaling for plot axes.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This object provides linear scaling for plot axes.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version January 10, 2001
 */
public class LinearAxisScale extends Object implements PlotAxisScale {

    //	Debug flag.
    private static final boolean DEBUG = false;

    /**
     *  The transformation function used to scale the data
     *  plotted against this axis.
     *  This axis uses a linear scaling function:  f(a) = a.
     */
    public final double func(double a) {
        return a;
    }

    /**
     *  Method that returns the default lower bounds for
     *  this axis scale.  Returns -1.0.
     */
    public double lowerBounds() {
        return -1.0;
    }

    /**
     *  Method that returns the default upper bounds for
     *  this axis scale.  Returns 1.0.
     */
    public double upperBounds() {
        return 1.0;
    }

    /**
     *  Method that returns an AxisLimitData object that contains
     *  the preferred axis limits and tick mark spacing for the
     *  specified range of data values for this linear axis scale.
     *
     *  @param  aLB  The lower bounds of the data plotted on this axis.
     *  @param  aUB  The upper bounds of the data plotted on this axis.
     */
    public AxisLimitData findGoodLimits(double aLB, double aUB) {
        //	The lower limit and tick mark spacing being calculated.
        double s = 0., r = 0.;
        //	Make sure we don't have a degenerate case.
        if (Math.abs(aUB - aLB) <= 0.000001) {
            if (aUB > 0.) {
                aUB = 2. * aUB;
                aLB = 0.;
            } else if (aLB < 0) {
                aLB = 2. * aLB;
                aUB = 0.;
            }
            if (Math.abs(aUB - aLB) <= 0.000001) {
                aLB = lowerBounds();
                aUB = upperBounds();
            }
        }
        if (DEBUG) {
            System.out.println(""In findGoodLimits()..."");
            System.out.println(""   aLB = "" + aLB + "", aUB = "" + aUB);
        }
        //	Object used to return results.
        AxisLimitData limData = new AxisLimitData();
        boolean done = false;
        while (!done) {
            done = true;
            double ub = aUB;
            double lb = aLB;
            double delta = ub - lb;
            //	Scale up by s, a power of 10, so range (delta) exceeds 1.
            s = 1.;
            while (delta * s < 10.) s *= 10.;
            //	Find power of 10 quantum, r, such that delta/10 <= r < delta.
            r = 1. / s;
            while (10. * r < delta) r *= 10.;
            //	Set r=(1,2,5)*10**n so that 3-5 quanta cover range.
            if (r >= delta / 2.)
                r /= 2.;
            else if (r < delta / 5.)
                r *= 2.;
            limData.ub = modceil(ub, r);
            limData.lb = modfloor(lb, r);
            //	If lower bound is <= r and > 0, then repeat.
            if (limData.lb <= r && limData.lb > 0.) {
                aLB = 0.;
                done = false;
                //	If upper bound >= -r and < 0, then repeat.
            } else if (limData.ub >= -r && limData.ub < 0.) {
                aUB = 0.;
                done = false;
            }
        }
        //	Save off tick mark spacing.
        limData.quantum = r;
        if (DEBUG) {
            System.out.println(""    limData.lb = "" + limData.lb + "", limData.ub = "" + limData.ub + "", limData.quantum = "" + limData.quantum);
        }
        return limData;
    }

    /**
     *  Find the position and size (in screen coordinates) of tick
     *  marks for a given axis scale.
     *
     *  @param  quantum   Tick mark step size for the axis using this scale.
     *  @param  aLB       Lower bounds of axis using this scale.
     *  @param  aUB       Upper bounds of axis using this scale.
     *  @param  xA        Scaling coefficient for this axis.
     *  @param  xB        Scaling coefficient for this axis.
     *  @return An TickMarkData object containing the tick mark positions, lengths,
     *          and data values at each tick mark.
     */
    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {
        double xl = 0;
        double xu = 0;
        double q = quantum;
        if (q > 0.) {
            xl = modfloor(aLB, q);
            xu = modfloor(aUB - q / 10., q / 5.) + q / 10.;
        } else {
            xl = modfloor(aUB, q);
            xu = modfloor(aLB + q / 10., q / 5.) - q / 10.;
        }
        //	Determine the number of tick marks.
        int xn = (int) ((xu - xl) / (Math.abs(quantum) / 5.));
        if (DEBUG) {
            System.out.println(""In calcTickMarks()..."");
            System.out.println(""    quantum = "" + quantum + "", aLB = "" + aLB + "", aUB = "" + aUB);
            System.out.println(""    xA = "" + xA + "", xB = "" + xB);
            System.out.println(""    xl = "" + xl + "", xu = "" + xu);
            System.out.println(""    xn = "" + xn);
        }
        //	Allocate memory for tick mark arrays.
        int[] mark = new int[xn];
        int[] lmark = new int[xn];
        float[] markValue = new float[xn];
        xn = 0;
        int i = 0;
        for (double x = xl; x <= xu; x += Math.abs(quantum) / 5., ++i) {
            //	Bounds check.
            if (q > 0.)
                if (x <= aLB || x >= aUB)
                    continue;
            if (q < 0.)
                if (x >= aLB || x <= aUB)
                    continue;
            //	Store tick mark.
            mark[xn] = (int) (func(x) * xA + xB);
            markValue[xn] = (float) x;
            if (i % 5 != 0)
                //	Minor tick mark.
                lmark[xn++] = PlotAxis.kTick;
            else
                //	Major tick mark.
                lmark[xn++] = 3 * PlotAxis.kTick;
        }
        if (DEBUG) {
            System.out.println(""Tick mark values:"");
            int length = markValue.length;
            for (i = 0; i < length; ++i) System.out.print(""   "" + markValue[i]);
            System.out.println();
        }
        //	Create a tick mark data object and pass it out.
        TickMarkData data = new TickMarkData();
        data.mark = mark;
        data.lmark = lmark;
        data.markValue = markValue;
        return data;
    }

    /**
     *  Adjust the upper and lower axis bounds, if necissary, to allow
     *  room for error bars on the specified data point.  New bounds
     *  returned in ""output"" object.
     *
     *  @param datum  The data point we are bounds checking.
     *  @param aUB    The current upper bounds.
     *  @param aLB    The current lower bounds.
     *  @param output An AxisLimitData structure for passing the new upper and
     *                lower bounds to the calling routine.
     */
    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {
        double temp = datum.getYError();
        aLB = Math.min(aLB, datum.y - temp);
        aUB = Math.max(aUB, datum.y + temp);
        output.lb = aLB;
        output.ub = aUB;
    }

    private double modceil(double f, double t) {
        t = Math.abs(t);
        return (Math.ceil(f / t) * t);
    }

    private double modfloor(double f, double t) {
        t = Math.abs(t);
        return (Math.floor(f / t) * t);
    }
}
","// LinearAxisScale_0Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#func(double)} method.
*/
class LinearAxisScale_0Test {","// LinearAxisScale_0Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#func(double)} method.
*/
class LinearAxisScale_0Test {

	/**
	* Test method for {@link LinearAxisScale#func(double)}.
	*/
	@Test
	void testFunc() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		assertEquals(0.0, linearAxisScale.func(0.0));
		assertEquals(1.0, linearAxisScale.func(1.0));
		assertEquals(2.0, linearAxisScale.func(2.0));
		assertEquals(3.0, linearAxisScale.func(3.0));
		assertEquals(4.0, linearAxisScale.func(4.0));
		assertEquals(5.0, linearAxisScale.func(5.0));
		assertEquals(6.0, linearAxisScale.func(6.0));
		assertEquals(7.0, linearAxisScale.func(7.0));
		assertEquals(8.0, linearAxisScale.func(8.0));
		assertEquals(9.0, linearAxisScale.func(9.0));
	}
	
}

// LinearAxisScale_1Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#lowerBounds()} method.
*/
class LinearAxisScale_1Test {
		
	/**
	* Test method for {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	void testLowerBounds() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		assertEquals(-1.0, linearAxisScale.lowerBounds());
	}
	
}

// LinearAxisScale_2Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#upperBounds()} method.
*/
class LinearAxisScale_2Test {
		
	/**
	* Test method for {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	void testUpperBounds() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		assertEquals(1.0, linearAxisScale.upperBounds());
	}
	
}

// LinearAxisScale_3Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#findGoodLimits(double, double)} method.
*/
class LinearAxisScale_3Test {
		
	/**
	* Test method for {@link LinearAxisScale#findGoodLimits(double, double)}.
	*/
	@Test
	void testFindGoodLimits() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		AxisLimitData axisLimitData = linearAxisScale.findGoodLimits(0.0, 0.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(1.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 1.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(2.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 2.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(3.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 3.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(4.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 4.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(5.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 5.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(6.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 6.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(7.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 7.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(8.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 8.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(9.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
		axisLimitData = linearAxisScale.findGoodLimits(0.0, 9.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(10.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
	}
	
}

// LinearAxisScale_4Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
*/
class LinearAxisScale_4Test {
		
	/**
	* Test method for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)}.
	*/
	@Test
	void testCalcTickMarks() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		TickMarkData tickMarkData = linearAxisScale.calcTickMarks(0.0, 0.0, 0.0, 0.0, 0.0);
		assertEquals(0, tickMarkData.mark.length);
		assertEquals(0, tickMarkData.lmark.length);
		assertEquals(0, tickMarkData.markValue.length);
		tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 1.0, 1.0, 0.0);
		assertEquals(1, tickMarkData.mark.length);
		assertEquals(1, tickMarkData.lmark.length);
		assertEquals(1, tickMarkData.markValue.length);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(3, tickMarkData.lmark[0]);
		assertEquals(0.0f, tickMarkData.markValue[0]);
		tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 2.0, 1.0, 0.0);
		assertEquals(2, tickMarkData.mark.length);
		assertEquals(2, tickMarkData.lmark.length);
		assertEquals(2, tickMarkData.markValue.length);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(3, tickMarkData.lmark[0]);
		assertEquals(0.0f, tickMarkData.markValue[0]);
		assertEquals(1, tickMarkData.mark[1]);
		assertEquals(3, tickMarkData.lmark[1]);
		assertEquals(1.0f, tickMarkData.markValue[1]);
		tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 3.0, 1.0, 0.0);
		assertEquals(3, tickMarkData.mark.length);
		assertEquals(3, tickMarkData.lmark.length);
		assertEquals(3, tickMarkData.markValue.length);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(3, tickMarkData.lmark[0]);
		assertEquals(0.0f, tickMarkData.markValue[0]);
		assertEquals(1, tickMarkData.mark[1]);
		assertEquals(3, tickMarkData.lmark[1]);
		assertEquals(1.0f, tickMarkData.markValue[1]);
		assertEquals(2, tickMarkData.mark[2]);
		assertEquals(3, tickMarkData.lmark[2]);
		assertEquals(2.0f, tickMarkData.markValue[2]);
		tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 4.0, 1.0, 0.0);
		assertEquals(4, tickMarkData.mark.length);
		assertEquals(4, tickMarkData.lmark.length);
		assertEquals(4, tickMarkData.markValue.length);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(3, tickMarkData.lmark[0]);
		assertEquals(0.0f, tickMarkData.markValue[0]);
		assertEquals(1, tickMarkData.mark[1]);
		assertEquals(3, tickMarkData.lmark[1]);
		assertEquals(1.0f, tickMarkData.markValue[1]);
		assertEquals(2, tickMarkData.mark[2]);
		assertEquals(3, tickMarkData.lmark[2]);
		assertEquals(2.0f, tickMarkData.markValue[2]);
		assertEquals(3, tickMarkData.mark[3]);
		assertEquals(3, tickMarkData.lmark[3]);
		assertEquals(3.0f, tickMarkData.markValue[3]);
		tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 5.0, 1.0, 0.0);
		assertEquals(5, tickMarkData.mark.length);
		assertEquals(5, tickMarkData.lmark.length);
		assertEquals(5, tickMarkData.markValue.length);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(3, tickMarkData.lmark[0]);
		assertEquals(0.0f, tickMarkData.markValue[0]);
		assertEquals(1, tickMarkData.mark[1]);
		assertEquals(3, tickMarkData.lmark[1]);
		assertEquals(1.0f, tickMarkData.markValue[1]);
		assertEquals(2, tickMarkData.mark[2]);
		assertEquals(3, tickMarkData.lmark[2]);
		assertEquals(2.0f, tickMarkData.markValue[2]);
		assertEquals(3, tickMarkData.mark[3]);
		assertEquals(3, tickMarkData.lmark[3]);
		assertEquals(3.0f, tickMarkData.markValue[3]);
		assertEquals(4, tickMarkData.mark[4]);
		assertEquals(3, tickMarkData.lmark[4]);
		assertEquals(4.0f, tickMarkData.markValue[4]);
		tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 6.0, 1.0, 0.0);
		assertEquals(6, tickMarkData.mark.length);
		assertEquals(6, tickMarkData.lmark.length);
		assertEquals(6, tickMarkData.markValue.length);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(3, tickMarkData.lmark[0]);
		assertEquals(0.0f, tickMarkData.markValue[0]);
		assertEquals(1, tickMarkData.mark[1]);
		assertEquals(3, tickMarkData.lmark[1]);
		assertEquals(1.0f, tickMarkData.markValue[1]);
		assertEquals(2, tickMarkData.mark[2]);
		assertEquals(3, tickMarkData.lmark[2]);
		assertEquals(2.0f, tickMarkData.markValue[2]);
		assertEquals(3, tickMarkData.mark[3]);
		assertEquals(3, tickMarkData.lmark[3]);
		assertEquals(3.0f, tickMarkData.markValue[3]);
		assertEquals(4, tickMarkData.mark[4]);
		assertEquals(3, tickMarkData.lmark[4]);
		assertEquals(4.0f, tickMarkData.markValue[4]);
		assertEquals(5, tickMarkData.mark[5]);
		assertEquals(3, tickMarkData.lmark[5]);
		assertEquals(5.0f, tickMarkData.markValue[5]);
		tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 7.0, 1.0, 0.0);
		assertEquals(7, tickMarkData.mark.length);
		assertEquals(7, tickMarkData.lmark.length);
		assertEquals(7, tickMarkData.markValue.length);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(3, tickMarkData.lmark[0]);
		assertEquals(0.0f, tickMarkData.markValue[0]);
		assertEquals(1, tickMarkData.mark[1]);
		assertEquals(3, tickMarkData.lmark[1]);
		assertEquals(1.0f, tickMarkData.markValue[1]);
		assertEquals(2, tickMarkData.mark[2]);
		assertEquals(3, tickMarkData.lmark[2]);
		assertEquals(2.0f, tickMarkData.markValue[2]);
		assertEquals(3, tickMarkData.mark[3]);
		assertEquals(3, tickMarkData.lmark[3]);
		assertEquals(3.0f, tickMarkData.markValue[3]);
		assertEquals(4, tickMarkData.mark[4]);
		assertEquals(3, tickMarkData.lmark[4]);"
cmpl-6twmu5xGY5SrZ5PnvI1yQFSbi0XR5,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_1Test.java,96.76780414581299,length,"// LinearAxisScale.java
/*
*   LinearAxisScale  -- Provides linear axis scaling for plot axes.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This object provides linear scaling for plot axes.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version January 10, 2001
 */
public class LinearAxisScale extends Object implements PlotAxisScale {

    //	Debug flag.
    private static final boolean DEBUG = false;

    /**
     *  The transformation function used to scale the data
     *  plotted against this axis.
     *  This axis uses a linear scaling function:  f(a) = a.
     */
    public final double func(double a) {
        return a;
    }

    /**
     *  Method that returns the default lower bounds for
     *  this axis scale.  Returns -1.0.
     */
    public double lowerBounds() {
        return -1.0;
    }

    /**
     *  Method that returns the default upper bounds for
     *  this axis scale.  Returns 1.0.
     */
    public double upperBounds() {
        return 1.0;
    }

    /**
     *  Method that returns an AxisLimitData object that contains
     *  the preferred axis limits and tick mark spacing for the
     *  specified range of data values for this linear axis scale.
     *
     *  @param  aLB  The lower bounds of the data plotted on this axis.
     *  @param  aUB  The upper bounds of the data plotted on this axis.
     */
    public AxisLimitData findGoodLimits(double aLB, double aUB) {
        //	The lower limit and tick mark spacing being calculated.
        double s = 0., r = 0.;
        //	Make sure we don't have a degenerate case.
        if (Math.abs(aUB - aLB) <= 0.000001) {
            if (aUB > 0.) {
                aUB = 2. * aUB;
                aLB = 0.;
            } else if (aLB < 0) {
                aLB = 2. * aLB;
                aUB = 0.;
            }
            if (Math.abs(aUB - aLB) <= 0.000001) {
                aLB = lowerBounds();
                aUB = upperBounds();
            }
        }
        if (DEBUG) {
            System.out.println(""In findGoodLimits()..."");
            System.out.println(""   aLB = "" + aLB + "", aUB = "" + aUB);
        }
        //	Object used to return results.
        AxisLimitData limData = new AxisLimitData();
        boolean done = false;
        while (!done) {
            done = true;
            double ub = aUB;
            double lb = aLB;
            double delta = ub - lb;
            //	Scale up by s, a power of 10, so range (delta) exceeds 1.
            s = 1.;
            while (delta * s < 10.) s *= 10.;
            //	Find power of 10 quantum, r, such that delta/10 <= r < delta.
            r = 1. / s;
            while (10. * r < delta) r *= 10.;
            //	Set r=(1,2,5)*10**n so that 3-5 quanta cover range.
            if (r >= delta / 2.)
                r /= 2.;
            else if (r < delta / 5.)
                r *= 2.;
            limData.ub = modceil(ub, r);
            limData.lb = modfloor(lb, r);
            //	If lower bound is <= r and > 0, then repeat.
            if (limData.lb <= r && limData.lb > 0.) {
                aLB = 0.;
                done = false;
                //	If upper bound >= -r and < 0, then repeat.
            } else if (limData.ub >= -r && limData.ub < 0.) {
                aUB = 0.;
                done = false;
            }
        }
        //	Save off tick mark spacing.
        limData.quantum = r;
        if (DEBUG) {
            System.out.println(""    limData.lb = "" + limData.lb + "", limData.ub = "" + limData.ub + "", limData.quantum = "" + limData.quantum);
        }
        return limData;
    }

    /**
     *  Find the position and size (in screen coordinates) of tick
     *  marks for a given axis scale.
     *
     *  @param  quantum   Tick mark step size for the axis using this scale.
     *  @param  aLB       Lower bounds of axis using this scale.
     *  @param  aUB       Upper bounds of axis using this scale.
     *  @param  xA        Scaling coefficient for this axis.
     *  @param  xB        Scaling coefficient for this axis.
     *  @return An TickMarkData object containing the tick mark positions, lengths,
     *          and data values at each tick mark.
     */
    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {
        double xl = 0;
        double xu = 0;
        double q = quantum;
        if (q > 0.) {
            xl = modfloor(aLB, q);
            xu = modfloor(aUB - q / 10., q / 5.) + q / 10.;
        } else {
            xl = modfloor(aUB, q);
            xu = modfloor(aLB + q / 10., q / 5.) - q / 10.;
        }
        //	Determine the number of tick marks.
        int xn = (int) ((xu - xl) / (Math.abs(quantum) / 5.));
        if (DEBUG) {
            System.out.println(""In calcTickMarks()..."");
            System.out.println(""    quantum = "" + quantum + "", aLB = "" + aLB + "", aUB = "" + aUB);
            System.out.println(""    xA = "" + xA + "", xB = "" + xB);
            System.out.println(""    xl = "" + xl + "", xu = "" + xu);
            System.out.println(""    xn = "" + xn);
        }
        //	Allocate memory for tick mark arrays.
        int[] mark = new int[xn];
        int[] lmark = new int[xn];
        float[] markValue = new float[xn];
        xn = 0;
        int i = 0;
        for (double x = xl; x <= xu; x += Math.abs(quantum) / 5., ++i) {
            //	Bounds check.
            if (q > 0.)
                if (x <= aLB || x >= aUB)
                    continue;
            if (q < 0.)
                if (x >= aLB || x <= aUB)
                    continue;
            //	Store tick mark.
            mark[xn] = (int) (func(x) * xA + xB);
            markValue[xn] = (float) x;
            if (i % 5 != 0)
                //	Minor tick mark.
                lmark[xn++] = PlotAxis.kTick;
            else
                //	Major tick mark.
                lmark[xn++] = 3 * PlotAxis.kTick;
        }
        if (DEBUG) {
            System.out.println(""Tick mark values:"");
            int length = markValue.length;
            for (i = 0; i < length; ++i) System.out.print(""   "" + markValue[i]);
            System.out.println();
        }
        //	Create a tick mark data object and pass it out.
        TickMarkData data = new TickMarkData();
        data.mark = mark;
        data.lmark = lmark;
        data.markValue = markValue;
        return data;
    }

    /**
     *  Adjust the upper and lower axis bounds, if necissary, to allow
     *  room for error bars on the specified data point.  New bounds
     *  returned in ""output"" object.
     *
     *  @param datum  The data point we are bounds checking.
     *  @param aUB    The current upper bounds.
     *  @param aLB    The current lower bounds.
     *  @param output An AxisLimitData structure for passing the new upper and
     *                lower bounds to the calling routine.
     */
    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {
        double temp = datum.getYError();
        aLB = Math.min(aLB, datum.y - temp);
        aUB = Math.max(aUB, datum.y + temp);
        output.lb = aLB;
        output.ub = aUB;
    }

    private double modceil(double f, double t) {
        t = Math.abs(t);
        return (Math.ceil(f / t) * t);
    }

    private double modfloor(double f, double t) {
        t = Math.abs(t);
        return (Math.floor(f / t) * t);
    }
}
","// LinearAxisScale_1Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#lowerBounds()} method.
*/
class LinearAxisScale_1Test {","// LinearAxisScale_1Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#lowerBounds()} method.
*/
class LinearAxisScale_1Test {

	/**
	* Test case 1 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_1() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 2 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_2() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 3 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_3() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 4 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_4() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 5 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_5() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 6 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_6() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 7 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_7() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 8 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_8() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 9 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_9() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
	/**
	* Test case 10 for method {@link LinearAxisScale#lowerBounds()}.
	*/
	@Test
	public void testLowerBounds_10() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.lowerBounds();
		assertEquals(-1.0, result, 0.0);
	}
	
}

// LinearAxisScale_2Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#upperBounds()} method.
*/
class LinearAxisScale_2Test {
		
	/**
	* Test case 1 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_1() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 2 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_2() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 3 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_3() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 4 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_4() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 5 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_5() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 6 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_6() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 7 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_7() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 8 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_8() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 9 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_9() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
	/**
	* Test case 10 for method {@link LinearAxisScale#upperBounds()}.
	*/
	@Test
	public void testUpperBounds_10() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.upperBounds();
		assertEquals(1.0, result, 0.0);
	}
	
}

// LinearAxisScale_3Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#func(double)} method.
*/
class LinearAxisScale_3Test {
		
	/**
	* Test case 1 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_1() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 2 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_2() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 3 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_3() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 4 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_4() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 5 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_5() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 6 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_6() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 7 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_7() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 8 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_8() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 9 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_9() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
	/**
	* Test case 10 for method {@link LinearAxisScale#func(double)}.
	*/
	@Test
	public void testFunc_10() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		double result = linearAxisScale.func(0.0);
		assertEquals(0.0, result, 0.0);
	}
	
}

// LinearAxisScale_4Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#findGoodLimits(double, double)} method.
*/
class LinearAxisScale_4Test {
		
	/**
	* Test case 1 for method {@link LinearAxisScale#findGoodLimits(double, double)}.
	*/
	@Test
	public void testFindGoodLimits_1() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		AxisLimitData result = linearAxisScale.findGoodLimits(0.0, 0.0);
		assertEquals(0.0, result.lb, 0.0);
		assertEquals(0.0, result.ub, 0.0);
		assertEquals(0.0, result.quantum, 0.0);
	}
	
	/**
	* Test case 2 for method {@link LinearAxisScale#findGoodLimits(double, double)}.
	*/
	@Test
	public void testFindGoodLimits_2() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		AxisLimitData result = linearAxisScale.findGoodLimits(0.0, 0.0);
		assertEquals(0.0, result.lb, 0.0);
		assertEquals(0.0, result.ub, 0.0);
		assertEquals(0.0, result.quantum, 0.0);
	}
	
	/**
	* Test case 3 for method {@link LinearAxisScale#findGoodLimits(double, double)}.
	*/
	@Test
	public void testFindGoodLimits_3() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		AxisLimitData result = linearAxisScale.findGoodLimits(0.0, 0.0);
		assertEquals(0.0, result.lb, 0.0);
		assertEquals(0.0, result.ub, 0.0);
		assertEquals(0.0, result.quantum, 0.0);
	}
	
	/**
	* Test case 4 for method {@link LinearAxisScale#findGoodLimits(double, double)}.
	*/
	@Test
	public void testFindGoodLimits_4() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		AxisLimitData result = linearAxisScale.findGoodLimits(0.0, 0.0);
		assertEquals(0.0, result.lb, 0.0);
		assertEquals(0.0, result.ub, 0.0);
		assertEquals(0.0, result.quantum, 0.0);
	}
	
	/**
	* Test case 5 for method {@link LinearAxisScale#findGoodLimits(double, double)}.
	*/
	@Test
	public"
cmpl-6twoTLNHylZqk2pXxRdg2vqbkrE6u,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_2Test.java,89.2652382850647,length,"// LinearAxisScale.java
/*
*   LinearAxisScale  -- Provides linear axis scaling for plot axes.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This object provides linear scaling for plot axes.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version January 10, 2001
 */
public class LinearAxisScale extends Object implements PlotAxisScale {

    //	Debug flag.
    private static final boolean DEBUG = false;

    /**
     *  The transformation function used to scale the data
     *  plotted against this axis.
     *  This axis uses a linear scaling function:  f(a) = a.
     */
    public final double func(double a) {
        return a;
    }

    /**
     *  Method that returns the default lower bounds for
     *  this axis scale.  Returns -1.0.
     */
    public double lowerBounds() {
        return -1.0;
    }

    /**
     *  Method that returns the default upper bounds for
     *  this axis scale.  Returns 1.0.
     */
    public double upperBounds() {
        return 1.0;
    }

    /**
     *  Method that returns an AxisLimitData object that contains
     *  the preferred axis limits and tick mark spacing for the
     *  specified range of data values for this linear axis scale.
     *
     *  @param  aLB  The lower bounds of the data plotted on this axis.
     *  @param  aUB  The upper bounds of the data plotted on this axis.
     */
    public AxisLimitData findGoodLimits(double aLB, double aUB) {
        //	The lower limit and tick mark spacing being calculated.
        double s = 0., r = 0.;
        //	Make sure we don't have a degenerate case.
        if (Math.abs(aUB - aLB) <= 0.000001) {
            if (aUB > 0.) {
                aUB = 2. * aUB;
                aLB = 0.;
            } else if (aLB < 0) {
                aLB = 2. * aLB;
                aUB = 0.;
            }
            if (Math.abs(aUB - aLB) <= 0.000001) {
                aLB = lowerBounds();
                aUB = upperBounds();
            }
        }
        if (DEBUG) {
            System.out.println(""In findGoodLimits()..."");
            System.out.println(""   aLB = "" + aLB + "", aUB = "" + aUB);
        }
        //	Object used to return results.
        AxisLimitData limData = new AxisLimitData();
        boolean done = false;
        while (!done) {
            done = true;
            double ub = aUB;
            double lb = aLB;
            double delta = ub - lb;
            //	Scale up by s, a power of 10, so range (delta) exceeds 1.
            s = 1.;
            while (delta * s < 10.) s *= 10.;
            //	Find power of 10 quantum, r, such that delta/10 <= r < delta.
            r = 1. / s;
            while (10. * r < delta) r *= 10.;
            //	Set r=(1,2,5)*10**n so that 3-5 quanta cover range.
            if (r >= delta / 2.)
                r /= 2.;
            else if (r < delta / 5.)
                r *= 2.;
            limData.ub = modceil(ub, r);
            limData.lb = modfloor(lb, r);
            //	If lower bound is <= r and > 0, then repeat.
            if (limData.lb <= r && limData.lb > 0.) {
                aLB = 0.;
                done = false;
                //	If upper bound >= -r and < 0, then repeat.
            } else if (limData.ub >= -r && limData.ub < 0.) {
                aUB = 0.;
                done = false;
            }
        }
        //	Save off tick mark spacing.
        limData.quantum = r;
        if (DEBUG) {
            System.out.println(""    limData.lb = "" + limData.lb + "", limData.ub = "" + limData.ub + "", limData.quantum = "" + limData.quantum);
        }
        return limData;
    }

    /**
     *  Find the position and size (in screen coordinates) of tick
     *  marks for a given axis scale.
     *
     *  @param  quantum   Tick mark step size for the axis using this scale.
     *  @param  aLB       Lower bounds of axis using this scale.
     *  @param  aUB       Upper bounds of axis using this scale.
     *  @param  xA        Scaling coefficient for this axis.
     *  @param  xB        Scaling coefficient for this axis.
     *  @return An TickMarkData object containing the tick mark positions, lengths,
     *          and data values at each tick mark.
     */
    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {
        double xl = 0;
        double xu = 0;
        double q = quantum;
        if (q > 0.) {
            xl = modfloor(aLB, q);
            xu = modfloor(aUB - q / 10., q / 5.) + q / 10.;
        } else {
            xl = modfloor(aUB, q);
            xu = modfloor(aLB + q / 10., q / 5.) - q / 10.;
        }
        //	Determine the number of tick marks.
        int xn = (int) ((xu - xl) / (Math.abs(quantum) / 5.));
        if (DEBUG) {
            System.out.println(""In calcTickMarks()..."");
            System.out.println(""    quantum = "" + quantum + "", aLB = "" + aLB + "", aUB = "" + aUB);
            System.out.println(""    xA = "" + xA + "", xB = "" + xB);
            System.out.println(""    xl = "" + xl + "", xu = "" + xu);
            System.out.println(""    xn = "" + xn);
        }
        //	Allocate memory for tick mark arrays.
        int[] mark = new int[xn];
        int[] lmark = new int[xn];
        float[] markValue = new float[xn];
        xn = 0;
        int i = 0;
        for (double x = xl; x <= xu; x += Math.abs(quantum) / 5., ++i) {
            //	Bounds check.
            if (q > 0.)
                if (x <= aLB || x >= aUB)
                    continue;
            if (q < 0.)
                if (x >= aLB || x <= aUB)
                    continue;
            //	Store tick mark.
            mark[xn] = (int) (func(x) * xA + xB);
            markValue[xn] = (float) x;
            if (i % 5 != 0)
                //	Minor tick mark.
                lmark[xn++] = PlotAxis.kTick;
            else
                //	Major tick mark.
                lmark[xn++] = 3 * PlotAxis.kTick;
        }
        if (DEBUG) {
            System.out.println(""Tick mark values:"");
            int length = markValue.length;
            for (i = 0; i < length; ++i) System.out.print(""   "" + markValue[i]);
            System.out.println();
        }
        //	Create a tick mark data object and pass it out.
        TickMarkData data = new TickMarkData();
        data.mark = mark;
        data.lmark = lmark;
        data.markValue = markValue;
        return data;
    }

    /**
     *  Adjust the upper and lower axis bounds, if necissary, to allow
     *  room for error bars on the specified data point.  New bounds
     *  returned in ""output"" object.
     *
     *  @param datum  The data point we are bounds checking.
     *  @param aUB    The current upper bounds.
     *  @param aLB    The current lower bounds.
     *  @param output An AxisLimitData structure for passing the new upper and
     *                lower bounds to the calling routine.
     */
    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {
        double temp = datum.getYError();
        aLB = Math.min(aLB, datum.y - temp);
        aUB = Math.max(aUB, datum.y + temp);
        output.lb = aLB;
        output.ub = aUB;
    }

    private double modceil(double f, double t) {
        t = Math.abs(t);
        return (Math.ceil(f / t) * t);
    }

    private double modfloor(double f, double t) {
        t = Math.abs(t);
        return (Math.floor(f / t) * t);
    }
}
","// LinearAxisScale_2Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#upperBounds()} method.
*/
class LinearAxisScale_2Test {","// LinearAxisScale_2Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#upperBounds()} method.
*/
class LinearAxisScale_2Test {

	@Test
	void testUpperBounds() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		assertEquals(1.0, linearAxisScale.upperBounds());
	}
	
}

// LinearAxisScale_3Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#lowerBounds()} method.
*/
class LinearAxisScale_3Test {
		
	@Test
	void testLowerBounds() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		assertEquals(-1.0, linearAxisScale.lowerBounds());
	}
	
}

// LinearAxisScale_4Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#func(double)} method.
*/
class LinearAxisScale_4Test {
		
	@Test
	void testFunc() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		assertEquals(1.0, linearAxisScale.func(1.0));
	}
	
}

// LinearAxisScale_5Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#findGoodLimits(double, double)} method.
*/
class LinearAxisScale_5Test {
		
	@Test
	void testFindGoodLimits() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		AxisLimitData axisLimitData = linearAxisScale.findGoodLimits(0.0, 0.0);
		assertEquals(-1.0, axisLimitData.lb);
		assertEquals(1.0, axisLimitData.ub);
		assertEquals(1.0, axisLimitData.quantum);
	}
	
}

// LinearAxisScale_6Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
*/
class LinearAxisScale_6Test {
		
	@Test
	void testCalcTickMarks() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		TickMarkData tickMarkData = linearAxisScale.calcTickMarks(1.0, 0.0, 0.0, 1.0, 0.0);
		assertEquals(0, tickMarkData.mark[0]);
		assertEquals(0, tickMarkData.lmark[0]);
		assertEquals(0.0, tickMarkData.markValue[0]);
	}
	
}

// LinearAxisScale_7Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#adjustForErrorBars(PlotDatum, double, double, AxisLimitData)} method.
*/
class LinearAxisScale_7Test {
		
	@Test
	void testAdjustForErrorBars() {
		LinearAxisScale linearAxisScale = new LinearAxisScale();
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0"
cmpl-6twpudnJOo9g1YszHkFmUeV3FB5zS,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_3Test.java,21.533222913742065,stop,"// LinearAxisScale.java
/*
*   LinearAxisScale  -- Provides linear axis scaling for plot axes.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This object provides linear scaling for plot axes.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version January 10, 2001
 */
public class LinearAxisScale extends Object implements PlotAxisScale {

    //	Debug flag.
    private static final boolean DEBUG = false;

    /**
     *  The transformation function used to scale the data
     *  plotted against this axis.
     *  This axis uses a linear scaling function:  f(a) = a.
     */
    public final double func(double a) {
        return a;
    }

    /**
     *  Method that returns the default lower bounds for
     *  this axis scale.  Returns -1.0.
     */
    public double lowerBounds() {
        return -1.0;
    }

    /**
     *  Method that returns the default upper bounds for
     *  this axis scale.  Returns 1.0.
     */
    public double upperBounds() {
        return 1.0;
    }

    /**
     *  Method that returns an AxisLimitData object that contains
     *  the preferred axis limits and tick mark spacing for the
     *  specified range of data values for this linear axis scale.
     *
     *  @param  aLB  The lower bounds of the data plotted on this axis.
     *  @param  aUB  The upper bounds of the data plotted on this axis.
     */
    public AxisLimitData findGoodLimits(double aLB, double aUB) {
        //	The lower limit and tick mark spacing being calculated.
        double s = 0., r = 0.;
        //	Make sure we don't have a degenerate case.
        if (Math.abs(aUB - aLB) <= 0.000001) {
            if (aUB > 0.) {
                aUB = 2. * aUB;
                aLB = 0.;
            } else if (aLB < 0) {
                aLB = 2. * aLB;
                aUB = 0.;
            }
            if (Math.abs(aUB - aLB) <= 0.000001) {
                aLB = lowerBounds();
                aUB = upperBounds();
            }
        }
        if (DEBUG) {
            System.out.println(""In findGoodLimits()..."");
            System.out.println(""   aLB = "" + aLB + "", aUB = "" + aUB);
        }
        //	Object used to return results.
        AxisLimitData limData = new AxisLimitData();
        boolean done = false;
        while (!done) {
            done = true;
            double ub = aUB;
            double lb = aLB;
            double delta = ub - lb;
            //	Scale up by s, a power of 10, so range (delta) exceeds 1.
            s = 1.;
            while (delta * s < 10.) s *= 10.;
            //	Find power of 10 quantum, r, such that delta/10 <= r < delta.
            r = 1. / s;
            while (10. * r < delta) r *= 10.;
            //	Set r=(1,2,5)*10**n so that 3-5 quanta cover range.
            if (r >= delta / 2.)
                r /= 2.;
            else if (r < delta / 5.)
                r *= 2.;
            limData.ub = modceil(ub, r);
            limData.lb = modfloor(lb, r);
            //	If lower bound is <= r and > 0, then repeat.
            if (limData.lb <= r && limData.lb > 0.) {
                aLB = 0.;
                done = false;
                //	If upper bound >= -r and < 0, then repeat.
            } else if (limData.ub >= -r && limData.ub < 0.) {
                aUB = 0.;
                done = false;
            }
        }
        //	Save off tick mark spacing.
        limData.quantum = r;
        if (DEBUG) {
            System.out.println(""    limData.lb = "" + limData.lb + "", limData.ub = "" + limData.ub + "", limData.quantum = "" + limData.quantum);
        }
        return limData;
    }

    /**
     *  Find the position and size (in screen coordinates) of tick
     *  marks for a given axis scale.
     *
     *  @param  quantum   Tick mark step size for the axis using this scale.
     *  @param  aLB       Lower bounds of axis using this scale.
     *  @param  aUB       Upper bounds of axis using this scale.
     *  @param  xA        Scaling coefficient for this axis.
     *  @param  xB        Scaling coefficient for this axis.
     *  @return An TickMarkData object containing the tick mark positions, lengths,
     *          and data values at each tick mark.
     */
    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {
        double xl = 0;
        double xu = 0;
        double q = quantum;
        if (q > 0.) {
            xl = modfloor(aLB, q);
            xu = modfloor(aUB - q / 10., q / 5.) + q / 10.;
        } else {
            xl = modfloor(aUB, q);
            xu = modfloor(aLB + q / 10., q / 5.) - q / 10.;
        }
        //	Determine the number of tick marks.
        int xn = (int) ((xu - xl) / (Math.abs(quantum) / 5.));
        if (DEBUG) {
            System.out.println(""In calcTickMarks()..."");
            System.out.println(""    quantum = "" + quantum + "", aLB = "" + aLB + "", aUB = "" + aUB);
            System.out.println(""    xA = "" + xA + "", xB = "" + xB);
            System.out.println(""    xl = "" + xl + "", xu = "" + xu);
            System.out.println(""    xn = "" + xn);
        }
        //	Allocate memory for tick mark arrays.
        int[] mark = new int[xn];
        int[] lmark = new int[xn];
        float[] markValue = new float[xn];
        xn = 0;
        int i = 0;
        for (double x = xl; x <= xu; x += Math.abs(quantum) / 5., ++i) {
            //	Bounds check.
            if (q > 0.)
                if (x <= aLB || x >= aUB)
                    continue;
            if (q < 0.)
                if (x >= aLB || x <= aUB)
                    continue;
            //	Store tick mark.
            mark[xn] = (int) (func(x) * xA + xB);
            markValue[xn] = (float) x;
            if (i % 5 != 0)
                //	Minor tick mark.
                lmark[xn++] = PlotAxis.kTick;
            else
                //	Major tick mark.
                lmark[xn++] = 3 * PlotAxis.kTick;
        }
        if (DEBUG) {
            System.out.println(""Tick mark values:"");
            int length = markValue.length;
            for (i = 0; i < length; ++i) System.out.print(""   "" + markValue[i]);
            System.out.println();
        }
        //	Create a tick mark data object and pass it out.
        TickMarkData data = new TickMarkData();
        data.mark = mark;
        data.lmark = lmark;
        data.markValue = markValue;
        return data;
    }

    /**
     *  Adjust the upper and lower axis bounds, if necissary, to allow
     *  room for error bars on the specified data point.  New bounds
     *  returned in ""output"" object.
     *
     *  @param datum  The data point we are bounds checking.
     *  @param aUB    The current upper bounds.
     *  @param aLB    The current lower bounds.
     *  @param output An AxisLimitData structure for passing the new upper and
     *                lower bounds to the calling routine.
     */
    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {
        double temp = datum.getYError();
        aLB = Math.min(aLB, datum.y - temp);
        aUB = Math.max(aUB, datum.y + temp);
        output.lb = aLB;
        output.ub = aUB;
    }

    private double modceil(double f, double t) {
        t = Math.abs(t);
        return (Math.ceil(f / t) * t);
    }

    private double modfloor(double f, double t) {
        t = Math.abs(t);
        return (Math.floor(f / t) * t);
    }
}
","// LinearAxisScale_3Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#findGoodLimits(double, double)} method.
*/
class LinearAxisScale_3Test {","// LinearAxisScale_3Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#findGoodLimits(double, double)} method.
*/
class LinearAxisScale_3Test {

	/**
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	*/
	@Test
	void testFindGoodLimits() {
		LinearAxisScale axisScale = new LinearAxisScale();
		AxisLimitData result = axisScale.findGoodLimits(0.0, 0.0);
		assertEquals(-1.0, result.lb, 1e-6);
		assertEquals(1.0, result.ub, 1e-6);
		assertEquals(1.0, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 1.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(1.0, result.ub, 1e-6);
		assertEquals(0.2, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 2.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(2.0, result.ub, 1e-6);
		assertEquals(0.2, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 3.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(3.0, result.ub, 1e-6);
		assertEquals(0.5, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 4.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(4.0, result.ub, 1e-6);
		assertEquals(1.0, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 5.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(5.0, result.ub, 1e-6);
		assertEquals(1.0, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 6.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(6.0, result.ub, 1e-6);
		assertEquals(1.0, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 7.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(7.0, result.ub, 1e-6);
		assertEquals(1.0, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 8.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(8.0, result.ub, 1e-6);
		assertEquals(2.0, result.quantum, 1e-6);
		result = axisScale.findGoodLimits(0.0, 9.0);
		assertEquals(0.0, result.lb, 1e-6);
		assertEquals(9.0, result.ub, 1e-6);
		assertEquals(2.0, result.quantum, 1e-6);
	}
	
}"
cmpl-6twqxk6hzr2Wa7ePIQoPVBAa4R2HS,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/LinearAxisScale_4Test.java,107.43148803710938,length,"// LinearAxisScale.java
/*
*   LinearAxisScale  -- Provides linear axis scaling for plot axes.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This object provides linear scaling for plot axes.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version January 10, 2001
 */
public class LinearAxisScale extends Object implements PlotAxisScale {

    //	Debug flag.
    private static final boolean DEBUG = false;

    /**
     *  The transformation function used to scale the data
     *  plotted against this axis.
     *  This axis uses a linear scaling function:  f(a) = a.
     */
    public final double func(double a) {
        return a;
    }

    /**
     *  Method that returns the default lower bounds for
     *  this axis scale.  Returns -1.0.
     */
    public double lowerBounds() {
        return -1.0;
    }

    /**
     *  Method that returns the default upper bounds for
     *  this axis scale.  Returns 1.0.
     */
    public double upperBounds() {
        return 1.0;
    }

    /**
     *  Method that returns an AxisLimitData object that contains
     *  the preferred axis limits and tick mark spacing for the
     *  specified range of data values for this linear axis scale.
     *
     *  @param  aLB  The lower bounds of the data plotted on this axis.
     *  @param  aUB  The upper bounds of the data plotted on this axis.
     */
    public AxisLimitData findGoodLimits(double aLB, double aUB) {
        //	The lower limit and tick mark spacing being calculated.
        double s = 0., r = 0.;
        //	Make sure we don't have a degenerate case.
        if (Math.abs(aUB - aLB) <= 0.000001) {
            if (aUB > 0.) {
                aUB = 2. * aUB;
                aLB = 0.;
            } else if (aLB < 0) {
                aLB = 2. * aLB;
                aUB = 0.;
            }
            if (Math.abs(aUB - aLB) <= 0.000001) {
                aLB = lowerBounds();
                aUB = upperBounds();
            }
        }
        if (DEBUG) {
            System.out.println(""In findGoodLimits()..."");
            System.out.println(""   aLB = "" + aLB + "", aUB = "" + aUB);
        }
        //	Object used to return results.
        AxisLimitData limData = new AxisLimitData();
        boolean done = false;
        while (!done) {
            done = true;
            double ub = aUB;
            double lb = aLB;
            double delta = ub - lb;
            //	Scale up by s, a power of 10, so range (delta) exceeds 1.
            s = 1.;
            while (delta * s < 10.) s *= 10.;
            //	Find power of 10 quantum, r, such that delta/10 <= r < delta.
            r = 1. / s;
            while (10. * r < delta) r *= 10.;
            //	Set r=(1,2,5)*10**n so that 3-5 quanta cover range.
            if (r >= delta / 2.)
                r /= 2.;
            else if (r < delta / 5.)
                r *= 2.;
            limData.ub = modceil(ub, r);
            limData.lb = modfloor(lb, r);
            //	If lower bound is <= r and > 0, then repeat.
            if (limData.lb <= r && limData.lb > 0.) {
                aLB = 0.;
                done = false;
                //	If upper bound >= -r and < 0, then repeat.
            } else if (limData.ub >= -r && limData.ub < 0.) {
                aUB = 0.;
                done = false;
            }
        }
        //	Save off tick mark spacing.
        limData.quantum = r;
        if (DEBUG) {
            System.out.println(""    limData.lb = "" + limData.lb + "", limData.ub = "" + limData.ub + "", limData.quantum = "" + limData.quantum);
        }
        return limData;
    }

    /**
     *  Find the position and size (in screen coordinates) of tick
     *  marks for a given axis scale.
     *
     *  @param  quantum   Tick mark step size for the axis using this scale.
     *  @param  aLB       Lower bounds of axis using this scale.
     *  @param  aUB       Upper bounds of axis using this scale.
     *  @param  xA        Scaling coefficient for this axis.
     *  @param  xB        Scaling coefficient for this axis.
     *  @return An TickMarkData object containing the tick mark positions, lengths,
     *          and data values at each tick mark.
     */
    public TickMarkData calcTickMarks(double quantum, double aLB, double aUB, double xA, double xB) {
        double xl = 0;
        double xu = 0;
        double q = quantum;
        if (q > 0.) {
            xl = modfloor(aLB, q);
            xu = modfloor(aUB - q / 10., q / 5.) + q / 10.;
        } else {
            xl = modfloor(aUB, q);
            xu = modfloor(aLB + q / 10., q / 5.) - q / 10.;
        }
        //	Determine the number of tick marks.
        int xn = (int) ((xu - xl) / (Math.abs(quantum) / 5.));
        if (DEBUG) {
            System.out.println(""In calcTickMarks()..."");
            System.out.println(""    quantum = "" + quantum + "", aLB = "" + aLB + "", aUB = "" + aUB);
            System.out.println(""    xA = "" + xA + "", xB = "" + xB);
            System.out.println(""    xl = "" + xl + "", xu = "" + xu);
            System.out.println(""    xn = "" + xn);
        }
        //	Allocate memory for tick mark arrays.
        int[] mark = new int[xn];
        int[] lmark = new int[xn];
        float[] markValue = new float[xn];
        xn = 0;
        int i = 0;
        for (double x = xl; x <= xu; x += Math.abs(quantum) / 5., ++i) {
            //	Bounds check.
            if (q > 0.)
                if (x <= aLB || x >= aUB)
                    continue;
            if (q < 0.)
                if (x >= aLB || x <= aUB)
                    continue;
            //	Store tick mark.
            mark[xn] = (int) (func(x) * xA + xB);
            markValue[xn] = (float) x;
            if (i % 5 != 0)
                //	Minor tick mark.
                lmark[xn++] = PlotAxis.kTick;
            else
                //	Major tick mark.
                lmark[xn++] = 3 * PlotAxis.kTick;
        }
        if (DEBUG) {
            System.out.println(""Tick mark values:"");
            int length = markValue.length;
            for (i = 0; i < length; ++i) System.out.print(""   "" + markValue[i]);
            System.out.println();
        }
        //	Create a tick mark data object and pass it out.
        TickMarkData data = new TickMarkData();
        data.mark = mark;
        data.lmark = lmark;
        data.markValue = markValue;
        return data;
    }

    /**
     *  Adjust the upper and lower axis bounds, if necissary, to allow
     *  room for error bars on the specified data point.  New bounds
     *  returned in ""output"" object.
     *
     *  @param datum  The data point we are bounds checking.
     *  @param aUB    The current upper bounds.
     *  @param aLB    The current lower bounds.
     *  @param output An AxisLimitData structure for passing the new upper and
     *                lower bounds to the calling routine.
     */
    public void adjustForErrorBars(PlotDatum datum, double aUB, double aLB, AxisLimitData output) {
        double temp = datum.getYError();
        aLB = Math.min(aLB, datum.y - temp);
        aUB = Math.max(aUB, datum.y + temp);
        output.lb = aLB;
        output.ub = aUB;
    }

    private double modceil(double f, double t) {
        t = Math.abs(t);
        return (Math.ceil(f / t) * t);
    }

    private double modfloor(double f, double t) {
        t = Math.abs(t);
        return (Math.floor(f / t) * t);
    }
}
","// LinearAxisScale_4Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
*/
class LinearAxisScale_4Test {","// LinearAxisScale_4Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
*/
class LinearAxisScale_4Test {

	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_1() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 1.0;
		double xB = 0.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(0, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(10, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_2() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 2.0;
		double xB = 0.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(0, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(20, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_3() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 1.0;
		double xB = 10.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(10, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(20, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_4() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 2.0;
		double xB = 10.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(20, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(40, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_5() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 1.0;
		double xB = -10.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(-10, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(0, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_6() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 2.0;
		double xB = -10.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(-20, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(-10, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_7() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 1.0;
		double xB = -5.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(-5, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(5, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_8() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 2.0;
		double xB = -5.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(-10, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(0, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_9() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 1.0;
		double xB = 5.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(5, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(15, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
	/**
	* Test case for {@link LinearAxisScale#calcTickMarks(double, double, double, double, double)} method.
	*/
	@Test
	void testCalcTickMarks_10() {
		double quantum = 0.1;
		double aLB = 0.0;
		double aUB = 1.0;
		double xA = 2.0;
		double xB = 5.0;
		TickMarkData result = new LinearAxisScale().calcTickMarks(quantum, aLB, aUB, xA, xB);
		assertEquals(10, result.mark.length);
		assertEquals(10, result.lmark.length);
		assertEquals(10, result.markValue.length);
		assertEquals(10, result.mark[0]);
		assertEquals(PlotAxis.kTick, result.lmark[0]);
		assertEquals(0.1f, result.markValue[0]);
		assertEquals(30, result.mark[9]);
		assertEquals(3 * PlotAxis.kTick, result.lmark[9]);
		assertEquals(1.0f, result.markValue[9]);
	}
	
}

// LinearAxisScale_5Test.java
package jahuwaldt.plot;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LinearAxisScale}.
* It contains ten unit test cases for the {@link LinearAxisScale#findGoodLimits(double, double)} method.
*/
class LinearAxisScale_5Test {
		
	/**
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	*/
	@Test
	void testFindGoodLimits_1() {
		double aLB = 0.0;
		double aUB = 1.0;
		AxisLimitData result = new LinearAxisScale().findGoodLimits(aLB, aUB);
		assertEquals(0.0, result.lb);
		assertEquals(1.0, result.ub);
		assertEquals(0.1, result.quantum);
	}
	
	/**
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	*/
	@Test
	void testFindGoodLimits_2() {
		double aLB = 0.0;
		double aUB = 0.1;
		AxisLimitData result = new LinearAxisScale().findGoodLimits(aLB, aUB);
		assertEquals(0.0, result.lb);
		assertEquals(0.1, result.ub);
		assertEquals(0.01, result.quantum);
	}
	
	/**
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	*/
	@Test
	void testFindGoodLimits_3() {
		double aLB = 0.0;
		double aUB = 0.01;
		AxisLimitData result = new LinearAxisScale().findGoodLimits(aLB, aUB);
		assertEquals(0.0, result.lb);
		assertEquals(0.01, result.ub);
		assertEquals(0.001, result.quantum);
	}
	
	/**
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	*/
	@Test
	void testFindGoodLimits_4() {
		double aLB = 0.0;
		double aUB = 0.001;
		AxisLimitData result = new LinearAxisScale().findGoodLimits(aLB, aUB);
		assertEquals(0.0, result.lb);
		assertEquals(0.001, result.ub);
		assertEquals(0.0001, result.quantum);
	}
	
	/**
	* Test case for {@link LinearAxisScale#findGoodLimits(double, double)} method.
	*/
	@Test
	void testFindGoodLimits_5() {
		double aLB = 0.0;
		double aUB = 0.0001;
		AxisLimitData result = new LinearAxisScale().findGoodLimits(aLB, aUB);
		assertEquals(0.0, result.lb);
		assertEquals(0.0001, result.ub);
		assertEquals(1.0E-4, result.quantum);
	}
	
	/**
	* Test"
cmpl-6twsghuAOD4IygC59f3nZ1UHsynqu,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotDatum_0Test.java,87.50709748268127,length,"// PlotDatum.java
/*
*   PlotDatum  -- Represents a single data point on a 2D plot.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;

/**
 *  <p> This class represents a single data point on a plot
 *      and includes all the information required by each point.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  June 1, 2000
 *  @version November 20, 2000
 */
public class PlotDatum extends Object implements Cloneable, java.io.Serializable {

    /**
     *  The X and Y coordinate points for this datum.
     */
    public double x, y;

    /**
     *  The error on the Y value.
     */
    private double yErr;

    /**
     *  A flag that indicates if there is an error bar.
     */
    private boolean errBarFlg = false;

    /**
     *  Flag that indicates if this point connects to the previous point.
     */
    private boolean conFlg;

    /**
     *  The line type for the line connecting this point to the previous point.
     *  This is not yet implemented!  Waiting until I learn Java2D.
     */
    //	private int lineMode;
    /**
     *  The line color used to connect this point to the previous one.
     */
    private Color lineColor = Color.black;

    /**
     *  The plot symbol used by this datum.
     */
    private PlotSymbol symbol = null;

    //-------------------------------------------------------------------------
    /**
     *  Create a new datum (plot coordinate point) given the specified
     *  X and Y values.  This datum will, by default, have no error bar.
     *
     *  @param xValue  The X coordinate value for this datum point.
     *  @param yValue  The Y coordinate value for this datum point.
     *  @param connected  A flag that indicates that this datum is connected
     *                    to the previous one if true, no line is drawn
     *                    to the previous datum if false.
     */
    public PlotDatum(double xValue, double yValue, boolean connected) {
        super();
        x = xValue;
        y = yValue;
        conFlg = connected;
    }

    /**
     *  Create a new datum (plot coordinate point) given the specified
     *  X and Y values and the given plot symbol.  This datum will, by
     *  default, have no error bar.
     *
     *  @param xValue  The X coordinate value for this datum point.
     *  @param yValue  The Y coordinate value for this datum point.
     *  @param connected  A flag that indicates that this datum is connected
     *                    to the previous one if true, no line is drawn
     *                    to the previous datum if false.
     *  @param  symbol  The plot symbol to be used for this data point.
     */
    public PlotDatum(double xValue, double yValue, boolean connected, PlotSymbol symbol) {
        super();
        x = xValue;
        y = yValue;
        conFlg = connected;
        this.symbol = symbol;
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the X coordinate value of this point.
     */
    public double getX() {
        return x;
    }

    /**
     *  Return the Y coordinate value of this point.
     */
    public double getY() {
        return y;
    }

    /**
     *  Set the X coordinate value of this point.
     */
    public void setX(double value) {
        x = value;
    }

    /**
     *  Set the Y coordinate value of this point.
     */
    public void setY(double value) {
        y = value;
    }

    /**
     *  Set the error on Y value.
     */
    public void setYError(double err) {
        yErr = err;
        if (yErr == 0.)
            errBarFlg = false;
        else
            errBarFlg = true;
    }

    /**
     *  Get the error on Y value.
     */
    public double getYError() {
        return yErr;
    }

    /**
     *  Returns true if this data point has an error bar.
     */
    public boolean hasErrorBar() {
        return errBarFlg;
    }

    /**
     *  Set if this datum is connected to the previous one by a line or not.
     */
    public void setConnected(boolean flag) {
        conFlg = flag;
    }

    /**
     *  Return true if this datum is connected to the previous one by a line
     *  and false if it is not.
     */
    public boolean connected() {
        return conFlg;
    }

    /**
     *  Set the plot symbol used for this datum.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        this.symbol = symbol;
    }

    /**
     *  Returns a reference to the plot symbol used by
     *  this datum.
     */
    public PlotSymbol getPlotSymbol() {
        return symbol;
    }

    /**
     *  Set the color used for the line connecting this datum
     *  to the previous one.  If null is passed, the line is
     *  drawn in black.
     */
    public void setLineColor(Color color) {
        if (color != null)
            lineColor = color;
        else
            lineColor = Color.black;
    }

    /**
     *  Return the color to be used for drawing the line
     *  connecting this datum to the previous.
     */
    public Color getLineColor() {
        return lineColor;
    }

    /**
     *  Make a copy of this PlotDatum object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotDatum newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotDatum) super.clone();
            // Clone this object's data structures.
            if (this.symbol != null)
                newObject.symbol = (PlotSymbol) this.symbol.clone();
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotDatum_0Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#hasErrorBar()} method.
*/
class PlotDatum_0Test {","// PlotDatum_0Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#hasErrorBar()} method.
*/
class PlotDatum_0Test {

	/**
	* Test case 1 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_1() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		boolean expected = false;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_2() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(0.0);
		boolean expected = false;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_3() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(1.0);
		boolean expected = true;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_4() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.NaN);
		boolean expected = false;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_5() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.NEGATIVE_INFINITY);
		boolean expected = false;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_6() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.POSITIVE_INFINITY);
		boolean expected = false;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_7() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_VALUE);
		boolean expected = true;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_8() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MAX_VALUE);
		boolean expected = true;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_9() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_NORMAL);
		boolean expected = true;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link PlotDatum#hasErrorBar()}.
	*/
	@Test
	void testHasErrorBar_10() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_NORMAL);
		boolean expected = true;
		boolean actual = plotDatum.hasErrorBar();
		assertEquals(expected, actual);
	}
	
}

// PlotDatum_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#getYError()} method.
*/
class PlotDatum_1Test {
		
	/**
	* Test case 1 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_1() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_2() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(0.0);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_3() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(1.0);
		double expected = 1.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_4() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.NaN);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_5() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.NEGATIVE_INFINITY);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_6() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.POSITIVE_INFINITY);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_7() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_VALUE);
		double expected = Double.MIN_VALUE;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_8() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MAX_VALUE);
		double expected = Double.MAX_VALUE;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_9() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_NORMAL);
		double expected = Double.MIN_NORMAL;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link PlotDatum#getYError()}.
	*/
	@Test
	void testGetYError_10() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_NORMAL);
		double expected = Double.MIN_NORMAL;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
}

// PlotDatum_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#setYError(double)} method.
*/
class PlotDatum_2Test {
		
	/**
	* Test case 1 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_1() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(0.0);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_2() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(1.0);
		double expected = 1.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_3() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.NaN);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_4() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.NEGATIVE_INFINITY);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_5() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.POSITIVE_INFINITY);
		double expected = 0.0;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_6() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_VALUE);
		double expected = Double.MIN_VALUE;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_7() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MAX_VALUE);
		double expected = Double.MAX_VALUE;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_8() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_NORMAL);
		double expected = Double.MIN_NORMAL;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_9() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_NORMAL);
		double expected = Double.MIN_NORMAL;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link PlotDatum#setYError(double)}.
	*/
	@Test
	void testSetYError_10() {
		PlotDatum plotDatum = new PlotDatum(0.0, 0.0, false);
		plotDatum.setYError(Double.MIN_NORMAL);
		double expected = Double.MIN_NORMAL;
		double actual = plotDatum.getYError();
		assertEquals(expected, actual);
	}
	
}

// PlotDatum_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
"
cmpl-6twu6eKEnFQJ3MJ1zGBVzPVJXEFWr,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotDatum_1Test.java,145.2673740386963,length,"// PlotDatum.java
/*
*   PlotDatum  -- Represents a single data point on a 2D plot.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;

/**
 *  <p> This class represents a single data point on a plot
 *      and includes all the information required by each point.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  June 1, 2000
 *  @version November 20, 2000
 */
public class PlotDatum extends Object implements Cloneable, java.io.Serializable {

    /**
     *  The X and Y coordinate points for this datum.
     */
    public double x, y;

    /**
     *  The error on the Y value.
     */
    private double yErr;

    /**
     *  A flag that indicates if there is an error bar.
     */
    private boolean errBarFlg = false;

    /**
     *  Flag that indicates if this point connects to the previous point.
     */
    private boolean conFlg;

    /**
     *  The line type for the line connecting this point to the previous point.
     *  This is not yet implemented!  Waiting until I learn Java2D.
     */
    //	private int lineMode;
    /**
     *  The line color used to connect this point to the previous one.
     */
    private Color lineColor = Color.black;

    /**
     *  The plot symbol used by this datum.
     */
    private PlotSymbol symbol = null;

    //-------------------------------------------------------------------------
    /**
     *  Create a new datum (plot coordinate point) given the specified
     *  X and Y values.  This datum will, by default, have no error bar.
     *
     *  @param xValue  The X coordinate value for this datum point.
     *  @param yValue  The Y coordinate value for this datum point.
     *  @param connected  A flag that indicates that this datum is connected
     *                    to the previous one if true, no line is drawn
     *                    to the previous datum if false.
     */
    public PlotDatum(double xValue, double yValue, boolean connected) {
        super();
        x = xValue;
        y = yValue;
        conFlg = connected;
    }

    /**
     *  Create a new datum (plot coordinate point) given the specified
     *  X and Y values and the given plot symbol.  This datum will, by
     *  default, have no error bar.
     *
     *  @param xValue  The X coordinate value for this datum point.
     *  @param yValue  The Y coordinate value for this datum point.
     *  @param connected  A flag that indicates that this datum is connected
     *                    to the previous one if true, no line is drawn
     *                    to the previous datum if false.
     *  @param  symbol  The plot symbol to be used for this data point.
     */
    public PlotDatum(double xValue, double yValue, boolean connected, PlotSymbol symbol) {
        super();
        x = xValue;
        y = yValue;
        conFlg = connected;
        this.symbol = symbol;
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the X coordinate value of this point.
     */
    public double getX() {
        return x;
    }

    /**
     *  Return the Y coordinate value of this point.
     */
    public double getY() {
        return y;
    }

    /**
     *  Set the X coordinate value of this point.
     */
    public void setX(double value) {
        x = value;
    }

    /**
     *  Set the Y coordinate value of this point.
     */
    public void setY(double value) {
        y = value;
    }

    /**
     *  Set the error on Y value.
     */
    public void setYError(double err) {
        yErr = err;
        if (yErr == 0.)
            errBarFlg = false;
        else
            errBarFlg = true;
    }

    /**
     *  Get the error on Y value.
     */
    public double getYError() {
        return yErr;
    }

    /**
     *  Returns true if this data point has an error bar.
     */
    public boolean hasErrorBar() {
        return errBarFlg;
    }

    /**
     *  Set if this datum is connected to the previous one by a line or not.
     */
    public void setConnected(boolean flag) {
        conFlg = flag;
    }

    /**
     *  Return true if this datum is connected to the previous one by a line
     *  and false if it is not.
     */
    public boolean connected() {
        return conFlg;
    }

    /**
     *  Set the plot symbol used for this datum.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        this.symbol = symbol;
    }

    /**
     *  Returns a reference to the plot symbol used by
     *  this datum.
     */
    public PlotSymbol getPlotSymbol() {
        return symbol;
    }

    /**
     *  Set the color used for the line connecting this datum
     *  to the previous one.  If null is passed, the line is
     *  drawn in black.
     */
    public void setLineColor(Color color) {
        if (color != null)
            lineColor = color;
        else
            lineColor = Color.black;
    }

    /**
     *  Return the color to be used for drawing the line
     *  connecting this datum to the previous.
     */
    public Color getLineColor() {
        return lineColor;
    }

    /**
     *  Make a copy of this PlotDatum object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotDatum newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotDatum) super.clone();
            // Clone this object's data structures.
            if (this.symbol != null)
                newObject.symbol = (PlotSymbol) this.symbol.clone();
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotDatum_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#connected()} method.
*/
class PlotDatum_1Test {","// PlotDatum_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#connected()} method.
*/
class PlotDatum_1Test {

	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true);
		assertTrue(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected2() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false);
		assertFalse(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected3() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		assertTrue(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected4() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		assertFalse(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected5() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setConnected(false);
		assertFalse(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected6() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setConnected(true);
		assertTrue(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected7() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setConnected(true);
		assertTrue(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected8() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setConnected(false);
		assertFalse(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected9() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setConnected(false);
		plotDatum.setConnected(true);
		assertTrue(plotDatum.connected());
	}
	
	/**
	* Test case for {@link PlotDatum#connected()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testConnected10() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setConnected(true);
		plotDatum.setConnected(false);
		assertFalse(plotDatum.connected());
	}
	
}

// PlotDatum_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#getLineColor()} method.
*/
class PlotDatum_2Test {
		
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true);
		assertEquals(Color.BLACK, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor2() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false);
		assertEquals(Color.BLACK, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor3() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		assertEquals(Color.BLACK, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor4() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		assertEquals(Color.BLACK, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor5() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setLineColor(Color.RED);
		assertEquals(Color.RED, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor6() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setLineColor(Color.RED);
		assertEquals(Color.RED, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor7() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setLineColor(Color.RED);
		plotDatum.setLineColor(Color.BLACK);
		assertEquals(Color.BLACK, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor8() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setLineColor(Color.RED);
		plotDatum.setLineColor(Color.BLACK);
		assertEquals(Color.BLACK, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor9() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setLineColor(Color.RED);
		plotDatum.setLineColor(Color.BLACK);
		plotDatum.setLineColor(Color.RED);
		assertEquals(Color.RED, plotDatum.getLineColor());
	}
	
	/**
	* Test case for {@link PlotDatum#getLineColor()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetLineColor10() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setLineColor(Color.RED);
		plotDatum.setLineColor(Color.BLACK);
		plotDatum.setLineColor(Color.RED);
		assertEquals(Color.RED, plotDatum.getLineColor());
	}
	
}

// PlotDatum_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#getPlotSymbol()} method.
*/
class PlotDatum_3Test {
		
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true);
		assertNull(plotDatum.getPlotSymbol());
	}
	
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol2() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false);
		assertNull(plotDatum.getPlotSymbol());
	}
	
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol3() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		assertEquals(new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0), plotDatum.getPlotSymbol());
	}
	
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol4() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		assertEquals(new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0), plotDatum.getPlotSymbol());
	}
	
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol5() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setPlotSymbol(new PlotSymbol(PlotSymbol.SQUARE, Color.RED, 1.0));
		assertEquals(new PlotSymbol(PlotSymbol.SQUARE, Color.RED, 1.0), plotDatum.getPlotSymbol());
	}
	
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol6() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setPlotSymbol(new PlotSymbol(PlotSymbol.SQUARE, Color.RED, 1.0));
		assertEquals(new PlotSymbol(PlotSymbol.SQUARE, Color.RED, 1.0), plotDatum.getPlotSymbol());
	}
	
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol7() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setPlotSymbol(new PlotSymbol(PlotSymbol.SQUARE, Color.RED, 1.0));
		plotDatum.setPlotSymbol(new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		assertEquals(new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0), plotDatum.getPlotSymbol());
	}
	
	/**
	* Test case for {@link PlotDatum#getPlotSymbol()} method.
	* Test if the method returns the correct value.
	*/
	@Test
	void testGetPlotSymbol8() {
		PlotDatum plotDatum = new PlotDatum(1.0, 1.0, false, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1.0));
		plotDatum.setPlotSymbol(new PlotSymbol(PlotSymbol.SQUARE, Color.RED, 1.0));
		plotDatum.setPlotSymbol(new PlotSymbol(PlotSy"
cmpl-6twwRr0TA4g9R2K3hLfOIBUOwQ4HK,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotDatum_2Test.java,52.6337456703186,stop,"// PlotDatum.java
/*
*   PlotDatum  -- Represents a single data point on a 2D plot.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;

/**
 *  <p> This class represents a single data point on a plot
 *      and includes all the information required by each point.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  June 1, 2000
 *  @version November 20, 2000
 */
public class PlotDatum extends Object implements Cloneable, java.io.Serializable {

    /**
     *  The X and Y coordinate points for this datum.
     */
    public double x, y;

    /**
     *  The error on the Y value.
     */
    private double yErr;

    /**
     *  A flag that indicates if there is an error bar.
     */
    private boolean errBarFlg = false;

    /**
     *  Flag that indicates if this point connects to the previous point.
     */
    private boolean conFlg;

    /**
     *  The line type for the line connecting this point to the previous point.
     *  This is not yet implemented!  Waiting until I learn Java2D.
     */
    //	private int lineMode;
    /**
     *  The line color used to connect this point to the previous one.
     */
    private Color lineColor = Color.black;

    /**
     *  The plot symbol used by this datum.
     */
    private PlotSymbol symbol = null;

    //-------------------------------------------------------------------------
    /**
     *  Create a new datum (plot coordinate point) given the specified
     *  X and Y values.  This datum will, by default, have no error bar.
     *
     *  @param xValue  The X coordinate value for this datum point.
     *  @param yValue  The Y coordinate value for this datum point.
     *  @param connected  A flag that indicates that this datum is connected
     *                    to the previous one if true, no line is drawn
     *                    to the previous datum if false.
     */
    public PlotDatum(double xValue, double yValue, boolean connected) {
        super();
        x = xValue;
        y = yValue;
        conFlg = connected;
    }

    /**
     *  Create a new datum (plot coordinate point) given the specified
     *  X and Y values and the given plot symbol.  This datum will, by
     *  default, have no error bar.
     *
     *  @param xValue  The X coordinate value for this datum point.
     *  @param yValue  The Y coordinate value for this datum point.
     *  @param connected  A flag that indicates that this datum is connected
     *                    to the previous one if true, no line is drawn
     *                    to the previous datum if false.
     *  @param  symbol  The plot symbol to be used for this data point.
     */
    public PlotDatum(double xValue, double yValue, boolean connected, PlotSymbol symbol) {
        super();
        x = xValue;
        y = yValue;
        conFlg = connected;
        this.symbol = symbol;
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the X coordinate value of this point.
     */
    public double getX() {
        return x;
    }

    /**
     *  Return the Y coordinate value of this point.
     */
    public double getY() {
        return y;
    }

    /**
     *  Set the X coordinate value of this point.
     */
    public void setX(double value) {
        x = value;
    }

    /**
     *  Set the Y coordinate value of this point.
     */
    public void setY(double value) {
        y = value;
    }

    /**
     *  Set the error on Y value.
     */
    public void setYError(double err) {
        yErr = err;
        if (yErr == 0.)
            errBarFlg = false;
        else
            errBarFlg = true;
    }

    /**
     *  Get the error on Y value.
     */
    public double getYError() {
        return yErr;
    }

    /**
     *  Returns true if this data point has an error bar.
     */
    public boolean hasErrorBar() {
        return errBarFlg;
    }

    /**
     *  Set if this datum is connected to the previous one by a line or not.
     */
    public void setConnected(boolean flag) {
        conFlg = flag;
    }

    /**
     *  Return true if this datum is connected to the previous one by a line
     *  and false if it is not.
     */
    public boolean connected() {
        return conFlg;
    }

    /**
     *  Set the plot symbol used for this datum.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        this.symbol = symbol;
    }

    /**
     *  Returns a reference to the plot symbol used by
     *  this datum.
     */
    public PlotSymbol getPlotSymbol() {
        return symbol;
    }

    /**
     *  Set the color used for the line connecting this datum
     *  to the previous one.  If null is passed, the line is
     *  drawn in black.
     */
    public void setLineColor(Color color) {
        if (color != null)
            lineColor = color;
        else
            lineColor = Color.black;
    }

    /**
     *  Return the color to be used for drawing the line
     *  connecting this datum to the previous.
     */
    public Color getLineColor() {
        return lineColor;
    }

    /**
     *  Make a copy of this PlotDatum object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotDatum newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotDatum) super.clone();
            // Clone this object's data structures.
            if (this.symbol != null)
                newObject.symbol = (PlotSymbol) this.symbol.clone();
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotDatum_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#clone()} method.
*/
class PlotDatum_2Test {","// PlotDatum_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotDatum}.
* It contains ten unit test cases for the {@link PlotDatum#clone()} method.
*/
class PlotDatum_2Test {

	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone2() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone3() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone4() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		datum.setConnected(false);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone5() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		datum.setConnected(false);
		datum.setLineColor(Color.RED);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone6() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		datum.setConnected(false);
		datum.setLineColor(Color.RED);
		datum.setX(4.0);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone7() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		datum.setConnected(false);
		datum.setLineColor(Color.RED);
		datum.setX(4.0);
		datum.setY(5.0);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone8() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		datum.setConnected(false);
		datum.setLineColor(Color.RED);
		datum.setX(4.0);
		datum.setY(5.0);
		datum.setPlotSymbol(new PlotSymbol(PlotSymbol.SQUARE, Color.GREEN, 20));
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone9() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		datum.setConnected(false);
		datum.setLineColor(Color.RED);
		datum.setX(4.0);
		datum.setY(5.0);
		datum.setPlotSymbol(new PlotSymbol(PlotSymbol.SQUARE, Color.GREEN, 20));
		datum.setYError(6.0);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
	/**
	* Test case for {@link PlotDatum#clone()}.
	*/
	@Test
	void testClone10() {
		PlotDatum datum = new PlotDatum(1.0, 2.0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		datum.setYError(3.0);
		datum.setConnected(false);
		datum.setLineColor(Color.RED);
		datum.setX(4.0);
		datum.setY(5.0);
		datum.setPlotSymbol(new PlotSymbol(PlotSymbol.SQUARE, Color.GREEN, 20));
		datum.setYError(6.0);
		datum.setConnected(true);
		PlotDatum clone = (PlotDatum) datum.clone();
		assertEquals(datum.getX(), clone.getX());
		assertEquals(datum.getY(), clone.getY());
		assertEquals(datum.connected(), clone.connected());
		assertEquals(datum.getLineColor(), clone.getLineColor());
		assertEquals(datum.getPlotSymbol(), clone.getPlotSymbol());
		assertEquals(datum.getYError(), clone.getYError());
		assertEquals(datum.hasErrorBar(), clone.hasErrorBar());
	}
	
}"
cmpl-6twxUYaGtZhIwXhrz8bJRq01UJDV6,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_0Test.java,93.2351598739624,length,"// PlotRunList.java
/*
*   PlotRunList  -- Container for a list of runs to be plotted.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a list of runs of data in a plot.
 *      A run is an array or list of PlotDatum objects.  A run
 *      list is an array or list of runs.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version November 20, 2000
 */
public class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The run objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run list that contains no runs.
     */
    public PlotRunList() {
    }

    /**
     *  Create a run list that contains the specified
     *  array of PlotRun objects.
     *
     *  @param run  An array of PlotRun objects that make up a list
     *              of runs to be plotted.
     */
    public PlotRunList(PlotRun[] runArr) {
        int length = runArr.length;
        for (int i = 0; i < length; ++i) data.add(runArr[i]);
    }

    /**
     *  Create a runlist  that contains the PlotRun objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotRun objects.
     */
    public PlotRunList(Collection runs) {
        if (runs instanceof PlotRunList)
            data.addAll(runs);
        else {
            for (Iterator i = runs.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotRun)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this
     *  run list.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinX());
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this
     *  run list.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxX());
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this
     *  run list.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinY());
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this
     *  run list.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxY());
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotRun objects in this run list.
     *
     *  @return The number of plot run objects in this run list.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotRun object at the specified position
     *  in this run list.
     *
     *  @param   index  The index of the plot run object to return.
     *  @return  The PlotRun object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot run element at the specified position
     *  in this run list with the specified run.
     *
     *  @param   index   The index of the data run to replace.
     *  @param   element The run to be stored a the specified position.
     *  @return  The run previously at the specified position in this list.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotRun type object.
     */
    public Object set(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot run element at the specified
     *  position in this run list.  Shifts the plot run element
     *  currently at that position (if any) and any subsequent
     *  runs to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified run is to be
     *                  inserted.
     *  @param  element PlotRun object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotRun type object.
     */
    public void add(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot run object at the specified position in
     *  this run list.  Shifts any subsequent run elements
     *  to the left (subtracts one from their indices).  Returns the
     *  run element that was removed from this run list.
     *
     *  @param   index  The index of the plot run element to remove.
     *  @return  The PlotRun object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot run elements from this run list.
     *  The run list will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot run elements in
     *  this run list.
     *
     *  @return An interation of all the PlotRun objects in this list.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRunList object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRunList newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRunList) super.clone();
            // Now clone the runs attached to this list.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object run = ((PlotRun) this.data.get(i)).clone();
                newObject.data.add(run);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRunList_0Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#size()} method.
*/
class PlotRunList_0Test {","// PlotRunList_0Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#size()} method.
*/
class PlotRunList_0Test {

	/**
	* Test case for {@link PlotRunList#size()}.
	*/
	@Test
	void testSize() {
		PlotRunList runList = new PlotRunList();
		assertEquals(0, runList.size());
		
		PlotRun[] runArr = new PlotRun[0];
		runList = new PlotRunList(runArr);
		assertEquals(0, runList.size());
		
		runArr = new PlotRun[1];
		runArr[0] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(1, runList.size());
		
		runArr = new PlotRun[2];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(2, runList.size());
		
		runArr = new PlotRun[3];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(3, runList.size());
		
		runArr = new PlotRun[4];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(4, runList.size());
		
		runArr = new PlotRun[5];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(5, runList.size());
		
		runArr = new PlotRun[6];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(6, runList.size());
		
		runArr = new PlotRun[7];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(7, runList.size());
		
		runArr = new PlotRun[8];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runArr[7] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(8, runList.size());
		
		runArr = new PlotRun[9];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runArr[7] = new PlotRun();
		runArr[8] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(9, runList.size());
		
		runArr = new PlotRun[10];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runArr[7] = new PlotRun();
		runArr[8] = new PlotRun();
		runArr[9] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(10, runList.size());
	}
}

// PlotRunList_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#get(int)} method.
*/
class PlotRunList_1Test {
		
	/**
	* Test case for {@link PlotRunList#get(int)}.
	*/
	@Test
	void testGet() {
		PlotRunList runList = new PlotRunList();
		assertEquals(null, runList.get(0));
		
		PlotRun[] runArr = new PlotRun[0];
		runList = new PlotRunList(runArr);
		assertEquals(null, runList.get(0));
		
		runArr = new PlotRun[1];
		runArr[0] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		
		runArr = new PlotRun[2];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		
		runArr = new PlotRun[3];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		
		runArr = new PlotRun[4];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		assertEquals(runArr[3], runList.get(3));
		
		runArr = new PlotRun[5];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		assertEquals(runArr[3], runList.get(3));
		assertEquals(runArr[4], runList.get(4));
		
		runArr = new PlotRun[6];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		assertEquals(runArr[3], runList.get(3));
		assertEquals(runArr[4], runList.get(4));
		assertEquals(runArr[5], runList.get(5));
		
		runArr = new PlotRun[7];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		assertEquals(runArr[3], runList.get(3));
		assertEquals(runArr[4], runList.get(4));
		assertEquals(runArr[5], runList.get(5));
		assertEquals(runArr[6], runList.get(6));
		
		runArr = new PlotRun[8];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runArr[7] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		assertEquals(runArr[3], runList.get(3));
		assertEquals(runArr[4], runList.get(4));
		assertEquals(runArr[5], runList.get(5));
		assertEquals(runArr[6], runList.get(6));
		assertEquals(runArr[7], runList.get(7));
		
		runArr = new PlotRun[9];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runArr[7] = new PlotRun();
		runArr[8] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		assertEquals(runArr[3], runList.get(3));
		assertEquals(runArr[4], runList.get(4));
		assertEquals(runArr[5], runList.get(5));
		assertEquals(runArr[6], runList.get(6));
		assertEquals(runArr[7], runList.get(7));
		assertEquals(runArr[8], runList.get(8));
		
		runArr = new PlotRun[10];
		runArr[0] = new PlotRun();
		runArr[1] = new PlotRun();
		runArr[2] = new PlotRun();
		runArr[3] = new PlotRun();
		runArr[4] = new PlotRun();
		runArr[5] = new PlotRun();
		runArr[6] = new PlotRun();
		runArr[7] = new PlotRun();
		runArr[8] = new PlotRun();
		runArr[9] = new PlotRun();
		runList = new PlotRunList(runArr);
		assertEquals(runArr[0], runList.get(0));
		assertEquals(runArr[1], runList.get(1));
		assertEquals(runArr[2], runList.get(2));
		assertEquals(runArr[3], runList.get(3));
		assertEquals(runArr[4], runList.get(4));
		assertEquals(runArr[5], runList.get(5));
		assertEquals(runArr[6], runList.get(6));
		assertEquals(runArr[7], runList.get(7));
		assertEquals(runArr[8], runList.get(8));
		assertEquals(runArr[9], runList.get(9));
	}
}

// PlotRunList_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#set(int, Object)} method.
*/
class PlotRunList_2Test {
		
	/**
	* Test case for {@link PlotRunList#set(int, Object)}.
	*/
	@Test
	void testSet() {
		PlotRunList runList = new PlotRunList();
		assertEquals(null, runList.set(0, new PlotRun()));
		
		PlotRun[] runArr = new PlotRun[0];
		runList = new PlotRunList(runArr);
		assertEquals(null, runList.set(0,"
cmpl-6twz0dva6kxKuijnQ3iD3206cJYKB,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_1Test.java,83.07421278953552,length,"// PlotRunList.java
/*
*   PlotRunList  -- Container for a list of runs to be plotted.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a list of runs of data in a plot.
 *      A run is an array or list of PlotDatum objects.  A run
 *      list is an array or list of runs.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version November 20, 2000
 */
public class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The run objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run list that contains no runs.
     */
    public PlotRunList() {
    }

    /**
     *  Create a run list that contains the specified
     *  array of PlotRun objects.
     *
     *  @param run  An array of PlotRun objects that make up a list
     *              of runs to be plotted.
     */
    public PlotRunList(PlotRun[] runArr) {
        int length = runArr.length;
        for (int i = 0; i < length; ++i) data.add(runArr[i]);
    }

    /**
     *  Create a runlist  that contains the PlotRun objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotRun objects.
     */
    public PlotRunList(Collection runs) {
        if (runs instanceof PlotRunList)
            data.addAll(runs);
        else {
            for (Iterator i = runs.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotRun)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this
     *  run list.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinX());
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this
     *  run list.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxX());
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this
     *  run list.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinY());
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this
     *  run list.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxY());
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotRun objects in this run list.
     *
     *  @return The number of plot run objects in this run list.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotRun object at the specified position
     *  in this run list.
     *
     *  @param   index  The index of the plot run object to return.
     *  @return  The PlotRun object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot run element at the specified position
     *  in this run list with the specified run.
     *
     *  @param   index   The index of the data run to replace.
     *  @param   element The run to be stored a the specified position.
     *  @return  The run previously at the specified position in this list.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotRun type object.
     */
    public Object set(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot run element at the specified
     *  position in this run list.  Shifts the plot run element
     *  currently at that position (if any) and any subsequent
     *  runs to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified run is to be
     *                  inserted.
     *  @param  element PlotRun object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotRun type object.
     */
    public void add(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot run object at the specified position in
     *  this run list.  Shifts any subsequent run elements
     *  to the left (subtracts one from their indices).  Returns the
     *  run element that was removed from this run list.
     *
     *  @param   index  The index of the plot run element to remove.
     *  @return  The PlotRun object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot run elements from this run list.
     *  The run list will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot run elements in
     *  this run list.
     *
     *  @return An interation of all the PlotRun objects in this list.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRunList object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRunList newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRunList) super.clone();
            // Now clone the runs attached to this list.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object run = ((PlotRun) this.data.get(i)).clone();
                newObject.data.add(run);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRunList_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#get(int)} method.
*/
class PlotRunList_1Test {","// PlotRunList_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#get(int)} method.
*/
class PlotRunList_1Test {

	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_1() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_2() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_3() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_4() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_5() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_6() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_7() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_8() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_9() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#get(int)} method.
	*/
	@Test
	void testGet_10() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		assertEquals(run, runList.get(0));
	}
	
}

// PlotRunList_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#set(int, Object)} method.
*/
class PlotRunList_2Test {
		
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_1() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_2() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_3() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_4() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_5() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_6() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_7() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_8() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_9() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#set(int, Object)} method.
	*/
	@Test
	void testSet_10() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		PlotRun run2 = new PlotRun();
		runList.set(0, run2);
		assertEquals(run2, runList.get(0));
	}
	
}

// PlotRunList_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#add(int, Object)} method.
*/
class PlotRunList_3Test {
		
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_1() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_2() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_3() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_4() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_5() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_6() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_7() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_8() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_9() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
	/**
	* Test case for {@link PlotRunList#add(int, Object)} method.
	*/
	@Test
	void testAdd_10() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(0, run);
		assertEquals(run, runList.get(0));
	}
	
}

// PlotRunList_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_4Test {
		
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove_1() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
	
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove_2() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
	
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove_3() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
	
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove_4() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
	
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove_5() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		runList.add(run);
		runList."
cmpl-6tx0LGJaBDxgqy2wvEvMvtmeOu8Cg,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_2Test.java,113.88778614997864,length,"// PlotRunList.java
/*
*   PlotRunList  -- Container for a list of runs to be plotted.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a list of runs of data in a plot.
 *      A run is an array or list of PlotDatum objects.  A run
 *      list is an array or list of runs.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version November 20, 2000
 */
public class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The run objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run list that contains no runs.
     */
    public PlotRunList() {
    }

    /**
     *  Create a run list that contains the specified
     *  array of PlotRun objects.
     *
     *  @param run  An array of PlotRun objects that make up a list
     *              of runs to be plotted.
     */
    public PlotRunList(PlotRun[] runArr) {
        int length = runArr.length;
        for (int i = 0; i < length; ++i) data.add(runArr[i]);
    }

    /**
     *  Create a runlist  that contains the PlotRun objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotRun objects.
     */
    public PlotRunList(Collection runs) {
        if (runs instanceof PlotRunList)
            data.addAll(runs);
        else {
            for (Iterator i = runs.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotRun)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this
     *  run list.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinX());
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this
     *  run list.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxX());
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this
     *  run list.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinY());
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this
     *  run list.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxY());
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotRun objects in this run list.
     *
     *  @return The number of plot run objects in this run list.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotRun object at the specified position
     *  in this run list.
     *
     *  @param   index  The index of the plot run object to return.
     *  @return  The PlotRun object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot run element at the specified position
     *  in this run list with the specified run.
     *
     *  @param   index   The index of the data run to replace.
     *  @param   element The run to be stored a the specified position.
     *  @return  The run previously at the specified position in this list.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotRun type object.
     */
    public Object set(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot run element at the specified
     *  position in this run list.  Shifts the plot run element
     *  currently at that position (if any) and any subsequent
     *  runs to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified run is to be
     *                  inserted.
     *  @param  element PlotRun object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotRun type object.
     */
    public void add(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot run object at the specified position in
     *  this run list.  Shifts any subsequent run elements
     *  to the left (subtracts one from their indices).  Returns the
     *  run element that was removed from this run list.
     *
     *  @param   index  The index of the plot run element to remove.
     *  @return  The PlotRun object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot run elements from this run list.
     *  The run list will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot run elements in
     *  this run list.
     *
     *  @return An interation of all the PlotRun objects in this list.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRunList object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRunList newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRunList) super.clone();
            // Now clone the runs attached to this list.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object run = ((PlotRun) this.data.get(i)).clone();
                newObject.data.add(run);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRunList_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_2Test {","// PlotRunList_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_2Test {

	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0));
		run.add(new PlotDatum(2.0, 3.0));
		run.add(new PlotDatum(3.0, 4.0));
		run.add(new PlotDatum(4.0, 5.0));
		run.add(new PlotDatum(5.0, 6.0));
		run.add(new PlotDatum(6.0, 7.0));
		run.add(new PlotDatum(7.0, 8.0));
		run.add(new PlotDatum(8.0, 9.0));
		run.add(new PlotDatum(9.0, 10.0));
		run.add(new PlotDatum(10.0, 11.0));
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
}

// PlotRunList_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_3Test {
		
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0));
		run.add(new PlotDatum(2.0, 3.0));
		run.add(new PlotDatum(3.0, 4.0));
		run.add(new PlotDatum(4.0, 5.0));
		run.add(new PlotDatum(5.0, 6.0));
		run.add(new PlotDatum(6.0, 7.0));
		run.add(new PlotDatum(7.0, 8.0));
		run.add(new PlotDatum(8.0, 9.0));
		run.add(new PlotDatum(9.0, 10.0));
		run.add(new PlotDatum(10.0, 11.0));
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
}

// PlotRunList_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_4Test {
		
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0));
		run.add(new PlotDatum(2.0, 3.0));
		run.add(new PlotDatum(3.0, 4.0));
		run.add(new PlotDatum(4.0, 5.0));
		run.add(new PlotDatum(5.0, 6.0));
		run.add(new PlotDatum(6.0, 7.0));
		run.add(new PlotDatum(7.0, 8.0));
		run.add(new PlotDatum(8.0, 9.0));
		run.add(new PlotDatum(9.0, 10.0));
		run.add(new PlotDatum(10.0, 11.0));
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
}

// PlotRunList_5Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_5Test {
		
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0));
		run.add(new PlotDatum(2.0, 3.0));
		run.add(new PlotDatum(3.0, 4.0));
		run.add(new PlotDatum(4.0, 5.0));
		run.add(new PlotDatum(5.0, 6.0));
		run.add(new PlotDatum(6.0, 7.0));
		run.add(new PlotDatum(7.0, 8.0));
		run.add(new PlotDatum(8.0, 9.0));
		run.add(new PlotDatum(9.0, 10.0));
		run.add(new PlotDatum(10.0, 11.0));
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
		runList.add(run);
		runList.remove(0);
		assertEquals(0, runList.size());
	}
}

// PlotRunList_6Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_6Test {
		
	/**
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	* Test case for {@link PlotRunList#remove(int)} method.
	*/
	@Test
	void testRemove() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0));
		run.add(new PlotDatum(2.0, 3.0));
		run.add(new PlotDatum(3.0, 4.0));
		run.add(new PlotDatum(4.0, 5.0));
		run.add(new PlotDatum(5.0, 6.0));
		run.add(new PlotDatum(6.0, 7.0));
		run.add(new PlotDatum(7.0, 8.0));
		run.add(new PlotDatum(8.0, 9.0));
		run.add(new PlotDatum(9.0,"
cmpl-6tx2AJL4SVU2PoIqVmPRkUtmMq4TR,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_3Test.java,89.22573137283325,length,"// PlotRunList.java
/*
*   PlotRunList  -- Container for a list of runs to be plotted.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a list of runs of data in a plot.
 *      A run is an array or list of PlotDatum objects.  A run
 *      list is an array or list of runs.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version November 20, 2000
 */
public class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The run objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run list that contains no runs.
     */
    public PlotRunList() {
    }

    /**
     *  Create a run list that contains the specified
     *  array of PlotRun objects.
     *
     *  @param run  An array of PlotRun objects that make up a list
     *              of runs to be plotted.
     */
    public PlotRunList(PlotRun[] runArr) {
        int length = runArr.length;
        for (int i = 0; i < length; ++i) data.add(runArr[i]);
    }

    /**
     *  Create a runlist  that contains the PlotRun objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotRun objects.
     */
    public PlotRunList(Collection runs) {
        if (runs instanceof PlotRunList)
            data.addAll(runs);
        else {
            for (Iterator i = runs.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotRun)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this
     *  run list.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinX());
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this
     *  run list.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxX());
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this
     *  run list.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinY());
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this
     *  run list.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxY());
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotRun objects in this run list.
     *
     *  @return The number of plot run objects in this run list.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotRun object at the specified position
     *  in this run list.
     *
     *  @param   index  The index of the plot run object to return.
     *  @return  The PlotRun object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot run element at the specified position
     *  in this run list with the specified run.
     *
     *  @param   index   The index of the data run to replace.
     *  @param   element The run to be stored a the specified position.
     *  @return  The run previously at the specified position in this list.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotRun type object.
     */
    public Object set(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot run element at the specified
     *  position in this run list.  Shifts the plot run element
     *  currently at that position (if any) and any subsequent
     *  runs to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified run is to be
     *                  inserted.
     *  @param  element PlotRun object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotRun type object.
     */
    public void add(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot run object at the specified position in
     *  this run list.  Shifts any subsequent run elements
     *  to the left (subtracts one from their indices).  Returns the
     *  run element that was removed from this run list.
     *
     *  @param   index  The index of the plot run element to remove.
     *  @return  The PlotRun object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot run elements from this run list.
     *  The run list will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot run elements in
     *  this run list.
     *
     *  @return An interation of all the PlotRun objects in this list.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRunList object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRunList newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRunList) super.clone();
            // Now clone the runs attached to this list.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object run = ((PlotRun) this.data.get(i)).clone();
                newObject.data.add(run);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRunList_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#iterator()} method.
*/
class PlotRunList_3Test {","// PlotRunList_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#iterator()} method.
*/
class PlotRunList_3Test {

	/**
	* Test method for {@link PlotRunList#iterator()}.
	*/
	@Test
	void testIterator() {
		PlotRunList list = new PlotRunList();
		assertNotNull(list.iterator());
		assertFalse(list.iterator().hasNext());
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertNotNull(list.iterator());
		assertTrue(list.iterator().hasNext());
		assertEquals(run, list.iterator().next());
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertNotNull(list.iterator());
		assertTrue(list.iterator().hasNext());
		assertEquals(run, list.iterator().next());
		assertTrue(list.iterator().hasNext());
		assertEquals(run2, list.iterator().next());
		
		list.remove(run);
		assertNotNull(list.iterator());
		assertTrue(list.iterator().hasNext());
		assertEquals(run2, list.iterator().next());
		
		list.remove(run2);
		assertNotNull(list.iterator());
		assertFalse(list.iterator().hasNext());
	}
	
}

// PlotRunList_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#get(int)} method.
*/
class PlotRunList_4Test {
		
	/**
	* Test method for {@link PlotRunList#get(int)}.
	*/
	@Test
	void testGet() {
		PlotRunList list = new PlotRunList();
		assertThrows(IndexOutOfBoundsException.class, () -> list.get(0));
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(run, list.get(0));
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(run, list.get(0));
		assertEquals(run2, list.get(1));
		
		list.remove(run);
		assertEquals(run2, list.get(0));
		
		list.remove(run2);
		assertThrows(IndexOutOfBoundsException.class, () -> list.get(0));
	}
	
}

// PlotRunList_5Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#set(int, Object)} method.
*/
class PlotRunList_5Test {
		
	/**
	* Test method for {@link PlotRunList#set(int, Object)}.
	*/
	@Test
	void testSet() {
		PlotRunList list = new PlotRunList();
		assertThrows(IndexOutOfBoundsException.class, () -> list.set(0, new PlotRun()));
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(run, list.set(0, new PlotRun()));
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(run, list.set(0, new PlotRun()));
		assertEquals(run2, list.set(1, new PlotRun()));
		
		list.remove(run);
		assertEquals(run2, list.set(0, new PlotRun()));
		
		list.remove(run2);
		assertThrows(IndexOutOfBoundsException.class, () -> list.set(0, new PlotRun()));
	}
	
}

// PlotRunList_6Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#add(int, Object)} method.
*/
class PlotRunList_6Test {
		
	/**
	* Test method for {@link PlotRunList#add(int, Object)}.
	*/
	@Test
	void testAdd() {
		PlotRunList list = new PlotRunList();
		assertThrows(IndexOutOfBoundsException.class, () -> list.add(1, new PlotRun()));
		
		PlotRun run = new PlotRun();
		list.add(0, run);
		assertEquals(run, list.get(0));
		
		PlotRun run2 = new PlotRun();
		list.add(1, run2);
		assertEquals(run, list.get(0));
		assertEquals(run2, list.get(1));
		
		list.remove(run);
		assertEquals(run2, list.get(0));
		
		list.remove(run2);
		assertThrows(IndexOutOfBoundsException.class, () -> list.get(0));
	}
	
}

// PlotRunList_7Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#remove(int)} method.
*/
class PlotRunList_7Test {
		
	/**
	* Test method for {@link PlotRunList#remove(int)}.
	*/
	@Test
	void testRemove() {
		PlotRunList list = new PlotRunList();
		assertThrows(IndexOutOfBoundsException.class, () -> list.remove(0));
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(run, list.remove(0));
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(run, list.remove(0));
		assertEquals(run2, list.remove(0));
		
		list.remove(run);
		assertThrows(IndexOutOfBoundsException.class, () -> list.remove(0));
	}
	
}

// PlotRunList_8Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#clear()} method.
*/
class PlotRunList_8Test {
		
	/**
	* Test method for {@link PlotRunList#clear()}.
	*/
	@Test
	void testClear() {
		PlotRunList list = new PlotRunList();
		assertEquals(0, list.size());
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(1, list.size());
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(2, list.size());
		
		list.clear();
		assertEquals(0, list.size());
	}
	
}

// PlotRunList_9Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#clone()} method.
*/
class PlotRunList_9Test {
		
	/**
	* Test method for {@link PlotRunList#clone()}.
	*/
	@Test
	void testClone() {
		PlotRunList list = new PlotRunList();
		assertEquals(0, list.size());
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(1, list.size());
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(2, list.size());
		
		PlotRunList list2 = (PlotRunList) list.clone();
		assertEquals(2, list2.size());
		assertEquals(run, list2.get(0));
		assertEquals(run2, list2.get(1));
	}
	
}

// PlotRunList_10Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#getMinX()} method.
*/
class PlotRunList_10Test {
		
	/**
	* Test method for {@link PlotRunList#getMinX()}.
	*/
	@Test
	void testGetMinX() {
		PlotRunList list = new PlotRunList();
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run3 = new PlotRun();
		list.add(run3);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run4 = new PlotRun();
		list.add(run4);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run5 = new PlotRun();
		list.add(run5);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run6 = new PlotRun();
		list.add(run6);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run7 = new PlotRun();
		list.add(run7);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run8 = new PlotRun();
		list.add(run8);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run9 = new PlotRun();
		list.add(run9);
		assertEquals(Double.MAX_VALUE, list.getMinX());
		
		PlotRun run10 = new PlotRun();
		list.add(run10);
		assertEquals(Double.MAX_VALUE, list.getMinX());
	}
	
}

// PlotRunList_11Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#getMaxX()} method.
*/
class PlotRunList_11Test {
		
	/**
	* Test method for {@link PlotRunList#getMaxX()}.
	*/
	@Test
	void testGetMaxX() {
		PlotRunList list = new PlotRunList();
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run3 = new PlotRun();
		list.add(run3);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run4 = new PlotRun();
		list.add(run4);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run5 = new PlotRun();
		list.add(run5);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run6 = new PlotRun();
		list.add(run6);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run7 = new PlotRun();
		list.add(run7);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run8 = new PlotRun();
		list.add(run8);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run9 = new PlotRun();
		list.add(run9);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
		
		PlotRun run10 = new PlotRun();
		list.add(run10);
		assertEquals(Double.MIN_VALUE, list.getMaxX());
	}
	
}

// PlotRunList_12Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#getMinY()} method.
*/
class PlotRunList_12Test {
		
	/**
	* Test method for {@link PlotRunList#getMinY()}.
	*/
	@Test
	void testGetMinY() {
		PlotRunList list = new PlotRunList();
		assertEquals(Double.MAX_VALUE, list.getMinY());
		
		PlotRun run = new PlotRun();
		list.add(run);
		assertEquals(Double.MAX_VALUE, list.getMinY());
		
		PlotRun run2 = new PlotRun();
		list.add(run2);
		assertEquals(Double.MAX_VALUE, list.getMinY());
		
		PlotRun run3 = new PlotRun();
		list.add(run3);
		assertEquals(Double.MAX_VALUE, list.getMinY());
		
		PlotRun run4 = new PlotRun();
		list."
cmpl-6tx3cLaNzY0Xp9PZ1RiBStbNIbopX,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRunList_4Test.java,85.99923372268677,length,"// PlotRunList.java
/*
*   PlotRunList  -- Container for a list of runs to be plotted.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a list of runs of data in a plot.
 *      A run is an array or list of PlotDatum objects.  A run
 *      list is an array or list of runs.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version November 20, 2000
 */
public class PlotRunList extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The run objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run list that contains no runs.
     */
    public PlotRunList() {
    }

    /**
     *  Create a run list that contains the specified
     *  array of PlotRun objects.
     *
     *  @param run  An array of PlotRun objects that make up a list
     *              of runs to be plotted.
     */
    public PlotRunList(PlotRun[] runArr) {
        int length = runArr.length;
        for (int i = 0; i < length; ++i) data.add(runArr[i]);
    }

    /**
     *  Create a runlist  that contains the PlotRun objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotRun objects.
     */
    public PlotRunList(Collection runs) {
        if (runs instanceof PlotRunList)
            data.addAll(runs);
        else {
            for (Iterator i = runs.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotRun)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this
     *  run list.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinX());
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this
     *  run list.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxX());
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this
     *  run list.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            min = Math.min(min, run.getMinY());
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this
     *  run list.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            max = Math.max(max, run.getMaxY());
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in all the runs in this run list.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotRun run = (PlotRun) i.next();
            run.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotRun objects in this run list.
     *
     *  @return The number of plot run objects in this run list.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotRun object at the specified position
     *  in this run list.
     *
     *  @param   index  The index of the plot run object to return.
     *  @return  The PlotRun object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot run element at the specified position
     *  in this run list with the specified run.
     *
     *  @param   index   The index of the data run to replace.
     *  @param   element The run to be stored a the specified position.
     *  @return  The run previously at the specified position in this list.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotRun type object.
     */
    public Object set(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot run element at the specified
     *  position in this run list.  Shifts the plot run element
     *  currently at that position (if any) and any subsequent
     *  runs to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified run is to be
     *                  inserted.
     *  @param  element PlotRun object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotRun type object.
     */
    public void add(int index, Object element) {
        PlotRun obj = (PlotRun) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot run object at the specified position in
     *  this run list.  Shifts any subsequent run elements
     *  to the left (subtracts one from their indices).  Returns the
     *  run element that was removed from this run list.
     *
     *  @param   index  The index of the plot run element to remove.
     *  @return  The PlotRun object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot run elements from this run list.
     *  The run list will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot run elements in
     *  this run list.
     *
     *  @return An interation of all the PlotRun objects in this list.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRunList object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRunList newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRunList) super.clone();
            // Now clone the runs attached to this list.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object run = ((PlotRun) this.data.get(i)).clone();
                newObject.data.add(run);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRunList_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#clone()} method.
*/
class PlotRunList_4Test {","// PlotRunList_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRunList}.
* It contains ten unit test cases for the {@link PlotRunList#clone()} method.
*/
class PlotRunList_4Test {

	/**
	* Test method for {@link PlotRunList#clone()}.
	*/
	@Test
	void testClone() {
		PlotRunList runList = new PlotRunList();
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0));
		run.add(new PlotDatum(3.0, 4.0));
		run.add(new PlotDatum(5.0, 6.0));
		run.setLineColor(Color.RED);
		run.setPlotSymbol(new PlotSymbol(PlotSymbol.CIRCLE, Color.BLUE, 10));
		runList.add(run);
		PlotRunList clone = (PlotRunList) runList.clone();
		assertEquals(runList.size(), clone.size());
		assertEquals(runList.get(0), clone.get(0));
		assertNotSame(runList.get(0), clone.get(0));
		assertEquals(runList.get(0).getClass(), clone.get(0).getClass());
		assertEquals(runList.get(0).hashCode(), clone.get(0).hashCode());
		assertEquals(runList.get(0).toString(), clone.get(0).toString());
		assertEquals(runList.get(0).getMinX(), clone.get(0).getMinX());
		assertEquals(runList.get(0).getMaxX(), clone.get(0).getMaxX());
		assertEquals(runList.get(0).getMinY(), clone.get(0).getMinY());
		assertEquals(runList.get(0).getMaxY(), clone.get(0).getMaxY());
		assertEquals(runList.get(0).getLineColor(), clone.get(0).getLineColor());
		assertEquals(runList.get(0).getPlotSymbol(), clone.get(0).getPlotSymbol());
		assertNotSame(runList.get(0).getPlotSymbol(), clone.get(0).getPlotSymbol());
		assertEquals(runList.get(0).getPlotSymbol().getClass(), clone.get(0).getPlotSymbol().getClass());
		assertEquals(runList.get(0).getPlotSymbol().hashCode(), clone.get(0).getPlotSymbol().hashCode());
		assertEquals(runList.get(0).getPlotSymbol().toString(), clone.get(0).getPlotSymbol().toString());
		assertEquals(runList.get(0).getPlotSymbol().getType(), clone.get(0).getPlotSymbol().getType());
		assertEquals(runList.get(0).getPlotSymbol().getColor(), clone.get(0).getPlotSymbol().getColor());
		assertEquals(runList.get(0).getPlotSymbol().getSize(), clone.get(0).getPlotSymbol().getSize());
		assertEquals(runList.get(0).getPlotSymbol().getLineWidth(), clone.get(0).getPlotSymbol().getLineWidth());
		assertEquals(runList.get(0).getPlotSymbol().getLineColor(), clone.get(0).getPlotSymbol().getLineColor());
		assertEquals(runList.get(0).getPlotSymbol().getFillColor(), clone.get(0).getPlotSymbol().getFillColor());
		assertEquals(runList.get(0).getPlotSymbol().getFillPattern(), clone.get(0).getPlotSymbol().getFillPattern());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternColor(), clone.get(0).getPlotSymbol().getFillPatternColor());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternSize(), clone.get(0).getPlotSymbol().getFillPatternSize());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineWidth(), clone.get(0).getPlotSymbol().getFillPatternLineWidth());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineColor(), clone.get(0).getPlotSymbol().getFillPatternLineColor());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDash(), clone.get(0).getPlotSymbol().getFillPatternLineDash());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashPhase(), clone.get(0).getPlotSymbol().getFillPatternLineDashPhase());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashOffset(), clone.get(0).getPlotSymbol().getFillPatternLineDashOffset());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths(), clone.get(0).getPlotSymbol().getFillPatternLineDashLengths());
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths().length, clone.get(0).getPlotSymbol().getFillPatternLineDashLengths().length);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[0], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[0]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[1], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[1]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[2], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[2]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[3], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[3]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[4], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[4]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[5], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[5]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[6], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[6]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[7], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[7]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[8], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[8]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[9], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[9]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[10], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[10]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[11], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[11]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[12], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[12]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[13], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[13]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[14], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[14]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[15], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[15]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[16], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[16]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[17], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[17]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[18], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[18]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[19], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[19]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[20], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[20]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[21], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[21]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[22], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[22]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[23], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[23]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[24], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[24]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[25], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[25]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[26], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[26]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[27], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[27]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[28], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[28]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[29], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[29]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[30], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[30]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[31], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[31]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[32], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[32]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[33], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[33]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[34], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[34]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[35], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[35]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[36], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[36]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[37], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[37]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[38], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[38]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[39], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[39]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[40], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[40]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[41], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[41]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[42], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[42]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[43], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[43]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[44], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[44]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[45], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[45]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[46], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[46]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[47], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[47]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[48], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[48]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[49], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[49]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[50], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[50]);
		assertEquals(runList.get(0).getPlotSymbol().getFillPatternLineDashLengths()[51], clone.get(0).getPlotSymbol().getFillPatternLineDashLengths()[51]);
		assertEquals(runList.get(0)."
cmpl-6tx50xNaV4vPw84q2scvu242B2Owi,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_0Test.java,96.14742016792297,length,"// PlotRun.java
/*
*   PlotRun  -- Container for a list of plot data points.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a single run of data in a plot.
 *      A run is an array or list of PlotDatum objects.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version December 12, 2000
 */
public class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The plot datum objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run that contains no data.
     */
    public PlotRun() {
    }

    /**
     *  Create a run that contains the specified array of PlotDatum objects.
     *
     *  @param run  An array of PlotDatum objects that make up a run of data
     *              to be plotted.
     */
    public PlotRun(PlotDatum[] run) {
        int length = run.length;
        for (int i = 0; i < length; ++i) data.add(run[i]);
    }

    /**
     *  Create a run from a set of Java arrays for the X & Y data.
     *
     *  @param  xArr  An array containing the X coordinates of the data points
     *                to be plotted.
     *  @param  yArr  An array containing the Y coordinates of the data points
     *                to be plotted.
     *  @param  connectFlg  Set to true to have the points in the X & Y arrays
     *                      connected by a line, false for them to not be connected.
     *  @param  symbol      The plot symbol to use for the plotted points.
     *
     *  @throws NullPointerException if either array is null.
     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the
     *          same length.
     */
    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {
        if (xArr == null || yArr == null)
            throw new NullPointerException();
        int length = xArr.length;
        if (yArr.length != length)
            throw new ArrayIndexOutOfBoundsException();
        for (int i = 0; i < length; ++i) {
            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));
        }
    }

    /**
     *  Create a run that contains the PlotDatum objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotDatum objects.
     */
    public PlotRun(Collection run) {
        if (run instanceof PlotRun)
            data.addAll(run);
        else {
            for (Iterator i = run.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotDatum)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this run.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.x);
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this run.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.x);
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this run.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.y);
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this run.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.y);
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in this run.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in this run.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotDatum objects in this run.
     *
     *  @return The number of plot data objects in this run.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotDatum object at the specified position
     *  in this run.
     *
     *  @param   index  The index of the plot data object to return.
     *  @return  The PlotDatum object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot data element at the specified position
     *  in this run with the specified datum.
     *
     *  @param   index   The index of the data element to replace.
     *  @param   element The datum to be stored a the specified position.
     *  @return  The datum previously at the specified position in this run.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotDatum type object.
     */
    public Object set(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot data element at the specified
     *  position in this run.  Shifts the plot data element
     *  currently at that position (if any) and any subsequent
     *  data elements to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified datum is to be
     *                  inserted.
     *  @param  element PlotDatum object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotDatum type object.
     */
    public void add(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot data object at the specified position in
     *  this run.  Shifts any subsequent data elements
     *  to the left (subtracts one from their indices).  Returns the
     *  data element that was removed from this run.
     *
     *  @param   index  The index of the plot data element to remove.
     *  @return  The PlotDatum object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot data elements from this run.
     *  The run will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot data elements in
     *  this run.
     *
     *  @return An interation of all the PlotDatum objects in this run.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRun object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRun newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRun) super.clone();
            // Now clone the data points attached to this run.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object datum = ((PlotDatum) this.data.get(i)).clone();
                newObject.data.add(datum);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRun_0Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#size()} method.
*/
class PlotRun_0Test {","// PlotRun_0Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#size()} method.
*/
class PlotRun_0Test {

	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_0() {
		PlotRun plotRun = new PlotRun();
		assertEquals(0, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_1() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(1, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_2() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(2, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_3() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(3, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_4() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(4, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_5() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(5, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_6() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(6, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_7() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(7, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_8() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(8, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_9() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(9, plotRun.size());
	}
	
	/**
	* Test case for {@link PlotRun#size()}.
	*/
	@Test
	void testSize_10() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(10, plotRun.size());
	}
	
}

// PlotRun_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#get(int)} method.
*/
class PlotRun_1Test {
		
	/**
	* Test case for {@link PlotRun#get(int)}.
	*/
	@Test
	void testGet_0() {
		PlotRun plotRun = new PlotRun();
		assertThrows(IndexOutOfBoundsException.class, () -> {
			plotRun.get(0);
		});
	}
	
	/**
	* Test case for {@link PlotRun#get(int)}.
	*/
	@Test
	void testGet_1() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)), plotRun.get(0));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)}.
	*/
	@Test
	void testGet_2() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		assertEquals(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)), plotRun.get(0));
		assertEquals(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)), plotRun.get(1));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)}.
	*/
	@Test
	void testGet_3() {
		PlotRun plotRun = new PlotRun();
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum(0.0, 0.0, true, new PlotSymbol(PlotSymbol.CROSS, Color.BLACK, 1.0f)));
		plotRun.add(new PlotDatum"
cmpl-6tx6YNI1JMVkyHPs5Q5THssAEWNMY,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_1Test.java,78.06480479240417,stop,"// PlotRun.java
/*
*   PlotRun  -- Container for a list of plot data points.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a single run of data in a plot.
 *      A run is an array or list of PlotDatum objects.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version December 12, 2000
 */
public class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The plot datum objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run that contains no data.
     */
    public PlotRun() {
    }

    /**
     *  Create a run that contains the specified array of PlotDatum objects.
     *
     *  @param run  An array of PlotDatum objects that make up a run of data
     *              to be plotted.
     */
    public PlotRun(PlotDatum[] run) {
        int length = run.length;
        for (int i = 0; i < length; ++i) data.add(run[i]);
    }

    /**
     *  Create a run from a set of Java arrays for the X & Y data.
     *
     *  @param  xArr  An array containing the X coordinates of the data points
     *                to be plotted.
     *  @param  yArr  An array containing the Y coordinates of the data points
     *                to be plotted.
     *  @param  connectFlg  Set to true to have the points in the X & Y arrays
     *                      connected by a line, false for them to not be connected.
     *  @param  symbol      The plot symbol to use for the plotted points.
     *
     *  @throws NullPointerException if either array is null.
     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the
     *          same length.
     */
    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {
        if (xArr == null || yArr == null)
            throw new NullPointerException();
        int length = xArr.length;
        if (yArr.length != length)
            throw new ArrayIndexOutOfBoundsException();
        for (int i = 0; i < length; ++i) {
            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));
        }
    }

    /**
     *  Create a run that contains the PlotDatum objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotDatum objects.
     */
    public PlotRun(Collection run) {
        if (run instanceof PlotRun)
            data.addAll(run);
        else {
            for (Iterator i = run.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotDatum)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this run.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.x);
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this run.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.x);
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this run.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.y);
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this run.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.y);
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in this run.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in this run.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotDatum objects in this run.
     *
     *  @return The number of plot data objects in this run.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotDatum object at the specified position
     *  in this run.
     *
     *  @param   index  The index of the plot data object to return.
     *  @return  The PlotDatum object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot data element at the specified position
     *  in this run with the specified datum.
     *
     *  @param   index   The index of the data element to replace.
     *  @param   element The datum to be stored a the specified position.
     *  @return  The datum previously at the specified position in this run.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotDatum type object.
     */
    public Object set(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot data element at the specified
     *  position in this run.  Shifts the plot data element
     *  currently at that position (if any) and any subsequent
     *  data elements to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified datum is to be
     *                  inserted.
     *  @param  element PlotDatum object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotDatum type object.
     */
    public void add(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot data object at the specified position in
     *  this run.  Shifts any subsequent data elements
     *  to the left (subtracts one from their indices).  Returns the
     *  data element that was removed from this run.
     *
     *  @param   index  The index of the plot data element to remove.
     *  @return  The PlotDatum object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot data elements from this run.
     *  The run will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot data elements in
     *  this run.
     *
     *  @return An interation of all the PlotDatum objects in this run.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRun object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRun newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRun) super.clone();
            // Now clone the data points attached to this run.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object datum = ((PlotDatum) this.data.get(i)).clone();
                newObject.data.add(datum);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRun_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#get(int)} method.
*/
class PlotRun_1Test {","// PlotRun_1Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#get(int)} method.
*/
class PlotRun_1Test {

	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_1() {
		PlotRun run = new PlotRun();
		assertEquals(0, run.size());
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.get(0);
		});
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_2() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		assertEquals(1, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_3() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		assertEquals(2, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_4() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		assertEquals(3, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_5() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		assertEquals(4, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_6() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		assertEquals(5, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.get(4));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_7() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		assertEquals(6, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.get(4));
		assertEquals(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE), run.get(5));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_8() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE));
		assertEquals(7, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.get(4));
		assertEquals(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE), run.get(5));
		assertEquals(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE), run.get(6));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_9() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE));
		assertEquals(8, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.get(4));
		assertEquals(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE), run.get(5));
		assertEquals(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE), run.get(6));
		assertEquals(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE), run.get(7));
	}
	
	/**
	* Test case for {@link PlotRun#get(int)} method.
	*/
	@Test
	void testGet_10() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(17.0, 18.0, true, PlotSymbol.CIRCLE));
		assertEquals(9, run.size());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.get(4));
		assertEquals(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE), run.get(5));
		assertEquals(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE), run.get(6));
		assertEquals(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE), run.get(7));
		assertEquals(new PlotDatum(17.0, 18.0, true, PlotSymbol.CIRCLE), run.get(8));
	}
	
}"
cmpl-6tx7oUlJFthLo7v9F1b59gVsCXQGo,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_2Test.java,85.66049814224243,length,"// PlotRun.java
/*
*   PlotRun  -- Container for a list of plot data points.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a single run of data in a plot.
 *      A run is an array or list of PlotDatum objects.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version December 12, 2000
 */
public class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The plot datum objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run that contains no data.
     */
    public PlotRun() {
    }

    /**
     *  Create a run that contains the specified array of PlotDatum objects.
     *
     *  @param run  An array of PlotDatum objects that make up a run of data
     *              to be plotted.
     */
    public PlotRun(PlotDatum[] run) {
        int length = run.length;
        for (int i = 0; i < length; ++i) data.add(run[i]);
    }

    /**
     *  Create a run from a set of Java arrays for the X & Y data.
     *
     *  @param  xArr  An array containing the X coordinates of the data points
     *                to be plotted.
     *  @param  yArr  An array containing the Y coordinates of the data points
     *                to be plotted.
     *  @param  connectFlg  Set to true to have the points in the X & Y arrays
     *                      connected by a line, false for them to not be connected.
     *  @param  symbol      The plot symbol to use for the plotted points.
     *
     *  @throws NullPointerException if either array is null.
     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the
     *          same length.
     */
    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {
        if (xArr == null || yArr == null)
            throw new NullPointerException();
        int length = xArr.length;
        if (yArr.length != length)
            throw new ArrayIndexOutOfBoundsException();
        for (int i = 0; i < length; ++i) {
            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));
        }
    }

    /**
     *  Create a run that contains the PlotDatum objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotDatum objects.
     */
    public PlotRun(Collection run) {
        if (run instanceof PlotRun)
            data.addAll(run);
        else {
            for (Iterator i = run.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotDatum)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this run.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.x);
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this run.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.x);
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this run.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.y);
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this run.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.y);
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in this run.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in this run.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotDatum objects in this run.
     *
     *  @return The number of plot data objects in this run.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotDatum object at the specified position
     *  in this run.
     *
     *  @param   index  The index of the plot data object to return.
     *  @return  The PlotDatum object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot data element at the specified position
     *  in this run with the specified datum.
     *
     *  @param   index   The index of the data element to replace.
     *  @param   element The datum to be stored a the specified position.
     *  @return  The datum previously at the specified position in this run.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotDatum type object.
     */
    public Object set(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot data element at the specified
     *  position in this run.  Shifts the plot data element
     *  currently at that position (if any) and any subsequent
     *  data elements to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified datum is to be
     *                  inserted.
     *  @param  element PlotDatum object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotDatum type object.
     */
    public void add(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot data object at the specified position in
     *  this run.  Shifts any subsequent data elements
     *  to the left (subtracts one from their indices).  Returns the
     *  data element that was removed from this run.
     *
     *  @param   index  The index of the plot data element to remove.
     *  @return  The PlotDatum object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot data elements from this run.
     *  The run will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot data elements in
     *  this run.
     *
     *  @return An interation of all the PlotDatum objects in this run.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRun object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRun newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRun) super.clone();
            // Now clone the data points attached to this run.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object datum = ((PlotDatum) this.data.get(i)).clone();
                newObject.data.add(datum);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRun_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#remove(int)} method.
*/
class PlotRun_2Test {","// PlotRun_2Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#remove(int)} method.
*/
class PlotRun_2Test {

	/**
	* Test case for {@link PlotRun#remove(int)} method.
	* Test case for {@link PlotRun#size()} method.
	* Test case for {@link PlotRun#get(int)} method.
	* Test case for {@link PlotRun#add(int, Object)} method.
	* Test case for {@link PlotRun#set(int, Object)} method.
	* Test case for {@link PlotRun#clear()} method.
	* Test case for {@link PlotRun#iterator()} method.
	* Test case for {@link PlotRun#clone()} method.
	*/
	@Test
	void testRemove() {
		PlotRun run = new PlotRun();
		assertEquals(0, run.size());
		assertThrows(IndexOutOfBoundsException.class, () -> run.get(0));
		assertThrows(IndexOutOfBoundsException.class, () -> run.remove(0));
		assertThrows(IndexOutOfBoundsException.class, () -> run.add(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		assertThrows(IndexOutOfBoundsException.class, () -> run.set(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		run.clear();
		assertEquals(0, run.size());
		assertFalse(run.iterator().hasNext());
		assertEquals(run, run.clone());
	}
	
	/**
	* Test case for {@link PlotRun#remove(int)} method.
	* Test case for {@link PlotRun#size()} method.
	* Test case for {@link PlotRun#get(int)} method.
	* Test case for {@link PlotRun#add(int, Object)} method.
	* Test case for {@link PlotRun#set(int, Object)} method.
	* Test case for {@link PlotRun#clear()} method.
	* Test case for {@link PlotRun#iterator()} method.
	* Test case for {@link PlotRun#clone()} method.
	*/
	@Test
	void testRemove2() {
		PlotRun run = new PlotRun();
		run.add(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		assertEquals(1, run.size());
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(0));
		assertThrows(IndexOutOfBoundsException.class, () -> run.get(1));
		assertThrows(IndexOutOfBoundsException.class, () -> run.remove(1));
		assertThrows(IndexOutOfBoundsException.class, () -> run.add(2, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		assertThrows(IndexOutOfBoundsException.class, () -> run.set(1, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		run.clear();
		assertEquals(0, run.size());
		assertFalse(run.iterator().hasNext());
		assertEquals(run, run.clone());
	}
	
	/**
	* Test case for {@link PlotRun#remove(int)} method.
	* Test case for {@link PlotRun#size()} method.
	* Test case for {@link PlotRun#get(int)} method.
	* Test case for {@link PlotRun#add(int, Object)} method.
	* Test case for {@link PlotRun#set(int, Object)} method.
	* Test case for {@link PlotRun#clear()} method.
	* Test case for {@link PlotRun#iterator()} method.
	* Test case for {@link PlotRun#clone()} method.
	*/
	@Test
	void testRemove3() {
		PlotRun run = new PlotRun();
		run.add(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(1, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		assertEquals(2, run.size());
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(0));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(1));
		assertThrows(IndexOutOfBoundsException.class, () -> run.get(2));
		assertThrows(IndexOutOfBoundsException.class, () -> run.remove(2));
		assertThrows(IndexOutOfBoundsException.class, () -> run.add(3, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		assertThrows(IndexOutOfBoundsException.class, () -> run.set(2, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		run.clear();
		assertEquals(0, run.size());
		assertFalse(run.iterator().hasNext());
		assertEquals(run, run.clone());
	}
	
	/**
	* Test case for {@link PlotRun#remove(int)} method.
	* Test case for {@link PlotRun#size()} method.
	* Test case for {@link PlotRun#get(int)} method.
	* Test case for {@link PlotRun#add(int, Object)} method.
	* Test case for {@link PlotRun#set(int, Object)} method.
	* Test case for {@link PlotRun#clear()} method.
	* Test case for {@link PlotRun#iterator()} method.
	* Test case for {@link PlotRun#clone()} method.
	*/
	@Test
	void testRemove4() {
		PlotRun run = new PlotRun();
		run.add(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(1, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(2, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		assertEquals(3, run.size());
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(0));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(1));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(2));
		assertThrows(IndexOutOfBoundsException.class, () -> run.get(3));
		assertThrows(IndexOutOfBoundsException.class, () -> run.remove(3));
		assertThrows(IndexOutOfBoundsException.class, () -> run.add(4, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		assertThrows(IndexOutOfBoundsException.class, () -> run.set(3, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		run.clear();
		assertEquals(0, run.size());
		assertFalse(run.iterator().hasNext());
		assertEquals(run, run.clone());
	}
	
	/**
	* Test case for {@link PlotRun#remove(int)} method.
	* Test case for {@link PlotRun#size()} method.
	* Test case for {@link PlotRun#get(int)} method.
	* Test case for {@link PlotRun#add(int, Object)} method.
	* Test case for {@link PlotRun#set(int, Object)} method.
	* Test case for {@link PlotRun#clear()} method.
	* Test case for {@link PlotRun#iterator()} method.
	* Test case for {@link PlotRun#clone()} method.
	*/
	@Test
	void testRemove5() {
		PlotRun run = new PlotRun();
		run.add(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(1, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(2, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(3, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		assertEquals(4, run.size());
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(0));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(1));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(2));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(3));
		assertThrows(IndexOutOfBoundsException.class, () -> run.get(4));
		assertThrows(IndexOutOfBoundsException.class, () -> run.remove(4));
		assertThrows(IndexOutOfBoundsException.class, () -> run.add(5, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		assertThrows(IndexOutOfBoundsException.class, () -> run.set(4, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		run.clear();
		assertEquals(0, run.size());
		assertFalse(run.iterator().hasNext());
		assertEquals(run, run.clone());
	}
	
	/**
	* Test case for {@link PlotRun#remove(int)} method.
	* Test case for {@link PlotRun#size()} method.
	* Test case for {@link PlotRun#get(int)} method.
	* Test case for {@link PlotRun#add(int, Object)} method.
	* Test case for {@link PlotRun#set(int, Object)} method.
	* Test case for {@link PlotRun#clear()} method.
	* Test case for {@link PlotRun#iterator()} method.
	* Test case for {@link PlotRun#clone()} method.
	*/
	@Test
	void testRemove6() {
		PlotRun run = new PlotRun();
		run.add(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(1, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(2, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(3, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(4, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		assertEquals(5, run.size());
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(0));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(1));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(2));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(3));
		assertEquals(new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)), run.get(4));
		assertThrows(IndexOutOfBoundsException.class, () -> run.get(5));
		assertThrows(IndexOutOfBoundsException.class, () -> run.remove(5));
		assertThrows(IndexOutOfBoundsException.class, () -> run.add(6, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		assertThrows(IndexOutOfBoundsException.class, () -> run.set(5, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1))));
		run.clear();
		assertEquals(0, run.size());
		assertFalse(run.iterator().hasNext());
		assertEquals(run, run.clone());
	}
	
	/**
	* Test case for {@link PlotRun#remove(int)} method.
	* Test case for {@link PlotRun#size()} method.
	* Test case for {@link PlotRun#get(int)} method.
	* Test case for {@link PlotRun#add(int, Object)} method.
	* Test case for {@link PlotRun#set(int, Object)} method.
	* Test case for {@link PlotRun#clear()} method.
	* Test case for {@link PlotRun#iterator()} method.
	* Test case for {@link PlotRun#clone()} method.
	*/
	@Test
	void testRemove7() {
		PlotRun run = new PlotRun();
		run.add(0, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(1, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(2, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add(3, new PlotDatum(0, 0, true, new PlotSymbol(PlotSymbol.CIRCLE, Color.BLACK, 1)));
		run.add("
cmpl-6tx9C91B0RbQ8KrdzZGQ22Jaj3Qu0,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_3Test.java,82.83035731315613,length,"// PlotRun.java
/*
*   PlotRun  -- Container for a list of plot data points.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a single run of data in a plot.
 *      A run is an array or list of PlotDatum objects.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version December 12, 2000
 */
public class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The plot datum objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run that contains no data.
     */
    public PlotRun() {
    }

    /**
     *  Create a run that contains the specified array of PlotDatum objects.
     *
     *  @param run  An array of PlotDatum objects that make up a run of data
     *              to be plotted.
     */
    public PlotRun(PlotDatum[] run) {
        int length = run.length;
        for (int i = 0; i < length; ++i) data.add(run[i]);
    }

    /**
     *  Create a run from a set of Java arrays for the X & Y data.
     *
     *  @param  xArr  An array containing the X coordinates of the data points
     *                to be plotted.
     *  @param  yArr  An array containing the Y coordinates of the data points
     *                to be plotted.
     *  @param  connectFlg  Set to true to have the points in the X & Y arrays
     *                      connected by a line, false for them to not be connected.
     *  @param  symbol      The plot symbol to use for the plotted points.
     *
     *  @throws NullPointerException if either array is null.
     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the
     *          same length.
     */
    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {
        if (xArr == null || yArr == null)
            throw new NullPointerException();
        int length = xArr.length;
        if (yArr.length != length)
            throw new ArrayIndexOutOfBoundsException();
        for (int i = 0; i < length; ++i) {
            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));
        }
    }

    /**
     *  Create a run that contains the PlotDatum objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotDatum objects.
     */
    public PlotRun(Collection run) {
        if (run instanceof PlotRun)
            data.addAll(run);
        else {
            for (Iterator i = run.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotDatum)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this run.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.x);
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this run.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.x);
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this run.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.y);
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this run.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.y);
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in this run.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in this run.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotDatum objects in this run.
     *
     *  @return The number of plot data objects in this run.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotDatum object at the specified position
     *  in this run.
     *
     *  @param   index  The index of the plot data object to return.
     *  @return  The PlotDatum object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot data element at the specified position
     *  in this run with the specified datum.
     *
     *  @param   index   The index of the data element to replace.
     *  @param   element The datum to be stored a the specified position.
     *  @return  The datum previously at the specified position in this run.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotDatum type object.
     */
    public Object set(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot data element at the specified
     *  position in this run.  Shifts the plot data element
     *  currently at that position (if any) and any subsequent
     *  data elements to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified datum is to be
     *                  inserted.
     *  @param  element PlotDatum object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotDatum type object.
     */
    public void add(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot data object at the specified position in
     *  this run.  Shifts any subsequent data elements
     *  to the left (subtracts one from their indices).  Returns the
     *  data element that was removed from this run.
     *
     *  @param   index  The index of the plot data element to remove.
     *  @return  The PlotDatum object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot data elements from this run.
     *  The run will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot data elements in
     *  this run.
     *
     *  @return An interation of all the PlotDatum objects in this run.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRun object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRun newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRun) super.clone();
            // Now clone the data points attached to this run.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object datum = ((PlotDatum) this.data.get(i)).clone();
                newObject.data.add(datum);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRun_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#iterator()} method.
*/
class PlotRun_3Test {","// PlotRun_3Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#iterator()} method.
*/
class PlotRun_3Test {

	/**
	* Test method for {@link PlotRun#iterator()}.
	*/
	@Test
	void testIterator() {
		PlotRun run = new PlotRun();
		Iterator<PlotDatum> it = run.iterator();
		assertFalse(it.hasNext());
		
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		it = run.iterator();
		assertTrue(it.hasNext());
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), it.next());
		assertTrue(it.hasNext());
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), it.next());
		assertTrue(it.hasNext());
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), it.next());
		assertTrue(it.hasNext());
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), it.next());
		assertTrue(it.hasNext());
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), it.next());
		assertFalse(it.hasNext());
	}
	
}

// PlotRun_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#get(int)} method.
*/
class PlotRun_4Test {
		
	/**
	* Test method for {@link PlotRun#get(int)}.
	*/
	@Test
	void testGet() {
		PlotRun run = new PlotRun();
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.get(0);
		});
		
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.get(4));
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.get(5);
		});
	}
	
}

// PlotRun_5Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#set(int, Object)} method.
*/
class PlotRun_5Test {
		
	/**
	* Test method for {@link PlotRun#set(int, Object)}.
	*/
	@Test
	void testSet() {
		PlotRun run = new PlotRun();
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.set(0, new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		});
		
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.set(0, new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE)));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.set(1, new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE)));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.set(2, new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE)));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.set(3, new PlotDatum(17.0, 18.0, true, PlotSymbol.CIRCLE)));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.set(4, new PlotDatum(19.0, 20.0, true, PlotSymbol.CIRCLE)));
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.set(5, new PlotDatum(21.0, 22.0, true, PlotSymbol.CIRCLE));
		});
		assertEquals(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(17.0, 18.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(19.0, 20.0, true, PlotSymbol.CIRCLE), run.get(4));
	}
	
}

// PlotRun_6Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#add(int, Object)} method.
*/
class PlotRun_6Test {
		
	/**
	* Test method for {@link PlotRun#add(int, Object)}.
	*/
	@Test
	void testAdd() {
		PlotRun run = new PlotRun();
		run.add(0, new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(1, new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(2, new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(3, new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(4, new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.get(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.get(1));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.get(2));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.get(3));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.get(4));
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.get(5);
		});
	}
	
}

// PlotRun_7Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#remove(int)} method.
*/
class PlotRun_7Test {
		
	/**
	* Test method for {@link PlotRun#remove(int)}.
	*/
	@Test
	void testRemove() {
		PlotRun run = new PlotRun();
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.remove(0);
		});
		
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		assertEquals(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE), run.remove(0));
		assertEquals(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE), run.remove(0));
		assertEquals(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE), run.remove(0));
		assertEquals(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE), run.remove(0));
		assertEquals(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE), run.remove(0));
		assertThrows(IndexOutOfBoundsException.class, () -> {
			run.remove(0);
		});
	}
	
}

// PlotRun_8Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#clear()} method.
*/
class PlotRun_8Test {
		
	/**
	* Test method for {@link PlotRun#clear()}.
	*/
	@Test
	void testClear() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.clear();
		assertEquals(0, run.size());
	}
	
}

// PlotRun_9Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#clone()} method.
*/
class PlotRun_9Test {
		
	/**
	* Test method for {@link PlotRun#clone()}.
	*/
	@Test
	void testClone() {
		PlotRun run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		PlotRun run2 = (PlotRun) run.clone();
		assertEquals(run, run2);
		assertNotSame(run, run2);
	}
	
}

// PlotSymbol.java
/*
*   PlotSymbol  -- Enumeration of the different plot symbols.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

/**
 *  <p> This class represents the different plot symbols that can be used
 *     "
cmpl-6txAWiZxl96n1xlzdI2R5O0N0UA7o,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/PlotRun_4Test.java,42.467865228652954,stop,"// PlotRun.java
/*
*   PlotRun  -- Container for a list of plot data points.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;

/**
 *  <p> This class represents a single run of data in a plot.
 *      A run is an array or list of PlotDatum objects.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 13, 2000
 *  @version December 12, 2000
 */
public class PlotRun extends AbstractList implements Cloneable, java.io.Serializable {

    /**
     *  The plot datum objects are stored in an ArrayList.
     */
    private List data = new ArrayList();

    //-------------------------------------------------------------------------
    /**
     *  Create an empty run that contains no data.
     */
    public PlotRun() {
    }

    /**
     *  Create a run that contains the specified array of PlotDatum objects.
     *
     *  @param run  An array of PlotDatum objects that make up a run of data
     *              to be plotted.
     */
    public PlotRun(PlotDatum[] run) {
        int length = run.length;
        for (int i = 0; i < length; ++i) data.add(run[i]);
    }

    /**
     *  Create a run from a set of Java arrays for the X & Y data.
     *
     *  @param  xArr  An array containing the X coordinates of the data points
     *                to be plotted.
     *  @param  yArr  An array containing the Y coordinates of the data points
     *                to be plotted.
     *  @param  connectFlg  Set to true to have the points in the X & Y arrays
     *                      connected by a line, false for them to not be connected.
     *  @param  symbol      The plot symbol to use for the plotted points.
     *
     *  @throws NullPointerException if either array is null.
     *  @throws ArrayIndexOutOfBoundsException if the X and Y arrays are not the
     *          same length.
     */
    public PlotRun(double[] xArr, double[] yArr, boolean connectFlg, PlotSymbol symbol) {
        if (xArr == null || yArr == null)
            throw new NullPointerException();
        int length = xArr.length;
        if (yArr.length != length)
            throw new ArrayIndexOutOfBoundsException();
        for (int i = 0; i < length; ++i) {
            data.add(new PlotDatum(xArr[i], yArr[i], connectFlg, symbol));
        }
    }

    /**
     *  Create a run that contains the PlotDatum objects in the specified
     *  Collection.
     *
     *  @param data  An Collection containing PlotDatum objects.
     */
    public PlotRun(Collection run) {
        if (run instanceof PlotRun)
            data.addAll(run);
        else {
            for (Iterator i = run.iterator(); i.hasNext(); ) {
                Object obj = i.next();
                if (obj instanceof PlotDatum)
                    data.add(obj);
            }
        }
    }

    //-------------------------------------------------------------------------
    /**
     *  Return the minimum X value of the data contained in this run.
     */
    public double getMinX() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.x);
        }
        return min;
    }

    /**
     *  Return the maximum X value of the data contained in this run.
     */
    public double getMaxX() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.x);
        }
        return max;
    }

    /**
     *  Return the minimum Y value of the data contained in this run.
     */
    public double getMinY() {
        double min = Double.MAX_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            min = Math.min(min, datum.y);
        }
        return min;
    }

    /**
     *  Return the maximum Y value of the data contained in this run.
     */
    public double getMaxY() {
        double max = Double.MIN_VALUE;
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            max = Math.max(max, datum.y);
        }
        return max;
    }

    /**
     *  Use this method to change the plot symbol used by all
     *  the plot data points in this run.
     */
    public void setPlotSymbol(PlotSymbol symbol) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setPlotSymbol(symbol);
        }
    }

    /**
     *  Use this method to change the line color used by all
     *  the plot data points in this run.
     */
    public void setLineColor(Color color) {
        for (Iterator i = data.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            datum.setLineColor(color);
        }
    }

    //**** Methods required to implement AbstractList  ******
    /**
     *  Returns the number of PlotDatum objects in this run.
     *
     *  @return The number of plot data objects in this run.
     */
    public int size() {
        return data.size();
    }

    /**
     *  Returns the PlotDatum object at the specified position
     *  in this run.
     *
     *  @param   index  The index of the plot data object to return.
     *  @return  The PlotDatum object at the specified position
     *           in this run.
     */
    public Object get(int index) {
        return data.get(index);
    }

    /**
     *  Replaces the plot data element at the specified position
     *  in this run with the specified datum.
     *
     *  @param   index   The index of the data element to replace.
     *  @param   element The datum to be stored a the specified position.
     *  @return  The datum previously at the specified position in this run.
     *  @throws  ClassCastException - if the specified element is not a
     *                                PlotDatum type object.
     */
    public Object set(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        return data.set(index, element);
    }

    /**
     *  Inserts the specified plot data element at the specified
     *  position in this run.  Shifts the plot data element
     *  currently at that position (if any) and any subsequent
     *  data elements to the right (adds one to their indices).
     *
     *  @param  index   Index at which the specified datum is to be
     *                  inserted.
     *  @param  element PlotDatum object to be inserted.
     *  @throws ClassCastException - if the specified element is not a
     *                               PlotDatum type object.
     */
    public void add(int index, Object element) {
        PlotDatum obj = (PlotDatum) element;
        data.add(index, element);
    }

    /**
     *  Remove the plot data object at the specified position in
     *  this run.  Shifts any subsequent data elements
     *  to the left (subtracts one from their indices).  Returns the
     *  data element that was removed from this run.
     *
     *  @param   index  The index of the plot data element to remove.
     *  @return  The PlotDatum object previously at the specified position.
     */
    public Object remove(int index) {
        return data.remove(index);
    }

    /**
     *  Removes all the plot data elements from this run.
     *  The run will be empty after this call returns
     *  (unless it throws an exception).
     */
    public void clear() {
        data.clear();
    }

    /**
     *  Return an enumeration of all the plot data elements in
     *  this run.
     *
     *  @return An interation of all the PlotDatum objects in this run.
     */
    public Iterator iterator() {
        return data.iterator();
    }

    /**
     *  Make a copy of this PlotRun object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        PlotRun newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (PlotRun) super.clone();
            // Now clone the data points attached to this run.
            newObject.data = new ArrayList();
            int size = this.data.size();
            for (int i = 0; i < size; ++i) {
                Object datum = ((PlotDatum) this.data.get(i)).clone();
                newObject.data.add(datum);
            }
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }
}
","// PlotRun_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#clone()} method.
*/
class PlotRun_4Test {","// PlotRun_4Test.java
package jahuwaldt.plot;

import java.awt.Color;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlotRun}.
* It contains ten unit test cases for the {@link PlotRun#clone()} method.
*/
class PlotRun_4Test {

	/**
	* Test method for {@link PlotRun#clone()}.
	*/
	@Test
	void testClone() {
		PlotRun run = new PlotRun();
		PlotRun clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun(new PlotDatum[] { new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE) });
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun(new double[] { 1.0, 2.0 }, new double[] { 3.0, 4.0 }, true, PlotSymbol.CIRCLE);
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun(Arrays.asList(new PlotDatum[] { new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE) }));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(17.0, 18.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
		
		run = new PlotRun();
		run.add(new PlotDatum(1.0, 2.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(3.0, 4.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(5.0, 6.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(7.0, 8.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(9.0, 10.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(11.0, 12.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(13.0, 14.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(15.0, 16.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(17.0, 18.0, true, PlotSymbol.CIRCLE));
		run.add(new PlotDatum(19.0, 20.0, true, PlotSymbol.CIRCLE));
		clone = (PlotRun) run.clone();
		assertEquals(run.size(), clone.size());
	}
}"
b46f37f5-9c98-4621-87e4-1edb6eca749e,/EvoSuiteBenchmark/29_apbsmem/src/main/java/jahuwaldt/plot/SimplePlotXY.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9658 tokens (5658 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// SimplePlotXY.java
/*
*   SimplePlotXY  -- Represents a simple X-Y scatter graph type data plot.
*
*   Copyright (C) 2000-2002 by Joseph A. Huwaldt <jhuwaldt@knology.net>.
*   All rights reserved.
*   
*   This library is free software; you can redistribute it and/or
*   modify it under the terms of the GNU Library General Public
*   License as published by the Free Software Foundation; either
*   version 2 of the License, or (at your option) any later version.
*   
*   This library is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*   Library General Public License for more details.
**/
package jahuwaldt.plot;

import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.text.NumberFormat;

/**
 *  <p> An object that represents a simple XY scatter
 *      graph type plot.  X is the horizontal axis
 *      and Y is the vertical axis.
 *  </p>
 *  <p> Grid styles, axis formats, and axis labels can
 *      be changed by accessing this object's axes and
 *      making the changes there.  Then call repaint()
 *      on the component containing this plot.
 *  </p>
 *  <p> The data being plotted can be
 *      changed by accessing this object's run list
 *      and making the changes to the runs and
 *      data points there.  Then call repaint()
 *      on the component containing this plot.
 *  </p>
 *
 *  <p>  Modified by:  Joseph A. Huwaldt  </p>
 *
 *  @author  Joseph A. Huwaldt   Date:  September 15, 2000
 *  @version December 2, 2000
 */
public class SimplePlotXY implements Plot2D {

    //	Debug flag.
    private static final boolean DEBUG = false;

    /**
     *  The title to be displayed across the top of the plot.
     */
    private String plotTitle;

    /**
     *  The list of runs plotted in this panel.
     */
    private PlotRunList runs = new PlotRunList();

    /**
     *  The X and Y axes for this plot.
     */
    private PlotAxis xAxis, yAxis;

    //-------------------------------------------------------------------------
    /**
     *  Only subclasses can access the default constructor.
     */
    protected SimplePlotXY() {
    }

    /**
     *  Creates an XY plot (scatter graph) using the data in
     *  the supplied run list.
     *
     *  @param  runList An list of runs of data points to be plotted.
     *  @param  title   The title to be displayed across the top
     *                  of the plot.
     *  @param  xLabel  The label to be displayed along the X-axis.
     *  @param  yLabel  The label to be displayed along the Y-axis.
     *  @param  xFormat The number format to be used for the X axis
     *                  tick mark labels.
     *  @param  yFormat The number format to be used for the Y axis
     *                  tick mark labels.
     */
    public SimplePlotXY(PlotRunList runList, String title, String xLabel, String yLabel, NumberFormat xFormat, NumberFormat yFormat) {
        plotTitle = title;
        runs = runList;
        //	Create our plot axes.
        xAxis = new PlotXAxis(xLabel, null, xFormat, PlotAxis.kMajorGrid);
        yAxis = new PlotYAxis(yLabel, null, yFormat, PlotAxis.kMajorGrid);
    }

    /**
     *  Creates an XY plot (scatter graph) using the supplied
     *  X and Y data values, titles, labels, and formats.
     *
     *  @param  xArr    An array of X coordinate values.
     *  @param  yArr    An array of Y coordinate values.
     *  @param  title   The title to be displayed across the top
     *                  of the plot.
     *  @param  xLabel  The label to be displayed along the X-axis.
     *  @param  yLabel  The label to be displayed along the Y-axis.
     *  @param  xFormat The number format to be used for the X axis
     *                  tick mark labels.
     *  @param  yFormat The number format to be used for the Y axis
     *                  tick mark labels.
     */
    public SimplePlotXY(double[] xArr, double[] yArr, String title, String xLabel, String yLabel, NumberFormat xFormat, NumberFormat yFormat) {
        plotTitle = title;
        createPlot(xArr, yArr, xLabel, yLabel, xFormat, yFormat, null);
    }

    /**
     *  Creates an XY plot (scatter graph) using the supplied
     *  X and Y data values, titles, labels, formats and plot symbols.
     *
     *  @param  xArr    An array of X coordinate values.
     *  @param  yArr    An array of Y coordinate values.
     *  @param  title   The title to be displayed across the top
     *                  of the plot.
     *  @param  xLabel  The label to be displayed along the X-axis.
     *  @param  yLabel  The label to be displayed along the Y-axis.
     *  @param  xFormat The number format to be used for the X axis
     *                  tick mark labels.
     *  @param  yFormat The number format to be used for the Y axis
     *                  tick mark labels.
     *  @param  symbol  The plot symbol to use for the data points in this plot.
     *                  If null is passed, no symbol will be drawn.
     */
    public SimplePlotXY(double[] xArr, double[] yArr, String title, String xLabel, String yLabel, NumberFormat xFormat, NumberFormat yFormat, PlotSymbol symbol) {
        plotTitle = title;
        createPlot(xArr, yArr, xLabel, yLabel, xFormat, yFormat, symbol);
    }

    private void createPlot(double[] xArr, double[] yArr, String xLabel, String yLabel, NumberFormat xFormat, NumberFormat yFormat, PlotSymbol symbol) {
        //	Create a single run of data.
        int numPoints = xArr.length;
        if (yArr.length != numPoints)
            throw new IllegalArgumentException(""Inconsistant array sizes."");
        //	Create a data run.
        PlotRun newRun = new PlotRun();
        //	Add each data point to the run.
        for (int i = 0; i < numPoints; ++i) {
            newRun.add(new PlotDatum(xArr[i], yArr[i], true, symbol));
        }
        //	Add this new run to this graph's run list.
        runs.add(newRun);
        //	Create our plot axes.
        xAxis = new PlotXAxis(xLabel, null, xFormat, PlotAxis.kMajorGrid);
        yAxis = new PlotYAxis(yLabel, null, yFormat, PlotAxis.kMajorGrid);
    }

    //-------------------------------------------------------------------------
    /**
     *  Returns the title assigned to this plot.
     */
    public String getTitle() {
        return plotTitle;
    }

    /**
     *  Set's the title assigned to this plot.
     */
    public void setTitle(String title) {
        plotTitle = title;
    }

    /**
     *  Return a reference to the plot's vertical or Y axis.
     */
    public PlotAxis getVerticalAxis() {
        return yAxis;
    }

    /**
     *  Set the plot's vertical or Y axis.
     */
    public void setVerticalAxis(PlotAxis axis) {
        yAxis = axis;
    }

    /**
     *  Return a reference to the plot's horizontal or X axis.
     */
    public PlotAxis getHorizontalAxis() {
        return xAxis;
    }

    /**
     *  Set the plot's horizontal or X axis.
     */
    public void setHorizontalAxis(PlotAxis axis) {
        xAxis = axis;
    }

    /**
     *  Return a reference to the list of data runs
     *  assigned to this plot.
     */
    public PlotRunList getRuns() {
        return runs;
    }

    /**
     *  Set the list of runs to be plotted in this plot.
     */
    public void setRuns(PlotRunList runList) {
        runs = runList;
    }

    /**
     *  Make a copy of this SimplePlotXY object.
     *
     *  @return  Returns a clone of this object.
     */
    public Object clone() {
        SimplePlotXY newObject = null;
        try {
            // Make a shallow copy of this object.
            newObject = (SimplePlotXY) super.clone();
            // Make a copy of this object's data structures.
            newObject.runs = (PlotRunList) this.runs.clone();
            newObject.xAxis = (PlotAxis) this.xAxis.clone();
            newObject.yAxis = (PlotAxis) this.yAxis.clone();
        } catch (CloneNotSupportedException e) {
            // Can't happen.
            e.printStackTrace();
        }
        // Output the newly cloned object.
        return newObject;
    }

    /**
     *  This method is called to render this plot to the
     *  specified graphics context within the specified bounding
     *  rectangle.
     *
     *  @param  gc      The graphics context we are drawing into.
     *  @param  comp    The component that we are drawing into.
     *  @param  bounds  The overall bounding rectangle we are drawing into
     *                  including the title and axis labels.  This is typically
     *                  the component bounding rectangle minus insets.
     */
    public void draw(Graphics gc, Component comp, Rectangle bounds) {
        //	Determine the bounds of the data to be plotted.
        xAxis.setAxisBounds(runs);
        yAxis.setAxisBounds(runs);
        // Find the bounds of the plot itself (minus labels).
        Rectangle plotBounds = findPlotBounds(bounds, xAxis, yAxis, plotTitle, gc);
        // Scale axes to the new plot data bounds.
        xAxis.setSize(plotBounds);
        yAxis.setSize(plotBounds);
        // Render this plot image.
        drawTitle(gc, bounds);
        drawAxesAndGrid(gc, comp, plotBounds);
        drawPlotData(gc, plotBounds);
    }

    /**
     *  Determines how much space is required for the plot title, axes,
     *  and labels and reduces the plot bounds accordingly.
     *
     *  @param  bounds     The overall bounding rectangle we are drawing into
     *                     including the title and axis labels.
     *  @param  xAxis      Reference to the plot's X axis.
     *  @param  yAxis      Reference to the plot's Y axis.
     *  @param  plotTitle  The title of the plot.
     *  @param  gc         The graphics context being used for rendering.
     *  @return A rectangle that defines the boundaries of the plot itself
     *          without the title, axes labels, etc.
     */
    private static Rectangle findPlotBounds(Rectangle bounds, PlotAxis xAxis, PlotAxis yAxis, String plotTitle, Graphics gc) {
        if (DEBUG)
            System.out.println(""In SimplePlotXY.findPlotBounds()..."");
        FontMetrics fm = null;
        int height = 0;
        int leading = 0;
        int width = 0;
        int offset = 0;
        //	Copy over overall bounds rectangle data.
        Rectangle plotBounds = new Rectangle(bounds.x, bounds.y, bounds.width, bounds.height);
        //	Make space for the plot title.
        if (plotTitle != null) {
            //	Retrieve information on the current font.
            Font currFont = gc.getFont();
            String fontName = currFont.getName();
            int fontSize = currFont.getSize();
            //	Enlarge the title text and make it bold.
            Font newFont = new Font(fontName, Font.BOLD, fontSize * 2);
            gc.setFont(newFont);
            //	Get info about the title font we are using
            fm = gc.getFontMetrics();
            height = fm.getHeight();
            leading = fm.getLeading();
            //	Lower top of plot enough to leave room for text.
            offset = height + leading + 1;
            plotBounds.y += offset;
            plotBounds.height -= offset;
            //	Restore the previous font.
            gc.setFont(currFont);
        }
        //	Make space for the X axis numbers and labels.
        //	Get info about the font we are using.
        fm = gc.getFontMetrics();
        height = fm.getHeight();
        leading = fm.getLeading();
        //	Raise bottom of plot enough to leave room for axis numbers.
        plotBounds.height -= height + leading + 1;
        //	Make room for X axis label.
        if (xAxis.getLabel() != null)
            plotBounds.height -= 1.5 * height;
        //	Move right bounds to allow room for the last X axis number
        //	to hang over.
        width = fm.stringWidth(xAxis.upperBoundsAsString());
        plotBounds.width -= width / 2 + 6;
        //	Make space for Y axis numbers and labels.
        //	Make room for the axis numbers.
        width = fm.stringWidth(yAxis.upperBoundsAsString());
        int width2 = fm.stringWidth(yAxis.lowerBoundsAsString());
        width = Math.max(width, width2);
        plotBounds.x += width + 4;
        plotBounds.width -= width + 4;
        plotBounds.y += height / 2;
        plotBounds.height -= height / 2;
        //	Make room for the axis label (if there is one).
        if (yAxis.getLabel() != null) {
            plotBounds.x += 1.5 * height;
            plotBounds.width -= 1.5 * height;
        }
        if (DEBUG)
            System.out.println(""    plotBounds = "" + plotBounds);
        return plotBounds;
    }

    /**
     *  Draw the plot title onto the plot.
     *
     *  @param  gc      The graphics context we are drawing into.
     *  @param  bounds  The overall bounding rectangle we are drawing into
     *                  including the title and axis labels.
     */
    private void drawTitle(Graphics gc, Rectangle bounds) {
        if (plotTitle != null && !plotTitle.equals("""")) {
            //	Retrieve information on the current font.
            Font currFont = gc.getFont();
            String fontName = currFont.getName();
            int fontSize = currFont.getSize();
            //	Enlarge the title text and make it bold.
            Font newFont = new Font(fontName, Font.BOLD, fontSize * 2);
            gc.setFont(newFont);
            //	Get info about the font we are using
            FontMetrics fm = gc.getFontMetrics();
            int textWidth = fm.stringWidth(plotTitle);
            //	Center the title in the frame.
            int xPos = bounds.width / 2 - textWidth / 2;
            int yPos = bounds.y + fm.getAscent() + fm.getLeading() + 1;
            //	Render the title.
            gc.drawString(plotTitle, xPos, yPos);
            //	Reset the font back to it's previous value.
            gc.setFont(currFont);
        }
    }

    /**
     *  Draw the plot's horizontal and vertical axes and
     *  grid lines (depending on grid style set for each
     *  axis).
     *
     *  @param  gc      The graphics context we are drawing into.
     *  @param  comp    The component that we are drawing into.
     *  @param  bounds  The bounding rectangle for the data area
     *                  of the plot (overall bounds minus area for titles,
     *                  labels, etc).
     */
    private void drawAxesAndGrid(Graphics gc, Component comp, Rectangle bounds) {
        //	Draw a box around the boundary of the plot.
        gc.drawRect(bounds.x, bounds.y, bounds.width, bounds.height);
        gc.drawRect(bounds.x + 1, bounds.y + 1, bounds.width - 2, bounds.height - 2);
        //	Draw the horizontal axis and grid.
        xAxis.draw(gc, comp, bounds);
        //	Draw the vertical axis and grid.
        yAxis.draw(gc, comp, bounds);
    }

    /**
     *  Loop over all the runs and render the data in
     *  each one in turn.
     *
     *  @param  gc      The graphics context we are drawing into.
     *  @param  bounds  The bounding rectangle for the data area
     *                  of the plot (overall bounds minus area for titles,
     *                  labels, etc).
     */
    private void drawPlotData(Graphics gc, Rectangle bounds) {
        if (runs != null && runs.size() > 0) {
            //	Loop over all the runs.
            for (Iterator i = runs.iterator(); i.hasNext(); ) {
                //	Extract the next run.
                PlotRun run = (PlotRun) i.next();
                if (run.size() > 0)
                    drawSingleRun(gc, bounds, run);
            }
        }
    }

    /**
     *  Loop over all the data points in a single run
     *  and render them to the plot.
     *
     *  @param  gc      The graphics context we are drawing into.
     *  @param  bounds  The bounding rectangle for the data area
     *                  of the plot (overall bounds minus area for titles,
     *                  labels, etc).
     *  @param  run     A single run of data to be plotted.
     */
    private void drawSingleRun(Graphics gc, Rectangle bounds, PlotRun run) {
        int xo = 0, yo = 0;
        boolean conFlg = false;
        Color saveColor = gc.getColor();
        //	Loop over all the data points to be plotted.
        for (Iterator i = run.iterator(); i.hasNext(); ) {
            PlotDatum datum = (PlotDatum) i.next();
            // Check for break in the line.
            conFlg &= datum.connected();
            //	Scale data points to screen coordinates.
            int xi = xAxis.scaleCoord(datum.x);
            int yi = yAxis.scaleCoord(datum.y);
            //	If this point falls outside the plot bounds, skip it.
            if (xi < bounds.x && xi > bounds.x + bounds.width && yi < bounds.y && yi > bounds.y + bounds.width) {
                conFlg = false;
                continue;
            }
            //	Is there an error bar to be drawn?
            if (datum.hasErrorBar()) {
                int topPos = bounds.y;
                int botPos = bounds.y + bounds.height;
                //	Deal with error bar.
                int yi1 = yAxis.scaleCoord(datum.y + datum.getYError());
                int yi2 = yAxis.scaleCoord(datum.y - datum.getYError());
                //	Start drawing the data point.
                //	Connect the center of the bar.
                if (conFlg) {
                    gc.setColor(datum.getLineColor());
                    gc.drawLine(xo, yo, xi, yi);
                    gc.setColor(saveColor);
                    xo = xi;
                    yo = yi;
                } else {
                    xo = xi;
                    yo = yi;
                }
                //	If error bar is off top or bottom, adjust.
                if (!bounds.contains(xi, yi1))
                    yi1 = topPos;
                if (!bounds.contains(xi, yi2))
                    yi2 = botPos;
                //	Height of error bar.
                int delta = yi1 - yi2;
                delta /= 5;
                int count = run.size();
                int bar = 3 * PlotAxis.kTick * (count + 10) / (3 * count + 10);
                int dbar = (bar < delta) ? bar : delta;
                int xi1 = (botPos < xi - dbar) ? xi - dbar : botPos;
                int xi2 = (topPos > xi + dbar) ? xi + dbar : topPos;
                //	Draw first segment of error bar.
                gc.drawLine(xi1, yi1, xi2, yi1);
                //	Draw 2nd segment of error bar.
                gc.drawLine(xi1, yi2, xi2, yi2);
                gc.drawLine(xi, yi1, xi, yi2);
            } else {
                //	Must not have an error bar.
                //	Just draw the line and point.
                if (conFlg) {
                    gc.setColor(datum.getLineColor());
                    gc.drawLine(xo, yo, xi, yi);
                    gc.setColor(saveColor);
                    xo = xi;
                    yo = yi;
                } else {
                    xo = xi;
                    yo = yi;
                }
            }
            //	Draw the plot symbol.
            PlotSymbol symbol = datum.getPlotSymbol();
            if (symbol != null)
                symbol.draw(gc, xi, yi);
            //	Prepare for next data point.
            conFlg = true;
        }
    }
}
","// SimplePlotXYTest.java
package jahuwaldt.plot;

import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.text.NumberFormat;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SimplePlotXY}.
* It contains ten unit test cases for the {@link SimplePlotXY#clone()} method.
*/
class SimplePlotXYTest {","// SimplePlotXYTest.java
package jahuwaldt.plot;

import java.awt.*;
import javax.swing.*;
import java.util.*;
import java.text.NumberFormat;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SimplePlotXY}.
* It contains ten unit test cases for the {@link SimplePlotXY#clone()} method.
*/
class SimplePlotXYTest {
"
