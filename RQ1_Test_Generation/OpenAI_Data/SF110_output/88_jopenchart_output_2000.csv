ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6ttEhwtHUKoqQwuqiNIUEsRjNzRPc,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/Axis.java,42.782294034957886,length,"// Axis.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Axis.java
    Created on 30. Juni 2001, 22:27
 */
package de.progra.charting;

import de.progra.charting.model.ChartDataModelConstraints;

/**
 * The CoordSystem contains two or possibly three Axis objects for the x-axis
 * and the at most two y-axis.
 * @author mueller
 * @version 1.0
 */
public class Axis {

    /**
     * Defines a horizontal x-axis.
     */
    public final static int HORIZONTAL = 1;

    /**
     * Defines a vertical y-axis.
     */
    public final static int VERTICAL = 2;

    /**
     * Defines a logarithmic scale.
     */
    public final static int LOGARITHMIC = 3;

    /**
     * Defines a linear scale.
     */
    public final static int LINEAR = 4;

    /**
     * The axis' alignment.
     */
    private int align = HORIZONTAL;

    ChartDataModelConstraints constraints;

    int length = Integer.MAX_VALUE;

    /**
     * Creates new Axis.
     * @param align the alignment of the axis.
     * @param c the ChartDataModelConstraints
     */
    public Axis(int align, ChartDataModelConstraints c) {
        if (align == HORIZONTAL || align == VERTICAL)
            this.align = align;
        this.constraints = c;
    }

    /**
     * Returns the alignment of the axis.
     * @return the alignment constant: <CODE>Axis.VERTICAL</CODE> or <CODE>Axis.HORIZONTAL</CODE>
     */
    public int getAlignment() {
        return align;
    }

    /**
     * Sets the Pixel length of the axis.
     * @param length the length in pixel
     */
    public void setLength(int length) {
        this.length = length;
    }

    /**
     * Returns length of the axis in pixels.
     * @return the length in pixels
     */
    public int getLength() {
        return length;
    }

    /**
     * Returns the point on the axis for a specific value.
     * If the axis is a x-axis and the column values are not numeric,
     * this isn't needed since then the axis can be divided into
     * equally long parts. This is a relative pixel distance to
     * the starting pixel of the axis.
     * @param value the double value to compute the pixel distance for
     * @return the pixel distance for the given value relative to the start of the axis
     */
    public double getPixelForValue(double value) {
        // if scale == linear
        if (getAlignment() == Axis.VERTICAL) {
            return (value - constraints.getMinimumValue().doubleValue()) / getPointToPixelRatio();
        } else {
            return (value - constraints.getMinimumColumnValue()) / getPointToPixelRatio();
        }
    }

    /**
     * Returns the ratio between a value unit and the screen pixels.
     * This is only useful for linear scales.
     * @return the ratio points / pixel length for the axis.
     */
    public double getPointToPixelRatio() {
        //System.out.println(""** constraints.getMaximumColumnValue() = ""+constraints.getMaximumColumnValue());
        if (getAlignment() == Axis.VERTICAL) {
            return (constraints.getMaximumValue().doubleValue() - constraints.getMinimumValue().doubleValue()) / length;
        } else
            return (constraints.getMaximumColumnValue() - constraints.getMinimumColumnValue()) / length;
    }
}
","// AxisTest.java
package de.progra.charting;

import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Axis}.
* It contains ten unit test cases for the {@link Axis#getPixelForValue(double)} method.
*/
class AxisTest {","// AxisTest.java
package de.progra.charting;

import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Axis}.
* It contains ten unit test cases for the {@link Axis#getPixelForValue(double)} method.
*/
class AxisTest {

		/**
		* Test case for {@link Axis#getPixelForValue(double)} with a linear scale.
		*/
		@Test
		void testGetPixelForValueLinear() {
				ChartDataModelConstraints c = new ChartDataModelConstraints(0, 10, 0, 10);
				Axis a = new Axis(Axis.VERTICAL, c);
				a.setLength(100);
				assertEquals(0, a.getPixelForValue(0), 0.001);
				assertEquals(10, a.getPixelForValue(1), 0.001);
				assertEquals(20, a.getPixelForValue(2), 0.001);
				assertEquals(30, a.getPixelForValue(3), 0.001);
				assertEquals(40, a.getPixelForValue(4), 0.001);
				assertEquals(50, a.getPixelForValue(5), 0.001);
				assertEquals(60, a.getPixelForValue(6), 0.001);
				assertEquals(70, a.getPixelForValue(7), 0.001);
				assertEquals(80, a.getPixelForValue(8), 0.001);
				assertEquals(90, a.getPixelForValue(9), 0.001);
				assertEquals(100, a.getPixelForValue(10), 0.001);
		}
		
		/**
		* Test case for {@link Axis#getPixelForValue(double)} with a logarithmic scale.
		*/
		@Test
		void testGetPixelForValueLogarithmic() {
				ChartDataModelConstraints c = new ChartDataModelConstraints(0, 10, 0, 10);
				Axis a = new Axis(Axis.VERTICAL, c);
				a.setLength(100);
				assertEquals(0, a.getPixelForValue(0), 0.001);
				assertEquals(10, a.getPixelForValue(1), 0.001);
				assertEquals(20, a.getPixelForValue(2), 0.001);
				assertEquals(30, a.getPixelForValue(3), 0.001);
				assertEquals(40, a.getPixelForValue(4), 0.001);
				assertEquals(50, a.getPixelForValue(5), 0.001);
				assertEquals(60, a.getPixelForValue(6), 0.001);
				assertEquals(70, a.getPixelForValue(7), 0.001);
				assertEquals(80, a.getPixelForValue(8), 0.001);
				assertEquals(90, a.getPixelForValue(9), 0.001);
				assertEquals(100, a.getPixelForValue(10), 0.001);
		}
		
		/**
		* Test case for {@link Axis#getPixelForValue(double)} with a linear scale and a negative minimum value.
		*/
		@Test
		void testGetPixelForValueLinearNegative() {
				ChartDataModelConstraints c = new ChartDataModelConstraints(-10, 10, -10, 10);
				Axis a = new Axis(Axis.VERTICAL, c);
				a.setLength(100);
				assertEquals(0, a.getPixelForValue(-10), 0.001);
				assertEquals(10, a.getPixelForValue(-9), 0.001);
				assertEquals(20, a.getPixelForValue(-8), 0.001);
				assertEquals(30, a.getPixelForValue(-7), 0.001);
				assertEquals(40, a.getPixelForValue(-6), 0.001);
				assertEquals(50, a.getPixelForValue(-5), 0.001);
				assertEquals(60, a.getPixelForValue(-4), 0.001);
				assertEquals(70, a.getPixelForValue(-3), 0.001);
				assertEquals(80, a.getPixelForValue(-2), 0.001);
				assertEquals(90, a.getPixelForValue(-1), 0.001);
				assertEquals(100, a.getPixelForValue(0), 0.001);
				assertEquals(90, a.getPixelForValue(1), 0.001);
				assertEquals(80, a.getPixelForValue(2), 0.001);
				assertEquals(70, a.getPixelForValue(3), 0.001);
				assertEquals(60, a.getPixelForValue(4), 0.001);
				assertEquals(50, a.getPixelForValue(5), 0.001);
				assertEquals(40, a.getPixelForValue(6), 0.001);
				assertEquals(30, a.getPixelForValue(7), 0.001);
				assertEquals(20, a.getPixelForValue(8), 0.001);
				assertEquals(10, a.getPixelForValue(9), 0.001);
				assertEquals(0, a.getPixelForValue(10), 0.001);
		}
		
		/**
		* Test case for {@link Axis#getPixelForValue(double)} with a logarithmic scale and a negative minimum value.
		*/
		@Test
		void testGetPixelForValueLogarithmicNegative() {
				ChartDataModelConstraints c = new ChartDataModelConstraints(-10, 10, -10, 10);
				Axis a = new Axis(Axis.VERTICAL, c);
				a.setLength(100);
				assertEquals(0, a.getPixelForValue(-10), 0.001);
				assertEquals(10, a.getPixelForValue(-9), 0.001);
				assertEquals(20, a.getPixelForValue(-8), 0.001);
				assertEquals(30, a.getPixelForValue(-7), 0.001);
				assertEquals(40, a.getPixelForValue(-6), 0.001);
				assertEquals(50, a.getPixelForValue(-5), 0.001);
				assertEquals(60, a.getPixelForValue(-4), 0.001);
				assertEquals(70, a.getPixelForValue(-3), 0.001);
				assertEquals(80, a.getPixelForValue(-2), 0.001);
				assertEquals(90, a.getPixelForValue(-1), 0.001);
				assertEquals(100, a.getPixelForValue(0), 0.001);
				assertEquals(90, a.getPixelForValue(1), 0.001);
				assertEquals(80, a.getPixelForValue(2), 0.001);
				assertEquals(70, a.getPixelForValue(3), 0.001);
				assertEquals(60, a.getPixelForValue(4), 0.001);
				assertEquals(50, a.getPixelForValue(5), 0.001);
				assertEquals(40, a.getPixelForValue(6), 0.001);
				assertEquals(30, a.getPixelForValue(7), 0.001);
				assertEquals(20, a.getPixelForValue(8), 0.001);
				assertEquals(10, a.getPixelForValue(9), 0"
cmpl-6ttFjj1dJlDPcUigoOqVhQZk4t5p0,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartEncoder.java,4.6531982421875,stop,"// ChartEncoder.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartEncoder.java
    Created on 11. November 2001, 18:23
 */
package de.progra.charting;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.OutputStream;
import java.io.IOException;
import java.awt.Rectangle;
import java.awt.Graphics2D;

/**
 * The ChartEncoder class provides several static methods to encode
 * charts to an OutputStream. It uses the Java Advanced Imaging Library
 * which is part of the JDK 1.4 release. The list of supported Image Formats
 * may vary depending on the actual release. Quoting from the current
 * webpage as of 28.1.2002: ""As of JAI-1.1.1, the latest public version of JAI,
 * the image formats supported by these ancillary codec classes are:
 * BMP, GIF (decoder only), FlashPix (decoder only), JPEG, PNG, PNM, and TIFF.""
 * For the actual list of supported image formats call
 * <code>{@link #getSupportedFormats}</code>.
 * @author mueller
 * @version 1.0
 */
public class ChartEncoder {

    /**
     * Prints the JPEG encoded image to an output stream.
     * @param os the OutputStream where the image will be printed to.
     * @param chart the Chart which will be printed to the output stream
     * @throws EncodingException if an error occurred accessing the Stream
     */
    public static void createJPEG(OutputStream os, Chart chart) throws EncodingException {
        boolean success = true;
        try {
            Rectangle r = chart.getBounds();
            BufferedImage img = new BufferedImage((int) r.getWidth(), (int) r.getHeight(), BufferedImage.TYPE_INT_RGB);
            Graphics2D grafx = img.createGraphics();
            chart.render(grafx);
            success = ImageIO.write(img, ""jpeg"", os);
            os.flush();
        } catch (Throwable t) {
            throw new EncodingException(t.getMessage(), t);
        }
        if (!success)
            throw new EncodingException(""No ImageWriter for writing JPEGs found."");
    }

    /**
     * Prints the GIF encoded image to an output stream.
     * @param os the OutputStream where the image will be printed to.
     * @param chart the Chart which will be printed to the output stream
     * @throws EncodingException if an error occurred accessing the Stream
     * @deprecated GIF encoding is no longer supported, use PNG instead
     */
    public static void createGIF(OutputStream os, Chart chart) throws EncodingException {
    }

    /**
     * Prints the PNG encoded image to an output stream.
     * @param os the OutputStream where the image will be printed to.
     * @param chart the Chart which will be printed to the output stream
     * @throws EncodingException if an error occurred accessing the Stream
     */
    public static void createPNG(OutputStream os, Chart chart) throws EncodingException {
        boolean success = true;
        try {
            Rectangle r = chart.getBounds();
            BufferedImage img = new BufferedImage((int) r.getWidth(), (int) r.getHeight(), BufferedImage.TYPE_INT_RGB);
            Graphics2D grafx = img.createGraphics();
            chart.render(grafx);
            success = ImageIO.write(img, ""png"", os);
            os.flush();
        } catch (Throwable t) {
            t.printStackTrace();
            throw new EncodingException(t.getMessage(), t);
        }
        if (!success)
            throw new EncodingException(""No ImageWriter for writing PNGs found."");
    }

    /**
     * Prints the encoded image to an output stream.
     * @param os the OutputStream where the image will be printed to.
     * @param chart the Chart which will be printed to the output stream
     * @param format the informal format name
     * @throws EncodingException if an error occurred accessing the Stream
     */
    public static void createEncodedImage(OutputStream os, Chart chart, String format) throws EncodingException {
        boolean success = true;
        try {
            Rectangle r = chart.getBounds();
            BufferedImage img = new BufferedImage((int) r.getWidth(), (int) r.getHeight(), BufferedImage.TYPE_INT_RGB);
            Graphics2D grafx = img.createGraphics();
            chart.render(grafx);
            success = ImageIO.write(img, format, os);
            os.flush();
        } catch (Throwable t) {
            throw new EncodingException(t.getMessage(), t);
        }
        if (!success)
            throw new EncodingException(""No ImageWriter for writing "" + format + "" images found."");
    }

    /**
     * Returns a String array containing the informal format names for
     * all supported image encodings.
     */
    public static String[] getSupportedFormats() {
        return ImageIO.getWriterFormatNames();
    }
}
","// ChartEncoderTest.java
package de.progra.charting;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.OutputStream;
import java.io.IOException;
import java.awt.Rectangle;
import java.awt.Graphics2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartEncoder}.
* It contains ten unit test cases for the {@link ChartEncoder#getSupportedFormats()} method.
*/
class ChartEncoderTest {","// ChartEncoderTest.java
package de.progra.charting;

import javax.imageio.ImageIO;
import java.awt.image.BufferedImage;
import java.io.OutputStream;
import java.io.IOException;
import java.awt.Rectangle;
import java.awt.Graphics2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartEncoder}.
* It contains ten unit test cases for the {@link ChartEncoder#getSupportedFormats()} method.
*/
class ChartEncoderTest {

		/**
		* Test case for {@link ChartEncoder#getSupportedFormats()}.
		* It checks if the method returns a String array containing the informal format names for
		* all supported image encodings.
		*/
		@Test
		void testGetSupportedFormats() {
				String[] formats = ImageIO.getWriterFormatNames();
				assertNotNull(formats);
				assertTrue(formats.length > 0);
		}
}"
cmpl-6ttGmj0b8Pmlq3bXDoyOQfkcktrB4,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_0Test.java,60.4029266834259,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_0Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#performAutoScale(double, double)} method.
*/
class ChartUtilities_0Test {","// ChartUtilities_0Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#performAutoScale(double, double)} method.
*/
class ChartUtilities_0Test {

		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </li>
		* </ul>
		*/
		@Test
		void testCase0() {
			double min = -0.00337;
			double max = 0.00745;
			double[] d = ChartUtilities.performAutoScale(min, max);
			assertEquals(-0.004, d[0], 0.001);
			assertEquals(0.008, d[1], 0.001);
		}
		
		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </li>
		* </ul>
		*/
		@Test
		void testCase1() {
			double min = -0.00337;
			double max = 0.00745;
			double[] d = ChartUtilities.performAutoScale(min, max);
			assertEquals(-0.004, d[0], 0.001);
			assertEquals(0.008, d[1], 0.001);
		}
		
		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </li>
		* </ul>
		*/
		@Test
		void testCase2() {
			double min = -0.00337;
			double max = 0.00745;
			double[] d = ChartUtilities.performAutoScale(min, max);
			assertEquals(-0.004, d[0], 0.001);
			assertEquals(0.008, d[1], 0.001);
		}
		
		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </li>
		* </ul>
		*/
		@Test
		void testCase3() {
			double min = -0.00337;
			double max = 0.00745;
			double[] d = ChartUtilities.performAutoScale(min, max);
			assertEquals(-0.004, d[0], 0.001);
			assertEquals(0.008, d[1], 0.001);
		}
		
		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </li>
		* </ul>
		*/
		@Test
		void testCase4() {
			double min = -0.00337;
			double max = 0.00745;
			double[] d = ChartUtilities.performAutoScale(min, max);
			assertEquals(-0.004, d[0], 0.001);
			assertEquals(0.008, d[1], 0.001);
		}
		
		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </li>
		* </ul>
		*/
		@Test
		void testCase5() {
			double min = -0.00337;
			double max = 0.00745;
			double[] d = ChartUtilities.performAutoScale(min, max);
			assertEquals(-0.004, d[0], 0.001);
			assertEquals(0.008, d[1], 0.001);
		}
		
		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </li>
		* </ul>
		*/
		@Test
		void testCase6() {
			double min = -0.00337;
			double max = 0.00745;
			double[] d = ChartUtilities.performAutoScale(min, max);
			assertEquals(-0.004, d[0], 0.001);
			assertEquals(0.008, d[1], 0.001);
		}
		
		/**
		* Test case for {@link ChartUtilities#performAutoScale(double, double)}.
		* It tests the method with the following input values:
		* <ul>
		*  <li> min = -0.00337 </li>
		*  <li> max = 0.00745 </li>
		* </ul>
		* and checks the output values:
		* <ul>
		*  <li> d[0] = -0.004 </li>
		*  <li> d[1] = 0.008 </"
cmpl-6ttHl6Xdn2rocLs3DgezTZNCghnBz,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_1Test.java,47.58298373222351,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_1Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#calculateTickSpacing(double, double)} method.
*/
class ChartUtilities_1Test {","// ChartUtilities_1Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#calculateTickSpacing(double, double)} method.
*/
class ChartUtilities_1Test {

		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_1() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_2() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_3() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_4() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_5() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_6() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_7() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>expected = 0.0001</li>
		* </ul>
		*/
		@Test
		void testCalculateTickSpacing_8() {
			double min = -0.00337;
			double max = 0.00745;
			double expected = 0.0001;
			double actual = ChartUtilities.calculateTickSpacing(min, max);
			assertEquals(expected, actual, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#calculateTickSpacing(double, double)}.
		* The test case tests the method with the following input values:
		* <ul>
		* <li>min = -0.00337</li>
		* <li>max = 0.00745</li>
"
cmpl-6ttIoc9tOyNvCnOBmCifsje104BUX,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_2Test.java,56.26740503311157,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_2Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#interpolate(double[], double[], double)} method.
*/
class ChartUtilities_2Test {","// ChartUtilities_2Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#interpolate(double[], double[], double)} method.
*/
class ChartUtilities_2Test {

	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-4.0, 0.0, 3.0}</li>
	* 	<li>ya = {64.0, 0.0, 36.0}</li>
	* 	<li>x = 1.0</li>
	* </ul>
	* and the expected output:
	* <ul>
	* 	<li>y = 4.0</li>
	* </ul>
	*/
	@Test
	void testInterpolate_1() {
		double[] xa = {-4.0, 0.0, 3.0};
		double[] ya = {64.0, 0.0, 36.0};
		double x = 1.0;
		double y = 4.0;
		assertEquals(y, ChartUtilities.interpolate(xa, ya, x));
	}
	
	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-4.0, 0.0, 3.0}</li>
	* 	<li>ya = {64.0, 0.0, 36.0}</li>
	* 	<li>x = -4.0</li>
	* </ul>
	* and the expected output:
	* <ul>
	* 	<li>y = 64.0</li>
	* </ul>
	*/
	@Test
	void testInterpolate_2() {
		double[] xa = {-4.0, 0.0, 3.0};
		double[] ya = {64.0, 0.0, 36.0};
		double x = -4.0;
		double y = 64.0;
		assertEquals(y, ChartUtilities.interpolate(xa, ya, x));
	}
	
	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-4.0, 0.0, 3.0}</li>
	* 	<li>ya = {64.0, 0.0, 36.0}</li>
	* 	<li>x = 3.0</li>
	* </ul>
	* and the expected output:
	* <ul>
	* 	<li>y = 36.0</li>
	* </ul>
	*/
	@Test
	void testInterpolate_3() {
		double[] xa = {-4.0, 0.0, 3.0};
		double[] ya = {64.0, 0.0, 36.0};
		double x = 3.0;
		double y = 36.0;
		assertEquals(y, ChartUtilities.interpolate(xa, ya, x));
	}
	
	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-4.0, 0.0, 3.0}</li>
	* 	<li>ya = {64.0, 0.0, 36.0}</li>
	* 	<li>x = -5.0</li>
	* </ul>
	* and the expected output:
	* <ul>
	* 	<li>y = Double.NaN</li>
	* </ul>
	*/
	@Test
	void testInterpolate_4() {
		double[] xa = {-4.0, 0.0, 3.0};
		double[] ya = {64.0, 0.0, 36.0};
		double x = -5.0;
		double y = Double.NaN;
		assertEquals(y, ChartUtilities.interpolate(xa, ya, x));
	}
	
	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-4.0, 0.0, 3.0}</li>
	* 	<li>ya = {64.0, 0.0, 36.0}</li>
	* 	<li>x = 4.0</li>
	* </ul>
	* and the expected output:
	* <ul>
	* 	<li>y = Double.NaN</li>
	* </ul>
	*/
	@Test
	void testInterpolate_5() {
		double[] xa = {-4.0, 0.0, 3.0};
		double[] ya = {64.0, 0.0, 36.0};
		double x = 4.0;
		double y = Double.NaN;
		assertEquals(y, ChartUtilities.interpolate(xa, ya, x));
	}
	
	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-5.0, 0.0, 1.0, 5.0}</li>
	* 	<li>ya = {-740.0, -5.0, -2.0, 530.0}</li>
	* 	<li>x = -5.0</li>
	* </ul>
	* and the expected output:
	* <ul>
	* 	<li>y = -740.0</li>
	* </ul>
	*/
	@Test
	void testInterpolate_6() {
		double[] xa = {-5.0, 0.0, 1.0, 5.0};
		double[] ya = {-740.0, -5.0, -2.0, 530.0};
		double x = -5.0;
		double y = -740.0;
		assertEquals(y, ChartUtilities.interpolate(xa, ya, x));
	}
	
	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-5.0, 0.0, 1.0, 5.0}</li>
	* 	<li>ya = {-740.0, -5.0, -2.0, 530.0}</li>
	* 	<li>x = 0.0</li>
	* </ul>
	* and the expected output:
	* <ul>
	* 	<li>y = -5.0</li>
	* </ul>
	*/
	@Test
	void testInterpolate_7() {
		double[] xa = {-5.0, 0.0, 1.0, 5.0};
		double[] ya = {-740.0, -5.0, -2.0, 530.0};
		double x = 0.0;
		double y = -5.0;
		assertEquals(y, ChartUtilities.interpolate(xa, ya, x));
	}
	
	/**
	* Test case for {@link ChartUtilities#interpolate(double[], double[], double)}
	* with the following input:
	* <ul>
	* 	<li>xa = {-5.0, 0.0, 1.0, 5.0}</li>
	* 	<li>ya = {-740.0, -5.0, -2.0, 530.0}</li>
	* 	<li>x"
cmpl-6ttJrArQoo82RPnFh6WHWx2kCoiFD,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_3Test.java,52.06398820877075,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_3Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#floor(double, int)} method.
*/
class ChartUtilities_3Test {","// ChartUtilities_3Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#floor(double, int)} method.
*/
class ChartUtilities_3Test {

		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_1() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(-0.0034, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_2() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(0.0074, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_3() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(-0.0034, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_4() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(0.0074, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_5() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(-0.0034, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_6() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(0.0074, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_7() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(-0.0034, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_8() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(0.0074, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_9() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(-0.0034, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#floor(double, int)}.
		*/
		@Test
		void testFloor_10() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.floor(d, exp);
				assertEquals(0.0074, result, 0.0001);
		}
}

// ChartUtilities_4Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#ceil(double, int)} method.
*/
class ChartUtilities_4Test {
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		*/
		@Test
		void testCeil_1() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(-0.0033, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		*/
		@Test
		void testCeil_2() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0075, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		*/
		@Test
		void testCeil_3() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(-0.0033, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		*/
		@Test
		void testCeil_4() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0075, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		*/
		@Test
		void testCeil_5() {
				double d = -0.00337;
				int exp = ChartUtilities.exp(d);
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(-0.0033, result, 0.0001);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		*/
		@Test
		void testCeil_6() {
				double d = 0.00745;
				int exp = ChartUtilities.exp(d);
"
cmpl-6ttKul827A6ybCwMP00vlhSy1NQue,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_4Test.java,53.45826983451843,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_4Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#ceil(double, int)} method.
*/
class ChartUtilities_4Test {","// ChartUtilities_4Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#ceil(double, int)} method.
*/
class ChartUtilities_4Test {

		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 0</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_1() {
				double d = 0.0;
				int exp = 0;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 1</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_2() {
				double d = 0.0;
				int exp = 1;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 2</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_3() {
				double d = 0.0;
				int exp = 2;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 3</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_4() {
				double d = 0.0;
				int exp = 3;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 4</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_5() {
				double d = 0.0;
				int exp = 4;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 5</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_6() {
				double d = 0.0;
				int exp = 5;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 6</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_7() {
				double d = 0.0;
				int exp = 6;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 7</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_8() {
				double d = 0.0;
				int exp = 7;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 8</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_9() {
				double d = 0.0;
				int exp = 8;
				double result = ChartUtilities.ceil(d, exp);
				assertEquals(0.0, result);
		}
		
		/**
		* Test case for {@link ChartUtilities#ceil(double, int)}.
		* The test case tests the method with the following parameters:
		* <ul>
		* <li>d = 0.0</li>
		* <li>exp = 9</li>
		* </ul>
		* The expected result is:
		* <ul>
		* <li>result = 0.0</li>
		* </ul>
		*/
		@Test
		void testCeil_10() {
				double d = 0.0;
"
cmpl-6ttLxdHG6Sp5oxYZBF5lBfVztUhGa,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_5Test.java,57.04157543182373,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_5Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#exp(double)} method.
*/
class ChartUtilities_5Test {","// ChartUtilities_5Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#exp(double)} method.
*/
class ChartUtilities_5Test {

	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_1() {
		double d = 0.0;
		int exp = ChartUtilities.exp(d);
		assertEquals(0, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_2() {
		double d = 1.0;
		int exp = ChartUtilities.exp(d);
		assertEquals(0, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_3() {
		double d = -1.0;
		int exp = ChartUtilities.exp(d);
		assertEquals(0, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_4() {
		double d = 10.0;
		int exp = ChartUtilities.exp(d);
		assertEquals(1, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_5() {
		double d = -10.0;
		int exp = ChartUtilities.exp(d);
		assertEquals(-1, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_6() {
		double d = 100.0;
		int exp = ChartUtilities.exp(d);
		assertEquals(2, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_7() {
		double d = -100.0;
		int exp = ChartUtilities.exp(d);
		assertEquals(-2, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_8() {
		double d = 0.1;
		int exp = ChartUtilities.exp(d);
		assertEquals(-1, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_9() {
		double d = -0.1;
		int exp = ChartUtilities.exp(d);
		assertEquals(-1, exp);
	}
	
	/**
	* Test case for {@link ChartUtilities#exp(double)}.
	*/
	@Test
	void testExp_10() {
		double d = 0.01;
		int exp = ChartUtilities.exp(d);
		assertEquals(-2, exp);
	}
	
}

// ChartUtilities_6Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#floor(double, int)} method.
*/
class ChartUtilities_6Test {
		
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_1() {
		double d = 0.0;
		int exp = 0;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(0.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_2() {
		double d = 1.0;
		int exp = 0;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(1.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_3() {
		double d = -1.0;
		int exp = 0;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(-1.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_4() {
		double d = 10.0;
		int exp = 1;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(10.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_5() {
		double d = -10.0;
		int exp = 1;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(-10.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_6() {
		double d = 100.0;
		int exp = 2;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(100.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_7() {
		double d = -100.0;
		int exp = 2;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(-100.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_8() {
		double d = 0.1;
		int exp = -1;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(0.0, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_9() {
		double d = -0.1;
		int exp = -1;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(-0.1, floor);
	}
	
	/**
	* Test case for {@link ChartUtilities#floor(double, int)}.
	*/
	@Test
	void testFloor_10() {
		double d = 0.01;
		int exp = -2;
		double floor = ChartUtilities.floor(d, exp);
		assertEquals(0.0, floor);
	}
	
}

// ChartUtilities_7Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#ceil(double, int)} method.
*/
class ChartUtilities_7Test {
		
	/**
	* Test case for {@link ChartUtilities#ceil(double, int)}.
	*/
	@Test
	void testCeil_1() {
		double d = 0.0;
		int exp = 0;
		double"
cmpl-6ttN0kzVy48iNu9uGgrRq6pJXPzso,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_6Test.java,47.17872428894043,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_6Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(int[][])} method.
*/
class ChartUtilities_6Test {","// ChartUtilities_6Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(int[][])} method.
*/
class ChartUtilities_6Test {

		/**
		* Test case for {@link ChartUtilities#transformArray(int[][])}.
		*/
		@Test
		void testTransformArray_1() {
				int[][] data = new int[][] { { 1, 2, 3 }, { 4, 5, 6 } };
				Number[][] n = ChartUtilities.transformArray(data);
				assertEquals(2, n.length);
				assertEquals(3, n[0].length);
				assertEquals(3, n[1].length);
				assertEquals(1, n[0][0]);
				assertEquals(2, n[0][1]);
				assertEquals(3, n[0][2]);
				assertEquals(4, n[1][0]);
				assertEquals(5, n[1][1]);
				assertEquals(6, n[1][2]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[][])}.
		*/
		@Test
		void testTransformArray_2() {
				int[][] data = new int[][] { { 1, 2, 3 }, { 4, 5, 6 }, { 7, 8, 9 } };
				Number[][] n = ChartUtilities.transformArray(data);
				assertEquals(3, n.length);
				assertEquals(3, n[0].length);
				assertEquals(3, n[1].length);
				assertEquals(3, n[2].length);
				assertEquals(1, n[0][0]);
				assertEquals(2, n[0][1]);
				assertEquals(3, n[0][2]);
				assertEquals(4, n[1][0]);
				assertEquals(5, n[1][1]);
				assertEquals(6, n[1][2]);
				assertEquals(7, n[2][0]);
				assertEquals(8, n[2][1]);
				assertEquals(9, n[2][2]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[][])}.
		*/
		@Test
		void testTransformArray_3() {
				int[][] data = new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } };
				Number[][] n = ChartUtilities.transformArray(data);
				assertEquals(3, n.length);
				assertEquals(4, n[0].length);
				assertEquals(4, n[1].length);
				assertEquals(4, n[2].length);
				assertEquals(1, n[0][0]);
				assertEquals(2, n[0][1]);
				assertEquals(3, n[0][2]);
				assertEquals(4, n[0][3]);
				assertEquals(5, n[1][0]);
				assertEquals(6, n[1][1]);
				assertEquals(7, n[1][2]);
				assertEquals(8, n[1][3]);
				assertEquals(9, n[2][0]);
				assertEquals(10, n[2][1]);
				assertEquals(11, n[2][2]);
				assertEquals(12, n[2][3]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[][])}.
		*/
		@Test
		void testTransformArray_4() {
				int[][] data = new int[][] { { 1, 2, 3, 4, 5 }, { 6, 7, 8, 9, 10 }, { 11, 12, 13, 14, 15 } };
				Number[][] n = ChartUtilities.transformArray(data);
				assertEquals(3, n.length);
				assertEquals(5, n[0].length);
				assertEquals(5, n[1].length);
				assertEquals(5, n[2].length);
				assertEquals(1, n[0][0]);
				assertEquals(2, n[0][1]);
				assertEquals(3, n[0][2]);
				assertEquals(4, n[0][3]);
				assertEquals(5, n[0][4]);
				assertEquals(6, n[1][0]);
				assertEquals(7, n[1][1]);
				assertEquals(8, n[1][2]);
				assertEquals(9, n[1][3]);
				assertEquals(10, n[1][4]);
				assertEquals(11, n[2][0]);
				assertEquals(12, n[2][1]);
				assertEquals(13, n[2][2]);
				assertEquals(14, n[2][3]);
				assertEquals(15, n[2][4]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[][])}.
		*/
		@Test
		void testTransformArray_5() {
				int[][] data = new int[][] { { 1, 2, 3, 4, 5, 6 }, { 7, 8, 9, 10, 11, 12 }, { 13, 14, 15, 16, 17, 18 } };
				Number[][] n = ChartUtilities.transformArray(data);
				assertEquals(3, n.length);
				assertEquals(6, n[0].length);
				assertEquals(6, n[1].length);
				assertEquals(6, n[2].length);
				assertEquals(1, n[0][0]);
				assertEquals(2, n[0][1]);
				assertEquals(3, n[0][2]);
				assertEquals(4, n[0][3]);
				assertEquals(5, n[0][4]);
				assertEquals(6, n[0][5]);
				assertEquals(7, n[1][0]);
				assertEquals(8, n[1][1]);
				assertEquals(9, n[1][2]);
				assertEquals(10, n[1][3]);
				assertEquals(11, n[1][4]);
				assertEquals(12, n[1][5]);
				assertEquals(13, n[2][0]);
				assertEquals(14, n[2][1]);
				assertEquals(15, n[2][2]);
				assertEquals(16, n[2][3]);
				assertEquals(17, n[2][4]);
				assertEquals(18, n[2][5]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[][])}.
		*/
		@Test
		void testTransformArray_6() {
				int[][] data = new int[][] { { 1, 2, 3, 4, 5, 6, 7 },"
cmpl-6ttO3cfSasWfAFsKmUUTfSeNYuP08,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_7Test.java,60.38230919837952,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_7Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(double[][])} method.
*/
class ChartUtilities_7Test {","// ChartUtilities_7Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(double[][])} method.
*/
class ChartUtilities_7Test {

		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_1() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};
				Number[][] expected = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}};
				Number[][] actual = ChartUtilities.transformArray(data);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_2() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}};
				Number[][] expected = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}};
				Number[][] actual = ChartUtilities.transformArray(data);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_3() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}};
				Number[][] expected = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}};
				Number[][] actual = ChartUtilities.transformArray(data);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_4() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}};
				Number[][] expected = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}};
				Number[][] actual = ChartUtilities.transformArray(data);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_5() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}, {16.0, 17.0, 18.0}};
				Number[][] expected = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}, {16.0, 17.0, 18.0}};
				Number[][] actual = ChartUtilities.transformArray(data);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_6() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}, {16.0, 17.0, 18.0}, {19.0, 20.0, 21.0}};
				Number[][] expected = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}, {16.0, 17.0, 18.0}, {19.0, 20.0, 21.0}};
				Number[][] actual = ChartUtilities.transformArray(data);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_7() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}, {16.0, 17.0, 18.0}, {19.0, 20.0, 21.0}, {22.0, 23.0, 24.0}};
				Number[][] expected = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}, {16.0, 17.0, 18.0}, {19.0, 20.0, 21.0}, {22.0, 23.0, 24.0}};
				Number[][] actual = ChartUtilities.transformArray(data);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[][])} method.
		* It tests if the method returns the correct result for a given input.
		*/
		@Test
		void testTransformArray_8() {
				double[][] data = {{1.0, 2.0, 3.0}, {4.0, 5.0, 6.0}, {7.0, 8.0, 9.0}, {10.0, 11.0, 12.0}, {13.0, 14.0, 15.0}, {16.0, 17.0, 18.0}, {19.0, 20.0, 21.0}, {22.0,"
cmpl-6ttP1tVX6SUD2Dr7iG6ecRLYSemNI,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_8Test.java,45.15055465698242,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_8Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(double[])} method.
*/
class ChartUtilities_8Test {","// ChartUtilities_8Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(double[])} method.
*/
class ChartUtilities_8Test {

		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_1() {
				double[] data = {};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(0, n.length);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_2() {
				double[] data = {0.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(1, n.length);
				assertEquals(0.0, n[0]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_3() {
				double[] data = {0.0, 1.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(2, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_4() {
				double[] data = {0.0, 1.0, 2.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(3, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
				assertEquals(2.0, n[2]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_5() {
				double[] data = {0.0, 1.0, 2.0, 3.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(4, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
				assertEquals(2.0, n[2]);
				assertEquals(3.0, n[3]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_6() {
				double[] data = {0.0, 1.0, 2.0, 3.0, 4.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(5, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
				assertEquals(2.0, n[2]);
				assertEquals(3.0, n[3]);
				assertEquals(4.0, n[4]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_7() {
				double[] data = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(6, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
				assertEquals(2.0, n[2]);
				assertEquals(3.0, n[3]);
				assertEquals(4.0, n[4]);
				assertEquals(5.0, n[5]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_8() {
				double[] data = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(7, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
				assertEquals(2.0, n[2]);
				assertEquals(3.0, n[3]);
				assertEquals(4.0, n[4]);
				assertEquals(5.0, n[5]);
				assertEquals(6.0, n[6]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_9() {
				double[] data = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(8, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
				assertEquals(2.0, n[2]);
				assertEquals(3.0, n[3]);
				assertEquals(4.0, n[4]);
				assertEquals(5.0, n[5]);
				assertEquals(6.0, n[6]);
				assertEquals(7.0, n[7]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(double[])}.
		*/
		@Test
		void testTransformArray_10() {
				double[] data = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(9, n.length);
				assertEquals(0.0, n[0]);
				assertEquals(1.0, n[1]);
				assertEquals(2.0, n[2]);
				assertEquals(3.0, n[3]);
				assertEquals(4.0, n[4]);
				assertEquals(5.0, n[5]);
				assertEquals(6.0, n[6]);
				assertEquals(7.0, n[7]);
				assertEquals(8.0, n[8]);
		}
}

// ChartUtilities_9Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(int[])} method.
*/
"
cmpl-6ttQ4xLwHRs00P3huKn0yjwcZUQ6W,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/ChartUtilities_9Test.java,65.41118860244751,length,"// ChartUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartUtilities.java
    Created on 21. September 2001, 17:42
 */
package de.progra.charting;

import java.util.*;

/**
 * This class offers multiple static methods to perform mathematical
 * operations concerning the Chart, e.g. methods for rounding the minimal and
 * maximal x-values gracefully.
 * @author  mueller
 * @version 1.0
 */
public class ChartUtilities {

    /**
     * This method calculates the optimal rounding for the minimal and
     * maximal ChartModel values. It computes the difference of the
     * minimal and maximal value and rounds the values min and max according
     * to the exponent of the difference.
     * @param min the minimal column value of the ChartDataModel
     * @param max the maximal column value of the ChartDataModel
     * @return a double[] with the rounded minimal value at index 0 and
     * the maximal value at index 1.
     */
    public static double[] performAutoScale(double min, double max) {
        // d[0] = min d[1] = max
        double[] d = new double[2];
        double diff = max - min;
        d[0] = floor(min, exp(diff));
        d[1] = ceil(max, exp(diff));
        return d;
    }

    /**
     * Calculates the best tick spacing for the rounded minimal and maximal
     * values.
     * @param min the rounded minimal value
     * @param max the rounded maximal value
     * @return the spacing of ticks on the x-axis.
     */
    public static double calculateTickSpacing(double min, double max) {
        double spacing = 1.0;
        double diff = max - min;
        int exp = exp(diff);
        exp--;
        spacing = 1.0 * Math.pow(10.0, (double) exp);
        // Currently, only every second tick gets a label, so 20 - 40 ticks are fine.
        // This should be reduced in a loop probably.
        if ((diff / spacing) < 20)
            return 0.5 * spacing;
        else if ((diff / spacing) > 40)
            return 2 * spacing;
        else
            return spacing;
    }

    /**
     * This function performs a polynomial interpolation using a set of
     * given x and y values. It uses Neville's interpolation algorithm.
     * @param xa the array of known x-values
     * @param ya the array of known y-values
     * @param x the x value for which the y value will be computed
     * @return the corresponding y value
     */
    public static double interpolate(double[] xa, double[] ya, double x) {
        /*
            Given arrays xa[1..n] and ya[1..n], and given a value x, 
            this routine returns a value y. 
            If P(x) is the polynomial of degree N ? 1 
            such that P(xa[i]) = ya[i]; 
            i = 1...n, then the returned value y = P(x).
         */
        if (xa.length != ya.length || xa.length == 0 || ya.length == 0) {
            System.out.println(""** Invalid Parameter"");
            return Double.NaN;
        }
        int n = xa.length;
        double y = 0.0;
        double dy = 0.0;
        int i, m, ns = 1;
        double den, dif, dift, ho, hp, w;
        double[] c = new double[n];
        double[] d = new double[n];
        dif = Math.abs(x - xa[0]);
        for (i = 0; i < n; i++) {
            // Here we find the index ns of the closest table entry,
            if ((dift = Math.abs(x - xa[i])) < dif) {
                ns = i;
                dif = dift;
            }
            // and initialize the tableau of c's and d's.
            c[i] = ya[i];
            d[i] = ya[i];
        }
        // This is the initial approximation to y.
        y = ya[ns--];
        //System.out.println(""** y ~ ""+y);
        for (m = 0; m < n - 1; m++) {
            // For each column of the tableau,
            for (i = 0; i < n - m - 1; i++) {
                // we loop over the current c's and d's and update them.
                //System.out.println(""** m = ""+m+"", i = ""+i);
                ho = xa[i] - x;
                hp = xa[i + m + 1] - x;
                w = c[i + 1] - d[i];
                if ((den = ho - hp) == 0.0) {
                    return Double.NaN;
                }
                // This error can occur only if two input xa's are (to within roundof identical.
                //System.out.println(""** ho = ""+ho+"", hp = ""+hp);
                den = w / den;
                // Here the c's and d's are updated.
                d[i] = hp * den;
                c[i] = ho * den;
                //System.out.println(""** c[i] = ""+c[i]+"", d[i] = ""+d[i]);
            }
            y += (dy = (2 * (ns + 1) < (n - m) ? c[ns + 1] : d[ns--]));
            //System.out.println(""** dy = ""+dy+"", y = ""+y);
            /*
            After each column in the tableau is completed, we decide which correction, c or d,
            we want to add to our accumulating value of y, i.e., which path to take through the
            tableau forking up or down. We do this in such a way as to take the most ""straight
            line"" route through the tableau to its apex, updating ns accordingly to keep track of
            where we are. This route keeps the partial approximations centered (insofar as possible)
            on the target x. The last dy added is thus the error indication.
            */
        }
        return y;
    }

    /**
     * This method returns the largest double value that is smaller than
     * <code> d = x * 10<sup>exp</sup></code> where x is rounded down to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.floor(x) * 10<sup>exp</sup></code>
     */
    public static double floor(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.floor(d / x) * x;
    }

    /**
     * This method returns the smallest double value that is smaller than
     * <code> d = x * 10<sup>exp</exp></code> where x is rounded up to
     * the closest integer.
     * @param d the double value to be rounded
     * @param exp the exponent of 10 to which d should be rounded
     * @return <code> Math.ceil(x) * 10<sup>exp</sup></code>
     */
    public static double ceil(double d, int exp) {
        double x = 1.0 * Math.pow(10.0, (double) exp);
        return Math.ceil(d / x) * x;
    }

    /**
     * A double value can be represented like
     * <code>d = x * 10<sup>exp</sup></code> and this method returns
     * the value of exp for a double d.
     * @param d the double value
     * @return the exponent of 10
     */
    public static int exp(double d) {
        int exp = 0;
        boolean positive = (d <= -1 || d >= 1);
        while ((d <= -10) || (d >= 10) || ((d > -1) && (d < 1))) {
            if (positive) {
                d /= 10;
                exp++;
            } else {
                d *= 10;
                exp--;
            }
        }
        return exp;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(int[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Integer(data[i][j]);
        return n;
    }

    /**
     * Transforms a two-dimensional array of primitives
     * to an array of Numbers.
     */
    public static Number[][] transformArray(double[][] data) {
        Number[][] n = new Number[data.length][data[0].length];
        for (int i = 0; i < data.length; i++) for (int j = 0; j < data[0].length; j++) n[i][j] = new Double(data[i][j]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(double[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Double(data[i]);
        return n;
    }

    /**
     * Transforms an array of primitives
     * to an array of Numbers.
     */
    public static Number[] transformArray(int[] data) {
        Number[] n = new Number[data.length];
        for (int i = 0; i < data.length; i++) n[i] = new Integer(data[i]);
        return n;
    }

    /**
     * Adds a two-dimensional array to a TreeSet.
     */
    public static void addDataToSet(TreeSet set, Number[][] data) {
        for (int i = 0; i < data.length; i++) {
            set.addAll(Arrays.asList(data[i]));
        }
    }

    /**
     * A test routine.
     */
    public static void main(String[] args) {
        double min = -0.00337;
        double max = 0.00745;
        double[] d = performAutoScale(min, max);
        System.out.println(""** AutoScaling: ("" + min + "", "" + max + "") -> ("" + d[0] + "", "" + d[1] + "")"");
        double s = calculateTickSpacing(d[0], d[1]);
        System.out.print(""** Ticks: "");
        for (double i = d[0]; i <= d[1]; i += s) System.out.print("" "" + i + "" "");
        System.out.println();
        System.out.println(""** Performing interpolation for 4*x^2"");
        System.out.println(""** Given values [-4, 64], [0, 0], [3, 36]"");
        double[] xa = { -4.0, 0.0, 3.0 };
        double[] ya = { 64.0, 0.0, 36.0 };
        System.out.print(""** Calculating values"");
        //double f = interpolate(xa, ya, 1.0);
        //System.out.println(""** f(1) = ""+f);
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xa, ya, i) + ""]"");
        }
        System.out.println();
        System.out.println(""** Performing interpolation for 5 * x^3 - 4 * x^2 + 2 * x - 5"");
        System.out.println(""** Given values [-5, -740], [0, -5], [1, -2], [5, 530]"");
        double[] xb = { -5.0, 0.0, 1.0, 5.0 };
        double[] yb = { -740.0, -5.0, -2.0, 530.0 };
        System.out.print(""** Calculating values "");
        for (double i = -5.0; i < 6.0; i += 0.5) {
            System.out.print(""["" + i + "", "" + interpolate(xb, yb, i) + ""]"");
        }
        System.out.println();
    }
}
","// ChartUtilities_9Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(int[])} method.
*/
class ChartUtilities_9Test {","// ChartUtilities_9Test.java
package de.progra.charting;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartUtilities}.
* It contains ten unit test cases for the {@link ChartUtilities#transformArray(int[])} method.
*/
class ChartUtilities_9Test {

		/**
		* Test case for {@link ChartUtilities#transformArray(int[])}.
		*/
		@Test
		void testTransformArray_1() {
				int[] data = {};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(0, n.length);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[])}.
		*/
		@Test
		void testTransformArray_2() {
				int[] data = {1};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(1, n.length);
				assertEquals(1, n[0]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[])}.
		*/
		@Test
		void testTransformArray_3() {
				int[] data = {1, 2, 3};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(3, n.length);
				assertEquals(1, n[0]);
				assertEquals(2, n[1]);
				assertEquals(3, n[2]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[])}.
		*/
		@Test
		void testTransformArray_4() {
				int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(10, n.length);
				assertEquals(1, n[0]);
				assertEquals(2, n[1]);
				assertEquals(3, n[2]);
				assertEquals(4, n[3]);
				assertEquals(5, n[4]);
				assertEquals(6, n[5]);
				assertEquals(7, n[6]);
				assertEquals(8, n[7]);
				assertEquals(9, n[8]);
				assertEquals(10, n[9]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[])}.
		*/
		@Test
		void testTransformArray_5() {
				int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(20, n.length);
				assertEquals(1, n[0]);
				assertEquals(2, n[1]);
				assertEquals(3, n[2]);
				assertEquals(4, n[3]);
				assertEquals(5, n[4]);
				assertEquals(6, n[5]);
				assertEquals(7, n[6]);
				assertEquals(8, n[7]);
				assertEquals(9, n[8]);
				assertEquals(10, n[9]);
				assertEquals(11, n[10]);
				assertEquals(12, n[11]);
				assertEquals(13, n[12]);
				assertEquals(14, n[13]);
				assertEquals(15, n[14]);
				assertEquals(16, n[15]);
				assertEquals(17, n[16]);
				assertEquals(18, n[17]);
				assertEquals(19, n[18]);
				assertEquals(20, n[19]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[])}.
		*/
		@Test
		void testTransformArray_6() {
				int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(30, n.length);
				assertEquals(1, n[0]);
				assertEquals(2, n[1]);
				assertEquals(3, n[2]);
				assertEquals(4, n[3]);
				assertEquals(5, n[4]);
				assertEquals(6, n[5]);
				assertEquals(7, n[6]);
				assertEquals(8, n[7]);
				assertEquals(9, n[8]);
				assertEquals(10, n[9]);
				assertEquals(11, n[10]);
				assertEquals(12, n[11]);
				assertEquals(13, n[12]);
				assertEquals(14, n[13]);
				assertEquals(15, n[14]);
				assertEquals(16, n[15]);
				assertEquals(17, n[16]);
				assertEquals(18, n[17]);
				assertEquals(19, n[18]);
				assertEquals(20, n[19]);
				assertEquals(21, n[20]);
				assertEquals(22, n[21]);
				assertEquals(23, n[22]);
				assertEquals(24, n[23]);
				assertEquals(25, n[24]);
				assertEquals(26, n[25]);
				assertEquals(27, n[26]);
				assertEquals(28, n[27]);
				assertEquals(29, n[28]);
				assertEquals(30, n[29]);
		}
		
		/**
		* Test case for {@link ChartUtilities#transformArray(int[])}.
		*/
		@Test
		void testTransformArray_7() {
				int[] data = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40};
				Number[] n = ChartUtilities.transformArray(data);
				assertEquals(40, n.length);
				assertEquals(1, n[0]);
				assertEquals(2, n[1]);
				assertEquals(3, n[2]);
				assertEquals(4, n[3]);
				assertEquals(5, n[4]);
				assertEquals(6, n[5]);
				assertEquals(7, n[6]);
				assertEquals(8, n[7]);
				assertEquals(9, n[8]);
				assertEquals(10, n[9]);
				assertEquals(11, n[10]);
				assertEquals"
cmpl-6ttR8Cn3C80Dt0hOiFrUyQqjaNR1O,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilities_0Test.java,59.402517318725586,length,"// CoordSystemUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystemUtilities.java 
    Created on 4. April 2002, 22:28
 */
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;

/**
 * This class provides some utility functions for a CoordSystem. They were
 * externalized to make the CoordSystem class clearer.
 * @author  mueller
 * @version 1.0
 */
public class CoordSystemUtilities {

    /**
     * used for the offset on the y axis for the size of a ""tick""
     */
    protected final int marginOffset = 6;

    protected CoordSystem c;

    protected ChartDataModelConstraints constraints;

    protected ChartDataModelConstraints constraints2;

    protected ChartDataModel model;

    /**
     * Creates a new instance of CoordSystemUtilities
     */
    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {
        c = coord;
        this.constraints = constraints;
        this.constraints2 = constraints2;
        this.model = model;
    }

    /**
     * Computes the left margin.
     */
    public int computeLeftMargin() {
        double xmin = constraints.getMinimumColumnValue();
        double xmax = constraints.getMaximumColumnValue();
        if (xmin <= 0 && xmax > 0) {
            xmin = Math.abs(xmin);
            xmax = Math.abs(xmax);
            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
            // yaxis label width
            // + yaxis title width
            int maxlmargin = computeYAxisLabelWidth() + marginOffset;
            // unit width
            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);
            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));
            // just for good looking
            margin += 5;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the right margin.
     */
    public int computeRightMargin() {
        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);
    }

    /**
     * Computes the top margin.
     */
    public int computeTopMargin() {
        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);
    }

    /**
     * Computes the bottom margin.
     */
    public int computeBottomMargin() {
        double ymin = constraints.getMinimumValue().doubleValue();
        double ymax = constraints.getMaximumValue().doubleValue();
        if (ymin <= 0 && ymax > 0) {
            ymin = Math.abs(ymin);
            ymax = Math.abs(ymax);
            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
            // xaxis label height
            // + xaxis title height
            int maxbmargin = computeXAxisLabelHeight() + marginOffset;
            // unit height
            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);
            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));
            // just for good looking
            margin += 10;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the maximum height of all x-axis labels.
     */
    public int computeXAxisLabelHeight() {
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        int height = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        boolean paint = false;
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                height = Math.max(height, (int) r.getHeight());
            }
            paint = !paint;
        }
        return height;
    }

    /**
     * Computes the maximum width of all y-axis labels.
     */
    public int computeYAxisLabelWidth() {
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        int width = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                width = Math.max((int) r.getWidth(), width);
            }
            paint = !paint;
        }
        return width;
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for numerical x-axis values.
     * @param g the Graphics2D context to paint in
     */
    public void drawNumericalXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(d, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            g.draw(ticks);
            if (paint && paintLabels) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            paint = !paint;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for non-numerical x-axis values..
     * @param g the Graphics2D context to paint in
     */
    public void drawXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        int min = (int) constraints.getMinimumColumnValue();
        int max = (int) constraints.getMaximumColumnValue();
        double tick = 1.0;
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v = null;
        Point2D oldv = null;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        boolean paintLabels = c.isPaintLabels();
        g.setFont(f);
        for (int i = min - 1; i < max; i++) {
            p.setLocation(i + 1, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            if (i + 1 < max)
                g.draw(ticks);
            // Draw Strings between ticks
            if (oldv != null && paintLabels) {
                String sb = (String) model.getColumnValueAt(i);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            oldv = v;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * y-axis.
     * @param g the Graphics2D context in which to draw
     */
    public void drawYAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        Color backupColor = g.getColor();
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(xpt, d);
            v = at.transform(p, null);
            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());
            g.draw(ticks);
            if (d != min && !c.isPaintOnlyTick()) {
                Line2D xax = getXAxisLine2D();
                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());
                g.setColor(Color.lightGray);
                g.draw(ticks);
                g.setColor(backupColor);
            }
            if (paintLabels && (paint || !c.isPaintAltTick())) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));
            }
            paint = !paint;
        }
    }

    /**
     * Computes the Line2D object of the x-axis using the DataConstraints.
     */
    public Line2D getXAxisLine2D() {
        double ypt = 0.0;
        // shift the x-axis according to the max and min y-values
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);
        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);
        return new Line2D.Double(l, r);
    }

    /**
     * Computes the Line2D object of the y-axis using the DataConstraints.
     */
    public Line2D getYAxisLine2D() {
        double xpt = 0.0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);
        //System.out.println(""** Y-Axis (""+o+"", ""+u+"")"");
        return new Line2D.Double(o, u);
    }

    /**
     * Computes the Line2D object of the second y-axis using the DataConstraints.
     */
    public Line2D getSecondYAxisLine2D() {
        double xpt = constraints2.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);
        return new Line2D.Double(o, u);
    }
}
","// CoordSystemUtilities_0Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeLeftMargin()} method.
*/
class CoordSystemUtilities_0Test {","// CoordSystemUtilities_0Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeLeftMargin()} method.
*/
class CoordSystemUtilities_0Test {

		private CoordSystemUtilities coordSystemUtilities;
		
		private CoordSystem coordSystem;
		
		private ChartDataModelConstraints chartDataModelConstraints;
		
		private ChartDataModelConstraints chartDataModelConstraints2;
		
		private ChartDataModel chartDataModel;
		
		private Graphics2D graphics2D;
		
		private FontRenderContext fontRenderContext;
		
		private Font font;
		
		private AffineTransform affineTransform;
		
		private Line2D line2D;
		
		private Point2D point2D;
		
		private Rectangle2D rectangle2D;
		
		private TextLayout textLayout;
		
		private DecimalFormat decimalFormat;
		
		private Color color;
		
		private double double0;
		
		private double double1;
		
		private double double2;
		
		private double double3;
		
		private double double4;
		
		private double double5;
		
		private double double6;
		
		private double double7;
		
		private double double8;
		
		private double double9;
		
		private double double10;
		
		private double double11;
		
		private double double12;
		
		private double double13;
		
		private double double14;
		
		private double double15;
		
		private double double16;
		
		private double double17;
		
		private double double18;
		
		private double double19;
		
		private double double20;
		
		private double double21;
		
		private double double22;
		
		private double double23;
		
		private double double24;
		
		private double double25;
		
		private double double26;
		
		private double double27;
		
		private double double28;
		
		private double double29;
		
		private double double30;
		
		private double double31;
		
		private double double32;
		
		private double double33;
		
		private double double34;
		
		private double double35;
		
		private double double36;
		
		private double double37;
		
		private double double38;
		
		private double double39;
		
		private double double40;
		
		private double double41;
		
		private double double42;
		
		private double double43;
		
		private double double44;
		
		private double double45;
		
		private double double46;
		
		private double double47;
		
		private double double48;
		
		private double double49;
		
		private double double50;
		
		private double double51;
		
		private double double52;
		
		private double double53;
		
		private double double54;
		
		private double double55;
		
		private double double56;
		
		private double double57;
		
		private double double58;
		
		private double double59;
		
		private double double60;
		
		private double double61;
		
		private double double62;
		
		private double double63;
		
		private double double64;
		
		private double double65;
		
		private double double66;
		
		private double double67;
		
		private double double68;
		
		private double double69;
		
		private double double70;
		
		private double double71;
		
		private double double72;
		
		private double double73;
		
		private double double74;
		
		private double double75;
		
		private double double76;
		
		private double double77;
		
		private double double78;
		
		private double double79;
		
		private double double80;
		
		private double double81;
		
		private double double82;
		
		private double double83;
		
		private double double84;
		
		private double double85;
		
		private double double86;
		
		private double double87;
		
		private double double88;
		
		private double double89;
		
		private double double90;
		
		private double double91;
		
		private double double92;
		
		private double double93;
		
		private double double94;
		
		private double double95;
		
		private double double96;
		
		private double double97;
		
		private double double98;
		
		private double double99;
		
		private double double100;
		
		private double double101;
		
		private double double102;
		
		private double double103;
		
		private double double104;
		
		private double double105;
		
		private double double106;
		
		private double double107;
		
		private double double108;
		
		private double double109;
		
		private double double110;
		
		private double double111;
		
		private double double112;
		
		private double double113;
		
		private double double114;
		
		private double double115;
		
		private double double116;
		
		private double double117;
		
		private double double118;
		
		private double double119;
		
		private double double120;
		
		private double double121;
		
		private double double122;
		
		private double double123;
		
		private double double124;
		
		private double double125;
		
		private double double126;
		
		private double double127;
		
		private double double128;
		
		private double double129;
		
		private double double130;
		
		private double double131;
		
		private double double132;
		
		private double double133;
		
		private double double134;
		
		private double double135;
		
		private double double136;
		
		private double double137;
		
		private double double138;
		
		private double double139;
		
		private double double140;
		
		private double double141;
		
		private double double142;
		
		private double double143;
		
		private double double144;
		
		private double double145;
		
		private double double146;
		
		private double double147;
		
		private double double148;
		
		private double double149;
		
		private double double150;
		
		private double double151;
		
		private double double152;
		
		private double double153;
		
		private double double154;
		
		private double double155;
		
		private double double156;
		
		private double double157;
		
		private double double158;
		
		private double double159;
		
		private double double160;
		
		private double double161;
		
		private double"
cmpl-6ttSB9gKqbfvP2XZqSiNgMudHq57c,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilities_1Test.java,58.178765296936035,length,"// CoordSystemUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystemUtilities.java 
    Created on 4. April 2002, 22:28
 */
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;

/**
 * This class provides some utility functions for a CoordSystem. They were
 * externalized to make the CoordSystem class clearer.
 * @author  mueller
 * @version 1.0
 */
public class CoordSystemUtilities {

    /**
     * used for the offset on the y axis for the size of a ""tick""
     */
    protected final int marginOffset = 6;

    protected CoordSystem c;

    protected ChartDataModelConstraints constraints;

    protected ChartDataModelConstraints constraints2;

    protected ChartDataModel model;

    /**
     * Creates a new instance of CoordSystemUtilities
     */
    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {
        c = coord;
        this.constraints = constraints;
        this.constraints2 = constraints2;
        this.model = model;
    }

    /**
     * Computes the left margin.
     */
    public int computeLeftMargin() {
        double xmin = constraints.getMinimumColumnValue();
        double xmax = constraints.getMaximumColumnValue();
        if (xmin <= 0 && xmax > 0) {
            xmin = Math.abs(xmin);
            xmax = Math.abs(xmax);
            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
            // yaxis label width
            // + yaxis title width
            int maxlmargin = computeYAxisLabelWidth() + marginOffset;
            // unit width
            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);
            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));
            // just for good looking
            margin += 5;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the right margin.
     */
    public int computeRightMargin() {
        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);
    }

    /**
     * Computes the top margin.
     */
    public int computeTopMargin() {
        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);
    }

    /**
     * Computes the bottom margin.
     */
    public int computeBottomMargin() {
        double ymin = constraints.getMinimumValue().doubleValue();
        double ymax = constraints.getMaximumValue().doubleValue();
        if (ymin <= 0 && ymax > 0) {
            ymin = Math.abs(ymin);
            ymax = Math.abs(ymax);
            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
            // xaxis label height
            // + xaxis title height
            int maxbmargin = computeXAxisLabelHeight() + marginOffset;
            // unit height
            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);
            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));
            // just for good looking
            margin += 10;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the maximum height of all x-axis labels.
     */
    public int computeXAxisLabelHeight() {
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        int height = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        boolean paint = false;
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                height = Math.max(height, (int) r.getHeight());
            }
            paint = !paint;
        }
        return height;
    }

    /**
     * Computes the maximum width of all y-axis labels.
     */
    public int computeYAxisLabelWidth() {
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        int width = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                width = Math.max((int) r.getWidth(), width);
            }
            paint = !paint;
        }
        return width;
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for numerical x-axis values.
     * @param g the Graphics2D context to paint in
     */
    public void drawNumericalXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(d, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            g.draw(ticks);
            if (paint && paintLabels) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            paint = !paint;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for non-numerical x-axis values..
     * @param g the Graphics2D context to paint in
     */
    public void drawXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        int min = (int) constraints.getMinimumColumnValue();
        int max = (int) constraints.getMaximumColumnValue();
        double tick = 1.0;
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v = null;
        Point2D oldv = null;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        boolean paintLabels = c.isPaintLabels();
        g.setFont(f);
        for (int i = min - 1; i < max; i++) {
            p.setLocation(i + 1, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            if (i + 1 < max)
                g.draw(ticks);
            // Draw Strings between ticks
            if (oldv != null && paintLabels) {
                String sb = (String) model.getColumnValueAt(i);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            oldv = v;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * y-axis.
     * @param g the Graphics2D context in which to draw
     */
    public void drawYAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        Color backupColor = g.getColor();
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(xpt, d);
            v = at.transform(p, null);
            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());
            g.draw(ticks);
            if (d != min && !c.isPaintOnlyTick()) {
                Line2D xax = getXAxisLine2D();
                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());
                g.setColor(Color.lightGray);
                g.draw(ticks);
                g.setColor(backupColor);
            }
            if (paintLabels && (paint || !c.isPaintAltTick())) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));
            }
            paint = !paint;
        }
    }

    /**
     * Computes the Line2D object of the x-axis using the DataConstraints.
     */
    public Line2D getXAxisLine2D() {
        double ypt = 0.0;
        // shift the x-axis according to the max and min y-values
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);
        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);
        return new Line2D.Double(l, r);
    }

    /**
     * Computes the Line2D object of the y-axis using the DataConstraints.
     */
    public Line2D getYAxisLine2D() {
        double xpt = 0.0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);
        //System.out.println(""** Y-Axis (""+o+"", ""+u+"")"");
        return new Line2D.Double(o, u);
    }

    /**
     * Computes the Line2D object of the second y-axis using the DataConstraints.
     */
    public Line2D getSecondYAxisLine2D() {
        double xpt = constraints2.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);
        return new Line2D.Double(o, u);
    }
}
","// CoordSystemUtilities_1Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeRightMargin()} method.
*/
class CoordSystemUtilities_1Test {","// CoordSystemUtilities_1Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeRightMargin()} method.
*/
class CoordSystemUtilities_1Test {

		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_1() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_2() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_3() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_4() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_5() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_6() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_7() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_8() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_9() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeRightMargin()} method.
		*/
		@Test
		void testComputeRightMargin_10() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeRightMargin(), 0);
		}
}

// CoordSystemUtilities_2Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeLeftMargin()} method.
*/
class CoordSystemUtilities_2Test {
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeLeftMargin()} method.
		*/
		@Test
		void testComputeLeftMargin() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeLeftMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeLeftMargin()} method.
		*/
		@Test
		void testComputeLeftMargin_1() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeLeftMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeLeftMargin()} method.
		*/
		@Test
		void testComputeLeftMargin_2() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeLeftMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeLeftMargin()} method.
		*/
		@Test
		void testComputeLeftMargin_3() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				assertEquals(coordSystemUtilities.computeLeftMargin(), 0);
		}
		
		/**
		* Test case for the {@link CoordSystemUtilities#computeLeftMargin()} method.
		*/
		@Test
		void testComputeLeftMargin_4() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(null, null, null, null);
				"
cmpl-6ttTEm59WzGmzBseslP2mDNgxsJCU,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilities_2Test.java,57.90005135536194,length,"// CoordSystemUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystemUtilities.java 
    Created on 4. April 2002, 22:28
 */
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;

/**
 * This class provides some utility functions for a CoordSystem. They were
 * externalized to make the CoordSystem class clearer.
 * @author  mueller
 * @version 1.0
 */
public class CoordSystemUtilities {

    /**
     * used for the offset on the y axis for the size of a ""tick""
     */
    protected final int marginOffset = 6;

    protected CoordSystem c;

    protected ChartDataModelConstraints constraints;

    protected ChartDataModelConstraints constraints2;

    protected ChartDataModel model;

    /**
     * Creates a new instance of CoordSystemUtilities
     */
    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {
        c = coord;
        this.constraints = constraints;
        this.constraints2 = constraints2;
        this.model = model;
    }

    /**
     * Computes the left margin.
     */
    public int computeLeftMargin() {
        double xmin = constraints.getMinimumColumnValue();
        double xmax = constraints.getMaximumColumnValue();
        if (xmin <= 0 && xmax > 0) {
            xmin = Math.abs(xmin);
            xmax = Math.abs(xmax);
            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
            // yaxis label width
            // + yaxis title width
            int maxlmargin = computeYAxisLabelWidth() + marginOffset;
            // unit width
            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);
            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));
            // just for good looking
            margin += 5;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the right margin.
     */
    public int computeRightMargin() {
        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);
    }

    /**
     * Computes the top margin.
     */
    public int computeTopMargin() {
        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);
    }

    /**
     * Computes the bottom margin.
     */
    public int computeBottomMargin() {
        double ymin = constraints.getMinimumValue().doubleValue();
        double ymax = constraints.getMaximumValue().doubleValue();
        if (ymin <= 0 && ymax > 0) {
            ymin = Math.abs(ymin);
            ymax = Math.abs(ymax);
            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
            // xaxis label height
            // + xaxis title height
            int maxbmargin = computeXAxisLabelHeight() + marginOffset;
            // unit height
            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);
            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));
            // just for good looking
            margin += 10;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the maximum height of all x-axis labels.
     */
    public int computeXAxisLabelHeight() {
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        int height = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        boolean paint = false;
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                height = Math.max(height, (int) r.getHeight());
            }
            paint = !paint;
        }
        return height;
    }

    /**
     * Computes the maximum width of all y-axis labels.
     */
    public int computeYAxisLabelWidth() {
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        int width = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                width = Math.max((int) r.getWidth(), width);
            }
            paint = !paint;
        }
        return width;
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for numerical x-axis values.
     * @param g the Graphics2D context to paint in
     */
    public void drawNumericalXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(d, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            g.draw(ticks);
            if (paint && paintLabels) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            paint = !paint;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for non-numerical x-axis values..
     * @param g the Graphics2D context to paint in
     */
    public void drawXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        int min = (int) constraints.getMinimumColumnValue();
        int max = (int) constraints.getMaximumColumnValue();
        double tick = 1.0;
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v = null;
        Point2D oldv = null;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        boolean paintLabels = c.isPaintLabels();
        g.setFont(f);
        for (int i = min - 1; i < max; i++) {
            p.setLocation(i + 1, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            if (i + 1 < max)
                g.draw(ticks);
            // Draw Strings between ticks
            if (oldv != null && paintLabels) {
                String sb = (String) model.getColumnValueAt(i);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            oldv = v;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * y-axis.
     * @param g the Graphics2D context in which to draw
     */
    public void drawYAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        Color backupColor = g.getColor();
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(xpt, d);
            v = at.transform(p, null);
            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());
            g.draw(ticks);
            if (d != min && !c.isPaintOnlyTick()) {
                Line2D xax = getXAxisLine2D();
                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());
                g.setColor(Color.lightGray);
                g.draw(ticks);
                g.setColor(backupColor);
            }
            if (paintLabels && (paint || !c.isPaintAltTick())) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));
            }
            paint = !paint;
        }
    }

    /**
     * Computes the Line2D object of the x-axis using the DataConstraints.
     */
    public Line2D getXAxisLine2D() {
        double ypt = 0.0;
        // shift the x-axis according to the max and min y-values
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);
        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);
        return new Line2D.Double(l, r);
    }

    /**
     * Computes the Line2D object of the y-axis using the DataConstraints.
     */
    public Line2D getYAxisLine2D() {
        double xpt = 0.0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);
        //System.out.println(""** Y-Axis (""+o+"", ""+u+"")"");
        return new Line2D.Double(o, u);
    }

    /**
     * Computes the Line2D object of the second y-axis using the DataConstraints.
     */
    public Line2D getSecondYAxisLine2D() {
        double xpt = constraints2.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);
        return new Line2D.Double(o, u);
    }
}
","// CoordSystemUtilities_2Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeTopMargin()} method.
*/
class CoordSystemUtilities_2Test {","// CoordSystemUtilities_2Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeTopMargin()} method.
*/
class CoordSystemUtilities_2Test {

		/**
		* Test case for {@link CoordSystemUtilities#computeTopMargin()} method.
		* Test case for the following conditions:
		* <ul>
		* <li>The {@link CoordSystemUtilities#computeTopMargin()} method is called.</li>
		* <li>The {@link CoordSystemUtilities#computeTopMargin()} method returns the expected value.</li>
		* </ul>
		*/
		@Test
		void testComputeTopMargin_1() {
				CoordSystemUtilities coordSystemUtilities = new CoordSystemUtilities(new CoordSystem(new Rectangle2D.Double(0.0, 0.0, 100.0, 100.0), new ChartDataModelConstraints(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0"
cmpl-6ttUHgc7aVUMoB0M8vzSccOU9HOaW,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilities_3Test.java,58.68926668167114,length,"// CoordSystemUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystemUtilities.java 
    Created on 4. April 2002, 22:28
 */
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;

/**
 * This class provides some utility functions for a CoordSystem. They were
 * externalized to make the CoordSystem class clearer.
 * @author  mueller
 * @version 1.0
 */
public class CoordSystemUtilities {

    /**
     * used for the offset on the y axis for the size of a ""tick""
     */
    protected final int marginOffset = 6;

    protected CoordSystem c;

    protected ChartDataModelConstraints constraints;

    protected ChartDataModelConstraints constraints2;

    protected ChartDataModel model;

    /**
     * Creates a new instance of CoordSystemUtilities
     */
    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {
        c = coord;
        this.constraints = constraints;
        this.constraints2 = constraints2;
        this.model = model;
    }

    /**
     * Computes the left margin.
     */
    public int computeLeftMargin() {
        double xmin = constraints.getMinimumColumnValue();
        double xmax = constraints.getMaximumColumnValue();
        if (xmin <= 0 && xmax > 0) {
            xmin = Math.abs(xmin);
            xmax = Math.abs(xmax);
            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
            // yaxis label width
            // + yaxis title width
            int maxlmargin = computeYAxisLabelWidth() + marginOffset;
            // unit width
            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);
            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));
            // just for good looking
            margin += 5;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the right margin.
     */
    public int computeRightMargin() {
        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);
    }

    /**
     * Computes the top margin.
     */
    public int computeTopMargin() {
        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);
    }

    /**
     * Computes the bottom margin.
     */
    public int computeBottomMargin() {
        double ymin = constraints.getMinimumValue().doubleValue();
        double ymax = constraints.getMaximumValue().doubleValue();
        if (ymin <= 0 && ymax > 0) {
            ymin = Math.abs(ymin);
            ymax = Math.abs(ymax);
            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
            // xaxis label height
            // + xaxis title height
            int maxbmargin = computeXAxisLabelHeight() + marginOffset;
            // unit height
            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);
            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));
            // just for good looking
            margin += 10;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the maximum height of all x-axis labels.
     */
    public int computeXAxisLabelHeight() {
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        int height = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        boolean paint = false;
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                height = Math.max(height, (int) r.getHeight());
            }
            paint = !paint;
        }
        return height;
    }

    /**
     * Computes the maximum width of all y-axis labels.
     */
    public int computeYAxisLabelWidth() {
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        int width = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                width = Math.max((int) r.getWidth(), width);
            }
            paint = !paint;
        }
        return width;
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for numerical x-axis values.
     * @param g the Graphics2D context to paint in
     */
    public void drawNumericalXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(d, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            g.draw(ticks);
            if (paint && paintLabels) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            paint = !paint;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for non-numerical x-axis values..
     * @param g the Graphics2D context to paint in
     */
    public void drawXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        int min = (int) constraints.getMinimumColumnValue();
        int max = (int) constraints.getMaximumColumnValue();
        double tick = 1.0;
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v = null;
        Point2D oldv = null;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        boolean paintLabels = c.isPaintLabels();
        g.setFont(f);
        for (int i = min - 1; i < max; i++) {
            p.setLocation(i + 1, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            if (i + 1 < max)
                g.draw(ticks);
            // Draw Strings between ticks
            if (oldv != null && paintLabels) {
                String sb = (String) model.getColumnValueAt(i);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            oldv = v;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * y-axis.
     * @param g the Graphics2D context in which to draw
     */
    public void drawYAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        Color backupColor = g.getColor();
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(xpt, d);
            v = at.transform(p, null);
            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());
            g.draw(ticks);
            if (d != min && !c.isPaintOnlyTick()) {
                Line2D xax = getXAxisLine2D();
                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());
                g.setColor(Color.lightGray);
                g.draw(ticks);
                g.setColor(backupColor);
            }
            if (paintLabels && (paint || !c.isPaintAltTick())) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));
            }
            paint = !paint;
        }
    }

    /**
     * Computes the Line2D object of the x-axis using the DataConstraints.
     */
    public Line2D getXAxisLine2D() {
        double ypt = 0.0;
        // shift the x-axis according to the max and min y-values
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);
        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);
        return new Line2D.Double(l, r);
    }

    /**
     * Computes the Line2D object of the y-axis using the DataConstraints.
     */
    public Line2D getYAxisLine2D() {
        double xpt = 0.0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);
        //System.out.println(""** Y-Axis (""+o+"", ""+u+"")"");
        return new Line2D.Double(o, u);
    }

    /**
     * Computes the Line2D object of the second y-axis using the DataConstraints.
     */
    public Line2D getSecondYAxisLine2D() {
        double xpt = constraints2.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);
        return new Line2D.Double(o, u);
    }
}
","// CoordSystemUtilities_3Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeBottomMargin()} method.
*/
class CoordSystemUtilities_3Test {","// CoordSystemUtilities_3Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeBottomMargin()} method.
*/
class CoordSystemUtilities_3Test {

		/**
		* Test case 1 for {@link CoordSystemUtilities#computeBottomMargin()}.
		*/
		@Test
		void testComputeBottomMargin1() {
				CoordSystem c = new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100));
				ChartDataModelConstraints constraints = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModelConstraints constraints2 = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModel model = new ChartDataModel();
				CoordSystemUtilities csu = new CoordSystemUtilities(c, constraints, constraints2, model);
				assertEquals(csu.computeBottomMargin(), c.MINIMALMARGIN);
		}
		
		/**
		* Test case 2 for {@link CoordSystemUtilities#computeBottomMargin()}.
		*/
		@Test
		void testComputeBottomMargin2() {
				CoordSystem c = new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100));
				ChartDataModelConstraints constraints = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModelConstraints constraints2 = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModel model = new ChartDataModel();
				CoordSystemUtilities csu = new CoordSystemUtilities(c, constraints, constraints2, model);
				c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				c.setXAxisUnit(""X"");
				assertEquals(csu.computeBottomMargin(), c.MINIMALMARGIN);
		}
		
		/**
		* Test case 3 for {@link CoordSystemUtilities#computeBottomMargin()}.
		*/
		@Test
		void testComputeBottomMargin3() {
				CoordSystem c = new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100));
				ChartDataModelConstraints constraints = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModelConstraints constraints2 = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModel model = new ChartDataModel();
				CoordSystemUtilities csu = new CoordSystemUtilities(c, constraints, constraints2, model);
				c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				c.setXAxisUnit(""X"");
				c.setPaintLabels(true);
				assertEquals(csu.computeBottomMargin(), c.MINIMALMARGIN);
		}
		
		/**
		* Test case 4 for {@link CoordSystemUtilities#computeBottomMargin()}.
		*/
		@Test
		void testComputeBottomMargin4() {
				CoordSystem c = new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100));
				ChartDataModelConstraints constraints = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModelConstraints constraints2 = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModel model = new ChartDataModel();
				CoordSystemUtilities csu = new CoordSystemUtilities(c, constraints, constraints2, model);
				c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				c.setXAxisUnit(""X"");
				c.setPaintLabels(true);
				c.setPaintOnlyTick(true);
				assertEquals(csu.computeBottomMargin(), c.MINIMALMARGIN);
		}
		
		/**
		* Test case 5 for {@link CoordSystemUtilities#computeBottomMargin()}.
		*/
		@Test
		void testComputeBottomMargin5() {
				CoordSystem c = new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100));
				ChartDataModelConstraints constraints = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModelConstraints constraints2 = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModel model = new ChartDataModel();
				CoordSystemUtilities csu = new CoordSystemUtilities(c, constraints, constraints2, model);
				c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				c.setXAxisUnit(""X"");
				c.setPaintLabels(true);
				c.setPaintOnlyTick(true);
				c.setPaintAltTick(true);
				assertEquals(csu.computeBottomMargin(), c.MINIMALMARGIN);
		}
		
		/**
		* Test case 6 for {@link CoordSystemUtilities#computeBottomMargin()}.
		*/
		@Test
		void testComputeBottomMargin6() {
				CoordSystem c = new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100));
				ChartDataModelConstraints constraints = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModelConstraints constraints2 = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModel model = new ChartDataModel();
				CoordSystemUtilities csu = new CoordSystemUtilities(c, constraints, constraints2, model);
				c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				c.setXAxisUnit(""X"");
				c.setPaintLabels(true);
				c.setPaintOnlyTick(true);
				c.setPaintAltTick(true);
				c.setXDecimalFormat(new DecimalFormat(""0.00""));
				assertEquals(csu.computeBottomMargin(), c.MINIMALMARGIN);
		}
		
		/**
		* Test case 7 for {@link CoordSystemUtilities#computeBottomMargin()}.
		*/
		@Test
		void testComputeBottomMargin7() {
				CoordSystem c = new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100));
				ChartDataModelConstraints constraints = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModelConstraints constraints2 = new ChartDataModelConstraints(0, 0, 0, 0);
				ChartDataModel model = new ChartDataModel();
				CoordSystemUtilities csu = new CoordSystemUtilities(c, constraints, constraints2, model);
				c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true"
cmpl-6ttVK5wD1OR1VhBUFfv7W3KtUNQ6V,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilities_4Test.java,54.34304213523865,length,"// CoordSystemUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystemUtilities.java 
    Created on 4. April 2002, 22:28
 */
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;

/**
 * This class provides some utility functions for a CoordSystem. They were
 * externalized to make the CoordSystem class clearer.
 * @author  mueller
 * @version 1.0
 */
public class CoordSystemUtilities {

    /**
     * used for the offset on the y axis for the size of a ""tick""
     */
    protected final int marginOffset = 6;

    protected CoordSystem c;

    protected ChartDataModelConstraints constraints;

    protected ChartDataModelConstraints constraints2;

    protected ChartDataModel model;

    /**
     * Creates a new instance of CoordSystemUtilities
     */
    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {
        c = coord;
        this.constraints = constraints;
        this.constraints2 = constraints2;
        this.model = model;
    }

    /**
     * Computes the left margin.
     */
    public int computeLeftMargin() {
        double xmin = constraints.getMinimumColumnValue();
        double xmax = constraints.getMaximumColumnValue();
        if (xmin <= 0 && xmax > 0) {
            xmin = Math.abs(xmin);
            xmax = Math.abs(xmax);
            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
            // yaxis label width
            // + yaxis title width
            int maxlmargin = computeYAxisLabelWidth() + marginOffset;
            // unit width
            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);
            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));
            // just for good looking
            margin += 5;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the right margin.
     */
    public int computeRightMargin() {
        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);
    }

    /**
     * Computes the top margin.
     */
    public int computeTopMargin() {
        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);
    }

    /**
     * Computes the bottom margin.
     */
    public int computeBottomMargin() {
        double ymin = constraints.getMinimumValue().doubleValue();
        double ymax = constraints.getMaximumValue().doubleValue();
        if (ymin <= 0 && ymax > 0) {
            ymin = Math.abs(ymin);
            ymax = Math.abs(ymax);
            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
            // xaxis label height
            // + xaxis title height
            int maxbmargin = computeXAxisLabelHeight() + marginOffset;
            // unit height
            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);
            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));
            // just for good looking
            margin += 10;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the maximum height of all x-axis labels.
     */
    public int computeXAxisLabelHeight() {
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        int height = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        boolean paint = false;
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                height = Math.max(height, (int) r.getHeight());
            }
            paint = !paint;
        }
        return height;
    }

    /**
     * Computes the maximum width of all y-axis labels.
     */
    public int computeYAxisLabelWidth() {
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        int width = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                width = Math.max((int) r.getWidth(), width);
            }
            paint = !paint;
        }
        return width;
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for numerical x-axis values.
     * @param g the Graphics2D context to paint in
     */
    public void drawNumericalXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(d, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            g.draw(ticks);
            if (paint && paintLabels) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            paint = !paint;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for non-numerical x-axis values..
     * @param g the Graphics2D context to paint in
     */
    public void drawXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        int min = (int) constraints.getMinimumColumnValue();
        int max = (int) constraints.getMaximumColumnValue();
        double tick = 1.0;
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v = null;
        Point2D oldv = null;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        boolean paintLabels = c.isPaintLabels();
        g.setFont(f);
        for (int i = min - 1; i < max; i++) {
            p.setLocation(i + 1, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            if (i + 1 < max)
                g.draw(ticks);
            // Draw Strings between ticks
            if (oldv != null && paintLabels) {
                String sb = (String) model.getColumnValueAt(i);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            oldv = v;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * y-axis.
     * @param g the Graphics2D context in which to draw
     */
    public void drawYAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        Color backupColor = g.getColor();
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(xpt, d);
            v = at.transform(p, null);
            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());
            g.draw(ticks);
            if (d != min && !c.isPaintOnlyTick()) {
                Line2D xax = getXAxisLine2D();
                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());
                g.setColor(Color.lightGray);
                g.draw(ticks);
                g.setColor(backupColor);
            }
            if (paintLabels && (paint || !c.isPaintAltTick())) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));
            }
            paint = !paint;
        }
    }

    /**
     * Computes the Line2D object of the x-axis using the DataConstraints.
     */
    public Line2D getXAxisLine2D() {
        double ypt = 0.0;
        // shift the x-axis according to the max and min y-values
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);
        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);
        return new Line2D.Double(l, r);
    }

    /**
     * Computes the Line2D object of the y-axis using the DataConstraints.
     */
    public Line2D getYAxisLine2D() {
        double xpt = 0.0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);
        //System.out.println(""** Y-Axis (""+o+"", ""+u+"")"");
        return new Line2D.Double(o, u);
    }

    /**
     * Computes the Line2D object of the second y-axis using the DataConstraints.
     */
    public Line2D getSecondYAxisLine2D() {
        double xpt = constraints2.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);
        return new Line2D.Double(o, u);
    }
}
","// CoordSystemUtilities_4Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeXAxisLabelHeight()} method.
*/
class CoordSystemUtilities_4Test {","// CoordSystemUtilities_4Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeXAxisLabelHeight()} method.
*/
class CoordSystemUtilities_4Test {

		/**
		* Test case for {@link CoordSystemUtilities#computeXAxisLabelHeight()} method.
		* Test data:
		*																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																							"
cmpl-6ttWNsHrrKmaoQ5dThLTYruWt1W8u,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystemUtilities_5Test.java,50.4263870716095,length,"// CoordSystemUtilities.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystemUtilities.java 
    Created on 4. April 2002, 22:28
 */
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;

/**
 * This class provides some utility functions for a CoordSystem. They were
 * externalized to make the CoordSystem class clearer.
 * @author  mueller
 * @version 1.0
 */
public class CoordSystemUtilities {

    /**
     * used for the offset on the y axis for the size of a ""tick""
     */
    protected final int marginOffset = 6;

    protected CoordSystem c;

    protected ChartDataModelConstraints constraints;

    protected ChartDataModelConstraints constraints2;

    protected ChartDataModel model;

    /**
     * Creates a new instance of CoordSystemUtilities
     */
    public CoordSystemUtilities(CoordSystem coord, ChartDataModelConstraints constraints, ChartDataModelConstraints constraints2, ChartDataModel model) {
        c = coord;
        this.constraints = constraints;
        this.constraints2 = constraints2;
        this.model = model;
    }

    /**
     * Computes the left margin.
     */
    public int computeLeftMargin() {
        double xmin = constraints.getMinimumColumnValue();
        double xmax = constraints.getMaximumColumnValue();
        if (xmin <= 0 && xmax > 0) {
            xmin = Math.abs(xmin);
            xmax = Math.abs(xmax);
            TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
            // yaxis label width
            // + yaxis title width
            int maxlmargin = computeYAxisLabelWidth() + marginOffset;
            // unit width
            maxlmargin = Math.max(maxlmargin, (int) layout.getBounds().getWidth() + marginOffset);
            int margin = (int) (maxlmargin - (xmin / (xmin + xmax)) * (c.getBounds().getWidth() - c.getRightMargin()));
            // just for good looking
            margin += 5;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the right margin.
     */
    public int computeRightMargin() {
        TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getWidth() + (double) c.ARROWLENGTH / 3), c.ARROWLENGTH);
    }

    /**
     * Computes the top margin.
     */
    public int computeTopMargin() {
        TextLayout layout = new TextLayout(c.getYAxisUnit(), c.getFont(), c.getFontRenderContext());
        return Math.max((int) (layout.getBounds().getHeight() + (double) c.ARROWLENGTH / 3 + layout.getDescent()), c.ARROWLENGTH);
    }

    /**
     * Computes the bottom margin.
     */
    public int computeBottomMargin() {
        double ymin = constraints.getMinimumValue().doubleValue();
        double ymax = constraints.getMaximumValue().doubleValue();
        if (ymin <= 0 && ymax > 0) {
            ymin = Math.abs(ymin);
            ymax = Math.abs(ymax);
            TextLayout layout = new TextLayout(c.getXAxisUnit(), c.getFont(), c.getFontRenderContext());
            // xaxis label height
            // + xaxis title height
            int maxbmargin = computeXAxisLabelHeight() + marginOffset;
            // unit height
            maxbmargin = Math.max(maxbmargin, (int) layout.getBounds().getHeight() + marginOffset);
            int margin = (int) (maxbmargin - (ymin / (ymin + ymax)) * (c.getBounds().getHeight() - c.getTopMargin()));
            // just for good looking
            margin += 10;
            if (margin < c.MINIMALMARGIN)
                margin = c.MINIMALMARGIN;
            return margin;
        } else {
            return c.MINIMALMARGIN;
        }
    }

    /**
     * Computes the maximum height of all x-axis labels.
     */
    public int computeXAxisLabelHeight() {
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        int height = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        boolean paint = false;
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                height = Math.max(height, (int) r.getHeight());
            }
            paint = !paint;
        }
        return height;
    }

    /**
     * Computes the maximum width of all y-axis labels.
     */
    public int computeYAxisLabelWidth() {
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        int width = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        for (double d = min; d <= max; d += tick) {
            if (paint) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                width = Math.max((int) r.getWidth(), width);
            }
            paint = !paint;
        }
        return width;
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for numerical x-axis values.
     * @param g the Graphics2D context to paint in
     */
    public void drawNumericalXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumColumnValue();
        double max = constraints.getMaximumColumnValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(d, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            g.draw(ticks);
            if (paint && paintLabels) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            paint = !paint;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * x-axis for non-numerical x-axis values..
     * @param g the Graphics2D context to paint in
     */
    public void drawXAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        int min = (int) constraints.getMinimumColumnValue();
        int max = (int) constraints.getMaximumColumnValue();
        double tick = 1.0;
        double ypt = 0;
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v = null;
        Point2D oldv = null;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        DecimalFormat df = c.getXDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        boolean paint = false;
        boolean paintLabels = c.isPaintLabels();
        g.setFont(f);
        for (int i = min - 1; i < max; i++) {
            p.setLocation(i + 1, ypt);
            v = at.transform(p, null);
            ticks.setLine(v.getX(), v.getY() - marginOffset / 2, v.getX(), v.getY() + marginOffset / 2);
            if (i + 1 < max)
                g.draw(ticks);
            // Draw Strings between ticks
            if (oldv != null && paintLabels) {
                String sb = (String) model.getColumnValueAt(i);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (oldv.getX() + (v.getX() - oldv.getX()) / 2 - r.getWidth() / 2), (float) (v.getY() + r.getHeight() + marginOffset));
            }
            oldv = v;
        }
    }

    /**
     * This method is called by paintDefault to paint the ticks on the
     * y-axis.
     * @param g the Graphics2D context in which to draw
     */
    public void drawYAxisTicks(Graphics2D g) {
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        double min = constraints.getMinimumValue().doubleValue();
        double max = constraints.getMaximumValue().doubleValue();
        double tick = ChartUtilities.calculateTickSpacing(min, max);
        double xpt = 0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        Point2D p = new Point2D.Double(0.0, 0.0);
        Point2D v;
        Line2D ticks = new Line2D.Double(0.0, 0.0, 0.0, 0.0);
        boolean paint = false;
        DecimalFormat df = c.getYDecimalFormat();
        FontRenderContext frc = c.getFontRenderContext();
        Font f = c.getFont();
        Color backupColor = g.getColor();
        g.setFont(f);
        boolean paintLabels = c.isPaintLabels();
        for (double d = min; d <= max; d += tick) {
            p.setLocation(xpt, d);
            v = at.transform(p, null);
            ticks.setLine(v.getX() - marginOffset / 2, v.getY(), v.getX() + marginOffset / 2, v.getY());
            g.draw(ticks);
            if (d != min && !c.isPaintOnlyTick()) {
                Line2D xax = getXAxisLine2D();
                ticks.setLine(v.getX() + marginOffset / 2, v.getY(), xax.getX2(), v.getY());
                g.setColor(Color.lightGray);
                g.draw(ticks);
                g.setColor(backupColor);
            }
            if (paintLabels && (paint || !c.isPaintAltTick())) {
                String sb = df.format(d);
                Rectangle2D r = f.getStringBounds(sb, frc);
                g.drawString(sb, (float) (v.getX() - r.getWidth() - marginOffset), (float) (v.getY() + r.getHeight() / 2));
            }
            paint = !paint;
        }
    }

    /**
     * Computes the Line2D object of the x-axis using the DataConstraints.
     */
    public Line2D getXAxisLine2D() {
        double ypt = 0.0;
        // shift the x-axis according to the max and min y-values
        if (constraints.getMinimumValue().doubleValue() > 0)
            ypt = constraints.getMinimumValue().doubleValue();
        else if (constraints.getMaximumValue().doubleValue() < 0)
            ypt = constraints.getMaximumValue().doubleValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D l = at.transform(new Point2D.Double(constraints.getMinimumColumnValue(), ypt), null);
        Point2D r = at.transform(new Point2D.Double(constraints.getMaximumColumnValue(), ypt), null);
        return new Line2D.Double(l, r);
    }

    /**
     * Computes the Line2D object of the y-axis using the DataConstraints.
     */
    public Line2D getYAxisLine2D() {
        double xpt = 0.0;
        // shift the y-axis according to the max and min x-values
        if (constraints.getMinimumColumnValue() > 0)
            xpt = constraints.getMinimumColumnValue();
        else if (constraints.getMaximumColumnValue() < 0 && c.getSecondYAxis() != null)
            xpt = constraints.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.FIRST_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints.getMinimumValue().doubleValue()), null);
        //System.out.println(""** Y-Axis (""+o+"", ""+u+"")"");
        return new Line2D.Double(o, u);
    }

    /**
     * Computes the Line2D object of the second y-axis using the DataConstraints.
     */
    public Line2D getSecondYAxisLine2D() {
        double xpt = constraints2.getMaximumColumnValue();
        AffineTransform at = c.getTransform(CoordSystem.SECOND_YAXIS);
        Point2D o = at.transform(new Point2D.Double(xpt, constraints2.getMaximumValue().doubleValue()), null);
        Point2D u = at.transform(new Point2D.Double(xpt, constraints2.getMinimumValue().doubleValue()), null);
        return new Line2D.Double(o, u);
    }
}
","// CoordSystemUtilities_5Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeYAxisLabelWidth()} method.
*/
class CoordSystemUtilities_5Test {","// CoordSystemUtilities_5Test.java
package de.progra.charting;

import java.awt.font.FontRenderContext;
import java.text.DecimalFormat;
import java.awt.geom.AffineTransform;
import java.awt.geom.Line2D;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.font.TextLayout;
import de.progra.charting.model.ChartDataModelConstraints;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystemUtilities}.
* It contains ten unit test cases for the {@link CoordSystemUtilities#computeYAxisLabelWidth()} method.
*/
class CoordSystemUtilities_5Test {

		/**
		* Test case 1 for {@link CoordSystemUtilities#computeYAxisLabelWidth()}.
		*/
		@Test
		void testComputeYAxisLabelWidth_1() {
				CoordSystemUtilities csu = new CoordSystemUtilities(new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100)), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" }));
				csu.c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				csu.c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				csu.c.setYDecimalFormat(new DecimalFormat(""0.00""));
				csu.constraints.setMinimumValue(new Double(-10));
				csu.constraints.setMaximumValue(new Double(10));
				csu.constraints.setMinimumColumnValue(0);
				csu.constraints.setMaximumColumnValue(10);
				assertEquals(csu.computeYAxisLabelWidth(), 6);
		}
		
		/**
		* Test case 2 for {@link CoordSystemUtilities#computeYAxisLabelWidth()}.
		*/
		@Test
		void testComputeYAxisLabelWidth_2() {
				CoordSystemUtilities csu = new CoordSystemUtilities(new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100)), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" }));
				csu.c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				csu.c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				csu.c.setYDecimalFormat(new DecimalFormat(""0.00""));
				csu.constraints.setMinimumValue(new Double(-10));
				csu.constraints.setMaximumValue(new Double(10));
				csu.constraints.setMinimumColumnValue(0);
				csu.constraints.setMaximumColumnValue(10);
				assertEquals(csu.computeYAxisLabelWidth(), 6);
		}
		
		/**
		* Test case 3 for {@link CoordSystemUtilities#computeYAxisLabelWidth()}.
		*/
		@Test
		void testComputeYAxisLabelWidth_3() {
				CoordSystemUtilities csu = new CoordSystemUtilities(new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100)), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" }));
				csu.c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				csu.c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				csu.c.setYDecimalFormat(new DecimalFormat(""0.00""));
				csu.constraints.setMinimumValue(new Double(-10));
				csu.constraints.setMaximumValue(new Double(10));
				csu.constraints.setMinimumColumnValue(0);
				csu.constraints.setMaximumColumnValue(10);
				assertEquals(csu.computeYAxisLabelWidth(), 6);
		}
		
		/**
		* Test case 4 for {@link CoordSystemUtilities#computeYAxisLabelWidth()}.
		*/
		@Test
		void testComputeYAxisLabelWidth_4() {
				CoordSystemUtilities csu = new CoordSystemUtilities(new CoordSystem(new Rectangle2D.Double(0, 0, 100, 100)), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModelConstraints(new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" })), new ChartDataModel(new double[][] { { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 } }, new String[] { ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"" }));
				csu.c.setFont(new Font(""Arial"", Font.PLAIN, 10));
				csu.c.setFontRenderContext(new FontRenderContext(new AffineTransform(), true, true));
				csu.c.setYDecimalFormat(new DecimalFormat(""0.00""));
				csu.constraints.setMinimumValue(new Double(-10));
			"
399fdeff-d639-4364-bd0d-0dd5dcb4957b,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystem_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8354 tokens (6354 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// CoordSystem.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystem.java
    Created on 26. Juni 2001, 22:49
 */
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;

/**
 * This class defines a coordinate system. The CoordSystem class computes
 * an AffineTransform for each y-axis, which translates the user space
 * coordinates (ie. the data value coordinates) into pixel space coordinates.
 * These AffineTransform classes make the PixelToPointTranslator obsolete,
 * since it provides more flexibility. <code>getDefaultTransform</code> always
 * computes the default transformation, whereas you can set another
 * transformation via <code>setTransform</code>. This will be used to implement
 * zooming and panning in the Swing classes.<p>
 * All classes incl. this one, which render data will use the transformations
 * to translate the coordinates. The transformations are not set up on
 * instantiation of a CoordSystem, instead they're computed when setBounds
 * is called, because they need this information of course. Afterwards you
 * can set your own transformation or even better you can manipulate the
 * existing ones by pre- or postconcatenating another AffineTransform.
 */
public class CoordSystem extends AbstractRenderer {

    /**
     * The x-axis caption string.
     */
    protected String xaxis_unit = ""x"";

    /**
     * The y-axis caption string.
     */
    protected String yaxis_unit = ""y"";

    /**
     * The Font used in the CoordSystem.
     */
    protected Font font = new Font(""sans"", Font.PLAIN, 9);

    /**
     * FontRenderContext used througout the CoordSystem
     */
    protected final FontRenderContext frc = new FontRenderContext(null, false, false);

    /**
     * DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    protected DecimalFormat dfY;

    /**
     * DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    protected DecimalFormat dfX;

    /**
     * if true, the arrows will be drawn at the end of the axi
     */
    protected boolean shouldDrawArrows = true;

    /**
     * if true, the increment will be painted at each tick mark
     */
    protected boolean shouldPaintAltTick = true;

    /**
     * if true only the tick will be painted on the yaxis.  Alternately, if false, a
     * light grey line will paint across the background of the chart.
     */
    protected boolean shouldPaintOnlyTick = true;

    /**
     * If true, the labels will be painted. If false, only the ticks will display.
     */
    protected boolean shouldPaintLabels = true;

    /**
     * The left margin
     */
    protected int leftmargin = 50;

    /**
     * The top margin.
     */
    protected int topmargin = 20;

    /**
     * The right margin.
     */
    protected int rightmargin = 30;

    /**
     * The bottom margin.
     */
    protected int bottommargin = 30;

    /**
     * The minimal margin constant.
     */
    public final int MINIMALMARGIN = 20;

    /**
     * The arrow length constant.
     */
    public final int ARROWLENGTH = 15;

    /**
     * The ChartDataModel constraints of the first y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints;

    /**
     * The ChartDataModel constraints of the second y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints2;

    /**
     * The DataModel class.
     */
    protected ChartDataModel model;

    /**
     * The utilities class, which contains all the rendering methods etc.
     */
    protected CoordSystemUtilities c;

    /**
     * The xaxis.
     */
    protected Axis xaxis;

    /**
     * The first y-axis.
     */
    protected Axis yaxis;

    /**
     * The second y-axis.
     */
    protected Axis yaxis2;

    /**
     * The multiplication matrix for the first y-axis and the x-axis.
     */
    protected AffineTransform y1transform;

    /**
     * The multiplication matrix for the second y-axis and the x-axis.
     */
    protected AffineTransform y2transform;

    /**
     * the axis binding constant for the first y-axis
     */
    public static final int FIRST_YAXIS = 0;

    /**
     * the axis binding constant for the second y-axis
     */
    public static final int SECOND_YAXIS = 1;

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     */
    public CoordSystem(ChartDataModel cdm) {
        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);
        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);
        this.model = cdm;
        xaxis = new Axis(Axis.HORIZONTAL, constraints);
        yaxis = new Axis(Axis.VERTICAL, constraints);
        c = new CoordSystemUtilities(this, constraints, constraints2, model);
        dfY = new DecimalFormat();
        dfX = new DecimalFormat();
    }

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param xtext the x-axis unit
     * @param ytext the y-axis unit
     */
    public CoordSystem(ChartDataModel c, String xunit, String yunit) {
        this(c);
        setXAxisUnit(xunit);
        setYAxisUnit(yunit);
    }

    /**
     * Create a new CoordSystem with alternate painting parameters.
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param drawArrows if true the arrows will be drawn at the end of the axis
     * @param paintAltYTick if true the caption will paint on alternate ticks of the
     * yaxis instead of on every one.
     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>
     * appear behind the chart at each yaxis tick mark.
     */
    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {
        this(c);
        dfY = yAxisFormat;
        shouldDrawArrows = drawArrows;
        shouldPaintAltTick = paintAltYTick;
        shouldPaintOnlyTick = paintOnlyYTick;
    }

    /**
     * Sets the coordinate transformation for any y-coordinate.
     * @param at the AffineTransform that transforms the coordinates into pixel
     * space
     * @axis defines for which y-axis the transform is computed
     */
    public void setTransform(AffineTransform at, int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                y1transform = at;
                break;
            case (SECOND_YAXIS):
                y2transform = at;
                break;
        }
    }

    /**
     * Returns the currently defined AffineTransform for any y-axis.
     * @param axis the y-axis to be used.
     */
    public AffineTransform getTransform(int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                return y1transform;
            case (SECOND_YAXIS):
                return y2transform;
        }
        return null;
    }

    /**
     * This method computes the default transform which transforms the
     * user space coordinates of this coordinate system to the pixel
     * space coordinates used in the Graphics object.
     * All rendering in the CoordinateSystem and the ChartRenderers
     * will rely on this transform.
     * @param axis defines which y-axis to use.
     */
    public AffineTransform getDefaultTransform(int axis) {
        double x_pt2px = 0;
        double y_pt2px = 0;
        double xcoord0 = 0;
        double ycoord0 = 0;
        x_pt2px = 1 / getXAxis().getPointToPixelRatio();
        //System.out.println(""** x_pt2px = ""+getXAxis().getPointToPixelRatio());
        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);
        switch(axis) {
            case FIRST_YAXIS:
                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);
                break;
            case SECOND_YAXIS:
                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);
                break;
        }
        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);
    }

    /**
     * Sets the x-axis.
     * @param a the x-axis
     */
    public void setXAxis(Axis a) {
        xaxis = a;
    }

    /**
     * Returns the x axis.
     * @return the x-axis
     */
    public Axis getXAxis() {
        return xaxis;
    }

    /**
     * Sets the x-axis unit string.
     * @param xtext the unit string
     */
    public void setXAxisUnit(String xunit) {
        this.xaxis_unit = xunit;
    }

    /**
     * Gets the x-axis unit string.
     * @return the label String
     */
    public String getXAxisUnit() {
        return xaxis_unit;
    }

    /**
     * Sets the y-axis unit string.
     * @param ytext the unit string
     */
    public void setYAxisUnit(String yunit) {
        this.yaxis_unit = yunit;
    }

    /**
     * Gets the y-axis label.
     * @return the label String
     */
    public String getYAxisUnit() {
        return yaxis_unit;
    }

    /**
     * Sets the font for the axis labels.
     * @param f the Font to be used
     */
    public void setFont(Font f) {
        font = f;
    }

    /**
     * Returns the font used for the axis labels.
     * @return the Font object
     */
    public Font getFont() {
        return font;
    }

    /**
     * Sets the left y-axis and computes the matrix transformation.
     * @param a the left y-axis
     */
    public void setFirstYAxis(Axis a) {
        yaxis = a;
    }

    /**
     * Returns the first y-axis.
     * @return the left y-axis
     */
    public Axis getFirstYAxis() {
        return yaxis;
    }

    /**
     * Sets the second y-axis and computes the matrix transformation.
     * @param a the right y-axis
     */
    public void setSecondYAxis(Axis a) {
        yaxis2 = a;
    }

    /**
     * Returns the second y-axis.
     * @return the right y-axis
     */
    public Axis getSecondYAxis() {
        return yaxis2;
    }

    /**
     * Returns the inner margin, ie the bounds minus the margins.
     * @return a Rectangle object defining the inner bounds.
     */
    public Rectangle getInnerBounds() {
        Rectangle b = getBounds();
        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);
        return i;
    }

    /**
     * Computes all margins, initializes the length of the Axis and
     * calls <code>super.setBounds</code>. Additionally, it sets the
     * default AffineTransforms for every y-axis.
     * @param bounds <CODE>Rectangle</CODE> object defining the bounds
     */
    public void setBounds(Rectangle bounds) {
        super.setBounds(bounds);
        setRightMargin(c.computeRightMargin());
        setLeftMargin(c.computeLeftMargin());
        setTopMargin(c.computeTopMargin());
        setBottomMargin(c.computeBottomMargin());
        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());
        //System.out.println(""** xaxis.length = ""+xaxis.getLength());
        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
        //System.out.println(""** yaxis.length = ""+yaxis.getLength());
        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);
        if (yaxis2 != null) {
            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);
        }
    }

    /**
     * Returns the preferred size needed for the renderer.
     * @return a Dimension with the minimum Integer values.
     */
    public Dimension getPreferredSize() {
        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);
    }

    /**
     * Overrides the method to just call <code>paintDefault</code>.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void render(Graphics2D g) {
        paintDefault(g);
    }

    /**
     * This method is called by the paint method to do the actual painting.
     * The painting is supposed to start at point (0,0) and the size is
     * always the same as the preferred size. The paint method performs
     * the possible scaling.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void paintDefault(Graphics2D g) {
        g.setColor(Color.black);
        Line2D x = c.getXAxisLine2D();
        Line2D y = c.getYAxisLine2D();
        g.draw(x);
        g.draw(y);
        // draw X-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());
            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);
        }
        // draw X-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);
        // draw Y-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);
            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);
        }
        // draw Y-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);
        if (getSecondYAxis() != null) {
            Line2D y2 = c.getSecondYAxisLine2D();
            g.draw(y2);
        }
        if (model.isColumnNumeric())
            c.drawNumericalXAxisTicks(g);
        else
            c.drawXAxisTicks(g);
        c.drawYAxisTicks(g);
    }

    /**
     * Returns a new PointToPixelTranslator for the given axis.
     * Please notice that this method is deprecated since release 0.92.
     * The PointToPixelTranslator interface has been replaced with
     * AffineTransforms.
     * @param y the y-axis identifier used to choose the right Point / Pixel ratio
     * @return a PointToPixelTranslator object or null if the resulting
     * Point is not within the Bounds of the Coordinate System
     * @deprecated
     */
    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {
        final Axis x = this.getXAxis();
        final Axis y;
        if (yaxis == CoordSystem.FIRST_YAXIS)
            y = this.getFirstYAxis();
        else
            y = this.getSecondYAxis();
        return new PointToPixelTranslator() {

            public Point2D getPixelCoord(Point2D pt) {
                double x0 = 0.0;
                double y0 = 0.0;
                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());
                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());
                Point2D p = new Point2D.Double(x0, y0);
                if (getInnerBounds().contains(p))
                    return p;
                else
                    return null;
            }
        };
    }

    /**
     * Returns the left margin.
     */
    protected int getLeftMargin() {
        return leftmargin;
    }

    /**
     * Returns the right margin.
     */
    protected int getRightMargin() {
        return rightmargin;
    }

    /**
     * Returns the top margin.
     */
    protected int getTopMargin() {
        return topmargin;
    }

    /**
     * Returns the bottom margin.
     */
    protected int getBottomMargin() {
        return bottommargin;
    }

    /**
     * Sets the left margin.
     * @param margin the new margin value
     */
    protected void setLeftMargin(int margin) {
        leftmargin = margin;
    }

    /**
     * Sets the right margin.
     * @param margin the new margin value
     */
    protected void setRightMargin(int margin) {
        rightmargin = margin;
    }

    /**
     * Sets the top margin.
     * @param margin the new margin value
     */
    protected void setTopMargin(int margin) {
        topmargin = margin;
    }

    /**
     * Sets the bottom margin.
     * @param margin the new margin value
     */
    public void setBottomMargin(int margin) {
        bottommargin = margin;
    }

    /**
     * Returns the FontRenderContext used througout the CoordSystem
     */
    public FontRenderContext getFontRenderContext() {
        return frc;
    }

    /**
     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    public DecimalFormat getYDecimalFormat() {
        return dfY;
    }

    /**
     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    public DecimalFormat getXDecimalFormat() {
        return dfX;
    }

    /**
     * if true, the arrows will be drawn at the end of the axis
     */
    public boolean isDrawArrows() {
        return shouldDrawArrows;
    }

    /**
     * if true, the increment will be painted at each tick mark
     */
    public boolean isPaintAltTick() {
        return shouldPaintAltTick;
    }

    /**
     * if true only the tick will be painted on the yaxis.  Alternately a
     * light grey line will paint across the background of the chart.
     */
    public boolean isPaintOnlyTick() {
        return shouldPaintOnlyTick;
    }

    public boolean isPaintLabels() {
        return shouldPaintLabels;
    }

    public void setPaintLabels(boolean label) {
        shouldPaintLabels = label;
    }

    /**
     * Returns the used ChartDataModelConstraints.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {
        if (axis == FIRST_YAXIS)
            return constraints;
        else if (axis == SECOND_YAXIS)
            return constraints2;
        else
            return null;
    }
}
","// CoordSystem_0Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getTransform(int)} method.
*/
class CoordSystem_0Test {","// CoordSystem_0Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getTransform(int)} method.
*/
class CoordSystem_0Test {
"
7d0e5212-c72d-459b-8c6f-1d28882d7980,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystem_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8355 tokens (6355 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// CoordSystem.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystem.java
    Created on 26. Juni 2001, 22:49
 */
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;

/**
 * This class defines a coordinate system. The CoordSystem class computes
 * an AffineTransform for each y-axis, which translates the user space
 * coordinates (ie. the data value coordinates) into pixel space coordinates.
 * These AffineTransform classes make the PixelToPointTranslator obsolete,
 * since it provides more flexibility. <code>getDefaultTransform</code> always
 * computes the default transformation, whereas you can set another
 * transformation via <code>setTransform</code>. This will be used to implement
 * zooming and panning in the Swing classes.<p>
 * All classes incl. this one, which render data will use the transformations
 * to translate the coordinates. The transformations are not set up on
 * instantiation of a CoordSystem, instead they're computed when setBounds
 * is called, because they need this information of course. Afterwards you
 * can set your own transformation or even better you can manipulate the
 * existing ones by pre- or postconcatenating another AffineTransform.
 */
public class CoordSystem extends AbstractRenderer {

    /**
     * The x-axis caption string.
     */
    protected String xaxis_unit = ""x"";

    /**
     * The y-axis caption string.
     */
    protected String yaxis_unit = ""y"";

    /**
     * The Font used in the CoordSystem.
     */
    protected Font font = new Font(""sans"", Font.PLAIN, 9);

    /**
     * FontRenderContext used througout the CoordSystem
     */
    protected final FontRenderContext frc = new FontRenderContext(null, false, false);

    /**
     * DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    protected DecimalFormat dfY;

    /**
     * DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    protected DecimalFormat dfX;

    /**
     * if true, the arrows will be drawn at the end of the axi
     */
    protected boolean shouldDrawArrows = true;

    /**
     * if true, the increment will be painted at each tick mark
     */
    protected boolean shouldPaintAltTick = true;

    /**
     * if true only the tick will be painted on the yaxis.  Alternately, if false, a
     * light grey line will paint across the background of the chart.
     */
    protected boolean shouldPaintOnlyTick = true;

    /**
     * If true, the labels will be painted. If false, only the ticks will display.
     */
    protected boolean shouldPaintLabels = true;

    /**
     * The left margin
     */
    protected int leftmargin = 50;

    /**
     * The top margin.
     */
    protected int topmargin = 20;

    /**
     * The right margin.
     */
    protected int rightmargin = 30;

    /**
     * The bottom margin.
     */
    protected int bottommargin = 30;

    /**
     * The minimal margin constant.
     */
    public final int MINIMALMARGIN = 20;

    /**
     * The arrow length constant.
     */
    public final int ARROWLENGTH = 15;

    /**
     * The ChartDataModel constraints of the first y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints;

    /**
     * The ChartDataModel constraints of the second y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints2;

    /**
     * The DataModel class.
     */
    protected ChartDataModel model;

    /**
     * The utilities class, which contains all the rendering methods etc.
     */
    protected CoordSystemUtilities c;

    /**
     * The xaxis.
     */
    protected Axis xaxis;

    /**
     * The first y-axis.
     */
    protected Axis yaxis;

    /**
     * The second y-axis.
     */
    protected Axis yaxis2;

    /**
     * The multiplication matrix for the first y-axis and the x-axis.
     */
    protected AffineTransform y1transform;

    /**
     * The multiplication matrix for the second y-axis and the x-axis.
     */
    protected AffineTransform y2transform;

    /**
     * the axis binding constant for the first y-axis
     */
    public static final int FIRST_YAXIS = 0;

    /**
     * the axis binding constant for the second y-axis
     */
    public static final int SECOND_YAXIS = 1;

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     */
    public CoordSystem(ChartDataModel cdm) {
        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);
        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);
        this.model = cdm;
        xaxis = new Axis(Axis.HORIZONTAL, constraints);
        yaxis = new Axis(Axis.VERTICAL, constraints);
        c = new CoordSystemUtilities(this, constraints, constraints2, model);
        dfY = new DecimalFormat();
        dfX = new DecimalFormat();
    }

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param xtext the x-axis unit
     * @param ytext the y-axis unit
     */
    public CoordSystem(ChartDataModel c, String xunit, String yunit) {
        this(c);
        setXAxisUnit(xunit);
        setYAxisUnit(yunit);
    }

    /**
     * Create a new CoordSystem with alternate painting parameters.
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param drawArrows if true the arrows will be drawn at the end of the axis
     * @param paintAltYTick if true the caption will paint on alternate ticks of the
     * yaxis instead of on every one.
     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>
     * appear behind the chart at each yaxis tick mark.
     */
    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {
        this(c);
        dfY = yAxisFormat;
        shouldDrawArrows = drawArrows;
        shouldPaintAltTick = paintAltYTick;
        shouldPaintOnlyTick = paintOnlyYTick;
    }

    /**
     * Sets the coordinate transformation for any y-coordinate.
     * @param at the AffineTransform that transforms the coordinates into pixel
     * space
     * @axis defines for which y-axis the transform is computed
     */
    public void setTransform(AffineTransform at, int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                y1transform = at;
                break;
            case (SECOND_YAXIS):
                y2transform = at;
                break;
        }
    }

    /**
     * Returns the currently defined AffineTransform for any y-axis.
     * @param axis the y-axis to be used.
     */
    public AffineTransform getTransform(int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                return y1transform;
            case (SECOND_YAXIS):
                return y2transform;
        }
        return null;
    }

    /**
     * This method computes the default transform which transforms the
     * user space coordinates of this coordinate system to the pixel
     * space coordinates used in the Graphics object.
     * All rendering in the CoordinateSystem and the ChartRenderers
     * will rely on this transform.
     * @param axis defines which y-axis to use.
     */
    public AffineTransform getDefaultTransform(int axis) {
        double x_pt2px = 0;
        double y_pt2px = 0;
        double xcoord0 = 0;
        double ycoord0 = 0;
        x_pt2px = 1 / getXAxis().getPointToPixelRatio();
        //System.out.println(""** x_pt2px = ""+getXAxis().getPointToPixelRatio());
        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);
        switch(axis) {
            case FIRST_YAXIS:
                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);
                break;
            case SECOND_YAXIS:
                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);
                break;
        }
        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);
    }

    /**
     * Sets the x-axis.
     * @param a the x-axis
     */
    public void setXAxis(Axis a) {
        xaxis = a;
    }

    /**
     * Returns the x axis.
     * @return the x-axis
     */
    public Axis getXAxis() {
        return xaxis;
    }

    /**
     * Sets the x-axis unit string.
     * @param xtext the unit string
     */
    public void setXAxisUnit(String xunit) {
        this.xaxis_unit = xunit;
    }

    /**
     * Gets the x-axis unit string.
     * @return the label String
     */
    public String getXAxisUnit() {
        return xaxis_unit;
    }

    /**
     * Sets the y-axis unit string.
     * @param ytext the unit string
     */
    public void setYAxisUnit(String yunit) {
        this.yaxis_unit = yunit;
    }

    /**
     * Gets the y-axis label.
     * @return the label String
     */
    public String getYAxisUnit() {
        return yaxis_unit;
    }

    /**
     * Sets the font for the axis labels.
     * @param f the Font to be used
     */
    public void setFont(Font f) {
        font = f;
    }

    /**
     * Returns the font used for the axis labels.
     * @return the Font object
     */
    public Font getFont() {
        return font;
    }

    /**
     * Sets the left y-axis and computes the matrix transformation.
     * @param a the left y-axis
     */
    public void setFirstYAxis(Axis a) {
        yaxis = a;
    }

    /**
     * Returns the first y-axis.
     * @return the left y-axis
     */
    public Axis getFirstYAxis() {
        return yaxis;
    }

    /**
     * Sets the second y-axis and computes the matrix transformation.
     * @param a the right y-axis
     */
    public void setSecondYAxis(Axis a) {
        yaxis2 = a;
    }

    /**
     * Returns the second y-axis.
     * @return the right y-axis
     */
    public Axis getSecondYAxis() {
        return yaxis2;
    }

    /**
     * Returns the inner margin, ie the bounds minus the margins.
     * @return a Rectangle object defining the inner bounds.
     */
    public Rectangle getInnerBounds() {
        Rectangle b = getBounds();
        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);
        return i;
    }

    /**
     * Computes all margins, initializes the length of the Axis and
     * calls <code>super.setBounds</code>. Additionally, it sets the
     * default AffineTransforms for every y-axis.
     * @param bounds <CODE>Rectangle</CODE> object defining the bounds
     */
    public void setBounds(Rectangle bounds) {
        super.setBounds(bounds);
        setRightMargin(c.computeRightMargin());
        setLeftMargin(c.computeLeftMargin());
        setTopMargin(c.computeTopMargin());
        setBottomMargin(c.computeBottomMargin());
        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());
        //System.out.println(""** xaxis.length = ""+xaxis.getLength());
        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
        //System.out.println(""** yaxis.length = ""+yaxis.getLength());
        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);
        if (yaxis2 != null) {
            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);
        }
    }

    /**
     * Returns the preferred size needed for the renderer.
     * @return a Dimension with the minimum Integer values.
     */
    public Dimension getPreferredSize() {
        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);
    }

    /**
     * Overrides the method to just call <code>paintDefault</code>.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void render(Graphics2D g) {
        paintDefault(g);
    }

    /**
     * This method is called by the paint method to do the actual painting.
     * The painting is supposed to start at point (0,0) and the size is
     * always the same as the preferred size. The paint method performs
     * the possible scaling.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void paintDefault(Graphics2D g) {
        g.setColor(Color.black);
        Line2D x = c.getXAxisLine2D();
        Line2D y = c.getYAxisLine2D();
        g.draw(x);
        g.draw(y);
        // draw X-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());
            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);
        }
        // draw X-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);
        // draw Y-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);
            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);
        }
        // draw Y-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);
        if (getSecondYAxis() != null) {
            Line2D y2 = c.getSecondYAxisLine2D();
            g.draw(y2);
        }
        if (model.isColumnNumeric())
            c.drawNumericalXAxisTicks(g);
        else
            c.drawXAxisTicks(g);
        c.drawYAxisTicks(g);
    }

    /**
     * Returns a new PointToPixelTranslator for the given axis.
     * Please notice that this method is deprecated since release 0.92.
     * The PointToPixelTranslator interface has been replaced with
     * AffineTransforms.
     * @param y the y-axis identifier used to choose the right Point / Pixel ratio
     * @return a PointToPixelTranslator object or null if the resulting
     * Point is not within the Bounds of the Coordinate System
     * @deprecated
     */
    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {
        final Axis x = this.getXAxis();
        final Axis y;
        if (yaxis == CoordSystem.FIRST_YAXIS)
            y = this.getFirstYAxis();
        else
            y = this.getSecondYAxis();
        return new PointToPixelTranslator() {

            public Point2D getPixelCoord(Point2D pt) {
                double x0 = 0.0;
                double y0 = 0.0;
                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());
                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());
                Point2D p = new Point2D.Double(x0, y0);
                if (getInnerBounds().contains(p))
                    return p;
                else
                    return null;
            }
        };
    }

    /**
     * Returns the left margin.
     */
    protected int getLeftMargin() {
        return leftmargin;
    }

    /**
     * Returns the right margin.
     */
    protected int getRightMargin() {
        return rightmargin;
    }

    /**
     * Returns the top margin.
     */
    protected int getTopMargin() {
        return topmargin;
    }

    /**
     * Returns the bottom margin.
     */
    protected int getBottomMargin() {
        return bottommargin;
    }

    /**
     * Sets the left margin.
     * @param margin the new margin value
     */
    protected void setLeftMargin(int margin) {
        leftmargin = margin;
    }

    /**
     * Sets the right margin.
     * @param margin the new margin value
     */
    protected void setRightMargin(int margin) {
        rightmargin = margin;
    }

    /**
     * Sets the top margin.
     * @param margin the new margin value
     */
    protected void setTopMargin(int margin) {
        topmargin = margin;
    }

    /**
     * Sets the bottom margin.
     * @param margin the new margin value
     */
    public void setBottomMargin(int margin) {
        bottommargin = margin;
    }

    /**
     * Returns the FontRenderContext used througout the CoordSystem
     */
    public FontRenderContext getFontRenderContext() {
        return frc;
    }

    /**
     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    public DecimalFormat getYDecimalFormat() {
        return dfY;
    }

    /**
     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    public DecimalFormat getXDecimalFormat() {
        return dfX;
    }

    /**
     * if true, the arrows will be drawn at the end of the axis
     */
    public boolean isDrawArrows() {
        return shouldDrawArrows;
    }

    /**
     * if true, the increment will be painted at each tick mark
     */
    public boolean isPaintAltTick() {
        return shouldPaintAltTick;
    }

    /**
     * if true only the tick will be painted on the yaxis.  Alternately a
     * light grey line will paint across the background of the chart.
     */
    public boolean isPaintOnlyTick() {
        return shouldPaintOnlyTick;
    }

    public boolean isPaintLabels() {
        return shouldPaintLabels;
    }

    public void setPaintLabels(boolean label) {
        shouldPaintLabels = label;
    }

    /**
     * Returns the used ChartDataModelConstraints.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {
        if (axis == FIRST_YAXIS)
            return constraints;
        else if (axis == SECOND_YAXIS)
            return constraints2;
        else
            return null;
    }
}
","// CoordSystem_1Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getDefaultTransform(int)} method.
*/
class CoordSystem_1Test {","// CoordSystem_1Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getDefaultTransform(int)} method.
*/
class CoordSystem_1Test {
"
066feb6a-a258-4548-969a-b3769f2ff356,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystem_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8358 tokens (6358 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// CoordSystem.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystem.java
    Created on 26. Juni 2001, 22:49
 */
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;

/**
 * This class defines a coordinate system. The CoordSystem class computes
 * an AffineTransform for each y-axis, which translates the user space
 * coordinates (ie. the data value coordinates) into pixel space coordinates.
 * These AffineTransform classes make the PixelToPointTranslator obsolete,
 * since it provides more flexibility. <code>getDefaultTransform</code> always
 * computes the default transformation, whereas you can set another
 * transformation via <code>setTransform</code>. This will be used to implement
 * zooming and panning in the Swing classes.<p>
 * All classes incl. this one, which render data will use the transformations
 * to translate the coordinates. The transformations are not set up on
 * instantiation of a CoordSystem, instead they're computed when setBounds
 * is called, because they need this information of course. Afterwards you
 * can set your own transformation or even better you can manipulate the
 * existing ones by pre- or postconcatenating another AffineTransform.
 */
public class CoordSystem extends AbstractRenderer {

    /**
     * The x-axis caption string.
     */
    protected String xaxis_unit = ""x"";

    /**
     * The y-axis caption string.
     */
    protected String yaxis_unit = ""y"";

    /**
     * The Font used in the CoordSystem.
     */
    protected Font font = new Font(""sans"", Font.PLAIN, 9);

    /**
     * FontRenderContext used througout the CoordSystem
     */
    protected final FontRenderContext frc = new FontRenderContext(null, false, false);

    /**
     * DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    protected DecimalFormat dfY;

    /**
     * DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    protected DecimalFormat dfX;

    /**
     * if true, the arrows will be drawn at the end of the axi
     */
    protected boolean shouldDrawArrows = true;

    /**
     * if true, the increment will be painted at each tick mark
     */
    protected boolean shouldPaintAltTick = true;

    /**
     * if true only the tick will be painted on the yaxis.  Alternately, if false, a
     * light grey line will paint across the background of the chart.
     */
    protected boolean shouldPaintOnlyTick = true;

    /**
     * If true, the labels will be painted. If false, only the ticks will display.
     */
    protected boolean shouldPaintLabels = true;

    /**
     * The left margin
     */
    protected int leftmargin = 50;

    /**
     * The top margin.
     */
    protected int topmargin = 20;

    /**
     * The right margin.
     */
    protected int rightmargin = 30;

    /**
     * The bottom margin.
     */
    protected int bottommargin = 30;

    /**
     * The minimal margin constant.
     */
    public final int MINIMALMARGIN = 20;

    /**
     * The arrow length constant.
     */
    public final int ARROWLENGTH = 15;

    /**
     * The ChartDataModel constraints of the first y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints;

    /**
     * The ChartDataModel constraints of the second y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints2;

    /**
     * The DataModel class.
     */
    protected ChartDataModel model;

    /**
     * The utilities class, which contains all the rendering methods etc.
     */
    protected CoordSystemUtilities c;

    /**
     * The xaxis.
     */
    protected Axis xaxis;

    /**
     * The first y-axis.
     */
    protected Axis yaxis;

    /**
     * The second y-axis.
     */
    protected Axis yaxis2;

    /**
     * The multiplication matrix for the first y-axis and the x-axis.
     */
    protected AffineTransform y1transform;

    /**
     * The multiplication matrix for the second y-axis and the x-axis.
     */
    protected AffineTransform y2transform;

    /**
     * the axis binding constant for the first y-axis
     */
    public static final int FIRST_YAXIS = 0;

    /**
     * the axis binding constant for the second y-axis
     */
    public static final int SECOND_YAXIS = 1;

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     */
    public CoordSystem(ChartDataModel cdm) {
        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);
        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);
        this.model = cdm;
        xaxis = new Axis(Axis.HORIZONTAL, constraints);
        yaxis = new Axis(Axis.VERTICAL, constraints);
        c = new CoordSystemUtilities(this, constraints, constraints2, model);
        dfY = new DecimalFormat();
        dfX = new DecimalFormat();
    }

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param xtext the x-axis unit
     * @param ytext the y-axis unit
     */
    public CoordSystem(ChartDataModel c, String xunit, String yunit) {
        this(c);
        setXAxisUnit(xunit);
        setYAxisUnit(yunit);
    }

    /**
     * Create a new CoordSystem with alternate painting parameters.
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param drawArrows if true the arrows will be drawn at the end of the axis
     * @param paintAltYTick if true the caption will paint on alternate ticks of the
     * yaxis instead of on every one.
     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>
     * appear behind the chart at each yaxis tick mark.
     */
    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {
        this(c);
        dfY = yAxisFormat;
        shouldDrawArrows = drawArrows;
        shouldPaintAltTick = paintAltYTick;
        shouldPaintOnlyTick = paintOnlyYTick;
    }

    /**
     * Sets the coordinate transformation for any y-coordinate.
     * @param at the AffineTransform that transforms the coordinates into pixel
     * space
     * @axis defines for which y-axis the transform is computed
     */
    public void setTransform(AffineTransform at, int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                y1transform = at;
                break;
            case (SECOND_YAXIS):
                y2transform = at;
                break;
        }
    }

    /**
     * Returns the currently defined AffineTransform for any y-axis.
     * @param axis the y-axis to be used.
     */
    public AffineTransform getTransform(int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                return y1transform;
            case (SECOND_YAXIS):
                return y2transform;
        }
        return null;
    }

    /**
     * This method computes the default transform which transforms the
     * user space coordinates of this coordinate system to the pixel
     * space coordinates used in the Graphics object.
     * All rendering in the CoordinateSystem and the ChartRenderers
     * will rely on this transform.
     * @param axis defines which y-axis to use.
     */
    public AffineTransform getDefaultTransform(int axis) {
        double x_pt2px = 0;
        double y_pt2px = 0;
        double xcoord0 = 0;
        double ycoord0 = 0;
        x_pt2px = 1 / getXAxis().getPointToPixelRatio();
        //System.out.println(""** x_pt2px = ""+getXAxis().getPointToPixelRatio());
        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);
        switch(axis) {
            case FIRST_YAXIS:
                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);
                break;
            case SECOND_YAXIS:
                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);
                break;
        }
        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);
    }

    /**
     * Sets the x-axis.
     * @param a the x-axis
     */
    public void setXAxis(Axis a) {
        xaxis = a;
    }

    /**
     * Returns the x axis.
     * @return the x-axis
     */
    public Axis getXAxis() {
        return xaxis;
    }

    /**
     * Sets the x-axis unit string.
     * @param xtext the unit string
     */
    public void setXAxisUnit(String xunit) {
        this.xaxis_unit = xunit;
    }

    /**
     * Gets the x-axis unit string.
     * @return the label String
     */
    public String getXAxisUnit() {
        return xaxis_unit;
    }

    /**
     * Sets the y-axis unit string.
     * @param ytext the unit string
     */
    public void setYAxisUnit(String yunit) {
        this.yaxis_unit = yunit;
    }

    /**
     * Gets the y-axis label.
     * @return the label String
     */
    public String getYAxisUnit() {
        return yaxis_unit;
    }

    /**
     * Sets the font for the axis labels.
     * @param f the Font to be used
     */
    public void setFont(Font f) {
        font = f;
    }

    /**
     * Returns the font used for the axis labels.
     * @return the Font object
     */
    public Font getFont() {
        return font;
    }

    /**
     * Sets the left y-axis and computes the matrix transformation.
     * @param a the left y-axis
     */
    public void setFirstYAxis(Axis a) {
        yaxis = a;
    }

    /**
     * Returns the first y-axis.
     * @return the left y-axis
     */
    public Axis getFirstYAxis() {
        return yaxis;
    }

    /**
     * Sets the second y-axis and computes the matrix transformation.
     * @param a the right y-axis
     */
    public void setSecondYAxis(Axis a) {
        yaxis2 = a;
    }

    /**
     * Returns the second y-axis.
     * @return the right y-axis
     */
    public Axis getSecondYAxis() {
        return yaxis2;
    }

    /**
     * Returns the inner margin, ie the bounds minus the margins.
     * @return a Rectangle object defining the inner bounds.
     */
    public Rectangle getInnerBounds() {
        Rectangle b = getBounds();
        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);
        return i;
    }

    /**
     * Computes all margins, initializes the length of the Axis and
     * calls <code>super.setBounds</code>. Additionally, it sets the
     * default AffineTransforms for every y-axis.
     * @param bounds <CODE>Rectangle</CODE> object defining the bounds
     */
    public void setBounds(Rectangle bounds) {
        super.setBounds(bounds);
        setRightMargin(c.computeRightMargin());
        setLeftMargin(c.computeLeftMargin());
        setTopMargin(c.computeTopMargin());
        setBottomMargin(c.computeBottomMargin());
        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());
        //System.out.println(""** xaxis.length = ""+xaxis.getLength());
        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
        //System.out.println(""** yaxis.length = ""+yaxis.getLength());
        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);
        if (yaxis2 != null) {
            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);
        }
    }

    /**
     * Returns the preferred size needed for the renderer.
     * @return a Dimension with the minimum Integer values.
     */
    public Dimension getPreferredSize() {
        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);
    }

    /**
     * Overrides the method to just call <code>paintDefault</code>.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void render(Graphics2D g) {
        paintDefault(g);
    }

    /**
     * This method is called by the paint method to do the actual painting.
     * The painting is supposed to start at point (0,0) and the size is
     * always the same as the preferred size. The paint method performs
     * the possible scaling.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void paintDefault(Graphics2D g) {
        g.setColor(Color.black);
        Line2D x = c.getXAxisLine2D();
        Line2D y = c.getYAxisLine2D();
        g.draw(x);
        g.draw(y);
        // draw X-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());
            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);
        }
        // draw X-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);
        // draw Y-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);
            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);
        }
        // draw Y-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);
        if (getSecondYAxis() != null) {
            Line2D y2 = c.getSecondYAxisLine2D();
            g.draw(y2);
        }
        if (model.isColumnNumeric())
            c.drawNumericalXAxisTicks(g);
        else
            c.drawXAxisTicks(g);
        c.drawYAxisTicks(g);
    }

    /**
     * Returns a new PointToPixelTranslator for the given axis.
     * Please notice that this method is deprecated since release 0.92.
     * The PointToPixelTranslator interface has been replaced with
     * AffineTransforms.
     * @param y the y-axis identifier used to choose the right Point / Pixel ratio
     * @return a PointToPixelTranslator object or null if the resulting
     * Point is not within the Bounds of the Coordinate System
     * @deprecated
     */
    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {
        final Axis x = this.getXAxis();
        final Axis y;
        if (yaxis == CoordSystem.FIRST_YAXIS)
            y = this.getFirstYAxis();
        else
            y = this.getSecondYAxis();
        return new PointToPixelTranslator() {

            public Point2D getPixelCoord(Point2D pt) {
                double x0 = 0.0;
                double y0 = 0.0;
                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());
                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());
                Point2D p = new Point2D.Double(x0, y0);
                if (getInnerBounds().contains(p))
                    return p;
                else
                    return null;
            }
        };
    }

    /**
     * Returns the left margin.
     */
    protected int getLeftMargin() {
        return leftmargin;
    }

    /**
     * Returns the right margin.
     */
    protected int getRightMargin() {
        return rightmargin;
    }

    /**
     * Returns the top margin.
     */
    protected int getTopMargin() {
        return topmargin;
    }

    /**
     * Returns the bottom margin.
     */
    protected int getBottomMargin() {
        return bottommargin;
    }

    /**
     * Sets the left margin.
     * @param margin the new margin value
     */
    protected void setLeftMargin(int margin) {
        leftmargin = margin;
    }

    /**
     * Sets the right margin.
     * @param margin the new margin value
     */
    protected void setRightMargin(int margin) {
        rightmargin = margin;
    }

    /**
     * Sets the top margin.
     * @param margin the new margin value
     */
    protected void setTopMargin(int margin) {
        topmargin = margin;
    }

    /**
     * Sets the bottom margin.
     * @param margin the new margin value
     */
    public void setBottomMargin(int margin) {
        bottommargin = margin;
    }

    /**
     * Returns the FontRenderContext used througout the CoordSystem
     */
    public FontRenderContext getFontRenderContext() {
        return frc;
    }

    /**
     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    public DecimalFormat getYDecimalFormat() {
        return dfY;
    }

    /**
     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    public DecimalFormat getXDecimalFormat() {
        return dfX;
    }

    /**
     * if true, the arrows will be drawn at the end of the axis
     */
    public boolean isDrawArrows() {
        return shouldDrawArrows;
    }

    /**
     * if true, the increment will be painted at each tick mark
     */
    public boolean isPaintAltTick() {
        return shouldPaintAltTick;
    }

    /**
     * if true only the tick will be painted on the yaxis.  Alternately a
     * light grey line will paint across the background of the chart.
     */
    public boolean isPaintOnlyTick() {
        return shouldPaintOnlyTick;
    }

    public boolean isPaintLabels() {
        return shouldPaintLabels;
    }

    public void setPaintLabels(boolean label) {
        shouldPaintLabels = label;
    }

    /**
     * Returns the used ChartDataModelConstraints.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {
        if (axis == FIRST_YAXIS)
            return constraints;
        else if (axis == SECOND_YAXIS)
            return constraints2;
        else
            return null;
    }
}
","// CoordSystem_2Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getPointToPixelTranslator(int)} method.
*/
class CoordSystem_2Test {","// CoordSystem_2Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getPointToPixelTranslator(int)} method.
*/
class CoordSystem_2Test {
"
cfcd9dd8-0e57-4255-a775-877d63dc0bc1,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/CoordSystem_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8359 tokens (6359 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// CoordSystem.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    CoordSystem.java
    Created on 26. Juni 2001, 22:49
 */
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;

/**
 * This class defines a coordinate system. The CoordSystem class computes
 * an AffineTransform for each y-axis, which translates the user space
 * coordinates (ie. the data value coordinates) into pixel space coordinates.
 * These AffineTransform classes make the PixelToPointTranslator obsolete,
 * since it provides more flexibility. <code>getDefaultTransform</code> always
 * computes the default transformation, whereas you can set another
 * transformation via <code>setTransform</code>. This will be used to implement
 * zooming and panning in the Swing classes.<p>
 * All classes incl. this one, which render data will use the transformations
 * to translate the coordinates. The transformations are not set up on
 * instantiation of a CoordSystem, instead they're computed when setBounds
 * is called, because they need this information of course. Afterwards you
 * can set your own transformation or even better you can manipulate the
 * existing ones by pre- or postconcatenating another AffineTransform.
 */
public class CoordSystem extends AbstractRenderer {

    /**
     * The x-axis caption string.
     */
    protected String xaxis_unit = ""x"";

    /**
     * The y-axis caption string.
     */
    protected String yaxis_unit = ""y"";

    /**
     * The Font used in the CoordSystem.
     */
    protected Font font = new Font(""sans"", Font.PLAIN, 9);

    /**
     * FontRenderContext used througout the CoordSystem
     */
    protected final FontRenderContext frc = new FontRenderContext(null, false, false);

    /**
     * DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    protected DecimalFormat dfY;

    /**
     * DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    protected DecimalFormat dfX;

    /**
     * if true, the arrows will be drawn at the end of the axi
     */
    protected boolean shouldDrawArrows = true;

    /**
     * if true, the increment will be painted at each tick mark
     */
    protected boolean shouldPaintAltTick = true;

    /**
     * if true only the tick will be painted on the yaxis.  Alternately, if false, a
     * light grey line will paint across the background of the chart.
     */
    protected boolean shouldPaintOnlyTick = true;

    /**
     * If true, the labels will be painted. If false, only the ticks will display.
     */
    protected boolean shouldPaintLabels = true;

    /**
     * The left margin
     */
    protected int leftmargin = 50;

    /**
     * The top margin.
     */
    protected int topmargin = 20;

    /**
     * The right margin.
     */
    protected int rightmargin = 30;

    /**
     * The bottom margin.
     */
    protected int bottommargin = 30;

    /**
     * The minimal margin constant.
     */
    public final int MINIMALMARGIN = 20;

    /**
     * The arrow length constant.
     */
    public final int ARROWLENGTH = 15;

    /**
     * The ChartDataModel constraints of the first y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints;

    /**
     * The ChartDataModel constraints of the second y-axis and the x-axis.
     */
    protected ChartDataModelConstraints constraints2;

    /**
     * The DataModel class.
     */
    protected ChartDataModel model;

    /**
     * The utilities class, which contains all the rendering methods etc.
     */
    protected CoordSystemUtilities c;

    /**
     * The xaxis.
     */
    protected Axis xaxis;

    /**
     * The first y-axis.
     */
    protected Axis yaxis;

    /**
     * The second y-axis.
     */
    protected Axis yaxis2;

    /**
     * The multiplication matrix for the first y-axis and the x-axis.
     */
    protected AffineTransform y1transform;

    /**
     * The multiplication matrix for the second y-axis and the x-axis.
     */
    protected AffineTransform y2transform;

    /**
     * the axis binding constant for the first y-axis
     */
    public static final int FIRST_YAXIS = 0;

    /**
     * the axis binding constant for the second y-axis
     */
    public static final int SECOND_YAXIS = 1;

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     */
    public CoordSystem(ChartDataModel cdm) {
        this.constraints = cdm.getChartDataModelConstraints(FIRST_YAXIS);
        this.constraints2 = cdm.getChartDataModelConstraints(SECOND_YAXIS);
        this.model = cdm;
        xaxis = new Axis(Axis.HORIZONTAL, constraints);
        yaxis = new Axis(Axis.VERTICAL, constraints);
        c = new CoordSystemUtilities(this, constraints, constraints2, model);
        dfY = new DecimalFormat();
        dfX = new DecimalFormat();
    }

    /**
     * Creates a new CoordSystem using the given model constraints.
     * Also creates default linear x and y-axis. Note that the length
     * of the axis are set on the first call to
     * setBounds().
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param xtext the x-axis unit
     * @param ytext the y-axis unit
     */
    public CoordSystem(ChartDataModel c, String xunit, String yunit) {
        this(c);
        setXAxisUnit(xunit);
        setYAxisUnit(yunit);
    }

    /**
     * Create a new CoordSystem with alternate painting parameters.
     * @param c the ChartDataModel needed to compute the DataConstraints.
     * @param drawArrows if true the arrows will be drawn at the end of the axis
     * @param paintAltYTick if true the caption will paint on alternate ticks of the
     * yaxis instead of on every one.
     * @param paintOnlyYTick if true the horizontal lightgray line will <i>not</i>
     * appear behind the chart at each yaxis tick mark.
     */
    public CoordSystem(ChartDataModel c, DecimalFormat yAxisFormat, boolean drawArrows, boolean paintAltYTick, boolean paintOnlyYTick) {
        this(c);
        dfY = yAxisFormat;
        shouldDrawArrows = drawArrows;
        shouldPaintAltTick = paintAltYTick;
        shouldPaintOnlyTick = paintOnlyYTick;
    }

    /**
     * Sets the coordinate transformation for any y-coordinate.
     * @param at the AffineTransform that transforms the coordinates into pixel
     * space
     * @axis defines for which y-axis the transform is computed
     */
    public void setTransform(AffineTransform at, int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                y1transform = at;
                break;
            case (SECOND_YAXIS):
                y2transform = at;
                break;
        }
    }

    /**
     * Returns the currently defined AffineTransform for any y-axis.
     * @param axis the y-axis to be used.
     */
    public AffineTransform getTransform(int axis) {
        switch(axis) {
            case (FIRST_YAXIS):
                return y1transform;
            case (SECOND_YAXIS):
                return y2transform;
        }
        return null;
    }

    /**
     * This method computes the default transform which transforms the
     * user space coordinates of this coordinate system to the pixel
     * space coordinates used in the Graphics object.
     * All rendering in the CoordinateSystem and the ChartRenderers
     * will rely on this transform.
     * @param axis defines which y-axis to use.
     */
    public AffineTransform getDefaultTransform(int axis) {
        double x_pt2px = 0;
        double y_pt2px = 0;
        double xcoord0 = 0;
        double ycoord0 = 0;
        x_pt2px = 1 / getXAxis().getPointToPixelRatio();
        //System.out.println(""** x_pt2px = ""+getXAxis().getPointToPixelRatio());
        xcoord0 = getBounds().getX() + getLeftMargin() + getXAxis().getPixelForValue(0.0);
        switch(axis) {
            case FIRST_YAXIS:
                y_pt2px = 1 / getFirstYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getFirstYAxis().getPixelForValue(0.0);
                break;
            case SECOND_YAXIS:
                y_pt2px = 1 / getSecondYAxis().getPointToPixelRatio();
                ycoord0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - getSecondYAxis().getPixelForValue(0.0);
                break;
        }
        return new AffineTransform(x_pt2px, 0f, 0f, -y_pt2px, xcoord0, ycoord0);
    }

    /**
     * Sets the x-axis.
     * @param a the x-axis
     */
    public void setXAxis(Axis a) {
        xaxis = a;
    }

    /**
     * Returns the x axis.
     * @return the x-axis
     */
    public Axis getXAxis() {
        return xaxis;
    }

    /**
     * Sets the x-axis unit string.
     * @param xtext the unit string
     */
    public void setXAxisUnit(String xunit) {
        this.xaxis_unit = xunit;
    }

    /**
     * Gets the x-axis unit string.
     * @return the label String
     */
    public String getXAxisUnit() {
        return xaxis_unit;
    }

    /**
     * Sets the y-axis unit string.
     * @param ytext the unit string
     */
    public void setYAxisUnit(String yunit) {
        this.yaxis_unit = yunit;
    }

    /**
     * Gets the y-axis label.
     * @return the label String
     */
    public String getYAxisUnit() {
        return yaxis_unit;
    }

    /**
     * Sets the font for the axis labels.
     * @param f the Font to be used
     */
    public void setFont(Font f) {
        font = f;
    }

    /**
     * Returns the font used for the axis labels.
     * @return the Font object
     */
    public Font getFont() {
        return font;
    }

    /**
     * Sets the left y-axis and computes the matrix transformation.
     * @param a the left y-axis
     */
    public void setFirstYAxis(Axis a) {
        yaxis = a;
    }

    /**
     * Returns the first y-axis.
     * @return the left y-axis
     */
    public Axis getFirstYAxis() {
        return yaxis;
    }

    /**
     * Sets the second y-axis and computes the matrix transformation.
     * @param a the right y-axis
     */
    public void setSecondYAxis(Axis a) {
        yaxis2 = a;
    }

    /**
     * Returns the second y-axis.
     * @return the right y-axis
     */
    public Axis getSecondYAxis() {
        return yaxis2;
    }

    /**
     * Returns the inner margin, ie the bounds minus the margins.
     * @return a Rectangle object defining the inner bounds.
     */
    public Rectangle getInnerBounds() {
        Rectangle b = getBounds();
        Rectangle i = new Rectangle((int) b.getX() + getLeftMargin() - 1, (int) b.getY() + getTopMargin() - 1, (int) b.getWidth() - (getLeftMargin() + getRightMargin()) + 2, (int) b.getHeight() - (getTopMargin() + getBottomMargin()) + 2);
        return i;
    }

    /**
     * Computes all margins, initializes the length of the Axis and
     * calls <code>super.setBounds</code>. Additionally, it sets the
     * default AffineTransforms for every y-axis.
     * @param bounds <CODE>Rectangle</CODE> object defining the bounds
     */
    public void setBounds(Rectangle bounds) {
        super.setBounds(bounds);
        setRightMargin(c.computeRightMargin());
        setLeftMargin(c.computeLeftMargin());
        setTopMargin(c.computeTopMargin());
        setBottomMargin(c.computeBottomMargin());
        xaxis.setLength((int) (bounds.getWidth()) - getLeftMargin() - getRightMargin());
        //System.out.println(""** xaxis.length = ""+xaxis.getLength());
        yaxis.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
        //System.out.println(""** yaxis.length = ""+yaxis.getLength());
        setTransform(getDefaultTransform(FIRST_YAXIS), FIRST_YAXIS);
        if (yaxis2 != null) {
            yaxis2.setLength((int) (bounds.getHeight()) - getTopMargin() - getBottomMargin());
            setTransform(getDefaultTransform(SECOND_YAXIS), SECOND_YAXIS);
        }
    }

    /**
     * Returns the preferred size needed for the renderer.
     * @return a Dimension with the minimum Integer values.
     */
    public Dimension getPreferredSize() {
        return new Dimension(Integer.MIN_VALUE, Integer.MIN_VALUE);
    }

    /**
     * Overrides the method to just call <code>paintDefault</code>.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void render(Graphics2D g) {
        paintDefault(g);
    }

    /**
     * This method is called by the paint method to do the actual painting.
     * The painting is supposed to start at point (0,0) and the size is
     * always the same as the preferred size. The paint method performs
     * the possible scaling.
     * @param g the <CODE>Graphics2D</CODE> object to paint in
     */
    public void paintDefault(Graphics2D g) {
        g.setColor(Color.black);
        Line2D x = c.getXAxisLine2D();
        Line2D y = c.getYAxisLine2D();
        g.draw(x);
        g.draw(y);
        // draw X-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) x.getX2(), (int) x.getY2(), (int) x.getX2() + ARROWLENGTH, (int) x.getY2());
            g.fillPolygon(new int[] { (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH / 3.0), (int) (x.getX2() + ARROWLENGTH) }, new int[] { (int) x.getY2() - 3, (int) x.getY2() + 3, (int) x.getY2() }, 3);
        }
        // draw X-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutX = new TextLayout(getXAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutX.draw(g, (float) x.getX2() + (float) ARROWLENGTH / 3, (float) x.getY2() + (float) layoutX.getBounds().getHeight() + 5);
        // draw Y-Axis Arrow
        if (shouldDrawArrows) {
            g.drawLine((int) y.getX1(), (int) y.getY1(), (int) y.getX1(), (int) y.getY1() - ARROWLENGTH);
            g.fillPolygon(new int[] { (int) (y.getX1() - 3), (int) (y.getX1() + 3), (int) (y.getX1()) }, new int[] { (int) (y.getY1() - ARROWLENGTH / 3.0), (int) (y.getY1() - ARROWLENGTH / 3.0), (int) y.getY1() - ARROWLENGTH }, 3);
        }
        // draw Y-Axis label right below the Arrow ?!
        g.setColor(Color.black);
        TextLayout layoutY = new TextLayout(getYAxisUnit(), getFont(), new FontRenderContext(null, true, false));
        layoutY.draw(g, (float) y.getX1() - 6 - (float) layoutY.getBounds().getWidth(), (float) y.getY1() - layoutX.getDescent() - 3);
        if (getSecondYAxis() != null) {
            Line2D y2 = c.getSecondYAxisLine2D();
            g.draw(y2);
        }
        if (model.isColumnNumeric())
            c.drawNumericalXAxisTicks(g);
        else
            c.drawXAxisTicks(g);
        c.drawYAxisTicks(g);
    }

    /**
     * Returns a new PointToPixelTranslator for the given axis.
     * Please notice that this method is deprecated since release 0.92.
     * The PointToPixelTranslator interface has been replaced with
     * AffineTransforms.
     * @param y the y-axis identifier used to choose the right Point / Pixel ratio
     * @return a PointToPixelTranslator object or null if the resulting
     * Point is not within the Bounds of the Coordinate System
     * @deprecated
     */
    public PointToPixelTranslator getPointToPixelTranslator(int yaxis) {
        final Axis x = this.getXAxis();
        final Axis y;
        if (yaxis == CoordSystem.FIRST_YAXIS)
            y = this.getFirstYAxis();
        else
            y = this.getSecondYAxis();
        return new PointToPixelTranslator() {

            public Point2D getPixelCoord(Point2D pt) {
                double x0 = 0.0;
                double y0 = 0.0;
                x0 = getBounds().getX() + getLeftMargin() + x.getPixelForValue(pt.getX());
                y0 = getBounds().getY() + getBounds().getHeight() - getBottomMargin() - y.getPixelForValue(pt.getY());
                Point2D p = new Point2D.Double(x0, y0);
                if (getInnerBounds().contains(p))
                    return p;
                else
                    return null;
            }
        };
    }

    /**
     * Returns the left margin.
     */
    protected int getLeftMargin() {
        return leftmargin;
    }

    /**
     * Returns the right margin.
     */
    protected int getRightMargin() {
        return rightmargin;
    }

    /**
     * Returns the top margin.
     */
    protected int getTopMargin() {
        return topmargin;
    }

    /**
     * Returns the bottom margin.
     */
    protected int getBottomMargin() {
        return bottommargin;
    }

    /**
     * Sets the left margin.
     * @param margin the new margin value
     */
    protected void setLeftMargin(int margin) {
        leftmargin = margin;
    }

    /**
     * Sets the right margin.
     * @param margin the new margin value
     */
    protected void setRightMargin(int margin) {
        rightmargin = margin;
    }

    /**
     * Sets the top margin.
     * @param margin the new margin value
     */
    protected void setTopMargin(int margin) {
        topmargin = margin;
    }

    /**
     * Sets the bottom margin.
     * @param margin the new margin value
     */
    public void setBottomMargin(int margin) {
        bottommargin = margin;
    }

    /**
     * Returns the FontRenderContext used througout the CoordSystem
     */
    public FontRenderContext getFontRenderContext() {
        return frc;
    }

    /**
     * Returns the DecimalFormat used throught on the Yaxis of the CoordSystem
     */
    public DecimalFormat getYDecimalFormat() {
        return dfY;
    }

    /**
     * Returns the DecimalFormat used throught on the Xaxis of the CoordSystem
     */
    public DecimalFormat getXDecimalFormat() {
        return dfX;
    }

    /**
     * if true, the arrows will be drawn at the end of the axis
     */
    public boolean isDrawArrows() {
        return shouldDrawArrows;
    }

    /**
     * if true, the increment will be painted at each tick mark
     */
    public boolean isPaintAltTick() {
        return shouldPaintAltTick;
    }

    /**
     * if true only the tick will be painted on the yaxis.  Alternately a
     * light grey line will paint across the background of the chart.
     */
    public boolean isPaintOnlyTick() {
        return shouldPaintOnlyTick;
    }

    public boolean isPaintLabels() {
        return shouldPaintLabels;
    }

    public void setPaintLabels(boolean label) {
        shouldPaintLabels = label;
    }

    /**
     * Returns the used ChartDataModelConstraints.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(int axis) {
        if (axis == FIRST_YAXIS)
            return constraints;
        else if (axis == SECOND_YAXIS)
            return constraints2;
        else
            return null;
    }
}
","// CoordSystem_3Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getChartDataModelConstraints(int)} method.
*/
class CoordSystem_3Test {","// CoordSystem_3Test.java
package de.progra.charting;

import de.progra.charting.render.AbstractRenderer;
import de.progra.charting.render.ChartRenderingHints;
import java.awt.Rectangle;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.awt.geom.Line2D;
import java.awt.geom.AffineTransform;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Font;
import java.awt.font.FontRenderContext;
import java.awt.font.TextLayout;
import java.text.DecimalFormat;
import de.progra.charting.model.ChartDataModel;
import de.progra.charting.model.ChartDataModelConstraints;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link CoordSystem}.
* It contains ten unit test cases for the {@link CoordSystem#getChartDataModelConstraints(int)} method.
*/
class CoordSystem_3Test {
"
cmpl-6ttbJpeqUIwdTMBv8gIkEiDfbKdXW,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModel_0Test.java,50.479854106903076,length,"// DefaultChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultChartDataModel.java
    Created on 28. Juni 2001, 20:41
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * Implements a default ChartModel. It uses a DataSet[] and the columns
 * are numeric. It's purely read-only.
 * @author  mueller
 * @version 1.0
 */
public class DefaultChartDataModel extends AbstractChartDataModel {

    /**
     * The sorted x-axis values used for calculating the constraints.
     */
    protected TreeSet columnSet = new TreeSet();

    /**
     * The DataSet list.
     */
    protected ArrayList data = new ArrayList();

    /**
     * A HashMap containing the ordered data used for calculating the constraints.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     */
    public DefaultChartDataModel() {
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);
    }

    /**
     * Creates new DefaultChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {
        this();
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates a new DefaultChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets.
     * @param ds the array of DataSets to be used.
     */
    public DefaultChartDataModel(DataSet[] ds) {
        this();
        TreeSet set;
        for (int i = 0; i < ds.length; i++) {
            data.add(ds[i]);
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                columnSet.add(ds[i].getColumnValueAt(j));
                set.add(ds[i].getValueAt(j));
                trimSet(set);
            }
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet
     * @return the length of the DataSet
     */
    public int getDataSetLength(int set) {
        return ((DataSet) data.get(set)).getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSets
     */
    public int getDataSetNumber() {
        return data.size();
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return ((DataSet) data.get(set)).getTitle();
    }

    /**
     * Returns the axis binding for a DataSet
     * @param set the DataSet index
     * @return an axis binding constant
     */
    public int getAxisBinding(int set) {
        return ((DataSet) data.get(set)).getYAxis();
    }

    /**
     * Returns true if the columns are numeric.
     * @return <CODE>true</CODE>
     */
    public boolean isColumnNumeric() {
        return true;
    }

    /**
     * Returns the class of the column values.
     * @return <CODE>Double.class</CODE>
     */
    public Class getColumnClass() {
        return Double.class;
    }

    /**
     * Returns the Value in a specific dataset at a certain index.      *
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value at the specified position
     */
    public Number getValueAt(int set, int index) {
        return (Number) ((DataSet) data.get(set)).getValueAt(index);
    }

    /**
     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel
     * can contain DataSets with different lengths and column values.
     * @return null
     */
    public Object getColumnValueAt(int col) {
        return null;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     * @param set the DataSet of which the column value is desired
     */
    public Object getColumnValueAt(int set, int col) {
        // PENDING: Why do we create a new Double here?
        if (col < getDataSetLength(set))
            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());
        else
            return null;
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant.
     * @return a ChartDataModelConstraints object with the constraints
     * for the specified y-axis.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet
     * containing all values. If asymptotic functions are plotted, infinite values
     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,
     * these values are omitted from these calculations.
     */
    protected void trimSet(TreeSet s) {
        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {
            s.remove(s.first());
        }
        double last = ((Number) s.last()).doubleValue();
        while (last == Double.POSITIVE_INFINITY || last != last) {
            s.remove(s.last());
            last = ((Number) s.last()).doubleValue();
        }
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Returns the first ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getFirstColumnValue() {
        return ((Number) columnSet.first()).doubleValue();
    }

    /**
     * Returns the last ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getLastColumnValue() {
        return ((Number) columnSet.last()).doubleValue();
    }
}
","// DefaultChartDataModel_0Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getDataSetLength(int)} method.
*/
class DefaultChartDataModel_0Test {","// DefaultChartDataModel_0Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getDataSetLength(int)} method.
*/
class DefaultChartDataModel_0Test {

		/**
		* Test case for the {@link DefaultChartDataModel#getDataSetLength(int)} method.
		*/
		@Test
		void testGetDataSetLength_0() {
				// Test values
				int set = 0;
				
				// Constructor arguments
				Number[][] data = new Number[][] {
						new Number[] { new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0), new Double(0.0"
cmpl-6ttcMBr6NYk0jo99fV6aDVSpO5KU0,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModel_1Test.java,40.35595631599426,length,"// DefaultChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultChartDataModel.java
    Created on 28. Juni 2001, 20:41
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * Implements a default ChartModel. It uses a DataSet[] and the columns
 * are numeric. It's purely read-only.
 * @author  mueller
 * @version 1.0
 */
public class DefaultChartDataModel extends AbstractChartDataModel {

    /**
     * The sorted x-axis values used for calculating the constraints.
     */
    protected TreeSet columnSet = new TreeSet();

    /**
     * The DataSet list.
     */
    protected ArrayList data = new ArrayList();

    /**
     * A HashMap containing the ordered data used for calculating the constraints.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     */
    public DefaultChartDataModel() {
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);
    }

    /**
     * Creates new DefaultChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {
        this();
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates a new DefaultChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets.
     * @param ds the array of DataSets to be used.
     */
    public DefaultChartDataModel(DataSet[] ds) {
        this();
        TreeSet set;
        for (int i = 0; i < ds.length; i++) {
            data.add(ds[i]);
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                columnSet.add(ds[i].getColumnValueAt(j));
                set.add(ds[i].getValueAt(j));
                trimSet(set);
            }
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet
     * @return the length of the DataSet
     */
    public int getDataSetLength(int set) {
        return ((DataSet) data.get(set)).getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSets
     */
    public int getDataSetNumber() {
        return data.size();
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return ((DataSet) data.get(set)).getTitle();
    }

    /**
     * Returns the axis binding for a DataSet
     * @param set the DataSet index
     * @return an axis binding constant
     */
    public int getAxisBinding(int set) {
        return ((DataSet) data.get(set)).getYAxis();
    }

    /**
     * Returns true if the columns are numeric.
     * @return <CODE>true</CODE>
     */
    public boolean isColumnNumeric() {
        return true;
    }

    /**
     * Returns the class of the column values.
     * @return <CODE>Double.class</CODE>
     */
    public Class getColumnClass() {
        return Double.class;
    }

    /**
     * Returns the Value in a specific dataset at a certain index.      *
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value at the specified position
     */
    public Number getValueAt(int set, int index) {
        return (Number) ((DataSet) data.get(set)).getValueAt(index);
    }

    /**
     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel
     * can contain DataSets with different lengths and column values.
     * @return null
     */
    public Object getColumnValueAt(int col) {
        return null;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     * @param set the DataSet of which the column value is desired
     */
    public Object getColumnValueAt(int set, int col) {
        // PENDING: Why do we create a new Double here?
        if (col < getDataSetLength(set))
            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());
        else
            return null;
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant.
     * @return a ChartDataModelConstraints object with the constraints
     * for the specified y-axis.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet
     * containing all values. If asymptotic functions are plotted, infinite values
     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,
     * these values are omitted from these calculations.
     */
    protected void trimSet(TreeSet s) {
        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {
            s.remove(s.first());
        }
        double last = ((Number) s.last()).doubleValue();
        while (last == Double.POSITIVE_INFINITY || last != last) {
            s.remove(s.last());
            last = ((Number) s.last()).doubleValue();
        }
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Returns the first ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getFirstColumnValue() {
        return ((Number) columnSet.first()).doubleValue();
    }

    /**
     * Returns the last ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getLastColumnValue() {
        return ((Number) columnSet.last()).doubleValue();
    }
}
","// DefaultChartDataModel_1Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getDataSetName(int)} method.
*/
class DefaultChartDataModel_1Test {","// DefaultChartDataModel_1Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getDataSetName(int)} method.
*/
class DefaultChartDataModel_1Test {

	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_1() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(0);
		assertEquals(""0"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_2() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(1);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_3() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(2);
		assertEquals(""2"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_4() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(3);
		assertEquals(""3"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_5() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(4);
		assertEquals(""4"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_6() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(5);
		assertEquals(""5"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_7() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(6);
		assertEquals(""6"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_8() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(7);
		assertEquals(""7"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_9() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(8);
		assertEquals(""8"", result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_10() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		String result = defaultChartDataModel.getDataSetName(9);
		assertEquals(""9"", result);
	}
	
}

// DefaultChartDataModel_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
*/
class DefaultChartDataModel_2Test {
		
	/**
	* Test case for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_1() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		int result = defaultChartDataModel.getAxisBinding(0);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_2() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		int result = defaultChartDataModel.getAxisBinding(1);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_3() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		int result = defaultChartDataModel.getAxisBinding(2);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_4() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		int result = defaultChartDataModel.getAxisBinding(3);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_5() {
		DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel();
		int result = defaultChartDataModel.getAxisBinding(4);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGet"
cmpl-6ttdPaps2B2U1SaI28ppnyepY8d9B,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModel_2Test.java,51.52821731567383,length,"// DefaultChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultChartDataModel.java
    Created on 28. Juni 2001, 20:41
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * Implements a default ChartModel. It uses a DataSet[] and the columns
 * are numeric. It's purely read-only.
 * @author  mueller
 * @version 1.0
 */
public class DefaultChartDataModel extends AbstractChartDataModel {

    /**
     * The sorted x-axis values used for calculating the constraints.
     */
    protected TreeSet columnSet = new TreeSet();

    /**
     * The DataSet list.
     */
    protected ArrayList data = new ArrayList();

    /**
     * A HashMap containing the ordered data used for calculating the constraints.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     */
    public DefaultChartDataModel() {
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);
    }

    /**
     * Creates new DefaultChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {
        this();
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates a new DefaultChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets.
     * @param ds the array of DataSets to be used.
     */
    public DefaultChartDataModel(DataSet[] ds) {
        this();
        TreeSet set;
        for (int i = 0; i < ds.length; i++) {
            data.add(ds[i]);
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                columnSet.add(ds[i].getColumnValueAt(j));
                set.add(ds[i].getValueAt(j));
                trimSet(set);
            }
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet
     * @return the length of the DataSet
     */
    public int getDataSetLength(int set) {
        return ((DataSet) data.get(set)).getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSets
     */
    public int getDataSetNumber() {
        return data.size();
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return ((DataSet) data.get(set)).getTitle();
    }

    /**
     * Returns the axis binding for a DataSet
     * @param set the DataSet index
     * @return an axis binding constant
     */
    public int getAxisBinding(int set) {
        return ((DataSet) data.get(set)).getYAxis();
    }

    /**
     * Returns true if the columns are numeric.
     * @return <CODE>true</CODE>
     */
    public boolean isColumnNumeric() {
        return true;
    }

    /**
     * Returns the class of the column values.
     * @return <CODE>Double.class</CODE>
     */
    public Class getColumnClass() {
        return Double.class;
    }

    /**
     * Returns the Value in a specific dataset at a certain index.      *
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value at the specified position
     */
    public Number getValueAt(int set, int index) {
        return (Number) ((DataSet) data.get(set)).getValueAt(index);
    }

    /**
     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel
     * can contain DataSets with different lengths and column values.
     * @return null
     */
    public Object getColumnValueAt(int col) {
        return null;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     * @param set the DataSet of which the column value is desired
     */
    public Object getColumnValueAt(int set, int col) {
        // PENDING: Why do we create a new Double here?
        if (col < getDataSetLength(set))
            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());
        else
            return null;
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant.
     * @return a ChartDataModelConstraints object with the constraints
     * for the specified y-axis.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet
     * containing all values. If asymptotic functions are plotted, infinite values
     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,
     * these values are omitted from these calculations.
     */
    protected void trimSet(TreeSet s) {
        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {
            s.remove(s.first());
        }
        double last = ((Number) s.last()).doubleValue();
        while (last == Double.POSITIVE_INFINITY || last != last) {
            s.remove(s.last());
            last = ((Number) s.last()).doubleValue();
        }
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Returns the first ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getFirstColumnValue() {
        return ((Number) columnSet.first()).doubleValue();
    }

    /**
     * Returns the last ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getLastColumnValue() {
        return ((Number) columnSet.last()).doubleValue();
    }
}
","// DefaultChartDataModel_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
*/
class DefaultChartDataModel_2Test {","// DefaultChartDataModel_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getAxisBinding(int)} method.
*/
class DefaultChartDataModel_2Test {

	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 0</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_1() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 0;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 1</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_2() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 1;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 2</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_3() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 2;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 3</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_4() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 3;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 4</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_5() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 4;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 5</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_6() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 5;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 6</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_7() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 6;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 7</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_8() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 7;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 8</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_9() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 8;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
	
	/**
	* Test case for {@link DefaultChartDataModel#getAxisBinding(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 9</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>returns 0</li>
	* </ul>
	*/
	@Test
	void testGetAxisBinding_10() {
		DefaultChartDataModel dataModel = new DefaultChartDataModel();
		int set = 9;
		int result = dataModel.getAxisBinding(set);
		assertEquals(0, result);
	}
}

// DefaultChartDataModel_3Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getDataSetLength(int)} method.
*/
class DefaultChartDataModel_3Test {
		
	/**
	* Test case for {@link DefaultChartDataModel#getDataSetLength(int)}.
	* The test case tests the method with the following parameters:
	* <ul>
	* <li>set = 0</li>
	* </ul>
	* The expected result is:
	* <ul>
	* <li>"
cmpl-6tteSe2KN6NOAoJO4mzkwAJsT4PnY,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModel_3Test.java,52.8272271156311,length,"// DefaultChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultChartDataModel.java
    Created on 28. Juni 2001, 20:41
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * Implements a default ChartModel. It uses a DataSet[] and the columns
 * are numeric. It's purely read-only.
 * @author  mueller
 * @version 1.0
 */
public class DefaultChartDataModel extends AbstractChartDataModel {

    /**
     * The sorted x-axis values used for calculating the constraints.
     */
    protected TreeSet columnSet = new TreeSet();

    /**
     * The DataSet list.
     */
    protected ArrayList data = new ArrayList();

    /**
     * A HashMap containing the ordered data used for calculating the constraints.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     */
    public DefaultChartDataModel() {
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);
    }

    /**
     * Creates new DefaultChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {
        this();
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates a new DefaultChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets.
     * @param ds the array of DataSets to be used.
     */
    public DefaultChartDataModel(DataSet[] ds) {
        this();
        TreeSet set;
        for (int i = 0; i < ds.length; i++) {
            data.add(ds[i]);
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                columnSet.add(ds[i].getColumnValueAt(j));
                set.add(ds[i].getValueAt(j));
                trimSet(set);
            }
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet
     * @return the length of the DataSet
     */
    public int getDataSetLength(int set) {
        return ((DataSet) data.get(set)).getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSets
     */
    public int getDataSetNumber() {
        return data.size();
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return ((DataSet) data.get(set)).getTitle();
    }

    /**
     * Returns the axis binding for a DataSet
     * @param set the DataSet index
     * @return an axis binding constant
     */
    public int getAxisBinding(int set) {
        return ((DataSet) data.get(set)).getYAxis();
    }

    /**
     * Returns true if the columns are numeric.
     * @return <CODE>true</CODE>
     */
    public boolean isColumnNumeric() {
        return true;
    }

    /**
     * Returns the class of the column values.
     * @return <CODE>Double.class</CODE>
     */
    public Class getColumnClass() {
        return Double.class;
    }

    /**
     * Returns the Value in a specific dataset at a certain index.      *
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value at the specified position
     */
    public Number getValueAt(int set, int index) {
        return (Number) ((DataSet) data.get(set)).getValueAt(index);
    }

    /**
     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel
     * can contain DataSets with different lengths and column values.
     * @return null
     */
    public Object getColumnValueAt(int col) {
        return null;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     * @param set the DataSet of which the column value is desired
     */
    public Object getColumnValueAt(int set, int col) {
        // PENDING: Why do we create a new Double here?
        if (col < getDataSetLength(set))
            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());
        else
            return null;
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant.
     * @return a ChartDataModelConstraints object with the constraints
     * for the specified y-axis.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet
     * containing all values. If asymptotic functions are plotted, infinite values
     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,
     * these values are omitted from these calculations.
     */
    protected void trimSet(TreeSet s) {
        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {
            s.remove(s.first());
        }
        double last = ((Number) s.last()).doubleValue();
        while (last == Double.POSITIVE_INFINITY || last != last) {
            s.remove(s.last());
            last = ((Number) s.last()).doubleValue();
        }
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Returns the first ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getFirstColumnValue() {
        return ((Number) columnSet.first()).doubleValue();
    }

    /**
     * Returns the last ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getLastColumnValue() {
        return ((Number) columnSet.last()).doubleValue();
    }
}
","// DefaultChartDataModel_3Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getValueAt(int, int)} method.
*/
class DefaultChartDataModel_3Test {","// DefaultChartDataModel_3Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getValueAt(int, int)} method.
*/
class DefaultChartDataModel_3Test {

		/**
		* Test case 1 for {@link DefaultChartDataModel#getValueAt(int, int)}
		*/
		@Test
		void testGetValueAt_1() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 1.0, 2.0, 3.0, 4.0, 5.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""1"", ""2"" };
				DefaultChartDataModel model = new DefaultChartDataModel(data, columns, rows);
				assertEquals(1.0, model.getValueAt(0, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(0, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(0, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(0, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(0, 4).doubleValue());
				assertEquals(1.0, model.getValueAt(1, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(1, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(1, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(1, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(1, 4).doubleValue());
		}
		
		/**
		* Test case 2 for {@link DefaultChartDataModel#getValueAt(int, int)}
		*/
		@Test
		void testGetValueAt_2() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 1.0, 2.0, 3.0, 4.0, 5.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""1"", ""2"" };
				DefaultChartDataModel model = new DefaultChartDataModel(data, columns, rows);
				assertEquals(1.0, model.getValueAt(0, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(0, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(0, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(0, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(0, 4).doubleValue());
				assertEquals(1.0, model.getValueAt(1, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(1, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(1, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(1, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(1, 4).doubleValue());
		}
		
		/**
		* Test case 3 for {@link DefaultChartDataModel#getValueAt(int, int)}
		*/
		@Test
		void testGetValueAt_3() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 1.0, 2.0, 3.0, 4.0, 5.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""1"", ""2"" };
				DefaultChartDataModel model = new DefaultChartDataModel(data, columns, rows);
				assertEquals(1.0, model.getValueAt(0, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(0, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(0, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(0, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(0, 4).doubleValue());
				assertEquals(1.0, model.getValueAt(1, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(1, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(1, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(1, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(1, 4).doubleValue());
		}
		
		/**
		* Test case 4 for {@link DefaultChartDataModel#getValueAt(int, int)}
		*/
		@Test
		void testGetValueAt_4() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 1.0, 2.0, 3.0, 4.0, 5.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""1"", ""2"" };
				DefaultChartDataModel model = new DefaultChartDataModel(data, columns, rows);
				assertEquals(1.0, model.getValueAt(0, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(0, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(0, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(0, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(0, 4).doubleValue());
				assertEquals(1.0, model.getValueAt(1, 0).doubleValue());
				assertEquals(2.0, model.getValueAt(1, 1).doubleValue());
				assertEquals(3.0, model.getValueAt(1, 2).doubleValue());
				assertEquals(4.0, model.getValueAt(1, 3).doubleValue());
				assertEquals(5.0, model.getValueAt(1, 4).doubleValue());
		}
		
		/**
		* Test case 5 for {@link DefaultChartDataModel#getValueAt(int, int)}
		*/
		@Test
		void testGetValueAt_5() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 1.0, 2.0, 3.0, 4.0, 5.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""1"", ""2"" };
				DefaultChartDataModel model = new DefaultChartDataModel(data, columns, rows);
				assertEqu"
cmpl-6ttfVYFl7YaUfHw5vzxE2O6a4eR8m,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModel_4Test.java,48.07220220565796,length,"// DefaultChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultChartDataModel.java
    Created on 28. Juni 2001, 20:41
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * Implements a default ChartModel. It uses a DataSet[] and the columns
 * are numeric. It's purely read-only.
 * @author  mueller
 * @version 1.0
 */
public class DefaultChartDataModel extends AbstractChartDataModel {

    /**
     * The sorted x-axis values used for calculating the constraints.
     */
    protected TreeSet columnSet = new TreeSet();

    /**
     * The DataSet list.
     */
    protected ArrayList data = new ArrayList();

    /**
     * A HashMap containing the ordered data used for calculating the constraints.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     */
    public DefaultChartDataModel() {
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);
    }

    /**
     * Creates new DefaultChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {
        this();
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates a new DefaultChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets.
     * @param ds the array of DataSets to be used.
     */
    public DefaultChartDataModel(DataSet[] ds) {
        this();
        TreeSet set;
        for (int i = 0; i < ds.length; i++) {
            data.add(ds[i]);
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                columnSet.add(ds[i].getColumnValueAt(j));
                set.add(ds[i].getValueAt(j));
                trimSet(set);
            }
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet
     * @return the length of the DataSet
     */
    public int getDataSetLength(int set) {
        return ((DataSet) data.get(set)).getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSets
     */
    public int getDataSetNumber() {
        return data.size();
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return ((DataSet) data.get(set)).getTitle();
    }

    /**
     * Returns the axis binding for a DataSet
     * @param set the DataSet index
     * @return an axis binding constant
     */
    public int getAxisBinding(int set) {
        return ((DataSet) data.get(set)).getYAxis();
    }

    /**
     * Returns true if the columns are numeric.
     * @return <CODE>true</CODE>
     */
    public boolean isColumnNumeric() {
        return true;
    }

    /**
     * Returns the class of the column values.
     * @return <CODE>Double.class</CODE>
     */
    public Class getColumnClass() {
        return Double.class;
    }

    /**
     * Returns the Value in a specific dataset at a certain index.      *
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value at the specified position
     */
    public Number getValueAt(int set, int index) {
        return (Number) ((DataSet) data.get(set)).getValueAt(index);
    }

    /**
     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel
     * can contain DataSets with different lengths and column values.
     * @return null
     */
    public Object getColumnValueAt(int col) {
        return null;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     * @param set the DataSet of which the column value is desired
     */
    public Object getColumnValueAt(int set, int col) {
        // PENDING: Why do we create a new Double here?
        if (col < getDataSetLength(set))
            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());
        else
            return null;
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant.
     * @return a ChartDataModelConstraints object with the constraints
     * for the specified y-axis.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet
     * containing all values. If asymptotic functions are plotted, infinite values
     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,
     * these values are omitted from these calculations.
     */
    protected void trimSet(TreeSet s) {
        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {
            s.remove(s.first());
        }
        double last = ((Number) s.last()).doubleValue();
        while (last == Double.POSITIVE_INFINITY || last != last) {
            s.remove(s.last());
            last = ((Number) s.last()).doubleValue();
        }
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Returns the first ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getFirstColumnValue() {
        return ((Number) columnSet.first()).doubleValue();
    }

    /**
     * Returns the last ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getLastColumnValue() {
        return ((Number) columnSet.last()).doubleValue();
    }
}
","// DefaultChartDataModel_4Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getColumnValueAt(int)} method.
*/
class DefaultChartDataModel_4Test {","// DefaultChartDataModel_4Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getColumnValueAt(int)} method.
*/
class DefaultChartDataModel_4Test {

		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is not null.
		*/
		@Test
		void testGetColumnValueAt_1() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(new Double(1.0), defaultChartDataModel.getColumnValueAt(0, 0));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is null.
		*/
		@Test
		void testGetColumnValueAt_2() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(null, defaultChartDataModel.getColumnValueAt(0, 5));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is not null.
		*/
		@Test
		void testGetColumnValueAt_3() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(new Double(1.0), defaultChartDataModel.getColumnValueAt(1, 0));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is null.
		*/
		@Test
		void testGetColumnValueAt_4() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(null, defaultChartDataModel.getColumnValueAt(1, 5));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is not null.
		*/
		@Test
		void testGetColumnValueAt_5() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(new Double(1.0), defaultChartDataModel.getColumnValueAt(0, 0));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is null.
		*/
		@Test
		void testGetColumnValueAt_6() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(null, defaultChartDataModel.getColumnValueAt(0, 5));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is not null.
		*/
		@Test
		void testGetColumnValueAt_7() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(new Double(1.0), defaultChartDataModel.getColumnValueAt(1, 0));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is null.
		*/
		@Test
		void testGetColumnValueAt_8() {
				double[][] data = new double[][] { { 1.0, 2.0, 3.0, 4.0, 5.0 }, { 6.0, 7.0, 8.0, 9.0, 10.0 } };
				double[] columns = new double[] { 1.0, 2.0, 3.0, 4.0, 5.0 };
				String[] rows = new String[] { ""row1"", ""row2"" };
				DefaultChartDataModel defaultChartDataModel = new DefaultChartDataModel(data, columns, rows);
				assertEquals(null, defaultChartDataModel.getColumnValueAt(1, 5));
		}
		
		/**
		* Test case for {@link DefaultChartDataModel#getColumnValueAt(int)} method.
		* Test case for the scenario when the column value is not null.
		*/
		@Test
		void testGetColumnValueAt_"
cmpl-6ttgYKI4P3lRvX7WUXhBpP8m61o6C,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModel_5Test.java,49.03104257583618,length,"// DefaultChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultChartDataModel.java
    Created on 28. Juni 2001, 20:41
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * Implements a default ChartModel. It uses a DataSet[] and the columns
 * are numeric. It's purely read-only.
 * @author  mueller
 * @version 1.0
 */
public class DefaultChartDataModel extends AbstractChartDataModel {

    /**
     * The sorted x-axis values used for calculating the constraints.
     */
    protected TreeSet columnSet = new TreeSet();

    /**
     * The DataSet list.
     */
    protected ArrayList data = new ArrayList();

    /**
     * A HashMap containing the ordered data used for calculating the constraints.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     */
    public DefaultChartDataModel() {
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);
    }

    /**
     * Creates new DefaultChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {
        this();
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates a new DefaultChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets.
     * @param ds the array of DataSets to be used.
     */
    public DefaultChartDataModel(DataSet[] ds) {
        this();
        TreeSet set;
        for (int i = 0; i < ds.length; i++) {
            data.add(ds[i]);
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                columnSet.add(ds[i].getColumnValueAt(j));
                set.add(ds[i].getValueAt(j));
                trimSet(set);
            }
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet
     * @return the length of the DataSet
     */
    public int getDataSetLength(int set) {
        return ((DataSet) data.get(set)).getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSets
     */
    public int getDataSetNumber() {
        return data.size();
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return ((DataSet) data.get(set)).getTitle();
    }

    /**
     * Returns the axis binding for a DataSet
     * @param set the DataSet index
     * @return an axis binding constant
     */
    public int getAxisBinding(int set) {
        return ((DataSet) data.get(set)).getYAxis();
    }

    /**
     * Returns true if the columns are numeric.
     * @return <CODE>true</CODE>
     */
    public boolean isColumnNumeric() {
        return true;
    }

    /**
     * Returns the class of the column values.
     * @return <CODE>Double.class</CODE>
     */
    public Class getColumnClass() {
        return Double.class;
    }

    /**
     * Returns the Value in a specific dataset at a certain index.      *
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value at the specified position
     */
    public Number getValueAt(int set, int index) {
        return (Number) ((DataSet) data.get(set)).getValueAt(index);
    }

    /**
     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel
     * can contain DataSets with different lengths and column values.
     * @return null
     */
    public Object getColumnValueAt(int col) {
        return null;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     * @param set the DataSet of which the column value is desired
     */
    public Object getColumnValueAt(int set, int col) {
        // PENDING: Why do we create a new Double here?
        if (col < getDataSetLength(set))
            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());
        else
            return null;
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant.
     * @return a ChartDataModelConstraints object with the constraints
     * for the specified y-axis.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet
     * containing all values. If asymptotic functions are plotted, infinite values
     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,
     * these values are omitted from these calculations.
     */
    protected void trimSet(TreeSet s) {
        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {
            s.remove(s.first());
        }
        double last = ((Number) s.last()).doubleValue();
        while (last == Double.POSITIVE_INFINITY || last != last) {
            s.remove(s.last());
            last = ((Number) s.last()).doubleValue();
        }
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Returns the first ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getFirstColumnValue() {
        return ((Number) columnSet.first()).doubleValue();
    }

    /**
     * Returns the last ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getLastColumnValue() {
        return ((Number) columnSet.last()).doubleValue();
    }
}
","// DefaultChartDataModel_5Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getColumnValueAt(int, int)} method.
*/
class DefaultChartDataModel_5Test {","// DefaultChartDataModel_5Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getColumnValueAt(int, int)} method.
*/
class DefaultChartDataModel_5Test {

	/**
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt(int, int)}.
	* Test case 1 for method {@link DefaultChartDataModel#getColumnValueAt("
cmpl-6tthbhvZWYGfeE2BYet1B2YFD91iF,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultChartDataModel_6Test.java,51.276068925857544,length,"// DefaultChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultChartDataModel.java
    Created on 28. Juni 2001, 20:41
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * Implements a default ChartModel. It uses a DataSet[] and the columns
 * are numeric. It's purely read-only.
 * @author  mueller
 * @version 1.0
 */
public class DefaultChartDataModel extends AbstractChartDataModel {

    /**
     * The sorted x-axis values used for calculating the constraints.
     */
    protected TreeSet columnSet = new TreeSet();

    /**
     * The DataSet list.
     */
    protected ArrayList data = new ArrayList();

    /**
     * A HashMap containing the ordered data used for calculating the constraints.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     */
    public DefaultChartDataModel() {
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS);
    }

    /**
     * Creates new DefaultChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(Number[][] data, double[] columns, String[] rows) {
        this();
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(data[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(int[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates new DefaultChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the array of DataSet titles. It has to have the same
     * length as the number of DataSets.
     */
    public DefaultChartDataModel(double[][] data, double[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        columnSet.addAll(Arrays.asList(ChartUtilities.transformArray(columns)));
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        trimSet(set);
        for (int i = 0; i < data.length; i++) {
            this.data.add(new DefaultDataSet(numdata[i], ChartUtilities.transformArray(columns), CoordSystem.FIRST_YAXIS, rows[i]));
        }
    }

    /**
     * Creates a new DefaultChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets.
     * @param ds the array of DataSets to be used.
     */
    public DefaultChartDataModel(DataSet[] ds) {
        this();
        TreeSet set;
        for (int i = 0; i < ds.length; i++) {
            data.add(ds[i]);
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                columnSet.add(ds[i].getColumnValueAt(j));
                set.add(ds[i].getValueAt(j));
                trimSet(set);
            }
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet
     * @return the length of the DataSet
     */
    public int getDataSetLength(int set) {
        return ((DataSet) data.get(set)).getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSets
     */
    public int getDataSetNumber() {
        return data.size();
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return ((DataSet) data.get(set)).getTitle();
    }

    /**
     * Returns the axis binding for a DataSet
     * @param set the DataSet index
     * @return an axis binding constant
     */
    public int getAxisBinding(int set) {
        return ((DataSet) data.get(set)).getYAxis();
    }

    /**
     * Returns true if the columns are numeric.
     * @return <CODE>true</CODE>
     */
    public boolean isColumnNumeric() {
        return true;
    }

    /**
     * Returns the class of the column values.
     * @return <CODE>Double.class</CODE>
     */
    public Class getColumnClass() {
        return Double.class;
    }

    /**
     * Returns the Value in a specific dataset at a certain index.      *
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value at the specified position
     */
    public Number getValueAt(int set, int index) {
        return (Number) ((DataSet) data.get(set)).getValueAt(index);
    }

    /**
     * Use getColumnValue(int set, int col) instead, because DefaultChartDataModel
     * can contain DataSets with different lengths and column values.
     * @return null
     */
    public Object getColumnValueAt(int col) {
        return null;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     * @param set the DataSet of which the column value is desired
     */
    public Object getColumnValueAt(int set, int col) {
        // PENDING: Why do we create a new Double here?
        if (col < getDataSetLength(set))
            return new Double(((Number) ((DataSet) data.get(set)).getColumnValueAt(col)).doubleValue());
        else
            return null;
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant.
     * @return a ChartDataModelConstraints object with the constraints
     * for the specified y-axis.
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Removes infinite and NaN values from a TreeSet. Called with the TreeSet
     * containing all values. If asymptotic functions are plotted, infinite values
     * are the max / min values, resulting in bogus point-to-pixel rations. Therefore,
     * these values are omitted from these calculations.
     */
    protected void trimSet(TreeSet s) {
        while (((Number) s.first()).doubleValue() == Double.NEGATIVE_INFINITY) {
            s.remove(s.first());
        }
        double last = ((Number) s.last()).doubleValue();
        while (last == Double.POSITIVE_INFINITY || last != last) {
            s.remove(s.last());
            last = ((Number) s.last()).doubleValue();
        }
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Returns the first ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getFirstColumnValue() {
        return ((Number) columnSet.first()).doubleValue();
    }

    /**
     * Returns the last ordered column value for use by the ChartDataModelConstraints.
     */
    protected double getLastColumnValue() {
        return ((Number) columnSet.last()).doubleValue();
    }
}
","// DefaultChartDataModel_6Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getChartDataModelConstraints(int)} method.
*/
class DefaultChartDataModel_6Test {","// DefaultChartDataModel_6Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getChartDataModelConstraints(int)} method.
*/
class DefaultChartDataModel_6Test {

	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	 * <ul>
	 * <li>axis = {@link CoordSystem#FIRST_YAXIS}</li>
	 * </ul>
	 * <p>Expected:
	 * <ul>
	 * <li>result = {@link DefaultChartDataModelConstraints}</li>
	 * </ul>
	 */
	@Test
	public void testGetChartDataModelConstraints_1() {
		DefaultChartDataModel fixture = new DefaultChartDataModel();
		fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS));
		int axis = CoordSystem.FIRST_YAXIS;
		DefaultChartDataModelConstraints result = fixture.getChartDataModelConstraints(axis);
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	 * <ul>
	 * <li>axis = {@link CoordSystem#SECOND_YAXIS}</li>
	 * </ul>
	 * <p>Expected:
	 * <ul>
	 * <li>result = {@link DefaultChartDataModelConstraints}</li>
	 * </ul>
	 */
	@Test
	public void testGetChartDataModelConstraints_2() {
		DefaultChartDataModel fixture = new DefaultChartDataModel();
		fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS));
		int axis = CoordSystem.SECOND_YAXIS;
		DefaultChartDataModelConstraints result = fixture.getChartDataModelConstraints(axis);
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	 * <ul>
	 * <li>axis = {@link CoordSystem#FIRST_YAXIS}</li>
	 * </ul>
	 * <p>Expected:
	 * <ul>
	 * <li>result = {@link DefaultChartDataModelConstraints}</li>
	 * </ul>
	 */
	@Test
	public void testGetChartDataModelConstraints_3() {
		DefaultChartDataModel fixture = new DefaultChartDataModel();
		fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS));
		int axis = CoordSystem.FIRST_YAXIS;
		DefaultChartDataModelConstraints result = fixture.getChartDataModelConstraints(axis);
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	 * <ul>
	 * <li>axis = {@link CoordSystem#SECOND_YAXIS}</li>
	 * </ul>
	 * <p>Expected:
	 * <ul>
	 * <li>result = {@link DefaultChartDataModelConstraints}</li>
	 * </ul>
	 */
	@Test
	public void testGetChartDataModelConstraints_4() {
		DefaultChartDataModel fixture = new DefaultChartDataModel();
		fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS));
		int axis = CoordSystem.SECOND_YAXIS;
		DefaultChartDataModelConstraints result = fixture.getChartDataModelConstraints(axis);
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	 * <ul>
	 * <li>axis = {@link CoordSystem#FIRST_YAXIS}</li>
	 * </ul>
	 * <p>Expected:
	 * <ul>
	 * <li>result = {@link DefaultChartDataModelConstraints}</li>
	 * </ul>
	 */
	@Test
	public void testGetChartDataModelConstraints_5() {
		DefaultChartDataModel fixture = new DefaultChartDataModel();
		fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS));
		int axis = CoordSystem.FIRST_YAXIS;
		DefaultChartDataModelConstraints result = fixture.getChartDataModelConstraints(axis);
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	 * <ul>
	 * <li>axis = {@link CoordSystem#SECOND_YAXIS}</li>
	 * </ul>
	 * <p>Expected:
	 * <ul>
	 * <li>result = {@link DefaultChartDataModelConstraints}</li>
	 * </ul>
	 */
	@Test
	public void testGetChartDataModelConstraints_6() {
		DefaultChartDataModel fixture = new DefaultChartDataModel();
		fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS));
		int axis = CoordSystem.SECOND_YAXIS;
		DefaultChartDataModelConstraints result = fixture.getChartDataModelConstraints(axis);
		assertNotNull(result);
	}
	
}

// DefaultChartDataModel_7Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultChartDataModel}.
* It contains ten unit test cases for the {@link DefaultChartDataModel#getChartDataModelConstraints(int)} method.
*/
class DefaultChartDataModel_7Test {
		
	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	 * <ul>
	 * <li>axis = {@link CoordSystem#FIRST_YAXIS}</li>
	 * </ul>
	 * <p>Expected:
	 * <ul>
	 * <li>result = {@link DefaultChartDataModelConstraints}</li>
	 * </ul>
	 */
	@Test
	public void testGetChartDataModelConstraints_1() {
		DefaultChartDataModel fixture = new DefaultChartDataModel();
		fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS));
		int axis = CoordSystem.FIRST_YAXIS;
		DefaultChartDataModelConstraints result = fixture.getChartDataModelConstraints(axis);
		assertNotNull(result);
	}
	
	/**
	 * Test case for {@link DefaultChartDataModel#getChartDataModelConstraints(int)}
	 * with the following input:
	"
cmpl-6ttieVNOAniuOwh784xG0Fg4ryeY6,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultDataSet_0Test.java,44.233797550201416,length,"// DefaultDataSet.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultDataSet.java
    Created on 1. Juli 2001, 21:20
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * This is a default DataSet implementation.
 * @author mueller
 * @version 1.0
 */
public class DefaultDataSet implements DataSet {

    protected ArrayList data = new ArrayList();

    protected ArrayList columns = new ArrayList();

    protected int axis = CoordSystem.FIRST_YAXIS;

    protected String title = """";

    /**
     * Creates a new empty DefaultDataSet with default axis binding.
     */
    public DefaultDataSet() {
    }

    /**
     * Creates a new empty DefaultDataSet with the given
     * Axis binding.
     */
    public DefaultDataSet(int axis) {
        this();
        setYAxis(axis);
    }

    /**
     * Creates a new DefaultDataSet with the given data and
     * the Axis binding.
     * @param data the DataSet values
     * @param columns the DataSet columns, the value and the column array should
     * have the same length. The columns have to be sorted.
     * @param axis the Axis binding
     */
    public DefaultDataSet(Object[] data, Object[] columns, int axis) {
        this(axis);
        this.data.addAll(Arrays.asList(data));
        this.columns.addAll(Arrays.asList(columns));
    }

    /**
     * Creates a new DefaultDataSet with the given data and
     * the Axis binding.
     * @param data the DataSet values
     * @param columns the DataSet columns, the value and the column array should
     * have the same length. The columns have to be sorted.
     * @param axis the Axis binding
     */
    public DefaultDataSet(Object[] data, Object[] columns, int axis, String title) {
        this(data, columns, axis);
        this.title = title;
    }

    /**
     * Returns the length of this data set, ie the minimum of the columns and the
     * data array length.
     * @return the length of the DataSet
     */
    public int getDataSetLength() {
        return Math.min(data.size(), columns.size());
    }

    /**
     * Returns the data at the specified index.
     * @param index the data index
     * @return the Object value
     */
    public Object getValueAt(int index) {
        return data.get(index);
    }

    /**
     * Returns the Axis binding.
     * @return the axis binding constant
     */
    public int getYAxis() {
        return axis;
    }

    /**
     * Sets the given value at the specified index.
     * @param index the value index
     * @param val the Object value
     */
    public void setValueAt(int index, Object val) {
        data.set(index, val);
    }

    /**
     * Sets the Axis binding.
     * @param yaxis the axis binding constant
     */
    public void setYAxis(int yaxis) {
        if (yaxis == CoordSystem.FIRST_YAXIS || yaxis == CoordSystem.SECOND_YAXIS)
            axis = yaxis;
    }

    /**
     * Returns the column value.
     * @param index the column index
     * @return the column value
     */
    public Object getColumnValueAt(int index) {
        return columns.get(index);
    }

    /**
     * Sets a column value.
     * @param index the column index
     * @param col the column value
     */
    public void setColumnValueAt(int index, Object col) {
        columns.set(index, col);
    }

    /**
     * Sets the title of this DataSet.
     * @param title the String title
     */
    public void setTitle(String title) {
        this.title = title;
    }

    /**
     * Returns the title of this DataSet.
     * @return the String title
     */
    public String getTitle() {
        return title;
    }
}
","// DefaultDataSet_0Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataSet}.
* It contains ten unit test cases for the {@link DefaultDataSet#getValueAt(int)} method.
*/
class DefaultDataSet_0Test {","// DefaultDataSet_0Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataSet}.
* It contains ten unit test cases for the {@link DefaultDataSet#getValueAt(int)} method.
*/
class DefaultDataSet_0Test {

		/**
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		* Test case 1 for method getValueAt(int).
		*/
		@Test
		public void testGetValueAt_0() {
				DefaultDataSet fixture = new DefaultDataSet(new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, CoordSystem.FIRST_YAXIS);
				int index = 0;
				Object result = fixture.getValueAt(index);
				assertEquals(new Integer(1), result);
		}
		
		/**
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		* Test case 2 for method getValueAt(int).
		*/
		@Test
		public void testGetValueAt_1() {
				DefaultDataSet fixture = new DefaultDataSet(new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, CoordSystem.FIRST_YAXIS);
				int index = 1;
				Object result = fixture.getValueAt(index);
				assertEquals(new Integer(1), result);
		}
		
		/**
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		* Test case 3 for method getValueAt(int).
		*/
		@Test
		public void testGetValueAt_2() {
				DefaultDataSet fixture = new DefaultDataSet(new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, CoordSystem.FIRST_YAXIS);
				int index = 2;
				Object result = fixture.getValueAt(index);
				assertEquals(new Integer(1), result);
		}
		
		/**
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		* Test case 4 for method getValueAt(int).
		*/
		@Test
		public void testGetValueAt_3() {
				DefaultDataSet fixture = new DefaultDataSet(new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, CoordSystem.FIRST_YAXIS);
				int index = 3;
				Object result = fixture.getValueAt(index);
				assertEquals(new Integer(1), result);
		}
		
		/**
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		* Test case 5 for method getValueAt(int).
		*/
		@Test
		public void testGetValueAt_4() {
				DefaultDataSet fixture = new DefaultDataSet(new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, new Object[] { new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1), new Integer(1) }, CoordSystem.FIRST_YAXIS);
				int index = 4;
				Object result = fixture.getValueAt(index);
				assertEquals(new Integer(1), result);
		}
		
		/**
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		* Test case 6 for method getValueAt(int).
		*/
		@Test
		public void testGetValueAt_5() {
				DefaultDataSet fixture = new DefaultDataSet(new Object[] { new Integer(1),"
cmpl-6ttjhDoYk9ZHWy05Xpf7NwbfgglwO,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/DefaultDataSet_1Test.java,35.66567897796631,length,"// DefaultDataSet.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    DefaultDataSet.java
    Created on 1. Juli 2001, 21:20
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import java.util.ArrayList;
import java.util.Arrays;

/**
 * This is a default DataSet implementation.
 * @author mueller
 * @version 1.0
 */
public class DefaultDataSet implements DataSet {

    protected ArrayList data = new ArrayList();

    protected ArrayList columns = new ArrayList();

    protected int axis = CoordSystem.FIRST_YAXIS;

    protected String title = """";

    /**
     * Creates a new empty DefaultDataSet with default axis binding.
     */
    public DefaultDataSet() {
    }

    /**
     * Creates a new empty DefaultDataSet with the given
     * Axis binding.
     */
    public DefaultDataSet(int axis) {
        this();
        setYAxis(axis);
    }

    /**
     * Creates a new DefaultDataSet with the given data and
     * the Axis binding.
     * @param data the DataSet values
     * @param columns the DataSet columns, the value and the column array should
     * have the same length. The columns have to be sorted.
     * @param axis the Axis binding
     */
    public DefaultDataSet(Object[] data, Object[] columns, int axis) {
        this(axis);
        this.data.addAll(Arrays.asList(data));
        this.columns.addAll(Arrays.asList(columns));
    }

    /**
     * Creates a new DefaultDataSet with the given data and
     * the Axis binding.
     * @param data the DataSet values
     * @param columns the DataSet columns, the value and the column array should
     * have the same length. The columns have to be sorted.
     * @param axis the Axis binding
     */
    public DefaultDataSet(Object[] data, Object[] columns, int axis, String title) {
        this(data, columns, axis);
        this.title = title;
    }

    /**
     * Returns the length of this data set, ie the minimum of the columns and the
     * data array length.
     * @return the length of the DataSet
     */
    public int getDataSetLength() {
        return Math.min(data.size(), columns.size());
    }

    /**
     * Returns the data at the specified index.
     * @param index the data index
     * @return the Object value
     */
    public Object getValueAt(int index) {
        return data.get(index);
    }

    /**
     * Returns the Axis binding.
     * @return the axis binding constant
     */
    public int getYAxis() {
        return axis;
    }

    /**
     * Sets the given value at the specified index.
     * @param index the value index
     * @param val the Object value
     */
    public void setValueAt(int index, Object val) {
        data.set(index, val);
    }

    /**
     * Sets the Axis binding.
     * @param yaxis the axis binding constant
     */
    public void setYAxis(int yaxis) {
        if (yaxis == CoordSystem.FIRST_YAXIS || yaxis == CoordSystem.SECOND_YAXIS)
            axis = yaxis;
    }

    /**
     * Returns the column value.
     * @param index the column index
     * @return the column value
     */
    public Object getColumnValueAt(int index) {
        return columns.get(index);
    }

    /**
     * Sets a column value.
     * @param index the column index
     * @param col the column value
     */
    public void setColumnValueAt(int index, Object col) {
        columns.set(index, col);
    }

    /**
     * Sets the title of this DataSet.
     * @param title the String title
     */
    public void setTitle(String title) {
        this.title = title;
    }

    /**
     * Returns the title of this DataSet.
     * @return the String title
     */
    public String getTitle() {
        return title;
    }
}
","// DefaultDataSet_1Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataSet}.
* It contains ten unit test cases for the {@link DefaultDataSet#getColumnValueAt(int)} method.
*/
class DefaultDataSet_1Test {","// DefaultDataSet_1Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataSet}.
* It contains ten unit test cases for the {@link DefaultDataSet#getColumnValueAt(int)} method.
*/
class DefaultDataSet_1Test {

	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_1() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(0, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(0));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_2() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(1, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(1));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_3() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(2, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(2));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_4() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(3, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(3));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_5() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(4, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(4));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_6() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(5, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(5));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_7() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(6, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(6));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_8() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(7, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(7));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_9() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(8, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(8));
	}
	
	/**
	* Test case for {@link DefaultDataSet#getColumnValueAt(int)}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetColumnValueAt_10() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setColumnValueAt(9, ""test"");
		assertEquals(""test"", dataSet.getColumnValueAt(9));
	}
}

// DefaultDataSet_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultDataSet}.
* It contains ten unit test cases for the {@link DefaultDataSet#getDataSetLength()} method.
*/
class DefaultDataSet_2Test {
		
	/**
	* Test case for {@link DefaultDataSet#getDataSetLength()}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetDataSetLength_1() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		assertEquals(0, dataSet.getDataSetLength());
	}
	
	/**
	* Test case for {@link DefaultDataSet#getDataSetLength()}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetDataSetLength_2() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setValueAt(0, ""test"");
		assertEquals(1, dataSet.getDataSetLength());
	}
	
	/**
	* Test case for {@link DefaultDataSet#getDataSetLength()}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetDataSetLength_3() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setValueAt(1, ""test"");
		assertEquals(2, dataSet.getDataSetLength());
	}
	
	/**
	* Test case for {@link DefaultDataSet#getDataSetLength()}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetDataSetLength_4() {
		DefaultDataSet dataSet = new DefaultDataSet(new Object[] {}, new Object[] {}, CoordSystem.FIRST_YAXIS);
		dataSet.setValueAt(2, ""test"");
		assertEquals(3, dataSet.getDataSetLength());
	}
	
	/**
	* Test case for {@link DefaultDataSet#getDataSetLength()}.
	* The test case tests the method with a valid index.
	*/
	@Test
	void testGetDataSetLength_5() {
		Default"
cmpl-6ttkkqPrIBd8tOFUSpGAYqhoVex3Z,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotter_0Test.java,44.34174180030823,length,"// JDBCPlotter.java
/*
 JOpenChart Java Charting Library and Toolkit
 Copyright (C) 2001  Sebastian M�ller
 http://jopenchart.sourceforge.net

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 JDBCPlotter.java
 Created on 9. October 2002
 Based on SQLPlotter.java, created on 29. December 2001
 
 */
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;

/**
 * The class is used to convert database queries into ChartDataModels.
 * You can initialize the Plotter with database parameters and afterwards
 * you can run consecutive queries resulting in a new database.
 */
public class JDBCPlotter {

    /**
     * The SQL connection.
     */
    protected Connection conn;

    /**
     * Creates a new JDBCPlotter using the given driver and URL.
     * @param jdbcDriver the fully qualified classname of the SQL driver class.
     * @param jdbcURL the URL of the JDBC database to connect to.
     * @param username the username for the JDBC resource
     * @param password the user's password
     */
    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {
        try {
            Class.forName(jdbcDriver);
            conn = DriverManager.getConnection(jdbcURL, username, password);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while creating a database connection."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            double x = 0.0;
            while (sqlResult.next()) {
                columnList.add(new Double(x));
                x += 1.0;
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(new Double(sqlResult.getDouble(columnRow)));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.
     * The columns are initialized with values from row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.
     * The columns are initialized with values of row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(sqlResult.getString(columnRow));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            String[] columns = (String[]) columnList.toArray(new String[0]);
            return new ObjectChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }
}
","// JDBCPlotter_0Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String[])} method.
*/
class JDBCPlotter_0Test {","// JDBCPlotter_0Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String[])} method.
*/
class JDBCPlotter_0Test {

		/**
		* Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String[])}.
		* It tests if the method returns a {@link DefaultChartDataModel} with the correct values.
		*/
		@Test
		void testCreateChartDataModelInstance_0() throws Exception {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
				jdbcPlotter.conn.createStatement().execute(""CREATE TABLE test (a INTEGER, b INTEGER, c INTEGER)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (1, 2, 3)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (4, 5, 6)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (7, 8, 9)"");
				DefaultChartDataModel result = jdbcPlotter.createChartDataModelInstance(""SELECT * FROM test"", new String[] { ""a"", ""b"", ""c"" });
				assertEquals(3, result.getDataSets().length);
				assertEquals(3, result.getDataSets()[0].length);
				assertEquals(3, result.getDataSets()[1].length);
				assertEquals(3, result.getDataSets()[2].length);
				assertEquals(3, result.getColumnCount());
				assertEquals(0.0, result.getColumn(0));
				assertEquals(1.0, result.getColumn(1));
				assertEquals(2.0, result.getColumn(2));
				assertEquals(1.0, result.getValue(0, 0));
				assertEquals(2.0, result.getValue(0, 1));
				assertEquals(3.0, result.getValue(0, 2));
				assertEquals(4.0, result.getValue(1, 0));
				assertEquals(5.0, result.getValue(1, 1));
				assertEquals(6.0, result.getValue(1, 2));
				assertEquals(7.0, result.getValue(2, 0));
				assertEquals(8.0, result.getValue(2, 1));
				assertEquals(9.0, result.getValue(2, 2));
		}
		
		/**
		* Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String[])}.
		* It tests if the method returns a {@link DefaultChartDataModel} with the correct values.
		*/
		@Test
		void testCreateChartDataModelInstance_1() throws Exception {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
				jdbcPlotter.conn.createStatement().execute(""CREATE TABLE test (a INTEGER, b INTEGER, c INTEGER)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (1, 2, 3)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (4, 5, 6)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (7, 8, 9)"");
				DefaultChartDataModel result = jdbcPlotter.createChartDataModelInstance(""SELECT * FROM test"", new String[] { ""a"", ""b"", ""c"" }, new String[] { ""A"", ""B"", ""C"" });
				assertEquals(3, result.getDataSets().length);
				assertEquals(3, result.getDataSets()[0].length);
				assertEquals(3, result.getDataSets()[1].length);
				assertEquals(3, result.getDataSets()[2].length);
				assertEquals(3, result.getColumnCount());
				assertEquals(0.0, result.getColumn(0));
				assertEquals(1.0, result.getColumn(1));
				assertEquals(2.0, result.getColumn(2));
				assertEquals(1.0, result.getValue(0, 0));
				assertEquals(2.0, result.getValue(0, 1));
				assertEquals(3.0, result.getValue(0, 2));
				assertEquals(4.0, result.getValue(1, 0));
				assertEquals(5.0, result.getValue(1, 1));
				assertEquals(6.0, result.getValue(1, 2));
				assertEquals(7.0, result.getValue(2, 0));
				assertEquals(8.0, result.getValue(2, 1));
				assertEquals(9.0, result.getValue(2, 2));
		}
		
		/**
		* Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String, String[])}.
		* It tests if the method returns a {@link DefaultChartDataModel} with the correct values.
		*/
		@Test
		void testCreateChartDataModelInstance_2() throws Exception {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
				jdbcPlotter.conn.createStatement().execute(""CREATE TABLE test (a INTEGER, b INTEGER, c INTEGER)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (1, 2, 3)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (4, 5, 6)"");
				jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (7, 8, 9)"");
				DefaultChartDataModel result = jdbcPlotter.createChartDataModelInstance(""SELECT * FROM test"", ""a"", new String[] { ""b"", ""c"" });
				assertEquals(2, result.getDataSets().length);
				assertEquals(3, result.getDataSets()[0].length);
				assertEquals(3, result.getDataSets()[1].length);
				assertEquals(3, result.getColumnCount());
				assertEquals(1.0, result.getColumn(0));
				assertEquals(4.0, result.getColumn(1));
				assertEquals(7.0, result.getColumn(2));
				assertEquals(2.0, result.getValue(0, 0));
				assertEquals(3.0, result.getValue(0, 1));
				assertEquals(5.0, result.getValue(0, 2));
				assertEquals(6.0, result.getValue(1, 0));
				assertEquals(8.0, result.getValue(1, 1));
				assertEquals(9.0, result.getValue(1, 2));
		}
		
		/**
		* Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String, String"
cmpl-6ttlnIJL1lift9Ac1ECbNE6QZE0jn,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotter_1Test.java,44.574058532714844,length,"// JDBCPlotter.java
/*
 JOpenChart Java Charting Library and Toolkit
 Copyright (C) 2001  Sebastian M�ller
 http://jopenchart.sourceforge.net

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 JDBCPlotter.java
 Created on 9. October 2002
 Based on SQLPlotter.java, created on 29. December 2001
 
 */
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;

/**
 * The class is used to convert database queries into ChartDataModels.
 * You can initialize the Plotter with database parameters and afterwards
 * you can run consecutive queries resulting in a new database.
 */
public class JDBCPlotter {

    /**
     * The SQL connection.
     */
    protected Connection conn;

    /**
     * Creates a new JDBCPlotter using the given driver and URL.
     * @param jdbcDriver the fully qualified classname of the SQL driver class.
     * @param jdbcURL the URL of the JDBC database to connect to.
     * @param username the username for the JDBC resource
     * @param password the user's password
     */
    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {
        try {
            Class.forName(jdbcDriver);
            conn = DriverManager.getConnection(jdbcURL, username, password);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while creating a database connection."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            double x = 0.0;
            while (sqlResult.next()) {
                columnList.add(new Double(x));
                x += 1.0;
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(new Double(sqlResult.getDouble(columnRow)));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.
     * The columns are initialized with values from row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.
     * The columns are initialized with values of row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(sqlResult.getString(columnRow));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            String[] columns = (String[]) columnList.toArray(new String[0]);
            return new ObjectChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }
}
","// JDBCPlotter_1Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String[], String[])} method.
*/
class JDBCPlotter_1Test {","// JDBCPlotter_1Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String[], String[])} method.
*/
class JDBCPlotter_1Test {

		/**
		 * Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String[], String[])}
		 * with a valid SQL query and valid row titles.
		 * The columns are initialized with values starting from 0.
		 * @throws JDBCPlotterException if an error occurs while creating the ChartDataModel
		 */
		@Test
		void testCreateChartDataModelInstance_1() throws JDBCPlotterException {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
				String sqlQuery = ""SELECT * FROM test"";
				String[] sqlRows = {""a"", ""b"", ""c""};
				DefaultChartDataModel chartDataModel = jdbcPlotter.createChartDataModelInstance(sqlQuery, sqlRows);
				assertEquals(3, chartDataModel.getDataSetCount());
				assertEquals(0, chartDataModel.getValue(0, 0));
				assertEquals(1, chartDataModel.getValue(0, 1));
				assertEquals(2, chartDataModel.getValue(0, 2));
				assertEquals(3, chartDataModel.getValue(0, 3));
				assertEquals(4, chartDataModel.getValue(0, 4));
				assertEquals(5, chartDataModel.getValue(0, 5));
				assertEquals(6, chartDataModel.getValue(0, 6));
				assertEquals(7, chartDataModel.getValue(0, 7));
				assertEquals(8, chartDataModel.getValue(0, 8));
				assertEquals(9, chartDataModel.getValue(0, 9));
				assertEquals(10, chartDataModel.getValue(0, 10));
				assertEquals(11, chartDataModel.getValue(0, 11));
				assertEquals(12, chartDataModel.getValue(0, 12));
				assertEquals(13, chartDataModel.getValue(0, 13));
				assertEquals(14, chartDataModel.getValue(0, 14));
				assertEquals(15, chartDataModel.getValue(0, 15));
				assertEquals(16, chartDataModel.getValue(0, 16));
				assertEquals(17, chartDataModel.getValue(0, 17));
				assertEquals(18, chartDataModel.getValue(0, 18));
				assertEquals(19, chartDataModel.getValue(0, 19));
				assertEquals(20, chartDataModel.getValue(0, 20));
				assertEquals(21, chartDataModel.getValue(0, 21));
				assertEquals(22, chartDataModel.getValue(0, 22));
				assertEquals(23, chartDataModel.getValue(0, 23));
				assertEquals(24, chartDataModel.getValue(0, 24));
				assertEquals(25, chartDataModel.getValue(0, 25));
				assertEquals(26, chartDataModel.getValue(0, 26));
				assertEquals(27, chartDataModel.getValue(0, 27));
				assertEquals(28, chartDataModel.getValue(0, 28));
				assertEquals(29, chartDataModel.getValue(0, 29));
				assertEquals(30, chartDataModel.getValue(0, 30));
				assertEquals(31, chartDataModel.getValue(0, 31));
				assertEquals(32, chartDataModel.getValue(0, 32));
				assertEquals(33, chartDataModel.getValue(0, 33));
				assertEquals(34, chartDataModel.getValue(0, 34));
				assertEquals(35, chartDataModel.getValue(0, 35));
				assertEquals(36, chartDataModel.getValue(0, 36));
				assertEquals(37, chartDataModel.getValue(0, 37));
				assertEquals(38, chartDataModel.getValue(0, 38));
				assertEquals(39, chartDataModel.getValue(0, 39));
				assertEquals(40, chartDataModel.getValue(0, 40));
				assertEquals(41, chartDataModel.getValue(0, 41));
				assertEquals(42, chartDataModel.getValue(0, 42));
				assertEquals(43, chartDataModel.getValue(0, 43));
				assertEquals(44, chartDataModel.getValue(0, 44));
				assertEquals(45, chartDataModel.getValue(0, 45));
				assertEquals(46, chartDataModel.getValue(0, 46));
				assertEquals(47, chartDataModel.getValue(0, 47));
				assertEquals(48, chartDataModel.getValue(0, 48));
				assertEquals(49, chartDataModel.getValue(0, 49));
				assertEquals(50, chartDataModel.getValue(0, 50));
				assertEquals(51, chartDataModel.getValue(0, 51));
				assertEquals(52, chartDataModel.getValue(0, 52));
				assertEquals(53, chartDataModel.getValue(0, 53));
				assertEquals(54, chartDataModel.getValue(0, 54));
				assertEquals(55, chartDataModel.getValue(0, 55));
				assertEquals(56, chartDataModel.getValue(0, 56));
				assertEquals(57, chartDataModel.getValue(0, 57));
				assertEquals(58, chartDataModel.getValue(0, 58));
				assertEquals(59, chartDataModel.getValue(0, 59));
				assertEquals(60, chartDataModel.getValue(0, 60));
				assertEquals(61, chartDataModel.getValue(0, 61));
				assertEquals(62, chartDataModel.getValue(0, 62));
				assertEquals(63, chartDataModel.getValue(0, 63));
				assertEquals(64, chartDataModel.getValue(0, 64));
				assertEquals(65, chartDataModel.getValue(0, 65));
				assertEquals(66, chartDataModel.getValue(0, 66));
				assertEquals(67, chartDataModel.getValue(0, 67));
				assertEquals(68, chartDataModel.getValue(0, 68));
				assertEquals(69, chartDataModel.getValue(0, 69));
				assertEquals(70, chartDataModel.getValue(0, 70));
				assertEquals(71, chartDataModel.getValue(0, 71));
				assertEquals(72, chartDataModel.getValue(0, 72));
				assertEquals(73, chartDataModel.getValue(0, 73));
				assertEquals(74, chartDataModel.getValue(0, 74));
				assertEquals(75, chartDataModel.getValue(0, 75));
				assertEquals(76, chartDataModel.getValue(0, 76));
				assertEquals(77, chartDataModel.getValue(0, 77));
				assertEquals(78, chartDataModel.getValue(0, 78));
				assertEquals"
cmpl-6ttmqcjGFZQ2vR6OcyTUOwrUEEQVV,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotter_2Test.java,45.64021277427673,length,"// JDBCPlotter.java
/*
 JOpenChart Java Charting Library and Toolkit
 Copyright (C) 2001  Sebastian M�ller
 http://jopenchart.sourceforge.net

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 JDBCPlotter.java
 Created on 9. October 2002
 Based on SQLPlotter.java, created on 29. December 2001
 
 */
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;

/**
 * The class is used to convert database queries into ChartDataModels.
 * You can initialize the Plotter with database parameters and afterwards
 * you can run consecutive queries resulting in a new database.
 */
public class JDBCPlotter {

    /**
     * The SQL connection.
     */
    protected Connection conn;

    /**
     * Creates a new JDBCPlotter using the given driver and URL.
     * @param jdbcDriver the fully qualified classname of the SQL driver class.
     * @param jdbcURL the URL of the JDBC database to connect to.
     * @param username the username for the JDBC resource
     * @param password the user's password
     */
    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {
        try {
            Class.forName(jdbcDriver);
            conn = DriverManager.getConnection(jdbcURL, username, password);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while creating a database connection."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            double x = 0.0;
            while (sqlResult.next()) {
                columnList.add(new Double(x));
                x += 1.0;
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(new Double(sqlResult.getDouble(columnRow)));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.
     * The columns are initialized with values from row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.
     * The columns are initialized with values of row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(sqlResult.getString(columnRow));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            String[] columns = (String[]) columnList.toArray(new String[0]);
            return new ObjectChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }
}
","// JDBCPlotter_2Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[])} method.
*/
class JDBCPlotter_2Test {","// JDBCPlotter_2Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[])} method.
*/
class JDBCPlotter_2Test {

		/**
		* Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String, String[])} method.
		* It tests the method with a valid SQL query and valid row titles.
		* The columns are initialized with values from columnRow.
		* @throws JDBCPlotterException if an error occurs while creating a database connection or while performing task.
		*/
		@Test
		void testCreateChartDataModelInstance_1() throws JDBCPlotterException {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:hsql://localhost/xdb"", ""SA"", """");
				String sqlQuery = ""SELECT * FROM test"";
				String columnRow = ""column"";
				String[] sqlRows = {""row1"", ""row2"", ""row3""};
				DefaultChartDataModel defaultChartDataModel = jdbcPlotter.createChartDataModelInstance(sqlQuery, columnRow, sqlRows);
				assertEquals(3, defaultChartDataModel.getDataSetCount());
				assertEquals(3, defaultChartDataModel.getDataSetSize());
				assertEquals(3, defaultChartDataModel.getColumnCount());
				assertEquals(1.0, defaultChartDataModel.getValue(0, 0).doubleValue());
				assertEquals(2.0, defaultChartDataModel.getValue(0, 1).doubleValue());
				assertEquals(3.0, defaultChartDataModel.getValue(0, 2).doubleValue());
				assertEquals(4.0, defaultChartDataModel.getValue(1, 0).doubleValue());
				assertEquals(5.0, defaultChartDataModel.getValue(1, 1).doubleValue());
				assertEquals(6.0, defaultChartDataModel.getValue(1, 2).doubleValue());
				assertEquals(7.0, defaultChartDataModel.getValue(2, 0).doubleValue());
				assertEquals(8.0, defaultChartDataModel.getValue(2, 1).doubleValue());
				assertEquals(9.0, defaultChartDataModel.getValue(2, 2).doubleValue());
				assertEquals(1.0, defaultChartDataModel.getColumn(0).doubleValue());
				assertEquals(2.0, defaultChartDataModel.getColumn(1).doubleValue());
				assertEquals(3.0, defaultChartDataModel.getColumn(2).doubleValue());
				assertEquals(""row1"", defaultChartDataModel.getDataSetTitle(0));
				assertEquals(""row2"", defaultChartDataModel.getDataSetTitle(1));
				assertEquals(""row3"", defaultChartDataModel.getDataSetTitle(2));
		}
		
		/**
		* Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String, String[])} method.
		* It tests the method with a valid SQL query and valid row titles.
		* The columns are initialized with values from columnRow.
		* @throws JDBCPlotterException if an error occurs while creating a database connection or while performing task.
		*/
		@Test
		void testCreateChartDataModelInstance_2() throws JDBCPlotterException {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:hsql://localhost/xdb"", ""SA"", """");
				String sqlQuery = ""SELECT * FROM test"";
				String columnRow = ""column"";
				String[] sqlRows = {""row1"", ""row2"", ""row3""};
				String[] dataSets = {""dataSet1"", ""dataSet2"", ""dataSet3""};
				DefaultChartDataModel defaultChartDataModel = jdbcPlotter.createChartDataModelInstance(sqlQuery, columnRow, sqlRows, dataSets);
				assertEquals(3, defaultChartDataModel.getDataSetCount());
				assertEquals(3, defaultChartDataModel.getDataSetSize());
				assertEquals(3, defaultChartDataModel.getColumnCount());
				assertEquals(1.0, defaultChartDataModel.getValue(0, 0).doubleValue());
				assertEquals(2.0, defaultChartDataModel.getValue(0, 1).doubleValue());
				assertEquals(3.0, defaultChartDataModel.getValue(0, 2).doubleValue());
				assertEquals(4.0, defaultChartDataModel.getValue(1, 0).doubleValue());
				assertEquals(5.0, defaultChartDataModel.getValue(1, 1).doubleValue());
				assertEquals(6.0, defaultChartDataModel.getValue(1, 2).doubleValue());
				assertEquals(7.0, defaultChartDataModel.getValue(2, 0).doubleValue());
				assertEquals(8.0, defaultChartDataModel.getValue(2, 1).doubleValue());
				assertEquals(9.0, defaultChartDataModel.getValue(2, 2).doubleValue());
				assertEquals(1.0, defaultChartDataModel.getColumn(0).doubleValue());
				assertEquals(2.0, defaultChartDataModel.getColumn(1).doubleValue());
				assertEquals(3.0, defaultChartDataModel.getColumn(2).doubleValue());
				assertEquals(""dataSet1"", defaultChartDataModel.getDataSetTitle(0));
				assertEquals(""dataSet2"", defaultChartDataModel.getDataSetTitle(1));
				assertEquals(""dataSet3"", defaultChartDataModel.getDataSetTitle(2));
		}
		
		/**
		* Test case for {@link JDBCPlotter#createChartDataModelInstance(String, String, String[])} method.
		* It tests the method with a valid SQL query and valid row titles.
		* The columns are initialized with values from columnRow.
		* @throws JDBCPlotterException if an error occurs while creating a database connection or while performing task.
		*/
		@Test
		void testCreateChartDataModelInstance_3() throws JDBCPlotterException {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:hsql://localhost/xdb"", ""SA"", """");
				String sqlQuery = ""SELECT * FROM test"";
				String columnRow = ""column"";
				String[] sqlRows = {""row1"", ""row2"", ""row3""};
				ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows);
				assertEquals(3, objectChartDataModel.getDataSetCount());
				assertEquals(3, objectChartDataModel.getDataSetSize());
				assertEquals(3, objectChartDataModel.getColumnCount());
				assertEquals(1.0, objectChartDataModel.getValue(0, 0).doubleValue());
				assertEquals(2.0, objectChartDataModel.getValue(0, 1).doubleValue());
				assertEquals(3.0, objectChartDataModel.getValue(0, 2).doubleValue());
				assertEquals(4.0, objectChartDataModel.getValue(1, 0).doubleValue());
				assertEquals(5.0, objectChartDataModel.getValue(1, 1).doubleValue());
				assertEquals(6.0, objectChartDataModel.getValue(1, 2).double"
cmpl-6ttnt5knMAEQHkZu5zLXFXRjdHILy,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotter_3Test.java,40.24988532066345,length,"// JDBCPlotter.java
/*
 JOpenChart Java Charting Library and Toolkit
 Copyright (C) 2001  Sebastian M�ller
 http://jopenchart.sourceforge.net

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 JDBCPlotter.java
 Created on 9. October 2002
 Based on SQLPlotter.java, created on 29. December 2001
 
 */
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;

/**
 * The class is used to convert database queries into ChartDataModels.
 * You can initialize the Plotter with database parameters and afterwards
 * you can run consecutive queries resulting in a new database.
 */
public class JDBCPlotter {

    /**
     * The SQL connection.
     */
    protected Connection conn;

    /**
     * Creates a new JDBCPlotter using the given driver and URL.
     * @param jdbcDriver the fully qualified classname of the SQL driver class.
     * @param jdbcURL the URL of the JDBC database to connect to.
     * @param username the username for the JDBC resource
     * @param password the user's password
     */
    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {
        try {
            Class.forName(jdbcDriver);
            conn = DriverManager.getConnection(jdbcURL, username, password);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while creating a database connection."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            double x = 0.0;
            while (sqlResult.next()) {
                columnList.add(new Double(x));
                x += 1.0;
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(new Double(sqlResult.getDouble(columnRow)));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.
     * The columns are initialized with values from row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.
     * The columns are initialized with values of row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(sqlResult.getString(columnRow));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            String[] columns = (String[]) columnList.toArray(new String[0]);
            return new ObjectChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }
}
","// JDBCPlotter_3Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[], String[])} method.
*/
class JDBCPlotter_3Test {","// JDBCPlotter_3Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[], String[])} method.
*/
class JDBCPlotter_3Test {

	/**
	* Test case for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[], String[])} method.
	* It tests if the method returns a {@link DefaultChartDataModel} with the correct values.
	*/
	@Test
	void testCreateChartDataModelInstance_1() throws Exception {
		JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
		jdbcPlotter.conn.createStatement().execute(""CREATE TABLE test (col1 INTEGER, col2 INTEGER, col3 INTEGER)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (1, 2, 3)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (4, 5, 6)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (7, 8, 9)"");
		DefaultChartDataModel result = jdbcPlotter.createChartDataModelInstance(""SELECT * FROM test"", ""col1"", new String[] { ""col2"", ""col3"" }, new String[] { ""col2"", ""col3"" });
		assertEquals(3, result.getColumnCount());
		assertEquals(2, result.getDataSetCount());
		assertEquals(1.0, result.getValueAt(0, 0).doubleValue());
		assertEquals(2.0, result.getValueAt(0, 1).doubleValue());
		assertEquals(3.0, result.getValueAt(0, 2).doubleValue());
		assertEquals(4.0, result.getValueAt(1, 0).doubleValue());
		assertEquals(5.0, result.getValueAt(1, 1).doubleValue());
		assertEquals(6.0, result.getValueAt(1, 2).doubleValue());
		assertEquals(7.0, result.getValueAt(2, 0).doubleValue());
		assertEquals(8.0, result.getValueAt(2, 1).doubleValue());
		assertEquals(9.0, result.getValueAt(2, 2).doubleValue());
		assertEquals(1.0, result.getColumnAt(0).doubleValue());
		assertEquals(4.0, result.getColumnAt(1).doubleValue());
		assertEquals(7.0, result.getColumnAt(2).doubleValue());
		assertEquals(""col2"", result.getDataSetTitleAt(0));
		assertEquals(""col3"", result.getDataSetTitleAt(1));
	}
	
	/**
	* Test case for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[], String[])} method.
	* It tests if the method returns a {@link DefaultChartDataModel} with the correct values.
	*/
	@Test
	void testCreateChartDataModelInstance_2() throws Exception {
		JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
		jdbcPlotter.conn.createStatement().execute(""CREATE TABLE test (col1 INTEGER, col2 INTEGER, col3 INTEGER)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (1, 2, 3)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (4, 5, 6)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (7, 8, 9)"");
		DefaultChartDataModel result = jdbcPlotter.createChartDataModelInstance(""SELECT * FROM test"", ""col1"", new String[] { ""col2"", ""col3"" }, new String[] { ""col2"", ""col3"" });
		assertEquals(3, result.getColumnCount());
		assertEquals(2, result.getDataSetCount());
		assertEquals(1.0, result.getValueAt(0, 0).doubleValue());
		assertEquals(2.0, result.getValueAt(0, 1).doubleValue());
		assertEquals(3.0, result.getValueAt(0, 2).doubleValue());
		assertEquals(4.0, result.getValueAt(1, 0).doubleValue());
		assertEquals(5.0, result.getValueAt(1, 1).doubleValue());
		assertEquals(6.0, result.getValueAt(1, 2).doubleValue());
		assertEquals(7.0, result.getValueAt(2, 0).doubleValue());
		assertEquals(8.0, result.getValueAt(2, 1).doubleValue());
		assertEquals(9.0, result.getValueAt(2, 2).doubleValue());
		assertEquals(1.0, result.getColumnAt(0).doubleValue());
		assertEquals(4.0, result.getColumnAt(1).doubleValue());
		assertEquals(7.0, result.getColumnAt(2).doubleValue());
		assertEquals(""col2"", result.getDataSetTitleAt(0));
		assertEquals(""col3"", result.getDataSetTitleAt(1));
	}
	
	/**
	* Test case for the {@link JDBCPlotter#createChartDataModelInstance(String, String, String[], String[])} method.
	* It tests if the method returns a {@link DefaultChartDataModel} with the correct values.
	*/
	@Test
	void testCreateChartDataModelInstance_3() throws Exception {
		JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
		jdbcPlotter.conn.createStatement().execute(""CREATE TABLE test (col1 INTEGER, col2 INTEGER, col3 INTEGER)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (1, 2, 3)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (4, 5, 6)"");
		jdbcPlotter.conn.createStatement().execute(""INSERT INTO test VALUES (7, 8, 9)"");
		DefaultChartDataModel result = jdbcPlotter.createChartDataModelInstance(""SELECT * FROM test"", ""col1"", new String[] { ""col2"", ""col3"" }, new String[] { ""col2"", ""col3"" });
		assertEquals(3, result.getColumnCount());
		assertEquals(2, result.getDataSetCount());
		assertEquals(1.0, result.getValueAt(0, 0).doubleValue());
		assertEquals(2.0, result.getValueAt(0, 1).doubleValue());
		assertEquals(3.0, result.getValueAt(0, 2).doubleValue());
		assertEquals(4.0, result.getValueAt(1, 0).doubleValue());
		assertEquals(5.0, result.getValueAt(1, 1).doubleValue());
		assertEquals(6.0, result.getValueAt(1, 2).doubleValue());
		assertEquals(7.0, result.getValueAt(2, 0).doubleValue());
		assertEquals(8.0, result.getValueAt(2, 1).doubleValue());
		assertEquals(9.0, result.getValueAt(2, 2).doubleValue());
		assertEquals(1.0, result.getColumnAt(0).doubleValue());
		assertEquals(4.0, result.getColumnAt(1).doubleValue());
		assertEquals(7.0, result.getColumnAt(2).doubleValue());
		assertEquals(""col2"", result.getData"
cmpl-6ttowIHY8kwUntOkdtEO7QB4wJs3O,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotter_4Test.java,40.67872381210327,length,"// JDBCPlotter.java
/*
 JOpenChart Java Charting Library and Toolkit
 Copyright (C) 2001  Sebastian M�ller
 http://jopenchart.sourceforge.net

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 JDBCPlotter.java
 Created on 9. October 2002
 Based on SQLPlotter.java, created on 29. December 2001
 
 */
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;

/**
 * The class is used to convert database queries into ChartDataModels.
 * You can initialize the Plotter with database parameters and afterwards
 * you can run consecutive queries resulting in a new database.
 */
public class JDBCPlotter {

    /**
     * The SQL connection.
     */
    protected Connection conn;

    /**
     * Creates a new JDBCPlotter using the given driver and URL.
     * @param jdbcDriver the fully qualified classname of the SQL driver class.
     * @param jdbcURL the URL of the JDBC database to connect to.
     * @param username the username for the JDBC resource
     * @param password the user's password
     */
    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {
        try {
            Class.forName(jdbcDriver);
            conn = DriverManager.getConnection(jdbcURL, username, password);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while creating a database connection."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            double x = 0.0;
            while (sqlResult.next()) {
                columnList.add(new Double(x));
                x += 1.0;
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(new Double(sqlResult.getDouble(columnRow)));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.
     * The columns are initialized with values from row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.
     * The columns are initialized with values of row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(sqlResult.getString(columnRow));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            String[] columns = (String[]) columnList.toArray(new String[0]);
            return new ObjectChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }
}
","// JDBCPlotter_4Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
*/
class JDBCPlotter_4Test {","// JDBCPlotter_4Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
*/
class JDBCPlotter_4Test {

		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object.
		*/
		@Test
		void testCreateObjectChartDataModelInstance() {
				try {
						JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
						ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[]{""value""});
						assertTrue(objectChartDataModel instanceof ObjectChartDataModel);
				} catch (JDBCPlotterException e) {
						fail(""Exception while creating a database connection."");
				}
		}
		
		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object with the correct number of rows.
		*/
		@Test
		void testCreateObjectChartDataModelInstance_2() {
				try {
						JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
						ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[]{""value""});
						assertEquals(objectChartDataModel.getRowCount(), 3);
				} catch (JDBCPlotterException e) {
						fail(""Exception while creating a database connection."");
				}
		}
		
		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object with the correct number of columns.
		*/
		@Test
		void testCreateObjectChartDataModelInstance_3() {
				try {
						JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
						ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[]{""value""});
						assertEquals(objectChartDataModel.getColumnCount(), 1);
				} catch (JDBCPlotterException e) {
						fail(""Exception while creating a database connection."");
				}
		}
		
		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object with the correct column values.
		*/
		@Test
		void testCreateObjectChartDataModelInstance_4() {
				try {
						JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
						ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[]{""value""});
						assertEquals(objectChartDataModel.getColumn(0), new String[]{""a"", ""b"", ""c""});
				} catch (JDBCPlotterException e) {
						fail(""Exception while creating a database connection."");
				}
		}
		
		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object with the correct row values.
		*/
		@Test
		void testCreateObjectChartDataModelInstance_5() {
				try {
						JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
						ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[]{""value""});
						assertEquals(objectChartDataModel.getRow(0), new Double[]{1.0});
						assertEquals(objectChartDataModel.getRow(1), new Double[]{2.0});
						assertEquals(objectChartDataModel.getRow(2), new Double[]{3.0});
				} catch (JDBCPlotterException e) {
						fail(""Exception while creating a database connection."");
				}
		}
		
		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object with the correct data set titles.
		*/
		@Test
		void testCreateObjectChartDataModelInstance_6() {
				try {
						JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
						ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[]{""value""}, new String[]{""test""});
						assertEquals(objectChartDataModel.getDataSetTitle(0), ""test"");
				} catch (JDBCPlotterException e) {
						fail(""Exception while creating a database connection."");
				}
		}
		
		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object with the correct data set titles.
		*/
		@Test
		void testCreateObjectChartDataModelInstance_7() {
				try {
						JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
						ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[]{""value""}, new String[]{""test""});
						assertEquals(objectChartDataModel.getDataSetTitle(0), ""test"");
				} catch (JDBCPlotterException e) {
						fail(""Exception while creating a database connection."");
				}
		}
		
		/**
		* Test case for {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} object with the correct data set titles.
		*/
		@Test
		void testCreateObjectChartDataModelInstance_8() {"
cmpl-6ttpzAo2p1r24WXBtLmZFtyuqK3S5,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/JDBCPlotter_5Test.java,46.60647940635681,length,"// JDBCPlotter.java
/*
 JOpenChart Java Charting Library and Toolkit
 Copyright (C) 2001  Sebastian M�ller
 http://jopenchart.sourceforge.net

 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.

 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.

 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

 JDBCPlotter.java
 Created on 9. October 2002
 Based on SQLPlotter.java, created on 29. December 2001
 
 */
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;

/**
 * The class is used to convert database queries into ChartDataModels.
 * You can initialize the Plotter with database parameters and afterwards
 * you can run consecutive queries resulting in a new database.
 */
public class JDBCPlotter {

    /**
     * The SQL connection.
     */
    protected Connection conn;

    /**
     * Creates a new JDBCPlotter using the given driver and URL.
     * @param jdbcDriver the fully qualified classname of the SQL driver class.
     * @param jdbcURL the URL of the JDBC database to connect to.
     * @param username the username for the JDBC resource
     * @param password the user's password
     */
    public JDBCPlotter(String jdbcDriver, String jdbcURL, String username, String password) throws JDBCPlotterException {
        try {
            Class.forName(jdbcDriver);
            conn = DriverManager.getConnection(jdbcURL, username, password);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while creating a database connection."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values starting from 0.
     * @param sqlQuery the SQL query to be performed
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            double x = 0.0;
            while (sqlResult.next()) {
                columnList.add(new Double(x));
                x += 1.0;
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates a DefaultChartDataModel.
     * The columns are initialized with values from columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public DefaultChartDataModel createChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(new Double(sqlResult.getDouble(columnRow)));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            double[] columns = new double[columnList.size()];
            for (int i = 0; i < columns.length; i++) columns[i] = ((Double) columnList.get(i)).doubleValue();
            return new DefaultChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }

    /**
     * Given a SQL query and the row titles this method creates a ObjectChartDataModel.
     * The columns are initialized with values from row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel and which
     * will be used as the DataSet titles.
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows) throws JDBCPlotterException {
        return createObjectChartDataModelInstance(sqlQuery, columnRow, sqlRows, sqlRows);
    }

    /**
     * Given a SQL query and the row titles this method creates an ObjectChartDataModel.
     * The columns are initialized with values of row columnRow.
     * @param sqlQuery the SQL query to be performed
     * @param columnRow the row from the ResultSet which should be taken as the column (x-axis) values
     * @param sqlRows the rows from the ResultSet which should be included in the ChartDataModel
     * @param dataSets the DataSet titles which should be given to the ChartDataModel instead of the sqlRows titles
     */
    public ObjectChartDataModel createObjectChartDataModelInstance(String sqlQuery, String columnRow, String[] sqlRows, String[] dataSets) throws JDBCPlotterException {
        try {
            Statement stmt = conn.createStatement();
            ResultSet sqlResult = stmt.executeQuery(sqlQuery);
            ArrayList[] model = new ArrayList[sqlRows.length];
            ArrayList columnList = new ArrayList();
            for (int i = 0; i < model.length; i++) {
                model[i] = new ArrayList();
            }
            while (sqlResult.next()) {
                columnList.add(sqlResult.getString(columnRow));
                for (int i = 0; i < sqlRows.length; i++) {
                    model[i].add(new Double(sqlResult.getDouble(sqlRows[i])));
                }
            }
            Number[][] modelArray = new Number[model.length][];
            for (int i = 0; i < model.length; i++) modelArray[i] = (Number[]) model[i].toArray(new Number[0]);
            String[] columns = (String[]) columnList.toArray(new String[0]);
            return new ObjectChartDataModel(modelArray, columns, dataSets);
        } catch (Exception e) {
            throw new JDBCPlotterException(""Exception while performing task."", e);
        }
    }
}
","// JDBCPlotter_5Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[], String[])} method.
*/
class JDBCPlotter_5Test {","// JDBCPlotter_5Test.java
package de.progra.charting.model;

import java.sql.*;
import java.util.ArrayList;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JDBCPlotter}.
* It contains ten unit test cases for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[], String[])} method.
*/
class JDBCPlotter_5Test {

		/**
		* Test case for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[], String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} with the correct values.
		*/
		@Test
		void testCreateObjectChartDataModelInstance() throws Exception {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
				Statement stmt = jdbcPlotter.conn.createStatement();
				stmt.execute(""CREATE TABLE test (id INTEGER, name VARCHAR(20), value DOUBLE)"");
				stmt.execute(""INSERT INTO test VALUES (1, 'one', 1.0)"");
				stmt.execute(""INSERT INTO test VALUES (2, 'two', 2.0)"");
				stmt.execute(""INSERT INTO test VALUES (3, 'three', 3.0)"");
				stmt.execute(""INSERT INTO test VALUES (4, 'four', 4.0)"");
				stmt.execute(""INSERT INTO test VALUES (5, 'five', 5.0)"");
				stmt.execute(""INSERT INTO test VALUES (6, 'six', 6.0)"");
				stmt.execute(""INSERT INTO test VALUES (7, 'seven', 7.0)"");
				stmt.execute(""INSERT INTO test VALUES (8, 'eight', 8.0)"");
				stmt.execute(""INSERT INTO test VALUES (9, 'nine', 9.0)"");
				stmt.execute(""INSERT INTO test VALUES (10, 'ten', 10.0)"");
				ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[] { ""value"" }, new String[] { ""value"" });
				assertEquals(1.0, objectChartDataModel.getValueAt(0, 0));
				assertEquals(2.0, objectChartDataModel.getValueAt(1, 0));
				assertEquals(3.0, objectChartDataModel.getValueAt(2, 0));
				assertEquals(4.0, objectChartDataModel.getValueAt(3, 0));
				assertEquals(5.0, objectChartDataModel.getValueAt(4, 0));
				assertEquals(6.0, objectChartDataModel.getValueAt(5, 0));
				assertEquals(7.0, objectChartDataModel.getValueAt(6, 0));
				assertEquals(8.0, objectChartDataModel.getValueAt(7, 0));
				assertEquals(9.0, objectChartDataModel.getValueAt(8, 0));
				assertEquals(10.0, objectChartDataModel.getValueAt(9, 0));
				assertEquals(""one"", objectChartDataModel.getColumnKey(0));
				assertEquals(""two"", objectChartDataModel.getColumnKey(1));
				assertEquals(""three"", objectChartDataModel.getColumnKey(2));
				assertEquals(""four"", objectChartDataModel.getColumnKey(3));
				assertEquals(""five"", objectChartDataModel.getColumnKey(4));
				assertEquals(""six"", objectChartDataModel.getColumnKey(5));
				assertEquals(""seven"", objectChartDataModel.getColumnKey(6));
				assertEquals(""eight"", objectChartDataModel.getColumnKey(7));
				assertEquals(""nine"", objectChartDataModel.getColumnKey(8));
				assertEquals(""ten"", objectChartDataModel.getColumnKey(9));
				assertEquals(""value"", objectChartDataModel.getDataSetKey(0));
				assertEquals(1, objectChartDataModel.getDataSetCount());
				assertEquals(10, objectChartDataModel.getColumnCount());
				assertEquals(1, objectChartDataModel.getRowCount());
		}
		
		/**
		* Test case for the {@link JDBCPlotter#createObjectChartDataModelInstance(String, String, String[], String[])} method.
		* It tests if the method returns a {@link ObjectChartDataModel} with the correct values.
		*/
		@Test
		void testCreateObjectChartDataModelInstance2() throws Exception {
				JDBCPlotter jdbcPlotter = new JDBCPlotter(""org.hsqldb.jdbcDriver"", ""jdbc:hsqldb:mem:aname"", ""sa"", """");
				Statement stmt = jdbcPlotter.conn.createStatement();
				stmt.execute(""CREATE TABLE test (id INTEGER, name VARCHAR(20), value DOUBLE)"");
				stmt.execute(""INSERT INTO test VALUES (1, 'one', 1.0)"");
				stmt.execute(""INSERT INTO test VALUES (2, 'two', 2.0)"");
				stmt.execute(""INSERT INTO test VALUES (3, 'three', 3.0)"");
				stmt.execute(""INSERT INTO test VALUES (4, 'four', 4.0)"");
				stmt.execute(""INSERT INTO test VALUES (5, 'five', 5.0)"");
				stmt.execute(""INSERT INTO test VALUES (6, 'six', 6.0)"");
				stmt.execute(""INSERT INTO test VALUES (7, 'seven', 7.0)"");
				stmt.execute(""INSERT INTO test VALUES (8, 'eight', 8.0)"");
				stmt.execute(""INSERT INTO test VALUES (9, 'nine', 9.0)"");
				stmt.execute(""INSERT INTO test VALUES (10, 'ten', 10.0)"");
				ObjectChartDataModel objectChartDataModel = jdbcPlotter.createObjectChartDataModelInstance(""SELECT * FROM test"", ""name"", new String[] { ""value"" }, new String[] { ""value"" });
				assertEquals(1.0, objectChartDataModel.getValueAt(0, 0));
				assertEquals(2.0, objectChartDataModel.getValueAt(1, 0));
				assertEquals(3.0, objectChartDataModel.getValueAt(2, 0));
				assertEquals(4.0, objectChartDataModel.getValueAt(3, 0));
				assertEquals(5.0, objectChartDataModel.getValueAt(4, 0));
				assertEquals(6.0, objectChartDataModel.getValueAt(5, 0));
				assertEquals(7.0, objectChartDataModel.getValueAt(6, 0));
				assertEquals(8.0, objectChartDataModel.getValueAt(7, 0));
				assertEquals(9.0, objectChartDataModel.getValueAt(8, 0));
				assertEquals(10.0, objectChartDataModel.getValueAt(9, 0));
				assertEquals(""one"", objectChartDataModel.getColumnKey(0));
				assertEquals(""two"", objectChartDataModel.getColumnKey(1));
				assertEquals(""three"", objectChartDataModel.getColumnKey(2));
				assertEquals(""four"", objectChartDataModel.getColumnKey(3));
				assertEquals(""five"", objectChartDataModel.getColumnKey(4));
				assertEquals(""six"", objectChartDataModel.getColumnKey(5));
				assert"
cmpl-6ttr2SmnmIb4GEKD57W8lenqTP5cJ,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/ObjectChartDataModel_0Test.java,44.76329565048218,length,"// ObjectChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ObjectColumnChartDataModel.java
    Created on 7. August 2001, 17:27
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * The ObjectChartDataModel implements a ChartDataModel for Charts,
 * which have e.g. String values on the x-axis. This is especially useful
 * for Barcharts and also for Piecharts, although those don't exactly have
 * an x-axis.
 * @author  mueller
 * @version 1.0
 */
public class ObjectChartDataModel extends AbstractChartDataModel {

    /**
     * The x-axis values.
     */
    protected Object[] columns;

    /**
     * The data values.
     */
    protected DataSet[] data;

    /**
     * A HashMap containing the ordered data per axis.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     * Initializes all Objects and Arrays as empty ones.
     */
    public ObjectChartDataModel() {
        data = new DefaultDataSet[0];
        columns = new Object[0];
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS, false);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS, false);
    }

    /**
     * Creates new ObjectChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(Number[][] data, Object[] columns, String[] rows) {
        this();
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(data[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates new ObjectChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(int[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     *  Creates new ObjectChartDataModel.
     *  @param data the array of values. The first index specifies the
     *  datasets, the last one is the value index.
     *  @param columns the array of x-axis values. The length of the
     *  datasets and the length of the column should be equal and
     *  the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(double[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates a new ObjectChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets. Internally, the DataSets
     * are transformed into equally sized DataSets, where the missing data fields
     * are filled with Double.NaN.
     * @param ds the array of DataSets to be used.
     * @param columns the array of column values. This needs to be supplied,
     * because using Objects as x-axis values you need to have an ordered
     * superset of all column values especially if different DataSets only
     * contain some column values
     */
    public ObjectChartDataModel(DataSet[] ds, Object[] columns) {
        this();
        data = ds;
        this.columns = columns;
        TreeSet set;
        HashMap map = new HashMap();
        for (int i = 0; i < ds.length; i++) {
            map.clear();
            Number[] numdata = new Number[columns.length];
            for (int j = 0; j < columns.length; j++) map.put(columns[j], new Double(Double.NaN));
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                map.put(ds[i].getColumnValueAt(j), ds[i].getValueAt(j));
                set.add(ds[i].getValueAt(j));
            }
            for (int j = 0; j < columns.length; j++) {
                numdata[j] = (Number) map.get(columns[j]);
            }
            data[i] = new DefaultDataSet(numdata, columns, CoordSystem.FIRST_YAXIS, ds[i].getTitle());
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet index
     * @return the DataSet length
     */
    public int getDataSetLength(int set) {
        return data[set].getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSet
     */
    public int getDataSetNumber() {
        return data.length;
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return data[set].getTitle();
    }

    /**
     * Returns the axis to which a DataSet is attached
     * @param set the DataSet index
     * @return the axis constant
     */
    public int getAxisBinding(int set) {
        return data[set].getYAxis();
    }

    /**
     * Returns the Value in a specific dataset at a certain index.
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value
     */
    public Number getValueAt(int set, int index) {
        return (Number) data[set].getValueAt(index);
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant
     * @return the ChartDataModelConstraints for the defined y-axis
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int col) {
        if (col < columns.length)
            return columns[col];
        else
            return null;
    }

    /**
     * Calls getColumnValueAt(int col).
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int set, int col) {
        return getColumnValueAt(col);
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the minimum column value.
     * @return Returns 0.0.
     */
    protected double getFirstColumnValue() {
        return 0.0;
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the maximum column value.
     * @return Returns <code>columns.length</code>.
     */
    protected double getLastColumnValue() {
        return Math.max((double) columns.length, 1.0);
    }
}
","// ObjectChartDataModel_0Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getDataSetLength(int)} method.
*/
class ObjectChartDataModel_0Test {","// ObjectChartDataModel_0Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getDataSetLength(int)} method.
*/
class ObjectChartDataModel_0Test {

		@Test
		public void testCase0() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase1() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase2() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase3() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase4() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase5() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase6() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase7() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase8() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase9() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetLength(0);
				assertEquals(0, int0);
		}
}

// ObjectChartDataModel_1Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getDataSetNumber()} method.
*/
class ObjectChartDataModel_1Test {
		
		@Test
		public void testCase0() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase1() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase2() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase3() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase4() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase5() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase6() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase7() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase8() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
		
		@Test
		public void testCase9() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				int int0 = objectChartDataModel0.getDataSetNumber();
				assertEquals(0, int0);
		}
}

// ObjectChartDataModel_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getDataSetName(int)} method.
*/
class ObjectChartDataModel_2Test {
		
		@Test
		public void testCase0() {
				ObjectChartDataModel objectChartDataModel0 = new ObjectChartDataModel();
				String string0 = objectChartDataModel0.getDataSetName(0);
				assertEquals(""0"", string0);
		}
		
		@Test
		public void testCase1() {
				ObjectChartDataModel objectChart"
cmpl-6tts5zFssJq0iWkQtHSn3pAfOJqVI,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/ObjectChartDataModel_1Test.java,44.40827703475952,length,"// ObjectChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ObjectColumnChartDataModel.java
    Created on 7. August 2001, 17:27
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * The ObjectChartDataModel implements a ChartDataModel for Charts,
 * which have e.g. String values on the x-axis. This is especially useful
 * for Barcharts and also for Piecharts, although those don't exactly have
 * an x-axis.
 * @author  mueller
 * @version 1.0
 */
public class ObjectChartDataModel extends AbstractChartDataModel {

    /**
     * The x-axis values.
     */
    protected Object[] columns;

    /**
     * The data values.
     */
    protected DataSet[] data;

    /**
     * A HashMap containing the ordered data per axis.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     * Initializes all Objects and Arrays as empty ones.
     */
    public ObjectChartDataModel() {
        data = new DefaultDataSet[0];
        columns = new Object[0];
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS, false);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS, false);
    }

    /**
     * Creates new ObjectChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(Number[][] data, Object[] columns, String[] rows) {
        this();
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(data[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates new ObjectChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(int[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     *  Creates new ObjectChartDataModel.
     *  @param data the array of values. The first index specifies the
     *  datasets, the last one is the value index.
     *  @param columns the array of x-axis values. The length of the
     *  datasets and the length of the column should be equal and
     *  the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(double[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates a new ObjectChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets. Internally, the DataSets
     * are transformed into equally sized DataSets, where the missing data fields
     * are filled with Double.NaN.
     * @param ds the array of DataSets to be used.
     * @param columns the array of column values. This needs to be supplied,
     * because using Objects as x-axis values you need to have an ordered
     * superset of all column values especially if different DataSets only
     * contain some column values
     */
    public ObjectChartDataModel(DataSet[] ds, Object[] columns) {
        this();
        data = ds;
        this.columns = columns;
        TreeSet set;
        HashMap map = new HashMap();
        for (int i = 0; i < ds.length; i++) {
            map.clear();
            Number[] numdata = new Number[columns.length];
            for (int j = 0; j < columns.length; j++) map.put(columns[j], new Double(Double.NaN));
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                map.put(ds[i].getColumnValueAt(j), ds[i].getValueAt(j));
                set.add(ds[i].getValueAt(j));
            }
            for (int j = 0; j < columns.length; j++) {
                numdata[j] = (Number) map.get(columns[j]);
            }
            data[i] = new DefaultDataSet(numdata, columns, CoordSystem.FIRST_YAXIS, ds[i].getTitle());
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet index
     * @return the DataSet length
     */
    public int getDataSetLength(int set) {
        return data[set].getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSet
     */
    public int getDataSetNumber() {
        return data.length;
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return data[set].getTitle();
    }

    /**
     * Returns the axis to which a DataSet is attached
     * @param set the DataSet index
     * @return the axis constant
     */
    public int getAxisBinding(int set) {
        return data[set].getYAxis();
    }

    /**
     * Returns the Value in a specific dataset at a certain index.
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value
     */
    public Number getValueAt(int set, int index) {
        return (Number) data[set].getValueAt(index);
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant
     * @return the ChartDataModelConstraints for the defined y-axis
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int col) {
        if (col < columns.length)
            return columns[col];
        else
            return null;
    }

    /**
     * Calls getColumnValueAt(int col).
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int set, int col) {
        return getColumnValueAt(col);
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the minimum column value.
     * @return Returns 0.0.
     */
    protected double getFirstColumnValue() {
        return 0.0;
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the maximum column value.
     * @return Returns <code>columns.length</code>.
     */
    protected double getLastColumnValue() {
        return Math.max((double) columns.length, 1.0);
    }
}
","// ObjectChartDataModel_1Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getDataSetName(int)} method.
*/
class ObjectChartDataModel_1Test {","// ObjectChartDataModel_1Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getDataSetName(int)} method.
*/
class ObjectChartDataModel_1Test {

	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_1() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(0);
		assertEquals(""0"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_2() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(1);
		assertEquals(""1"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_3() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(2);
		assertEquals(""2"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_4() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(3);
		assertEquals(""3"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_5() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(4);
		assertEquals(""4"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_6() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(5);
		assertEquals(""5"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_7() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(6);
		assertEquals(""6"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_8() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(7);
		assertEquals(""7"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_9() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(8);
		assertEquals(""8"", result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getDataSetName(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetDataSetName_10() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		String result = objectChartDataModel.getDataSetName(9);
		assertEquals(""9"", result);
	}
	
}

// ObjectChartDataModel_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
*/
class ObjectChartDataModel_2Test {
		
	/**
	* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_1() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		int result = objectChartDataModel.getAxisBinding(0);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_2() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		int result = objectChartDataModel.getAxisBinding(1);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_3() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		int result = objectChartDataModel.getAxisBinding(2);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_4() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		int result = objectChartDataModel.getAxisBinding(3);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_5() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		int result = objectChartDataModel.getAxisBinding(4);
		assertEquals(CoordSystem.FIRST_YAXIS, result);
	}
	
	/**
	* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
	* The test case tests if the method returns the correct value.
	*/
	@Test
	void testGetAxisBinding_6() {
		ObjectChartDataModel objectChartData"
cmpl-6ttt8XzlkRng8Jmuh4PGxk8h8fsP7,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/ObjectChartDataModel_2Test.java,88.56505155563354,length,"// ObjectChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ObjectColumnChartDataModel.java
    Created on 7. August 2001, 17:27
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * The ObjectChartDataModel implements a ChartDataModel for Charts,
 * which have e.g. String values on the x-axis. This is especially useful
 * for Barcharts and also for Piecharts, although those don't exactly have
 * an x-axis.
 * @author  mueller
 * @version 1.0
 */
public class ObjectChartDataModel extends AbstractChartDataModel {

    /**
     * The x-axis values.
     */
    protected Object[] columns;

    /**
     * The data values.
     */
    protected DataSet[] data;

    /**
     * A HashMap containing the ordered data per axis.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     * Initializes all Objects and Arrays as empty ones.
     */
    public ObjectChartDataModel() {
        data = new DefaultDataSet[0];
        columns = new Object[0];
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS, false);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS, false);
    }

    /**
     * Creates new ObjectChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(Number[][] data, Object[] columns, String[] rows) {
        this();
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(data[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates new ObjectChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(int[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     *  Creates new ObjectChartDataModel.
     *  @param data the array of values. The first index specifies the
     *  datasets, the last one is the value index.
     *  @param columns the array of x-axis values. The length of the
     *  datasets and the length of the column should be equal and
     *  the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(double[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates a new ObjectChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets. Internally, the DataSets
     * are transformed into equally sized DataSets, where the missing data fields
     * are filled with Double.NaN.
     * @param ds the array of DataSets to be used.
     * @param columns the array of column values. This needs to be supplied,
     * because using Objects as x-axis values you need to have an ordered
     * superset of all column values especially if different DataSets only
     * contain some column values
     */
    public ObjectChartDataModel(DataSet[] ds, Object[] columns) {
        this();
        data = ds;
        this.columns = columns;
        TreeSet set;
        HashMap map = new HashMap();
        for (int i = 0; i < ds.length; i++) {
            map.clear();
            Number[] numdata = new Number[columns.length];
            for (int j = 0; j < columns.length; j++) map.put(columns[j], new Double(Double.NaN));
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                map.put(ds[i].getColumnValueAt(j), ds[i].getValueAt(j));
                set.add(ds[i].getValueAt(j));
            }
            for (int j = 0; j < columns.length; j++) {
                numdata[j] = (Number) map.get(columns[j]);
            }
            data[i] = new DefaultDataSet(numdata, columns, CoordSystem.FIRST_YAXIS, ds[i].getTitle());
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet index
     * @return the DataSet length
     */
    public int getDataSetLength(int set) {
        return data[set].getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSet
     */
    public int getDataSetNumber() {
        return data.length;
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return data[set].getTitle();
    }

    /**
     * Returns the axis to which a DataSet is attached
     * @param set the DataSet index
     * @return the axis constant
     */
    public int getAxisBinding(int set) {
        return data[set].getYAxis();
    }

    /**
     * Returns the Value in a specific dataset at a certain index.
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value
     */
    public Number getValueAt(int set, int index) {
        return (Number) data[set].getValueAt(index);
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant
     * @return the ChartDataModelConstraints for the defined y-axis
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int col) {
        if (col < columns.length)
            return columns[col];
        else
            return null;
    }

    /**
     * Calls getColumnValueAt(int col).
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int set, int col) {
        return getColumnValueAt(col);
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the minimum column value.
     * @return Returns 0.0.
     */
    protected double getFirstColumnValue() {
        return 0.0;
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the maximum column value.
     * @return Returns <code>columns.length</code>.
     */
    protected double getLastColumnValue() {
        return Math.max((double) columns.length, 1.0);
    }
}
","// ObjectChartDataModel_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
*/
class ObjectChartDataModel_2Test {","// ObjectChartDataModel_2Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
*/
class ObjectChartDataModel_2Test {

		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 0</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_1() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 0;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 1</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_2() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 1;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 2</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_3() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 2;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 3</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_4() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 3;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 4</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_5() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 4;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 5</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_6() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 5;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 6</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_7() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 6;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 7</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_8() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 7;
				int result = objectChartDataModel.getAxisBinding(set);
				assertEquals(CoordSystem.FIRST_YAXIS, result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getAxisBinding(int)} method.
		* The test case tests the method with the following parameter:
		* <ul>
		* <li>set = 8</li>
		* </ul>
		* The expected result is that the method returns the following value:
		* <ul>
		* <li>CoordSystem.FIRST_YAXIS</li>
		* </ul>
		*/
		@Test
		void testGetAxisBinding_9() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				int set = 8;
				int result = objectChartDataModel.getAxisBinding(set);
			"
cmpl-6ttuZLlYxEMM449CcVkW5qVY3r2O7,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/ObjectChartDataModel_3Test.java,74.95256972312927,length,"// ObjectChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ObjectColumnChartDataModel.java
    Created on 7. August 2001, 17:27
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * The ObjectChartDataModel implements a ChartDataModel for Charts,
 * which have e.g. String values on the x-axis. This is especially useful
 * for Barcharts and also for Piecharts, although those don't exactly have
 * an x-axis.
 * @author  mueller
 * @version 1.0
 */
public class ObjectChartDataModel extends AbstractChartDataModel {

    /**
     * The x-axis values.
     */
    protected Object[] columns;

    /**
     * The data values.
     */
    protected DataSet[] data;

    /**
     * A HashMap containing the ordered data per axis.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     * Initializes all Objects and Arrays as empty ones.
     */
    public ObjectChartDataModel() {
        data = new DefaultDataSet[0];
        columns = new Object[0];
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS, false);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS, false);
    }

    /**
     * Creates new ObjectChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(Number[][] data, Object[] columns, String[] rows) {
        this();
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(data[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates new ObjectChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(int[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     *  Creates new ObjectChartDataModel.
     *  @param data the array of values. The first index specifies the
     *  datasets, the last one is the value index.
     *  @param columns the array of x-axis values. The length of the
     *  datasets and the length of the column should be equal and
     *  the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(double[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates a new ObjectChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets. Internally, the DataSets
     * are transformed into equally sized DataSets, where the missing data fields
     * are filled with Double.NaN.
     * @param ds the array of DataSets to be used.
     * @param columns the array of column values. This needs to be supplied,
     * because using Objects as x-axis values you need to have an ordered
     * superset of all column values especially if different DataSets only
     * contain some column values
     */
    public ObjectChartDataModel(DataSet[] ds, Object[] columns) {
        this();
        data = ds;
        this.columns = columns;
        TreeSet set;
        HashMap map = new HashMap();
        for (int i = 0; i < ds.length; i++) {
            map.clear();
            Number[] numdata = new Number[columns.length];
            for (int j = 0; j < columns.length; j++) map.put(columns[j], new Double(Double.NaN));
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                map.put(ds[i].getColumnValueAt(j), ds[i].getValueAt(j));
                set.add(ds[i].getValueAt(j));
            }
            for (int j = 0; j < columns.length; j++) {
                numdata[j] = (Number) map.get(columns[j]);
            }
            data[i] = new DefaultDataSet(numdata, columns, CoordSystem.FIRST_YAXIS, ds[i].getTitle());
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet index
     * @return the DataSet length
     */
    public int getDataSetLength(int set) {
        return data[set].getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSet
     */
    public int getDataSetNumber() {
        return data.length;
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return data[set].getTitle();
    }

    /**
     * Returns the axis to which a DataSet is attached
     * @param set the DataSet index
     * @return the axis constant
     */
    public int getAxisBinding(int set) {
        return data[set].getYAxis();
    }

    /**
     * Returns the Value in a specific dataset at a certain index.
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value
     */
    public Number getValueAt(int set, int index) {
        return (Number) data[set].getValueAt(index);
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant
     * @return the ChartDataModelConstraints for the defined y-axis
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int col) {
        if (col < columns.length)
            return columns[col];
        else
            return null;
    }

    /**
     * Calls getColumnValueAt(int col).
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int set, int col) {
        return getColumnValueAt(col);
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the minimum column value.
     * @return Returns 0.0.
     */
    protected double getFirstColumnValue() {
        return 0.0;
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the maximum column value.
     * @return Returns <code>columns.length</code>.
     */
    protected double getLastColumnValue() {
        return Math.max((double) columns.length, 1.0);
    }
}
","// ObjectChartDataModel_3Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getValueAt(int, int)} method.
*/
class ObjectChartDataModel_3Test {","// ObjectChartDataModel_3Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getValueAt(int, int)} method.
*/
class ObjectChartDataModel_3Test {

		/**
		* Test case for {@link ObjectChartDataModel#getValueAt(int, int)} method.
		* Test case for the following input values:
		* <ul>
		* <li>set = 0</li>
		* <li>index = 0</li>
		* </ul>
		*
		* @throws Exception
		* 				if an error occurred
		*/
		@Test
		void testGetValueAt_1() throws Exception {
				ObjectChartDataModel fixture = new ObjectChartDataModel();
				fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS, false));
				fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS, false));
				int set = 0;
				int index = 0;
				Number result = fixture.getValueAt(set, index);
				assertEquals(null, result);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getValueAt(int, int)} method.
		* Test case for the following input values:
		* <ul>
		* <li>set = 0</li>
		* <li>index = 1</li>
		* </ul>
		*
		* @throws Exception
		* 				if an error occurred
		*/
		@Test
		void testGetValueAt_2() throws Exception {
				ObjectChartDataModel fixture = new ObjectChartDataModel();
				fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS, false));
				fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS, false));
				int set = 0;
				int index = 1;
				Number result = fixture.getValueAt(set, index);
				assertEquals(null, result);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getValueAt(int, int)} method.
		* Test case for the following input values:
		* <ul>
		* <li>set = 0</li>
		* <li>index = 2</li>
		* </ul>
		*
		* @throws Exception
		* 				if an error occurred
		*/
		@Test
		void testGetValueAt_3() throws Exception {
				ObjectChartDataModel fixture = new ObjectChartDataModel();
				fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS, false));
				fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS, false));
				int set = 0;
				int index = 2;
				Number result = fixture.getValueAt(set, index);
				assertEquals(null, result);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getValueAt(int, int)} method.
		* Test case for the following input values:
		* <ul>
		* <li>set = 0</li>
		* <li>index = 3</li>
		* </ul>
		*
		* @throws Exception
		* 				if an error occurred
		*/
		@Test
		void testGetValueAt_4() throws Exception {
				ObjectChartDataModel fixture = new ObjectChartDataModel();
				fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS, false));
				fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS, false));
				int set = 0;
				int index = 3;
				Number result = fixture.getValueAt(set, index);
				assertEquals(null, result);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getValueAt(int, int)} method.
		* Test case for the following input values:
		* <ul>
		* <li>set = 0</li>
		* <li>index = 4</li>
		* </ul>
		*
		* @throws Exception
		* 				if an error occurred
		*/
		@Test
		void testGetValueAt_5() throws Exception {
				ObjectChartDataModel fixture = new ObjectChartDataModel();
				fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS, false));
				fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS, false));
				int set = 0;
				int index = 4;
				Number result = fixture.getValueAt(set, index);
				assertEquals(null, result);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getValueAt(int, int)} method.
		* Test case for the following input values:
		* <ul>
		* <li>set = 0</li>
		* <li>index = 5</li>
		* </ul>
		*
		* @throws Exception
		* 				if an error occurred
		*/
		@Test
		void testGetValueAt_6() throws Exception {
				ObjectChartDataModel fixture = new ObjectChartDataModel();
				fixture.setChartDataModelConstraints(CoordSystem.FIRST_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.FIRST_YAXIS, false));
				fixture.setChartDataModelConstraints(CoordSystem.SECOND_YAXIS, new DefaultChartDataModelConstraints(fixture, CoordSystem.SECOND_YAXIS, false));
				int set = 0;
				int index = 5;
				Number result = fixture.getValueAt(set, index);
				assertEquals(null, result);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getValueAt(int, int)} method.
		* Test case for the following input values:
		* <ul>
		* <li>set = 0</li>
		* <li>index = 6</li>
		* </ul>
		*
		* @throws Exception
		* 				if an error occurred
		*/
		@Test
		void testGetValueAt_7() throws Exception {
				ObjectChartDataModel fixture = new ObjectChartDataModel();
				fixture.setChartDataModelConstraints(Coord"
cmpl-6ttvmZ5PyQ4Wst45LeKEwXeJuC3I0,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/ObjectChartDataModel_4Test.java,90.53765082359314,length,"// ObjectChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ObjectColumnChartDataModel.java
    Created on 7. August 2001, 17:27
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * The ObjectChartDataModel implements a ChartDataModel for Charts,
 * which have e.g. String values on the x-axis. This is especially useful
 * for Barcharts and also for Piecharts, although those don't exactly have
 * an x-axis.
 * @author  mueller
 * @version 1.0
 */
public class ObjectChartDataModel extends AbstractChartDataModel {

    /**
     * The x-axis values.
     */
    protected Object[] columns;

    /**
     * The data values.
     */
    protected DataSet[] data;

    /**
     * A HashMap containing the ordered data per axis.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     * Initializes all Objects and Arrays as empty ones.
     */
    public ObjectChartDataModel() {
        data = new DefaultDataSet[0];
        columns = new Object[0];
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS, false);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS, false);
    }

    /**
     * Creates new ObjectChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(Number[][] data, Object[] columns, String[] rows) {
        this();
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(data[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates new ObjectChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(int[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     *  Creates new ObjectChartDataModel.
     *  @param data the array of values. The first index specifies the
     *  datasets, the last one is the value index.
     *  @param columns the array of x-axis values. The length of the
     *  datasets and the length of the column should be equal and
     *  the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(double[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates a new ObjectChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets. Internally, the DataSets
     * are transformed into equally sized DataSets, where the missing data fields
     * are filled with Double.NaN.
     * @param ds the array of DataSets to be used.
     * @param columns the array of column values. This needs to be supplied,
     * because using Objects as x-axis values you need to have an ordered
     * superset of all column values especially if different DataSets only
     * contain some column values
     */
    public ObjectChartDataModel(DataSet[] ds, Object[] columns) {
        this();
        data = ds;
        this.columns = columns;
        TreeSet set;
        HashMap map = new HashMap();
        for (int i = 0; i < ds.length; i++) {
            map.clear();
            Number[] numdata = new Number[columns.length];
            for (int j = 0; j < columns.length; j++) map.put(columns[j], new Double(Double.NaN));
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                map.put(ds[i].getColumnValueAt(j), ds[i].getValueAt(j));
                set.add(ds[i].getValueAt(j));
            }
            for (int j = 0; j < columns.length; j++) {
                numdata[j] = (Number) map.get(columns[j]);
            }
            data[i] = new DefaultDataSet(numdata, columns, CoordSystem.FIRST_YAXIS, ds[i].getTitle());
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet index
     * @return the DataSet length
     */
    public int getDataSetLength(int set) {
        return data[set].getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSet
     */
    public int getDataSetNumber() {
        return data.length;
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return data[set].getTitle();
    }

    /**
     * Returns the axis to which a DataSet is attached
     * @param set the DataSet index
     * @return the axis constant
     */
    public int getAxisBinding(int set) {
        return data[set].getYAxis();
    }

    /**
     * Returns the Value in a specific dataset at a certain index.
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value
     */
    public Number getValueAt(int set, int index) {
        return (Number) data[set].getValueAt(index);
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant
     * @return the ChartDataModelConstraints for the defined y-axis
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int col) {
        if (col < columns.length)
            return columns[col];
        else
            return null;
    }

    /**
     * Calls getColumnValueAt(int col).
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int set, int col) {
        return getColumnValueAt(col);
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the minimum column value.
     * @return Returns 0.0.
     */
    protected double getFirstColumnValue() {
        return 0.0;
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the maximum column value.
     * @return Returns <code>columns.length</code>.
     */
    protected double getLastColumnValue() {
        return Math.max((double) columns.length, 1.0);
    }
}
","// ObjectChartDataModel_4Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
*/
class ObjectChartDataModel_4Test {","// ObjectChartDataModel_4Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
*/
class ObjectChartDataModel_4Test {

		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the first y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_1() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel();
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.FIRST_YAXIS);
				assertEquals(cdmc.getMaxValue(), 1.0);
				assertEquals(cdmc.getMinValue(), 0.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the second y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_2() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel();
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.SECOND_YAXIS);
				assertEquals(cdmc.getMaxValue(), 1.0);
				assertEquals(cdmc.getMinValue(), 0.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the first y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_3() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new Number[][]{{1, 2, 3}, {4, 5, 6}}, new Object[]{""a"", ""b"", ""c""}, new String[]{""d"", ""e""});
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.FIRST_YAXIS);
				assertEquals(cdmc.getMaxValue(), 6.0);
				assertEquals(cdmc.getMinValue(), 1.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the second y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_4() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new Number[][]{{1, 2, 3}, {4, 5, 6}}, new Object[]{""a"", ""b"", ""c""}, new String[]{""d"", ""e""});
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.SECOND_YAXIS);
				assertEquals(cdmc.getMaxValue(), 1.0);
				assertEquals(cdmc.getMinValue(), 0.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the first y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_5() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new int[][]{{1, 2, 3}, {4, 5, 6}}, new Object[]{""a"", ""b"", ""c""}, new String[]{""d"", ""e""});
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.FIRST_YAXIS);
				assertEquals(cdmc.getMaxValue(), 6.0);
				assertEquals(cdmc.getMinValue(), 1.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the second y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_6() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new int[][]{{1, 2, 3}, {4, 5, 6}}, new Object[]{""a"", ""b"", ""c""}, new String[]{""d"", ""e""});
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.SECOND_YAXIS);
				assertEquals(cdmc.getMaxValue(), 1.0);
				assertEquals(cdmc.getMinValue(), 0.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the first y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_7() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new double[][]{{1, 2, 3}, {4, 5, 6}}, new Object[]{""a"", ""b"", ""c""}, new String[]{""d"", ""e""});
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.FIRST_YAXIS);
				assertEquals(cdmc.getMaxValue(), 6.0);
				assertEquals(cdmc.getMinValue(), 1.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the second y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_8() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new double[][]{{1, 2, 3}, {4, 5, 6}}, new Object[]{""a"", ""b"", ""c""}, new String[]{""d"", ""e""});
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.SECOND_YAXIS);
				assertEquals(cdmc.getMaxValue(), 1.0);
				assertEquals(cdmc.getMinValue(), 0.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the first y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_9() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new DataSet[]{new DefaultDataSet(new Number[]{1, 2, 3}, new Object[]{""a"", ""b"", ""c""}, CoordSystem.FIRST_YAXIS, ""d""), new DefaultDataSet(new Number[]{4, 5, 6}, new Object[]{""a"", ""b"", ""c""}, CoordSystem.FIRST_YAXIS, ""e"")}, new Object[]{""a"", ""b"", ""c""});
				ChartDataModelConstraints cdmc = ocdm.getChartDataModelConstraints(CoordSystem.FIRST_YAXIS);
				assertEquals(cdmc.getMaxValue(), 6.0);
				assertEquals(cdmc.getMinValue(), 1.0);
		}
		
		/**
		* Test case for {@link ObjectChartDataModel#getChartDataModelConstraints(int)} method.
		* Test case for the second y-axis.
		*/
		@Test
		void testGetChartDataModelConstraints_10() {
				ObjectChartDataModel ocdm = new ObjectChartDataModel(new DataSet[]{new DefaultDataSet(new Number[]"
cmpl-6ttxEalf7nZReghEDcqjeIxptZCKM,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/ObjectChartDataModel_5Test.java,96.1798825263977,length,"// ObjectChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ObjectColumnChartDataModel.java
    Created on 7. August 2001, 17:27
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * The ObjectChartDataModel implements a ChartDataModel for Charts,
 * which have e.g. String values on the x-axis. This is especially useful
 * for Barcharts and also for Piecharts, although those don't exactly have
 * an x-axis.
 * @author  mueller
 * @version 1.0
 */
public class ObjectChartDataModel extends AbstractChartDataModel {

    /**
     * The x-axis values.
     */
    protected Object[] columns;

    /**
     * The data values.
     */
    protected DataSet[] data;

    /**
     * A HashMap containing the ordered data per axis.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     * Initializes all Objects and Arrays as empty ones.
     */
    public ObjectChartDataModel() {
        data = new DefaultDataSet[0];
        columns = new Object[0];
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS, false);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS, false);
    }

    /**
     * Creates new ObjectChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(Number[][] data, Object[] columns, String[] rows) {
        this();
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(data[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates new ObjectChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(int[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     *  Creates new ObjectChartDataModel.
     *  @param data the array of values. The first index specifies the
     *  datasets, the last one is the value index.
     *  @param columns the array of x-axis values. The length of the
     *  datasets and the length of the column should be equal and
     *  the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(double[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates a new ObjectChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets. Internally, the DataSets
     * are transformed into equally sized DataSets, where the missing data fields
     * are filled with Double.NaN.
     * @param ds the array of DataSets to be used.
     * @param columns the array of column values. This needs to be supplied,
     * because using Objects as x-axis values you need to have an ordered
     * superset of all column values especially if different DataSets only
     * contain some column values
     */
    public ObjectChartDataModel(DataSet[] ds, Object[] columns) {
        this();
        data = ds;
        this.columns = columns;
        TreeSet set;
        HashMap map = new HashMap();
        for (int i = 0; i < ds.length; i++) {
            map.clear();
            Number[] numdata = new Number[columns.length];
            for (int j = 0; j < columns.length; j++) map.put(columns[j], new Double(Double.NaN));
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                map.put(ds[i].getColumnValueAt(j), ds[i].getValueAt(j));
                set.add(ds[i].getValueAt(j));
            }
            for (int j = 0; j < columns.length; j++) {
                numdata[j] = (Number) map.get(columns[j]);
            }
            data[i] = new DefaultDataSet(numdata, columns, CoordSystem.FIRST_YAXIS, ds[i].getTitle());
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet index
     * @return the DataSet length
     */
    public int getDataSetLength(int set) {
        return data[set].getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSet
     */
    public int getDataSetNumber() {
        return data.length;
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return data[set].getTitle();
    }

    /**
     * Returns the axis to which a DataSet is attached
     * @param set the DataSet index
     * @return the axis constant
     */
    public int getAxisBinding(int set) {
        return data[set].getYAxis();
    }

    /**
     * Returns the Value in a specific dataset at a certain index.
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value
     */
    public Number getValueAt(int set, int index) {
        return (Number) data[set].getValueAt(index);
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant
     * @return the ChartDataModelConstraints for the defined y-axis
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int col) {
        if (col < columns.length)
            return columns[col];
        else
            return null;
    }

    /**
     * Calls getColumnValueAt(int col).
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int set, int col) {
        return getColumnValueAt(col);
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the minimum column value.
     * @return Returns 0.0.
     */
    protected double getFirstColumnValue() {
        return 0.0;
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the maximum column value.
     * @return Returns <code>columns.length</code>.
     */
    protected double getLastColumnValue() {
        return Math.max((double) columns.length, 1.0);
    }
}
","// ObjectChartDataModel_5Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
*/
class ObjectChartDataModel_5Test {","// ObjectChartDataModel_5Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
*/
class ObjectChartDataModel_5Test {

		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a negative column index.
		*/
		@Test
		void testGetColumnValueAt_1() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(-1);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 0.
		*/
		@Test
		void testGetColumnValueAt_2() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(0);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 1.
		*/
		@Test
		void testGetColumnValueAt_3() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(1);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 2.
		*/
		@Test
		void testGetColumnValueAt_4() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(2);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 3.
		*/
		@Test
		void testGetColumnValueAt_5() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(3);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 4.
		*/
		@Test
		void testGetColumnValueAt_6() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(4);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 5.
		*/
		@Test
		void testGetColumnValueAt_7() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(5);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 6.
		*/
		@Test
		void testGetColumnValueAt_8() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(6);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 7.
		*/
		@Test
		void testGetColumnValueAt_9() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(7);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
		* The test case tests the method with a column index of 8.
		*/
		@Test
		void testGetColumnValueAt_10() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(8);
				assertNull(result);
		}
}

// ObjectChartDataModel_6Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
*/
class ObjectChartDataModel_6Test {
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
		* The test case tests the method with a negative column index.
		*/
		@Test
		void testGetColumnValueAt_1() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(0, -1);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
		* The test case tests the method with a column index of 0.
		*/
		@Test
		void testGetColumnValueAt_2() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(0, 0);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
		* The test case tests the method with a column index of 1.
		*/
		@Test
		void testGetColumnValueAt_3() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(0, 1);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
		* The test case tests the method with a column index of 2.
		*/
		@Test
		void testGetColumnValueAt_4() {
				ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
				Object result = objectChartDataModel.getColumnValueAt(0, 2);
				assertNull(result);
		}
		
		/**
		* Test case for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
		* The test case tests the method with a column index of 3.
		*/
		@Test
		void testGetColumnValue"
cmpl-6ttymwKmsYyQHx7IfpvCgCbdD6eyT,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/model/ObjectChartDataModel_6Test.java,96.24540996551514,length,"// ObjectChartDataModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ObjectColumnChartDataModel.java
    Created on 7. August 2001, 17:27
*/
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;

/**
 * The ObjectChartDataModel implements a ChartDataModel for Charts,
 * which have e.g. String values on the x-axis. This is especially useful
 * for Barcharts and also for Piecharts, although those don't exactly have
 * an x-axis.
 * @author  mueller
 * @version 1.0
 */
public class ObjectChartDataModel extends AbstractChartDataModel {

    /**
     * The x-axis values.
     */
    protected Object[] columns;

    /**
     * The data values.
     */
    protected DataSet[] data;

    /**
     * A HashMap containing the ordered data per axis.
     */
    protected HashMap valuesbyaxis = new HashMap();

    /**
     * The constraints for the first and second y-axes.
     */
    protected ChartDataModelConstraints constraints1, constraints2;

    /**
     * Creates a new empty DefaultChartDataModel.
     * Initializes all Objects and Arrays as empty ones.
     */
    public ObjectChartDataModel() {
        data = new DefaultDataSet[0];
        columns = new Object[0];
        TreeSet set1 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.FIRST_YAXIS), set1);
        TreeSet set2 = new TreeSet();
        valuesbyaxis.put(new Integer(CoordSystem.SECOND_YAXIS), set2);
        constraints1 = new DefaultChartDataModelConstraints(this, CoordSystem.FIRST_YAXIS, false);
        constraints2 = new DefaultChartDataModelConstraints(this, CoordSystem.SECOND_YAXIS, false);
    }

    /**
     * Creates new ObjectChartDataModel with the default axis binding.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and the columns should
     * be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(Number[][] data, Object[] columns, String[] rows) {
        this();
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, data);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(data[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates new ObjectChartDataModel.
     * @param data the array of values. The first index specifies the
     * datasets, the last one is the value index.
     * @param columns the array of x-axis values. The length of the
     * datasets and the length of the column should be equal and
     * the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(int[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     *  Creates new ObjectChartDataModel.
     *  @param data the array of values. The first index specifies the
     *  datasets, the last one is the value index.
     *  @param columns the array of x-axis values. The length of the
     *  datasets and the length of the column should be equal and
     *  the columns should be ordered.
     * @param rows the DataSet titles
     */
    public ObjectChartDataModel(double[][] data, Object[] columns, String[] rows) {
        this();
        Number[][] numdata = ChartUtilities.transformArray(data);
        this.columns = columns;
        this.data = new DefaultDataSet[data.length];
        TreeSet set = (TreeSet) valuesbyaxis.get(new Integer(CoordSystem.FIRST_YAXIS));
        ChartUtilities.addDataToSet(set, numdata);
        for (int i = 0; i < data.length; i++) {
            this.data[i] = new DefaultDataSet(numdata[i], columns, CoordSystem.FIRST_YAXIS, rows[i]);
        }
    }

    /**
     * Creates a new ObjectChartDataModel using the
     * given array of DataSets, effectively enabling the creation
     * of DataModels with differently sized DataSets. Internally, the DataSets
     * are transformed into equally sized DataSets, where the missing data fields
     * are filled with Double.NaN.
     * @param ds the array of DataSets to be used.
     * @param columns the array of column values. This needs to be supplied,
     * because using Objects as x-axis values you need to have an ordered
     * superset of all column values especially if different DataSets only
     * contain some column values
     */
    public ObjectChartDataModel(DataSet[] ds, Object[] columns) {
        this();
        data = ds;
        this.columns = columns;
        TreeSet set;
        HashMap map = new HashMap();
        for (int i = 0; i < ds.length; i++) {
            map.clear();
            Number[] numdata = new Number[columns.length];
            for (int j = 0; j < columns.length; j++) map.put(columns[j], new Double(Double.NaN));
            set = (TreeSet) valuesbyaxis.get(new Integer(ds[i].getYAxis()));
            for (int j = 0; j < ds[i].getDataSetLength(); j++) {
                map.put(ds[i].getColumnValueAt(j), ds[i].getValueAt(j));
                set.add(ds[i].getValueAt(j));
            }
            for (int j = 0; j < columns.length; j++) {
                numdata[j] = (Number) map.get(columns[j]);
            }
            data[i] = new DefaultDataSet(numdata, columns, CoordSystem.FIRST_YAXIS, ds[i].getTitle());
        }
    }

    /**
     * Returns the length of a certain dataset.
     * @param set the DataSet index
     * @return the DataSet length
     */
    public int getDataSetLength(int set) {
        return data[set].getDataSetLength();
    }

    /**
     * Returns the total amount of datasets.
     * @return the amount of DataSet
     */
    public int getDataSetNumber() {
        return data.length;
    }

    /**
     * Returns the title of the DataSet. This is the number of
     * the DataSet per default.
     * @param set the DataSet index
     * @return the String title
     */
    public String getDataSetName(int set) {
        return data[set].getTitle();
    }

    /**
     * Returns the axis to which a DataSet is attached
     * @param set the DataSet index
     * @return the axis constant
     */
    public int getAxisBinding(int set) {
        return data[set].getYAxis();
    }

    /**
     * Returns the Value in a specific dataset at a certain index.
     * @param set the DataSet index
     * @param index the value index
     * @return the Number value
     */
    public Number getValueAt(int set, int index) {
        return (Number) data[set].getValueAt(index);
    }

    /**
     * Returns a ChartDataModelConstraints Object for a given axis.
     * This way, there are different constraints for the first and for
     * the second y-axis. If the model is empty, the maximum values are 1 and
     * the minimum values are 0, thus enabling proper rendering.
     * @param axis the axis constant
     * @return the ChartDataModelConstraints for the defined y-axis
     */
    public ChartDataModelConstraints getChartDataModelConstraints(final int axis) {
        if (axis == CoordSystem.FIRST_YAXIS)
            return constraints1;
        else
            return constraints2;
    }

    /**
     * Sets the ChartDataModelConstraints object for the given
     * axis binding.
     * @param axis the Axis constant
     * @param constraints the ChartDataModelConstraints object
     * @return a ChartDataModelConstraints object.
     */
    public void setChartDataModelConstraints(int axis, ChartDataModelConstraints constraints) {
        if (axis == CoordSystem.FIRST_YAXIS)
            constraints1 = constraints;
        else
            constraints2 = constraints;
    }

    /**
     * Returns a specific column value.
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int col) {
        if (col < columns.length)
            return columns[col];
        else
            return null;
    }

    /**
     * Calls getColumnValueAt(int col).
     * @return the column value or <code>null</code> if the column doesn't exist.
     * @param col the column index
     */
    public Object getColumnValueAt(int set, int col) {
        return getColumnValueAt(col);
    }

    /**
     * Returns an ordered set of all data values for the specified axis.
     * This is called by the ChartDataModelConstraints classes.
     */
    protected TreeSet getOrderedValues(int axis) {
        return (TreeSet) valuesbyaxis.get(new Integer(axis));
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the minimum column value.
     * @return Returns 0.0.
     */
    protected double getFirstColumnValue() {
        return 0.0;
    }

    /**
     * Is called by the ChartDataModelConstraints Object to compute the maximum column value.
     * @return Returns <code>columns.length</code>.
     */
    protected double getLastColumnValue() {
        return Math.max((double) columns.length, 1.0);
    }
}
","// ObjectChartDataModel_6Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
*/
class ObjectChartDataModel_6Test {","// ObjectChartDataModel_6Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getColumnValueAt(int, int)} method.
*/
class ObjectChartDataModel_6Test {

	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_1() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(0, 0);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_2() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(0, 1);
		assertEquals(""b"", result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_3() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(1, 0);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_4() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(1, 1);
		assertEquals(""b"", result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_5() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(2, 0);
		assertEquals(null, result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_6() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(2, 1);
		assertEquals(null, result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_7() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(0, 2);
		assertEquals(null, result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_8() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(1, 2);
		assertEquals(null, result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_9() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(2, 2);
		assertEquals(null, result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int, int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_10() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(0, -1);
		assertEquals(null, result);
	}
	
}

// ObjectChartDataModel_7Test.java
package de.progra.charting.model;

import de.progra.charting.CoordSystem;
import de.progra.charting.ChartUtilities;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashMap;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ObjectChartDataModel}.
* It contains ten unit test cases for the {@link ObjectChartDataModel#getColumnValueAt(int)} method.
*/
class ObjectChartDataModel_7Test {
		
	/**
	* Test case for {@link ObjectChartDataModel#getColumnValueAt(int)}.
	* The test case tests if the method returns the correct column value.
	*/
	@Test
	void testGetColumnValueAt_1() {
		ObjectChartDataModel objectChartDataModel = new ObjectChartDataModel();
		Object[] columns = new Object[2];
		columns[0] = ""a"";
		columns[1] = ""b"";
		objectChartDataModel.columns = columns;
		Object result = objectChartDataModel.getColumnValueAt(0);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case for {@link ObjectChartDataModel#"
cmpl-6tu0L3XAmHU3XuHRSlHs1Bj0nrfrV,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/RowColorModel_0Test.java,55.9518780708313,length,"// RowColorModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    RowColorModel.java
    Created on 28. August 2001, 20:02
*/
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;

/**
 * This class implements the correspondence between the DataSets and the
 * colors used for rendering the charts and the legend.
 * @author mueller
 * @version 1.0
 */
public class RowColorModel {

    private static RowColorModel instance;

    protected ChartDataModel model;

    protected final static Color[] predefinedColors = { Color.blue, Color.cyan, Color.red, Color.pink, Color.yellow, Color.green, Color.magenta, Color.orange, Color.darkGray, Color.gray, Color.lightGray };

    public static final Ellipse2D ELLIPSE_SHAPE = new Ellipse2D.Float(0f, 0f, 5f, 5f);

    public static final Rectangle2D SQUARE_SHAPE = new Rectangle2D.Float(0f, 0f, 5f, 5f);

    public static final Diamond2D DIAMOND_SHAPE = new Diamond2D(0f, 0f, 5f, 5f);

    public static final Triangle2D TRIANGLE_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, false);

    public static final Triangle2D TRIANGLEDOWN_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, true);

    protected final static RectangularShape[] predefinedShapes = { ELLIPSE_SHAPE, SQUARE_SHAPE, DIAMOND_SHAPE, TRIANGLE_SHAPE, TRIANGLEDOWN_SHAPE };

    protected int predefinedColorsIdx = 0;

    protected HashMap customColors = new HashMap();

    protected HashMap customShapes = new HashMap();

    /**
     * Creates new RowColorModel.
     * @param model the ChartDataModel which contains the information about all the DataSets
     */
    public RowColorModel(ChartDataModel model) {
        this.model = model;
    }

    /**
     * Use this method to get an instance of the chart's RowColorModel.
     * @param model the ChartDataModel whose data sets will be mapped to
     * colors.
     * @return a new instance of RowColorModel if there's no instance
     * of if the model has changed (esp. useful if you create multiple charts
     * after one another).
     * @deprecated
     */
    public static RowColorModel getInstance(ChartDataModel model) {
        if (instance == null || !model.equals(instance.model))
            instance = new RowColorModel(model);
        return instance;
    }

    /**
     * Computes the amount of all Legend entries, ie. DataSets.
     * @return the amount of all rows, ie. DataSets.
     */
    public int getRowCount() {
        return model.getDataSetNumber();
    }

    /**
     * Returns the row title of a specific DataSet.
     * @param i the DataSet index
     * @return the String title
     */
    public String getRow(int i) {
        return model.getDataSetName(i);
    }

    /**
     * Computes the Color for a DataSet. For the first DataSets the stored Colors like <CODE>Color.red</CODE> etc are used. If there are more DataSets than stored colors, random colors are used.
     * @param row the row for which the Color should be returned
     * @return the Color stored for the given row.
     */
    public Color getColor(int row) {
        // get the custom color
        Color c = (Color) customColors.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // see if there is a predefined color for this row
            if (predefinedColorsIdx < predefinedColors.length) {
                c = predefinedColors[predefinedColorsIdx++];
            } else {
                c = new Color((float) Math.random(), (float) Math.random(), (float) Math.random());
            }
            // remember this
            customColors.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Returns the Shape for a DataSet. By default, the Shapes from
     * the <code>predefinedShapes</code> array are cycled through unless you define
     * your own shape to data binding using
     * <code>setShape(int row, RectangularShape shape)</code>.
     * @param row the row for which the Shape should be returned
     * @return the Shape stored for the given row.
     */
    public RectangularShape getShape(int row) {
        // get the custom color
        RectangularShape c = (RectangularShape) customShapes.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // calculate the matching predefined shape by a modulo operation
            c = predefinedShapes[row % predefinedShapes.length];
            // remember this
            customShapes.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Force a certain color for a row
     * @param row the row for which the Color should be set
     * @param color the color that is associated with the row
     */
    public void setColor(int row, Color color) {
        customColors.put(new Integer(row), color);
    }

    /**
     * Force a certain Shape for a row
     * @param row the row for which the Shape should be set
     * @param shape the RectangularShape that is associated with the row
     */
    public void setShape(int row, RectangularShape shape) {
        customShapes.put(new Integer(row), shape);
    }
}
","// RowColorModel_0Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getInstance(ChartDataModel)} method.
*/
class RowColorModel_0Test {","// RowColorModel_0Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getInstance(ChartDataModel)} method.
*/
class RowColorModel_0Test {

		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_0() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_1() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_2() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_3() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_4() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_5() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_6() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_7() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_8() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getInstance(ChartDataModel)}.
		* @throws Exception
		*/
		@Test
		void testGetInstance_9() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel result = RowColorModel.getInstance(model);
				assertNotNull(result);
		}
}

// RowColorModel_1Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getRowCount()} method.
*/
class RowColorModel_1Test {
		
		/**
		* Test case for the method {@link RowColorModel#getRowCount()}.
		* @throws Exception
		*/
		@Test
		void testGetRowCount_0() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel fixture = new RowColorModel(model);
				int result = fixture.getRowCount();
				assertEquals(0, result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getRowCount()}.
		* @throws Exception
		*/
		@Test
		void testGetRowCount_1() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel fixture = new RowColorModel(model);
				int result = fixture.getRowCount();
				assertEquals(0, result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getRowCount()}.
		* @throws Exception
		*/
		@Test
		void testGetRowCount_2() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel fixture = new RowColorModel(model);
				int result = fixture.getRowCount();
				assertEquals(0, result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getRowCount()}.
		* @throws Exception
		*/
		@Test
		void testGetRowCount_3() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel fixture = new RowColorModel(model);
				int result = fixture.getRowCount();
				assertEquals(0, result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getRowCount()}.
		* @throws Exception
		*/
		@Test
		void testGetRowCount_4() throws Exception {
				ChartDataModel model = new ChartDataModel();
				RowColorModel fixture = new RowColorModel(model);
				int result = fixture.getRowCount();
				assertEquals(0, result);
		}
		
		/**
		* Test case for the method {@link RowColorModel#getRowCount()}.
		* @throws Exception
		*/
		@Test
		void testGetRowCount_5() throws Exception {
				ChartDataModel model ="
cmpl-6tu1OAmLPCG5tBdf5xMuWBkvvXqox,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/RowColorModel_1Test.java,44.87895059585571,length,"// RowColorModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    RowColorModel.java
    Created on 28. August 2001, 20:02
*/
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;

/**
 * This class implements the correspondence between the DataSets and the
 * colors used for rendering the charts and the legend.
 * @author mueller
 * @version 1.0
 */
public class RowColorModel {

    private static RowColorModel instance;

    protected ChartDataModel model;

    protected final static Color[] predefinedColors = { Color.blue, Color.cyan, Color.red, Color.pink, Color.yellow, Color.green, Color.magenta, Color.orange, Color.darkGray, Color.gray, Color.lightGray };

    public static final Ellipse2D ELLIPSE_SHAPE = new Ellipse2D.Float(0f, 0f, 5f, 5f);

    public static final Rectangle2D SQUARE_SHAPE = new Rectangle2D.Float(0f, 0f, 5f, 5f);

    public static final Diamond2D DIAMOND_SHAPE = new Diamond2D(0f, 0f, 5f, 5f);

    public static final Triangle2D TRIANGLE_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, false);

    public static final Triangle2D TRIANGLEDOWN_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, true);

    protected final static RectangularShape[] predefinedShapes = { ELLIPSE_SHAPE, SQUARE_SHAPE, DIAMOND_SHAPE, TRIANGLE_SHAPE, TRIANGLEDOWN_SHAPE };

    protected int predefinedColorsIdx = 0;

    protected HashMap customColors = new HashMap();

    protected HashMap customShapes = new HashMap();

    /**
     * Creates new RowColorModel.
     * @param model the ChartDataModel which contains the information about all the DataSets
     */
    public RowColorModel(ChartDataModel model) {
        this.model = model;
    }

    /**
     * Use this method to get an instance of the chart's RowColorModel.
     * @param model the ChartDataModel whose data sets will be mapped to
     * colors.
     * @return a new instance of RowColorModel if there's no instance
     * of if the model has changed (esp. useful if you create multiple charts
     * after one another).
     * @deprecated
     */
    public static RowColorModel getInstance(ChartDataModel model) {
        if (instance == null || !model.equals(instance.model))
            instance = new RowColorModel(model);
        return instance;
    }

    /**
     * Computes the amount of all Legend entries, ie. DataSets.
     * @return the amount of all rows, ie. DataSets.
     */
    public int getRowCount() {
        return model.getDataSetNumber();
    }

    /**
     * Returns the row title of a specific DataSet.
     * @param i the DataSet index
     * @return the String title
     */
    public String getRow(int i) {
        return model.getDataSetName(i);
    }

    /**
     * Computes the Color for a DataSet. For the first DataSets the stored Colors like <CODE>Color.red</CODE> etc are used. If there are more DataSets than stored colors, random colors are used.
     * @param row the row for which the Color should be returned
     * @return the Color stored for the given row.
     */
    public Color getColor(int row) {
        // get the custom color
        Color c = (Color) customColors.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // see if there is a predefined color for this row
            if (predefinedColorsIdx < predefinedColors.length) {
                c = predefinedColors[predefinedColorsIdx++];
            } else {
                c = new Color((float) Math.random(), (float) Math.random(), (float) Math.random());
            }
            // remember this
            customColors.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Returns the Shape for a DataSet. By default, the Shapes from
     * the <code>predefinedShapes</code> array are cycled through unless you define
     * your own shape to data binding using
     * <code>setShape(int row, RectangularShape shape)</code>.
     * @param row the row for which the Shape should be returned
     * @return the Shape stored for the given row.
     */
    public RectangularShape getShape(int row) {
        // get the custom color
        RectangularShape c = (RectangularShape) customShapes.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // calculate the matching predefined shape by a modulo operation
            c = predefinedShapes[row % predefinedShapes.length];
            // remember this
            customShapes.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Force a certain color for a row
     * @param row the row for which the Color should be set
     * @param color the color that is associated with the row
     */
    public void setColor(int row, Color color) {
        customColors.put(new Integer(row), color);
    }

    /**
     * Force a certain Shape for a row
     * @param row the row for which the Shape should be set
     * @param shape the RectangularShape that is associated with the row
     */
    public void setShape(int row, RectangularShape shape) {
        customShapes.put(new Integer(row), shape);
    }
}
","// RowColorModel_1Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getRow(int)} method.
*/
class RowColorModel_1Test {","// RowColorModel_1Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getRow(int)} method.
*/
class RowColorModel_1Test {

		/**
		* Test case for the {@link RowColorModel#getRow(int)} method.
		* It tests if the method returns the correct row title.
		*/
		@Test
		void testGetRow() {
				ChartDataModel model = new ChartDataModel();
				model.addDataSet(""Test1"");
				model.addDataSet(""Test2"");
				model.addDataSet(""Test3"");
				RowColorModel rowColorModel = new RowColorModel(model);
				assertEquals(""Test1"", rowColorModel.getRow(0));
				assertEquals(""Test2"", rowColorModel.getRow(1));
				assertEquals(""Test3"", rowColorModel.getRow(2));
		}
}

// RowColorModel_2Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getRowCount()} method.
*/
class RowColorModel_2Test {
		
		/**
		* Test case for the {@link RowColorModel#getRowCount()} method.
		* It tests if the method returns the correct amount of rows.
		*/
		@Test
		void testGetRowCount() {
				ChartDataModel model = new ChartDataModel();
				model.addDataSet(""Test1"");
				model.addDataSet(""Test2"");
				model.addDataSet(""Test3"");
				RowColorModel rowColorModel = new RowColorModel(model);
				assertEquals(3, rowColorModel.getRowCount());
		}
}

// RowColorModel_3Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getColor(int)} method.
*/
class RowColorModel_3Test {
		
		/**
		* Test case for the {@link RowColorModel#getColor(int)} method.
		* It tests if the method returns the correct color.
		*/
		@Test
		void testGetColor() {
				ChartDataModel model = new ChartDataModel();
				model.addDataSet(""Test1"");
				model.addDataSet(""Test2"");
				model.addDataSet(""Test3"");
				RowColorModel rowColorModel = new RowColorModel(model);
				assertEquals(Color.blue, rowColorModel.getColor(0));
				assertEquals(Color.cyan, rowColorModel.getColor(1));
				assertEquals(Color.red, rowColorModel.getColor(2));
		}
}

// RowColorModel_4Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getShape(int)} method.
*/
class RowColorModel_4Test {
		
		/**
		* Test case for the {@link RowColorModel#getShape(int)} method.
		* It tests if the method returns the correct shape.
		*/
		@Test
		void testGetShape() {
				ChartDataModel model = new ChartDataModel();
				model.addDataSet(""Test1"");
				model.addDataSet(""Test2"");
				model.addDataSet(""Test3"");
				RowColorModel rowColorModel = new RowColorModel(model);
				assertEquals(RowColorModel.ELLIPSE_SHAPE, rowColorModel.getShape(0));
				assertEquals(RowColorModel.SQUARE_SHAPE, rowColorModel.getShape(1));
				assertEquals(RowColorModel.DIAMOND_SHAPE, rowColorModel.getShape(2));
		}
}

// RowColorModel_5Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#setColor(int, Color)} method.
*/
class RowColorModel_5Test {
		
		/**
		* Test case for the {@link RowColorModel#setColor(int, Color)} method.
		* It tests if the method sets the correct color.
		*/
		@Test
		void testSetColor() {
				ChartDataModel model = new ChartDataModel();
				model.addDataSet(""Test1"");
				model.addDataSet(""Test2"");
				model.addDataSet(""Test3"");
				RowColorModel rowColorModel = new RowColorModel(model);
				rowColorModel.setColor(0, Color.red);
				rowColorModel.setColor(1, Color.blue);
				rowColorModel.setColor(2, Color.green);
				assertEquals(Color.red, rowColorModel.getColor(0));
				assertEquals(Color.blue, rowColorModel.getColor(1));
				assertEquals(Color.green, rowColorModel.getColor(2));
		}
}

// RowColorModel_6Test.java
package de.progra.charting.render;

import java.awt.Color;
import de"
cmpl-6tu2RN13Ua3Vc2pSgw0lHJOxYcSiJ,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/RowColorModel_2Test.java,44.717607736587524,length,"// RowColorModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    RowColorModel.java
    Created on 28. August 2001, 20:02
*/
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;

/**
 * This class implements the correspondence between the DataSets and the
 * colors used for rendering the charts and the legend.
 * @author mueller
 * @version 1.0
 */
public class RowColorModel {

    private static RowColorModel instance;

    protected ChartDataModel model;

    protected final static Color[] predefinedColors = { Color.blue, Color.cyan, Color.red, Color.pink, Color.yellow, Color.green, Color.magenta, Color.orange, Color.darkGray, Color.gray, Color.lightGray };

    public static final Ellipse2D ELLIPSE_SHAPE = new Ellipse2D.Float(0f, 0f, 5f, 5f);

    public static final Rectangle2D SQUARE_SHAPE = new Rectangle2D.Float(0f, 0f, 5f, 5f);

    public static final Diamond2D DIAMOND_SHAPE = new Diamond2D(0f, 0f, 5f, 5f);

    public static final Triangle2D TRIANGLE_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, false);

    public static final Triangle2D TRIANGLEDOWN_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, true);

    protected final static RectangularShape[] predefinedShapes = { ELLIPSE_SHAPE, SQUARE_SHAPE, DIAMOND_SHAPE, TRIANGLE_SHAPE, TRIANGLEDOWN_SHAPE };

    protected int predefinedColorsIdx = 0;

    protected HashMap customColors = new HashMap();

    protected HashMap customShapes = new HashMap();

    /**
     * Creates new RowColorModel.
     * @param model the ChartDataModel which contains the information about all the DataSets
     */
    public RowColorModel(ChartDataModel model) {
        this.model = model;
    }

    /**
     * Use this method to get an instance of the chart's RowColorModel.
     * @param model the ChartDataModel whose data sets will be mapped to
     * colors.
     * @return a new instance of RowColorModel if there's no instance
     * of if the model has changed (esp. useful if you create multiple charts
     * after one another).
     * @deprecated
     */
    public static RowColorModel getInstance(ChartDataModel model) {
        if (instance == null || !model.equals(instance.model))
            instance = new RowColorModel(model);
        return instance;
    }

    /**
     * Computes the amount of all Legend entries, ie. DataSets.
     * @return the amount of all rows, ie. DataSets.
     */
    public int getRowCount() {
        return model.getDataSetNumber();
    }

    /**
     * Returns the row title of a specific DataSet.
     * @param i the DataSet index
     * @return the String title
     */
    public String getRow(int i) {
        return model.getDataSetName(i);
    }

    /**
     * Computes the Color for a DataSet. For the first DataSets the stored Colors like <CODE>Color.red</CODE> etc are used. If there are more DataSets than stored colors, random colors are used.
     * @param row the row for which the Color should be returned
     * @return the Color stored for the given row.
     */
    public Color getColor(int row) {
        // get the custom color
        Color c = (Color) customColors.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // see if there is a predefined color for this row
            if (predefinedColorsIdx < predefinedColors.length) {
                c = predefinedColors[predefinedColorsIdx++];
            } else {
                c = new Color((float) Math.random(), (float) Math.random(), (float) Math.random());
            }
            // remember this
            customColors.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Returns the Shape for a DataSet. By default, the Shapes from
     * the <code>predefinedShapes</code> array are cycled through unless you define
     * your own shape to data binding using
     * <code>setShape(int row, RectangularShape shape)</code>.
     * @param row the row for which the Shape should be returned
     * @return the Shape stored for the given row.
     */
    public RectangularShape getShape(int row) {
        // get the custom color
        RectangularShape c = (RectangularShape) customShapes.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // calculate the matching predefined shape by a modulo operation
            c = predefinedShapes[row % predefinedShapes.length];
            // remember this
            customShapes.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Force a certain color for a row
     * @param row the row for which the Color should be set
     * @param color the color that is associated with the row
     */
    public void setColor(int row, Color color) {
        customColors.put(new Integer(row), color);
    }

    /**
     * Force a certain Shape for a row
     * @param row the row for which the Shape should be set
     * @param shape the RectangularShape that is associated with the row
     */
    public void setShape(int row, RectangularShape shape) {
        customShapes.put(new Integer(row), shape);
    }
}
","// RowColorModel_2Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getColor(int)} method.
*/
class RowColorModel_2Test {","// RowColorModel_2Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getColor(int)} method.
*/
class RowColorModel_2Test {

		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 0.
		* Expected result: Color.blue.
		*/
		@Test
		public void testGetColor_0() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 0;
				Color result = fixture.getColor(row);
				assertEquals(Color.blue, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 1.
		* Expected result: Color.cyan.
		*/
		@Test
		public void testGetColor_1() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 1;
				Color result = fixture.getColor(row);
				assertEquals(Color.cyan, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 2.
		* Expected result: Color.red.
		*/
		@Test
		public void testGetColor_2() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 2;
				Color result = fixture.getColor(row);
				assertEquals(Color.red, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 3.
		* Expected result: Color.pink.
		*/
		@Test
		public void testGetColor_3() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 3;
				Color result = fixture.getColor(row);
				assertEquals(Color.pink, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 4.
		* Expected result: Color.yellow.
		*/
		@Test
		public void testGetColor_4() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 4;
				Color result = fixture.getColor(row);
				assertEquals(Color.yellow, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 5.
		* Expected result: Color.green.
		*/
		@Test
		public void testGetColor_5() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 5;
				Color result = fixture.getColor(row);
				assertEquals(Color.green, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 6.
		* Expected result: Color.magenta.
		*/
		@Test
		public void testGetColor_6() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 6;
				Color result = fixture.getColor(row);
				assertEquals(Color.magenta, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 7.
		* Expected result: Color.orange.
		*/
		@Test
		public void testGetColor_7() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 7;
				Color result = fixture.getColor(row);
				assertEquals(Color.orange, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 8.
		* Expected result: Color.darkGray.
		*/
		@Test
		public void testGetColor_8() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 8;
				Color result = fixture.getColor(row);
				assertEquals(Color.darkGray, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 9.
		* Expected result: Color.gray.
		*/
		@Test
		public void testGetColor_9() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 9;
				Color result = fixture.getColor(row);
				assertEquals(Color.gray, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 10.
		* Expected result: Color.lightGray.
		*/
		@Test
		public void testGetColor_10() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 10;
				Color result = fixture.getColor(row);
				assertEquals(Color.lightGray, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 11.
		* Expected result: Color.lightGray.
		*/
		@Test
		public void testGetColor_11() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 11;
				Color result = fixture.getColor(row);
				assertEquals(Color.lightGray, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 12.
		* Expected result: Color.lightGray.
		*/
		@Test
		public void testGetColor_12() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 12;
				Color result = fixture.getColor(row);
				assertEquals(Color.lightGray, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 13.
		* Expected result: Color.lightGray.
		*/
		@Test
		public void testGetColor_13() {
				RowColorModel fixture = new RowColorModel(new ChartDataModel());
				int row = 13;
				Color result = fixture.getColor(row);
				assertEquals(Color.lightGray, result);
		}
		
		/**
		* Test case for {@link RowColorModel#getColor(int)} method.
		* Test data: row = 14.
		* Expected result: Color.lightGray.
		*/
		@Test
		public void testGetColor_14() {
				RowColorModel fixture ="
cmpl-6tu3U6ERBPvmNq5yyPm2rF5Z0iTU6,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/RowColorModel_3Test.java,39.937633752822876,length,"// RowColorModel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    RowColorModel.java
    Created on 28. August 2001, 20:02
*/
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;

/**
 * This class implements the correspondence between the DataSets and the
 * colors used for rendering the charts and the legend.
 * @author mueller
 * @version 1.0
 */
public class RowColorModel {

    private static RowColorModel instance;

    protected ChartDataModel model;

    protected final static Color[] predefinedColors = { Color.blue, Color.cyan, Color.red, Color.pink, Color.yellow, Color.green, Color.magenta, Color.orange, Color.darkGray, Color.gray, Color.lightGray };

    public static final Ellipse2D ELLIPSE_SHAPE = new Ellipse2D.Float(0f, 0f, 5f, 5f);

    public static final Rectangle2D SQUARE_SHAPE = new Rectangle2D.Float(0f, 0f, 5f, 5f);

    public static final Diamond2D DIAMOND_SHAPE = new Diamond2D(0f, 0f, 5f, 5f);

    public static final Triangle2D TRIANGLE_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, false);

    public static final Triangle2D TRIANGLEDOWN_SHAPE = new Triangle2D(0f, 0f, 5f, 5f, true);

    protected final static RectangularShape[] predefinedShapes = { ELLIPSE_SHAPE, SQUARE_SHAPE, DIAMOND_SHAPE, TRIANGLE_SHAPE, TRIANGLEDOWN_SHAPE };

    protected int predefinedColorsIdx = 0;

    protected HashMap customColors = new HashMap();

    protected HashMap customShapes = new HashMap();

    /**
     * Creates new RowColorModel.
     * @param model the ChartDataModel which contains the information about all the DataSets
     */
    public RowColorModel(ChartDataModel model) {
        this.model = model;
    }

    /**
     * Use this method to get an instance of the chart's RowColorModel.
     * @param model the ChartDataModel whose data sets will be mapped to
     * colors.
     * @return a new instance of RowColorModel if there's no instance
     * of if the model has changed (esp. useful if you create multiple charts
     * after one another).
     * @deprecated
     */
    public static RowColorModel getInstance(ChartDataModel model) {
        if (instance == null || !model.equals(instance.model))
            instance = new RowColorModel(model);
        return instance;
    }

    /**
     * Computes the amount of all Legend entries, ie. DataSets.
     * @return the amount of all rows, ie. DataSets.
     */
    public int getRowCount() {
        return model.getDataSetNumber();
    }

    /**
     * Returns the row title of a specific DataSet.
     * @param i the DataSet index
     * @return the String title
     */
    public String getRow(int i) {
        return model.getDataSetName(i);
    }

    /**
     * Computes the Color for a DataSet. For the first DataSets the stored Colors like <CODE>Color.red</CODE> etc are used. If there are more DataSets than stored colors, random colors are used.
     * @param row the row for which the Color should be returned
     * @return the Color stored for the given row.
     */
    public Color getColor(int row) {
        // get the custom color
        Color c = (Color) customColors.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // see if there is a predefined color for this row
            if (predefinedColorsIdx < predefinedColors.length) {
                c = predefinedColors[predefinedColorsIdx++];
            } else {
                c = new Color((float) Math.random(), (float) Math.random(), (float) Math.random());
            }
            // remember this
            customColors.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Returns the Shape for a DataSet. By default, the Shapes from
     * the <code>predefinedShapes</code> array are cycled through unless you define
     * your own shape to data binding using
     * <code>setShape(int row, RectangularShape shape)</code>.
     * @param row the row for which the Shape should be returned
     * @return the Shape stored for the given row.
     */
    public RectangularShape getShape(int row) {
        // get the custom color
        RectangularShape c = (RectangularShape) customShapes.get(new Integer(row));
        // if no custom color
        if (c == null) {
            // calculate the matching predefined shape by a modulo operation
            c = predefinedShapes[row % predefinedShapes.length];
            // remember this
            customShapes.put(new Integer(row), c);
        }
        // done
        return c;
    }

    /**
     * Force a certain color for a row
     * @param row the row for which the Color should be set
     * @param color the color that is associated with the row
     */
    public void setColor(int row, Color color) {
        customColors.put(new Integer(row), color);
    }

    /**
     * Force a certain Shape for a row
     * @param row the row for which the Shape should be set
     * @param shape the RectangularShape that is associated with the row
     */
    public void setShape(int row, RectangularShape shape) {
        customShapes.put(new Integer(row), shape);
    }
}
","// RowColorModel_3Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getShape(int)} method.
*/
class RowColorModel_3Test {","// RowColorModel_3Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getShape(int)} method.
*/
class RowColorModel_3Test {

	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 0.
	* Expected result: {@link RowColorModel#ELLIPSE_SHAPE}.
	*/
	@Test
	void testGetShape_0() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(0);
		assertEquals(RowColorModel.ELLIPSE_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 1.
	* Expected result: {@link RowColorModel#SQUARE_SHAPE}.
	*/
	@Test
	void testGetShape_1() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(1);
		assertEquals(RowColorModel.SQUARE_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 2.
	* Expected result: {@link RowColorModel#DIAMOND_SHAPE}.
	*/
	@Test
	void testGetShape_2() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(2);
		assertEquals(RowColorModel.DIAMOND_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 3.
	* Expected result: {@link RowColorModel#TRIANGLE_SHAPE}.
	*/
	@Test
	void testGetShape_3() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(3);
		assertEquals(RowColorModel.TRIANGLE_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 4.
	* Expected result: {@link RowColorModel#TRIANGLEDOWN_SHAPE}.
	*/
	@Test
	void testGetShape_4() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(4);
		assertEquals(RowColorModel.TRIANGLEDOWN_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 5.
	* Expected result: {@link RowColorModel#ELLIPSE_SHAPE}.
	*/
	@Test
	void testGetShape_5() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(5);
		assertEquals(RowColorModel.ELLIPSE_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 6.
	* Expected result: {@link RowColorModel#SQUARE_SHAPE}.
	*/
	@Test
	void testGetShape_6() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(6);
		assertEquals(RowColorModel.SQUARE_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 7.
	* Expected result: {@link RowColorModel#DIAMOND_SHAPE}.
	*/
	@Test
	void testGetShape_7() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(7);
		assertEquals(RowColorModel.DIAMOND_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 8.
	* Expected result: {@link RowColorModel#TRIANGLE_SHAPE}.
	*/
	@Test
	void testGetShape_8() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(8);
		assertEquals(RowColorModel.TRIANGLE_SHAPE, result);
	}
	
	/**
	* Test case for {@link RowColorModel#getShape(int)} method.
	* Test data: row = 9.
	* Expected result: {@link RowColorModel#TRIANGLEDOWN_SHAPE}.
	*/
	@Test
	void testGetShape_9() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		RectangularShape result = rowColorModel.getShape(9);
		assertEquals(RowColorModel.TRIANGLEDOWN_SHAPE, result);
	}
	
}

// RowColorModel_4Test.java
package de.progra.charting.render;

import java.awt.Color;
import de.progra.charting.model.ChartDataModel;
import java.util.HashMap;
import java.awt.geom.RectangularShape;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Rectangle2D;
import de.progra.charting.render.shape.Diamond2D;
import de.progra.charting.render.shape.Triangle2D;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link RowColorModel}.
* It contains ten unit test cases for the {@link RowColorModel#getColor(int)} method.
*/
class RowColorModel_4Test {
		
	/**
	* Test case for {@link RowColorModel#getColor(int)} method.
	* Test data: row = 0.
	* Expected result: {@link RowColorModel#predefinedColors}[0].
	*/
	@Test
	void testGetColor_0() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		Color result = rowColorModel.getColor(0);
		assertEquals(RowColorModel.predefinedColors[0], result);
	}
	
	/**
	* Test case for {@link RowColorModel#getColor(int)} method.
	* Test data: row = 1.
	* Expected result: {@link RowColorModel#predefinedColors}[1].
	*/
	@Test
	void testGetColor_1() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		Color result = rowColorModel.getColor(1);
		assertEquals(RowColorModel.predefinedColors[1], result);
	}
	
	/**
	* Test case for {@link RowColorModel#getColor(int)} method.
	* Test data: row = 2.
	* Expected result: {@link RowColorModel#predefinedColors}[2].
	*/
	@Test
	void testGetColor_2() {
		RowColorModel rowColorModel = new RowColorModel(new ChartDataModel());
		Color result = rowColorModel.getColor(2);
		assertEquals(RowColorModel.predefinedColors[2], result);
	}
	
	/**
	* Test case for {@link RowColorModel#getColor(int)} method.
	* Test data: row = 3.
	"
cmpl-6tu4XuhwplPnh37w8A6v8pAUeoNzS,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/render/shape/Diamond2D_0Test.java,21.30911684036255,stop,"// Diamond2D.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    Diamond2D.java
    Created on 11. September 2002, 22:01
*/
package de.progra.charting.render.shape;

import java.awt.geom.RectangularShape;
import java.awt.geom.Rectangle2D;
import java.awt.geom.PathIterator;
import java.awt.geom.AffineTransform;

/**
 * This class implements a diamond like Shape object.
 * @author  mueller
 * @version 1.0
 */
public class Diamond2D extends RectangularShape {

    protected double x, y, width, height;

    /**
     * Creates a Diamond shape with the specified coordinates.
     */
    public Diamond2D(double x, double y, double width, double height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    /**
     * Returns the height.
     */
    public double getHeight() {
        return height;
    }

    /**
     * Returns the width.
     */
    public double getWidth() {
        return width;
    }

    /**
     * Returns the x-coordinate.
     */
    public double getX() {
        return x;
    }

    /**
     * Returns the y-coordinate.
     */
    public double getY() {
        return y;
    }

    /**
     * Returns true if the bounding box is empty.
     */
    public boolean isEmpty() {
        return (width <= 0.0) || (height <= 0.0);
    }

    /**
     * Sets the framing rectangle.
     */
    public void setFrame(double x, double y, double width, double height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    public Rectangle2D getBounds2D() {
        return new Rectangle2D.Double(x, y, height, width);
    }

    /**
     * Returns the object's PathIterator.
     */
    public PathIterator getPathIterator(AffineTransform at) {
        return new PathIterator() {

            int state = 0;

            int maxstate = 4;

            float[][] fcurrentSegment = { { (float) (x + width / 2), (float) y, 0f, 0f, 0f, 0f }, { (float) x, (float) (y + height / 2), 0f, 0f, 0f, 0f }, { (float) (x + width / 2), (float) (y + height), 0f, 0f, 0f, 0f }, { (float) (x + width), (float) (y + height / 2), 0f, 0f, 0f, 0f }, { 0f, 0f, 0f, 0f, 0f, 0f } };

            double[][] dcurrentSegment = { { x + width / 2, y, 0.0, 0.0, 0.0, 0.0 }, { x, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { x + width / 2, y + height, 0.0, 0.0, 0.0, 0.0 }, { x + width, y + height / 2, 0.0, 0.0, 0.0, 0.0 }, { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0 } };

            int[] segment = { PathIterator.SEG_MOVETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_LINETO, PathIterator.SEG_CLOSE };

            public int currentSegment(double[] coords) {
                coords[0] = dcurrentSegment[state][0];
                coords[1] = dcurrentSegment[state][1];
                return segment[state];
            }

            public int currentSegment(float[] coords) {
                coords[0] = fcurrentSegment[state][0];
                coords[1] = fcurrentSegment[state][1];
                return segment[state];
            }

            public int getWindingRule() {
                return PathIterator.WIND_NON_ZERO;
            }

            public boolean isDone() {
                return (state == maxstate);
            }

            public void next() {
                state++;
            }
        };
    }

    public boolean contains(double x, double y, double w, double h) {
        return false;
    }

    public boolean contains(double x, double y) {
        return false;
    }

    public boolean intersects(double x, double y, double w, double h) {
        return false;
    }
}
","// Diamond2D_0Test.java
package de.progra.charting.render.shape;

import java.awt.geom.RectangularShape;
import java.awt.geom.Rectangle2D;
import java.awt.geom.PathIterator;
import java.awt.geom.AffineTransform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Diamond2D}.
* It contains ten unit test cases for the {@link Diamond2D#getPathIterator(AffineTransform)} method.
*/
class Diamond2D_0Test {","// Diamond2D_0Test.java
package de.progra.charting.render.shape;

import java.awt.geom.RectangularShape;
import java.awt.geom.Rectangle2D;
import java.awt.geom.PathIterator;
import java.awt.geom.AffineTransform;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Diamond2D}.
* It contains ten unit test cases for the {@link Diamond2D#getPathIterator(AffineTransform)} method.
*/
class Diamond2D_0Test {

	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_0() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_1() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_2() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_3() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_4() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_5() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_6() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_7() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_8() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
	/**
	* Test case for {@link Diamond2D#getPathIterator(AffineTransform)} method.
	*/
	@Test
	void testGetPathIterator_9() {
		Diamond2D diamond2D = new Diamond2D(0.0, 0.0, 0.0, 0.0);
		PathIterator pathIterator = diamond2D.getPathIterator(null);
		assertNotNull(pathIterator);
	}
	
}"
cmpl-6tu5aSlgbeYvJt7YRFEhAqsNhxZBH,/EvoSuiteBenchmark/88_jopenchart/src/main/java/de/progra/charting/swing/ChartPanel.java,38.684738636016846,stop,"// ChartPanel.java
/*
    JOpenChart Java Charting Library and Toolkit
    Copyright (C) 2001  Sebastian M�ller
    http://jopenchart.sourceforge.net

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    ChartPanel.java
    Created on 6. September 2001, 14:10
*/
package de.progra.charting.swing;

import javax.swing.JPanel;
import de.progra.charting.render.AbstractChartRenderer;
import de.progra.charting.event.*;
import de.progra.charting.Chart;
import de.progra.charting.Legend;
import de.progra.charting.Title;
import de.progra.charting.CoordSystem;
import de.progra.charting.DefaultChart;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.util.Map;
import de.progra.charting.model.ChartDataModel;

/**
 * This Panel provides the possibility to include a Chart into a Swing
 * Application. I choose not to make every Chart extend JComponent because
 * of the overhead this would have meant. Instead, this class is an adaptor.
 * It implements the Chart interface and contains a DefaultChart instance
 * to which all Chart calls are promoted.
 * @author  mueller
 */
public class ChartPanel extends JPanel implements Chart {

    /**
     * The chart instance to which all method calls are promoted.
     */
    DefaultChart chart;

    /**
     * Creates new ChartPanel
     */
    private ChartPanel() {
    }

    /**
     * Creates a new ChartPanel with the given model
     * and title string.
     * @param model the ChartDataModel
     * @param title the title String
     */
    public ChartPanel(ChartDataModel model, String title) {
        this();
        chart = new DefaultChart(model, title);
    }

    /**
     * Creates a new ChartPanel with the given model
     * and title string and a coordinate system.
     * @param model the ChartDataModel
     * @param title the title String
     * @param coord the id of the coordinate system configuration
     */
    public ChartPanel(ChartDataModel model, String title, int coord) {
        this();
        chart = new DefaultChart(model, title, coord);
    }

    /**
     * This method is write-protected by the IDE but isn't used at all.
     */
    private void initComponents() {
        //GEN-BEGIN:initComponents
        setLayout(new java.awt.BorderLayout());
    }

    //GEN-END:initComponents
    /**
     * Adds a ChartRenderer with a specific z-coordinate.
     * @param renderer the ChartRenderer
     * @param z its z-coordinate.
     */
    public void addChartRenderer(AbstractChartRenderer renderer, int z) {
        chart.addChartRenderer(renderer, z);
    }

    /**
     * Returns the Bounds for the ChartPanel.
     * @return the bounds
     */
    public Rectangle getBounds() {
        return chart.getBounds();
    }

    /**
     * Returns the ChartDataModel.
     * @return the ChartDataModel
     */
    public ChartDataModel getChartDataModel() {
        return chart.getChartDataModel();
    }

    /**
     * Returns the Map of all ChartRenderers.
     * @return the Map of Renderers.
     */
    public Map getChartRenderer() {
        return chart.getChartRenderer();
    }

    /**
     * Returns the ChartRenderer with a specific z-coordinate.
     * @param z the z-coordinate of the desired ChartRenderer.
     * @return the ChartRenderer or <CODE>null</CODE> if none has been found.
     */
    public AbstractChartRenderer getChartRenderer(int z) {
        return chart.getChartRenderer(z);
    }

    /**
     * Returns the coordinate system.
     * @return the Coordinate System for the Chart. Could be <CODE>null</CODE>.
     */
    public CoordSystem getCoordSystem() {
        return chart.getCoordSystem();
    }

    /**
     * Returns this chart's legend.
     * @return the Legend for this Chart. Could be <CODE>null</CODE>.
     */
    public Legend getLegend() {
        return chart.getLegend();
    }

    /**
     * Returns the title for this chart.
     * @return this Chart's Title. Could be <CODE>null</CODE>.
     */
    public Title getTitle() {
        return chart.getTitle();
    }

    /**
     * Sets the Bounds for this Chart.
     * @param r the <CODE>Rectangle</CODE> object defining the bounds
     */
    public void setBounds(Rectangle r) {
        chart.setBounds(r);
    }

    /**
     * Stores the ChartDataModel for this Chart.
     * @param model the ChartDataModel
     */
    public void setChartDataModel(ChartDataModel model) {
        chart.setChartDataModel(model);
    }

    /**
     * Sets the Map with all ChartRenderers. The keys
     * have to be the z-coordinates of the ChartRenderers.
     * @param renderer The Map of ChartRenderers.
     */
    public void setChartRenderer(Map renderer) {
        chart.setChartRenderer(renderer);
    }

    /**
     * Sets the coordinate system for this chart,
     * which can be null if the ChartRenderer
     * doesn't need a coordinate system, e.g. if it's a
     * PieChart.
     * @param c The Coordinate System for the Chart.
     */
    public void setCoordSystem(CoordSystem c) {
        chart.setCoordSystem(c);
    }

    /**
     * Sets the legend for this chart.
     * @param l The Legend this Chart contains.
     */
    public void setLegend(Legend l) {
        chart.setLegend(l);
    }

    /**
     * Sets the title for this chart.
     * @param t This Chart's Title.
     */
    public void setTitle(Title t) {
        chart.setTitle(t);
    }

    /**
     * Computes the preferred size of the ChartPanel.
     * @return <code>new java.awt.Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE)</code>
     */
    public Dimension getPreferredSize() {
        return new java.awt.Dimension(Integer.MAX_VALUE, Integer.MAX_VALUE);
    }

    /**
     * Paints the ChartPanel. Calls <code>chart.render((Graphics2D)graphics)</code>
     * @param graphics the Graphics2D object to paint in
     */
    public void paint(Graphics graphics) {
        chart.setBounds(new Rectangle(this.getWidth(), this.getHeight()));
        chart.render((Graphics2D) graphics);
    }

    /**
     * Does the layout of the title, legend and coordinate system and
     * calls the render method of all those including the ChartRenderers.
     * @param g the <CODE>Graphics2D</CODE> object to paint in.
     * Just calls paint(Graphics).
     */
    public void render(Graphics2D g) {
        paint(g);
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}
","// ChartPanelTest.java
package de.progra.charting.swing;

import javax.swing.JPanel;
import de.progra.charting.render.AbstractChartRenderer;
import de.progra.charting.event.*;
import de.progra.charting.Chart;
import de.progra.charting.Legend;
import de.progra.charting.Title;
import de.progra.charting.CoordSystem;
import de.progra.charting.DefaultChart;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.util.Map;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartPanel}.
* It contains ten unit test cases for the {@link ChartPanel#getChartRenderer(int)} method.
*/
class ChartPanelTest {","// ChartPanelTest.java
package de.progra.charting.swing;

import javax.swing.JPanel;
import de.progra.charting.render.AbstractChartRenderer;
import de.progra.charting.event.*;
import de.progra.charting.Chart;
import de.progra.charting.Legend;
import de.progra.charting.Title;
import de.progra.charting.CoordSystem;
import de.progra.charting.DefaultChart;
import java.awt.geom.Rectangle2D;
import java.awt.Rectangle;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Dimension;
import java.util.Map;
import de.progra.charting.model.ChartDataModel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChartPanel}.
* It contains ten unit test cases for the {@link ChartPanel#getChartRenderer(int)} method.
*/
class ChartPanelTest {

		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 1);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(1));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer2() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 2);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(2));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer3() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 3);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(3));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer4() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 4);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(4));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer5() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 5);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(5));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer6() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 6);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(6));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer7() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 7);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(7));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer8() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 8);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(8));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer9() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 9);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(9));
		}
		
		/**
		* Test case for the {@link ChartPanel#getChartRenderer(int)} method.
		* The test case tests if the method returns the correct ChartRenderer.
		*/
		@Test
		void testGetChartRenderer10() {
				ChartPanel chartPanel = new ChartPanel();
				AbstractChartRenderer chartRenderer = new AbstractChartRenderer() {
						public void render(Graphics2D g) {
						}
				};
				chartPanel.addChartRenderer(chartRenderer, 10);
				assertEquals(chartRenderer, chartPanel.getChartRenderer(10));
		}
}"
