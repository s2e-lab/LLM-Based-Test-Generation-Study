ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6ttd1S11P6rxjRZuO008l9pxE2Wzg,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/ChatPanel.java,26.78689169883728,stop,"// ChatPanel.java
/* $Id: ChatPanel.java,v 1.6 2004/05/02 23:01:54 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 *
 * @author: Bartek Tatkowski
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.6 $
 *
 */
package gui;

import java.awt.event.*;
import java.awt.BorderLayout;
import java.awt.Insets;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.JTabbedPane;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JScrollPane;
import javax.swing.JButton;
import java.util.ResourceBundle;
import java.util.Locale;
import java.util.Hashtable;
import module.GUIModule;
import module.Kernel;
import module.AbstractModule;
import module.Message;
import module.ModuleRegisterException;
import module.Module;
import module.MessageProcessingException;
import module.MessageDeliveryException;
import static module.MessageFactory.*;

/**
 * The chat panel.
 */
public class ChatPanel extends JPanel {

    /**
     * Localized strings.
     */
    protected ResourceBundle locale;

    /**
     * The tabs representing different chat windows.
     */
    JTabbedPane tabs;

    ChatListener chatlistener;

    //DebugPanel debugPanel;
    GUIModule module;

    Hashtable<Object, ChatTabPanel> chattabs;

    /**
     * This class subscribes to every message topic, so it will
     * receive all messages sent with null recipient.
     */
    @module.mod(name = ""SnoopyModule"")
    private class SnoopyModule extends AbstractModule {

        SnoopyModule(Kernel krn) throws ModuleRegisterException {
            super(krn);
        }

        public void sendTextMessage(String topic, String data) {
            try {
                createMessage(topic, data).send(this);
            } catch (MessageDeliveryException e) {
                e.printStackTrace(System.err);
            }
        }

        protected void processKernelMessage(Message m) throws MessageProcessingException {
            try {
                //debugPanel.append(m);
                if (m.getBody().equals(""REGISTERED"")) {
                    subscribe(""*"");
                }
            } catch (Exception e) {
                throw new MessageProcessingException(this, m, e);
            }
        }

        protected void processMessage(Message m) {
            //debugPanel.append(m);
        }
    }

    /**
     * Creates a new ChatPanel.
     */
    public ChatPanel(GUIModule mod) {
        module = mod;
        locale = ResourceBundle.getBundle(""gangup"", Locale.getDefault());
        chatlistener = new ChatListener();
        chattabs = new Hashtable<Object, ChatTabPanel>();
        tabs = new JTabbedPane();
        setLayout(new BorderLayout());
        add(tabs, BorderLayout.CENTER);
        addTab(module.GENERAL_MESSAGE);
        addTab(module.GROUP_MESSAGE);
        //try {
        //SnoopyModule snoopy = new SnoopyModule(mod.getKernel());
        //addDebugTab(snoopy);
        //snoopy.start();
        //} catch (ModuleRegisterException e) {
        // e.printStackTrace(System.err);
        //}
        tabs.setSelectedComponent(chattabs.get(module.GENERAL_MESSAGE));
        tabs.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);
    }

    /**
     * Adds a tab to the tabbed pane.
     *
     * @param name The identifying object of this tab. This must be
     * the same object passed to a removeTab call, or when specifying
     * which tab to write to with a writeTo call. Also, when text is
     * written in this inputfield, this Object is sent as target.
     * @return The tab just created.
     */
    public ChatTabPanel addTab(Object id) {
        if (!chattabs.containsKey(id)) {
            ChatTabPanel panel = new ChatTabPanel(id);
            chattabs.put(id, panel);
            tabs.add(panel, id.toString());
            tabs.setSelectedComponent(panel);
            return panel;
        }
        return null;
    }

    /*
    private DebugPanel addDebugTab(Module source) {
	if (debugPanel == null) {
	    debugPanel = new DebugPanel(module.getKernel());
	    tabs.add(debugPanel,""Debug"");
	}
	return debugPanel;
    }
    */
    /**
     * Removes a tab to the tabbed pane.
     *
     * @param id The identifying object of this tab. This must be
     * the same object passed to the addTab call, or when specifying
     * which tab to write to with a writeTo call. Also, when text is
     * written in this inputfield, this Object is sent as target.
     */
    public void removeTab(Object id) {
        ChatTabPanel panel = chattabs.get(id);
        tabs.remove(panel);
        chattabs.remove(id);
    }

    /**
     * Writes the specified text to the text area identified by id.
     *
     * @param id The identifying object of this tab. This must be
     * the same object passed to the addTab call, or when specifying
     * which tab to write to with a writeTo call. Also, when text is
     * written in this inputfield, this Object is sent as target.
     */
    public void writeTo(Object id, String text) {
        ChatTabPanel ctp = chattabs.get(id);
        if (ctp == null) {
            ctp = addTab(id);
        }
        ctp.outputarea.append(text + ""\n"");
        ctp.scroll.getVerticalScrollBar().setValue(ctp.scroll.getVerticalScrollBar().getMaximum());
    }

    /**
     * Listener that listens if the player sends a message to the chat.
     */
    private class ChatListener extends KeyAdapter implements ActionListener {

        /**
         * Called whenever a key is typed.
         */
        public void keyTyped(KeyEvent e) {
            if (e.getKeyChar() == KeyEvent.VK_ENTER) {
                sendText();
            }
        }

        private void sendText() {
            ChatTabPanel p = (ChatTabPanel) tabs.getSelectedComponent();
            JTextField txt = p.inputfield;
            module.sendTextMessage(txt.getText(), p.identifier);
            txt.setText("""");
        }

        public void actionPerformed(ActionEvent e) {
            if (e.getActionCommand().equals(""send"")) {
                sendText();
            } else if (e.getActionCommand().equals(""close"")) {
                ChatTabPanel p = (ChatTabPanel) tabs.getSelectedComponent();
                if (p != chattabs.get(module.GENERAL_MESSAGE) && p != chattabs.get(module.GROUP_MESSAGE)) {
                    removeTab(p.identifier);
                }
            }
        }
    }

    private class ChatTabPanel extends JPanel {

        Object identifier;

        JTextField inputfield;

        JButton inputsend;

        JButton inputclose;

        JTextArea outputarea;

        JScrollPane scroll;

        ChatTabPanel(Object id) {
            identifier = id;
            setLayout(new BorderLayout());
            outputarea = new JTextArea();
            outputarea.setEditable(false);
            outputarea.setRows(5);
            scroll = new JScrollPane(outputarea);
            JPanel inputpanel = new JPanel();
            inputfield = new JTextField();
            JLabel inputtext = new JLabel("" "" + locale.getString(""_GUI_INPUTTEXT"") + "" "");
            inputsend = new JButton(locale.getString(""_GUI_SEND_BUTTON""));
            inputclose = new JButton(locale.getString(""_GUI_CLOSE_BUTTON""));
            inputsend.setActionCommand(""send"");
            inputclose.setActionCommand(""close"");
            inputsend.addActionListener(chatlistener);
            inputclose.addActionListener(chatlistener);
            JPanel temp = new JPanel();
            temp.setLayout(new BorderLayout());
            temp.add(inputsend, BorderLayout.CENTER);
            temp.add(inputclose, BorderLayout.EAST);
            inputpanel.setLayout(new BorderLayout());
            inputpanel.add(inputtext, BorderLayout.WEST);
            inputpanel.add(inputfield, BorderLayout.CENTER);
            inputpanel.add(temp, BorderLayout.EAST);
            add(scroll, BorderLayout.CENTER);
            add(inputpanel, BorderLayout.SOUTH);
            inputfield.addKeyListener(chatlistener);
        }
    }
}
","// ChatPanelTest.java
package gui;

import java.awt.event.*;
import java.awt.BorderLayout;
import java.awt.Insets;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.JTabbedPane;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JScrollPane;
import javax.swing.JButton;
import java.util.ResourceBundle;
import java.util.Locale;
import java.util.Hashtable;
import module.GUIModule;
import module.Kernel;
import module.AbstractModule;
import module.Message;
import module.ModuleRegisterException;
import module.Module;
import module.MessageProcessingException;
import module.MessageDeliveryException;
import static module.MessageFactory.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChatPanel}.
* It contains ten unit test cases for the {@link ChatPanel#addTab(Object)} method.
*/
class ChatPanelTest {","// ChatPanelTest.java
package gui;

import java.awt.event.*;
import java.awt.BorderLayout;
import java.awt.Insets;
import javax.swing.JPanel;
import javax.swing.JLabel;
import javax.swing.JTabbedPane;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JScrollPane;
import javax.swing.JButton;
import java.util.ResourceBundle;
import java.util.Locale;
import java.util.Hashtable;
import module.GUIModule;
import module.Kernel;
import module.AbstractModule;
import module.Message;
import module.ModuleRegisterException;
import module.Module;
import module.MessageProcessingException;
import module.MessageDeliveryException;
import static module.MessageFactory.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ChatPanel}.
* It contains ten unit test cases for the {@link ChatPanel#addTab(Object)} method.
*/
class ChatPanelTest {

	/**
	* Test case 1 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab1() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		chatPanel.addTab(id);
		assertNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 2 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab2() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		assertNotNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 3 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab3() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		chatPanel.addTab(id);
		assertNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 4 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab4() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		assertNotNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 5 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab5() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		chatPanel.addTab(id);
		assertNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 6 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab6() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		assertNotNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 7 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab7() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		chatPanel.addTab(id);
		assertNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 8 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab8() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		assertNotNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 9 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab9() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		chatPanel.addTab(id);
		assertNull(chatPanel.addTab(id));
	}
	
	/**
	* Test case 10 for the {@link ChatPanel#addTab(Object)} method.
	* This test case checks if the method returns null when the hashtable already contains the key.
	*/
	@Test
	void testAddTab10() {
		ChatPanel chatPanel = new ChatPanel(new GUIModule(new Kernel()));
		Object id = new Object();
		assertNotNull(chatPanel.addTab(id));
	}
}"
cmpl-6tte45ottgYCWygVX1Y4sP7y8Yiht,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/Map_0Test.java,19.414021968841553,stop,"// Map.java
/**
 * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties.
 *
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 */
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;

/**
 * The MapEdit implementation of Map. Some things may be altered to
 * work better with the WorldView in the GUI.
 */
public class Map {

    private final static int WORLD_OFFSET_X = 672;

    private final static int WORLD_OFFSET_Y = 32;

    private final static int GRID_OFFSET_X = 14;

    private final static int GRID_OFFSET_Y = -2;

    static final int MAX_NUM_CELLS = 1000;

    public final static int N_LAYERS = 4;

    public final static int PLAYER_LAYER = 2;

    MapCell[][] cell;

    MapTile[] tileList;

    int numOfTiles;

    int[] numOfCells;

    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();

    /**
     * Each tile represents one different kind of tile that can be placed
     * on the map.
     */
    public static class MapTile {

        public String name;

        public Image image;

        private static final Toolkit tk;

        static {
            tk = Toolkit.getDefaultToolkit();
        }

        public MapTile(String fileName) throws IOException {
            name = fileName;
            image = tk.getImage(fileName);
        }
    }

    /**
     * Each cell is the smallest part of the map.
     */
    public static class MapCell {

        float x, y;

        int tile, layer;

        float depthvalue;

        public MapCell(int x, int y, int tile, int layer) {
            this((float) x, (float) y, tile, layer);
        }

        public MapCell(int x, int y, int tile) {
            this(x, y, tile, 0);
        }

        public MapCell(float x, float y, int tile, int layer) {
            this.x = x;
            this.y = y;
            this.tile = tile;
            this.layer = layer;
        }

        public String toString() {
            return String.format(""MapCell[x=%f,y=%f,tile=%d,layer=%d]"", x, y, tile, layer);
        }
    }

    public static class MapPlayerCell extends MapCell {

        Player p;

        public MapPlayerCell(Player p1) {
            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);
            p = p1;
        }
    }

    /**
     * Compares two MapCells and determine their order.
     */
    private class MapCellComparator implements Comparator<MapCell> {

        // MapCellComparator() { /* ... */ }
        public int compare(MapCell src, MapCell dst) {
            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));
        }

        /*if (src.y > src.x) {
		if (src.y > dst.y)
		    return 1;
		if (src.y < dst.y)
		    return -1;
		return 0;
	    }

	    if (src.y < src.x) {
		if (src.x > dst.x)
		    return 1;
		if (src.x < dst.x)
		    return -1;
		return 0;
	    }
	    
	    if (src.x+src.y > dst.x+dst.y)
		return 1;
	    if (src.x+src.y < dst.x+dst.y)
		return -1;
		return 0;
	}*/
        private float depthvalue(MapCell c) {
            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;
        }

        public boolean equals(Object obj) {
            return obj == this;
        }
    }

    /**
     * Creates a new instance of the Map class.
     * @param fileName the name of the map to open.
     */
    public Map(String fileName) throws IOException {
        open(fileName);
    }

    /**
     * Open the specified map fileName.
     * @param fileName the name of the file to open.
     */
    public Map open(String fileName) throws IOException {
        //System.err.println(""Map.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[4];
        //numOfCells = Integer.parseInt(in.readLine());
        numOfCells = new int[N_LAYERS];
        int readNumOfTiles = Integer.parseInt(in.readLine());
        numOfTiles = Integer.parseInt(in.readLine());
        cell = new MapCell[N_LAYERS][];
        for (i = 0; i < N_LAYERS; i++) {
            cell[i] = new MapCell[MAX_NUM_CELLS];
        }
        tileList = new MapTile[numOfTiles];
        for (i = 0; i < numOfTiles; i++) {
            tileList[i] = new MapTile(in.readLine());
        }
        j = 0;
        int[] c = new int[N_LAYERS];
        while (st.nextToken() != st.TT_EOF) {
            if (j > 3) {
                numOfCells[tmp[3]]++;
                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == 4) {
            numOfCells[tmp[3]]++;
            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
            // System.err.println(""Map.open(): Missing end of line!"");
        }
        //if ( != numOfCells) {
        //    System.err.println(""Map.open(): Unable to open file!"");
        //}
        in.close();
        try {
            MediaTracker tracker = new MediaTracker(new Frame());
            for (MapTile t : tileList) {
                tracker.addImage(t.image, 0);
            }
            //System.err.println(""Map.open(): waiting for images!"");
            tracker.waitForAll();
        } catch (InterruptedException e) {
            e.printStackTrace(System.err);
        }
        return this;
    }

    /**
     * Lookup and return the MapCell at the specified x and y coordinates.
     * Returns null if no MapCell is found. This method does a linear
     * search through all the cells. This is considered a bug!
     *
     * @param x the x-coordinate of the MapCell.
     * @param y the y-coordinate of the MapCell.
     * @return The MapCell at the coordinates, or null if not exists.
     */
    public MapCell lookup(int x, int y) {
        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {
            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {
                return cell[PLAYER_LAYER][i];
            }
        }
        return null;
    }

    /**
     * Converts the input coordinats in screen space to their respective
     * coordinates in world space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point pixelTransform(int x, int y, int z) {
        return new Point(x + 2 * (y + z), y - (x + z) / 2);
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in screen space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point worldTransform(float x, float y) {
        //return new Point( (int) ((x - z) / 2 - z - y),
        //		  (int) ((x + 2 * (y - z) + z) / 4));
        x += GRID_OFFSET_X;
        y += GRID_OFFSET_Y;
        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in defined grid.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point gridTransform(int x, int y) {
        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;
	int i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;

	j = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);
	i = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);

	return new Point(j, i);*/
        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);
    }

    public MapCell addPlayerCell(Player p) {
        MapCell c = new MapPlayerCell(p);
        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;
        sortCells(PLAYER_LAYER);
        playercells.put(p, c);
        return c;
    }

    public void updatePlayerCell(Player p) {
        if (p.isDead()) {
            MapCell m = playercells.get(p);
            m.tile = 39;
        } else {
            MapCell m = playercells.get(p);
            m.x = p.getX();
            m.y = p.getY();
        }
    }

    public void sortCells(int layer) {
        //System.err.print(""Sorting... "");
        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());
        //System.err.println(""done!"");
    }

    /**
     * Paints a layer of this map on a Graphics object.
     */
    public void draw(Graphics2D g, int layer) {
        int i, z, w, h;
        float x, y;
        MapTile t;
        Point p;
        i = 0;
        try {
            for (i = 0; i < numOfCells[layer]; i++) {
                x = cell[layer][i].x;
                y = cell[layer][i].y;
                z = cell[layer][i].tile;
                /* check whether this cell should be drawn */
                if (z != -1) {
                    t = tileList[z];
                    w = t.image.getWidth(null);
                    h = t.image.getHeight(null);
                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,
                    //	       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);
                    p = worldTransform(x, y);
                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);
                }
            }
        } catch (Exception e) {
            System.err.printf(""MapGrid.paint(): i=%d l=%d\n"", i, cell.length);
            e.printStackTrace(System.err);
        }
    }

    public String toString() {
        return ""Map[]"";
    }
}
","// Map_0Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#open(String)} method.
*/
class Map_0Test {","// Map_0Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#open(String)} method.
*/
class Map_0Test {

		/**
		* Test case 1 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_1() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 2 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_2() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 3 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_3() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 4 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_4() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 5 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_5() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 6 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_6() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 7 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_7() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 8 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_8() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 9 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_9() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
		
		/**
		* Test case 10 for {@link Map#open(String)}.
		* It tests if the method can open a map file.
		*/
		@Test
		void testOpen_10() {
				Map map = new Map(""maps/testmap.map"");
				assertNotNull(map);
		}
}"
cmpl-6ttf7RyoEsF6fof04lU3df11U6oed,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/Map_1Test.java,21.268107652664185,stop,"// Map.java
/**
 * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties.
 *
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 */
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;

/**
 * The MapEdit implementation of Map. Some things may be altered to
 * work better with the WorldView in the GUI.
 */
public class Map {

    private final static int WORLD_OFFSET_X = 672;

    private final static int WORLD_OFFSET_Y = 32;

    private final static int GRID_OFFSET_X = 14;

    private final static int GRID_OFFSET_Y = -2;

    static final int MAX_NUM_CELLS = 1000;

    public final static int N_LAYERS = 4;

    public final static int PLAYER_LAYER = 2;

    MapCell[][] cell;

    MapTile[] tileList;

    int numOfTiles;

    int[] numOfCells;

    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();

    /**
     * Each tile represents one different kind of tile that can be placed
     * on the map.
     */
    public static class MapTile {

        public String name;

        public Image image;

        private static final Toolkit tk;

        static {
            tk = Toolkit.getDefaultToolkit();
        }

        public MapTile(String fileName) throws IOException {
            name = fileName;
            image = tk.getImage(fileName);
        }
    }

    /**
     * Each cell is the smallest part of the map.
     */
    public static class MapCell {

        float x, y;

        int tile, layer;

        float depthvalue;

        public MapCell(int x, int y, int tile, int layer) {
            this((float) x, (float) y, tile, layer);
        }

        public MapCell(int x, int y, int tile) {
            this(x, y, tile, 0);
        }

        public MapCell(float x, float y, int tile, int layer) {
            this.x = x;
            this.y = y;
            this.tile = tile;
            this.layer = layer;
        }

        public String toString() {
            return String.format(""MapCell[x=%f,y=%f,tile=%d,layer=%d]"", x, y, tile, layer);
        }
    }

    public static class MapPlayerCell extends MapCell {

        Player p;

        public MapPlayerCell(Player p1) {
            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);
            p = p1;
        }
    }

    /**
     * Compares two MapCells and determine their order.
     */
    private class MapCellComparator implements Comparator<MapCell> {

        // MapCellComparator() { /* ... */ }
        public int compare(MapCell src, MapCell dst) {
            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));
        }

        /*if (src.y > src.x) {
		if (src.y > dst.y)
		    return 1;
		if (src.y < dst.y)
		    return -1;
		return 0;
	    }

	    if (src.y < src.x) {
		if (src.x > dst.x)
		    return 1;
		if (src.x < dst.x)
		    return -1;
		return 0;
	    }
	    
	    if (src.x+src.y > dst.x+dst.y)
		return 1;
	    if (src.x+src.y < dst.x+dst.y)
		return -1;
		return 0;
	}*/
        private float depthvalue(MapCell c) {
            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;
        }

        public boolean equals(Object obj) {
            return obj == this;
        }
    }

    /**
     * Creates a new instance of the Map class.
     * @param fileName the name of the map to open.
     */
    public Map(String fileName) throws IOException {
        open(fileName);
    }

    /**
     * Open the specified map fileName.
     * @param fileName the name of the file to open.
     */
    public Map open(String fileName) throws IOException {
        //System.err.println(""Map.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[4];
        //numOfCells = Integer.parseInt(in.readLine());
        numOfCells = new int[N_LAYERS];
        int readNumOfTiles = Integer.parseInt(in.readLine());
        numOfTiles = Integer.parseInt(in.readLine());
        cell = new MapCell[N_LAYERS][];
        for (i = 0; i < N_LAYERS; i++) {
            cell[i] = new MapCell[MAX_NUM_CELLS];
        }
        tileList = new MapTile[numOfTiles];
        for (i = 0; i < numOfTiles; i++) {
            tileList[i] = new MapTile(in.readLine());
        }
        j = 0;
        int[] c = new int[N_LAYERS];
        while (st.nextToken() != st.TT_EOF) {
            if (j > 3) {
                numOfCells[tmp[3]]++;
                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == 4) {
            numOfCells[tmp[3]]++;
            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
            // System.err.println(""Map.open(): Missing end of line!"");
        }
        //if ( != numOfCells) {
        //    System.err.println(""Map.open(): Unable to open file!"");
        //}
        in.close();
        try {
            MediaTracker tracker = new MediaTracker(new Frame());
            for (MapTile t : tileList) {
                tracker.addImage(t.image, 0);
            }
            //System.err.println(""Map.open(): waiting for images!"");
            tracker.waitForAll();
        } catch (InterruptedException e) {
            e.printStackTrace(System.err);
        }
        return this;
    }

    /**
     * Lookup and return the MapCell at the specified x and y coordinates.
     * Returns null if no MapCell is found. This method does a linear
     * search through all the cells. This is considered a bug!
     *
     * @param x the x-coordinate of the MapCell.
     * @param y the y-coordinate of the MapCell.
     * @return The MapCell at the coordinates, or null if not exists.
     */
    public MapCell lookup(int x, int y) {
        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {
            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {
                return cell[PLAYER_LAYER][i];
            }
        }
        return null;
    }

    /**
     * Converts the input coordinats in screen space to their respective
     * coordinates in world space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point pixelTransform(int x, int y, int z) {
        return new Point(x + 2 * (y + z), y - (x + z) / 2);
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in screen space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point worldTransform(float x, float y) {
        //return new Point( (int) ((x - z) / 2 - z - y),
        //		  (int) ((x + 2 * (y - z) + z) / 4));
        x += GRID_OFFSET_X;
        y += GRID_OFFSET_Y;
        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in defined grid.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point gridTransform(int x, int y) {
        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;
	int i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;

	j = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);
	i = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);

	return new Point(j, i);*/
        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);
    }

    public MapCell addPlayerCell(Player p) {
        MapCell c = new MapPlayerCell(p);
        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;
        sortCells(PLAYER_LAYER);
        playercells.put(p, c);
        return c;
    }

    public void updatePlayerCell(Player p) {
        if (p.isDead()) {
            MapCell m = playercells.get(p);
            m.tile = 39;
        } else {
            MapCell m = playercells.get(p);
            m.x = p.getX();
            m.y = p.getY();
        }
    }

    public void sortCells(int layer) {
        //System.err.print(""Sorting... "");
        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());
        //System.err.println(""done!"");
    }

    /**
     * Paints a layer of this map on a Graphics object.
     */
    public void draw(Graphics2D g, int layer) {
        int i, z, w, h;
        float x, y;
        MapTile t;
        Point p;
        i = 0;
        try {
            for (i = 0; i < numOfCells[layer]; i++) {
                x = cell[layer][i].x;
                y = cell[layer][i].y;
                z = cell[layer][i].tile;
                /* check whether this cell should be drawn */
                if (z != -1) {
                    t = tileList[z];
                    w = t.image.getWidth(null);
                    h = t.image.getHeight(null);
                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,
                    //	       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);
                    p = worldTransform(x, y);
                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);
                }
            }
        } catch (Exception e) {
            System.err.printf(""MapGrid.paint(): i=%d l=%d\n"", i, cell.length);
            e.printStackTrace(System.err);
        }
    }

    public String toString() {
        return ""Map[]"";
    }
}
","// Map_1Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#lookup(int, int)} method.
*/
class Map_1Test {","// Map_1Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#lookup(int, int)} method.
*/
class Map_1Test {

		/**
		* Test case 1 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup1() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(0, 0));
		}
		
		/**
		* Test case 2 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup2() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(0, 1));
		}
		
		/**
		* Test case 3 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup3() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(1, 0));
		}
		
		/**
		* Test case 4 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup4() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(1, 1));
		}
		
		/**
		* Test case 5 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup5() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(2, 0));
		}
		
		/**
		* Test case 6 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup6() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(2, 1));
		}
		
		/**
		* Test case 7 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup7() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(3, 0));
		}
		
		/**
		* Test case 8 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup8() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(3, 1));
		}
		
		/**
		* Test case 9 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup9() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(4, 0));
		}
		
		/**
		* Test case 10 for {@link Map#lookup(int, int)}.
		* It tests if the method returns null when the coordinates are out of bounds.
		*/
		@Test
		void testLookup10() {
				Map map = new Map(""maps/testmap.map"");
				assertNull(map.lookup(4, 1));
		}
}"
cmpl-6ttgABNwymX3VyjeWMGL1xFF2Ngjx,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/Map_2Test.java,92.88216304779053,length,"// Map.java
/**
 * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties.
 *
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 */
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;

/**
 * The MapEdit implementation of Map. Some things may be altered to
 * work better with the WorldView in the GUI.
 */
public class Map {

    private final static int WORLD_OFFSET_X = 672;

    private final static int WORLD_OFFSET_Y = 32;

    private final static int GRID_OFFSET_X = 14;

    private final static int GRID_OFFSET_Y = -2;

    static final int MAX_NUM_CELLS = 1000;

    public final static int N_LAYERS = 4;

    public final static int PLAYER_LAYER = 2;

    MapCell[][] cell;

    MapTile[] tileList;

    int numOfTiles;

    int[] numOfCells;

    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();

    /**
     * Each tile represents one different kind of tile that can be placed
     * on the map.
     */
    public static class MapTile {

        public String name;

        public Image image;

        private static final Toolkit tk;

        static {
            tk = Toolkit.getDefaultToolkit();
        }

        public MapTile(String fileName) throws IOException {
            name = fileName;
            image = tk.getImage(fileName);
        }
    }

    /**
     * Each cell is the smallest part of the map.
     */
    public static class MapCell {

        float x, y;

        int tile, layer;

        float depthvalue;

        public MapCell(int x, int y, int tile, int layer) {
            this((float) x, (float) y, tile, layer);
        }

        public MapCell(int x, int y, int tile) {
            this(x, y, tile, 0);
        }

        public MapCell(float x, float y, int tile, int layer) {
            this.x = x;
            this.y = y;
            this.tile = tile;
            this.layer = layer;
        }

        public String toString() {
            return String.format(""MapCell[x=%f,y=%f,tile=%d,layer=%d]"", x, y, tile, layer);
        }
    }

    public static class MapPlayerCell extends MapCell {

        Player p;

        public MapPlayerCell(Player p1) {
            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);
            p = p1;
        }
    }

    /**
     * Compares two MapCells and determine their order.
     */
    private class MapCellComparator implements Comparator<MapCell> {

        // MapCellComparator() { /* ... */ }
        public int compare(MapCell src, MapCell dst) {
            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));
        }

        /*if (src.y > src.x) {
		if (src.y > dst.y)
		    return 1;
		if (src.y < dst.y)
		    return -1;
		return 0;
	    }

	    if (src.y < src.x) {
		if (src.x > dst.x)
		    return 1;
		if (src.x < dst.x)
		    return -1;
		return 0;
	    }
	    
	    if (src.x+src.y > dst.x+dst.y)
		return 1;
	    if (src.x+src.y < dst.x+dst.y)
		return -1;
		return 0;
	}*/
        private float depthvalue(MapCell c) {
            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;
        }

        public boolean equals(Object obj) {
            return obj == this;
        }
    }

    /**
     * Creates a new instance of the Map class.
     * @param fileName the name of the map to open.
     */
    public Map(String fileName) throws IOException {
        open(fileName);
    }

    /**
     * Open the specified map fileName.
     * @param fileName the name of the file to open.
     */
    public Map open(String fileName) throws IOException {
        //System.err.println(""Map.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[4];
        //numOfCells = Integer.parseInt(in.readLine());
        numOfCells = new int[N_LAYERS];
        int readNumOfTiles = Integer.parseInt(in.readLine());
        numOfTiles = Integer.parseInt(in.readLine());
        cell = new MapCell[N_LAYERS][];
        for (i = 0; i < N_LAYERS; i++) {
            cell[i] = new MapCell[MAX_NUM_CELLS];
        }
        tileList = new MapTile[numOfTiles];
        for (i = 0; i < numOfTiles; i++) {
            tileList[i] = new MapTile(in.readLine());
        }
        j = 0;
        int[] c = new int[N_LAYERS];
        while (st.nextToken() != st.TT_EOF) {
            if (j > 3) {
                numOfCells[tmp[3]]++;
                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == 4) {
            numOfCells[tmp[3]]++;
            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
            // System.err.println(""Map.open(): Missing end of line!"");
        }
        //if ( != numOfCells) {
        //    System.err.println(""Map.open(): Unable to open file!"");
        //}
        in.close();
        try {
            MediaTracker tracker = new MediaTracker(new Frame());
            for (MapTile t : tileList) {
                tracker.addImage(t.image, 0);
            }
            //System.err.println(""Map.open(): waiting for images!"");
            tracker.waitForAll();
        } catch (InterruptedException e) {
            e.printStackTrace(System.err);
        }
        return this;
    }

    /**
     * Lookup and return the MapCell at the specified x and y coordinates.
     * Returns null if no MapCell is found. This method does a linear
     * search through all the cells. This is considered a bug!
     *
     * @param x the x-coordinate of the MapCell.
     * @param y the y-coordinate of the MapCell.
     * @return The MapCell at the coordinates, or null if not exists.
     */
    public MapCell lookup(int x, int y) {
        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {
            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {
                return cell[PLAYER_LAYER][i];
            }
        }
        return null;
    }

    /**
     * Converts the input coordinats in screen space to their respective
     * coordinates in world space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point pixelTransform(int x, int y, int z) {
        return new Point(x + 2 * (y + z), y - (x + z) / 2);
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in screen space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point worldTransform(float x, float y) {
        //return new Point( (int) ((x - z) / 2 - z - y),
        //		  (int) ((x + 2 * (y - z) + z) / 4));
        x += GRID_OFFSET_X;
        y += GRID_OFFSET_Y;
        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in defined grid.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point gridTransform(int x, int y) {
        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;
	int i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;

	j = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);
	i = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);

	return new Point(j, i);*/
        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);
    }

    public MapCell addPlayerCell(Player p) {
        MapCell c = new MapPlayerCell(p);
        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;
        sortCells(PLAYER_LAYER);
        playercells.put(p, c);
        return c;
    }

    public void updatePlayerCell(Player p) {
        if (p.isDead()) {
            MapCell m = playercells.get(p);
            m.tile = 39;
        } else {
            MapCell m = playercells.get(p);
            m.x = p.getX();
            m.y = p.getY();
        }
    }

    public void sortCells(int layer) {
        //System.err.print(""Sorting... "");
        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());
        //System.err.println(""done!"");
    }

    /**
     * Paints a layer of this map on a Graphics object.
     */
    public void draw(Graphics2D g, int layer) {
        int i, z, w, h;
        float x, y;
        MapTile t;
        Point p;
        i = 0;
        try {
            for (i = 0; i < numOfCells[layer]; i++) {
                x = cell[layer][i].x;
                y = cell[layer][i].y;
                z = cell[layer][i].tile;
                /* check whether this cell should be drawn */
                if (z != -1) {
                    t = tileList[z];
                    w = t.image.getWidth(null);
                    h = t.image.getHeight(null);
                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,
                    //	       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);
                    p = worldTransform(x, y);
                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);
                }
            }
        } catch (Exception e) {
            System.err.printf(""MapGrid.paint(): i=%d l=%d\n"", i, cell.length);
            e.printStackTrace(System.err);
        }
    }

    public String toString() {
        return ""Map[]"";
    }
}
","// Map_2Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#pixelTransform(int, int, int)} method.
*/
class Map_2Test {","// Map_2Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#pixelTransform(int, int, int)} method.
*/
class Map_2Test {

	/**
	* Test case 1 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0</li>
	* 	<li>y = 0</li>
	* 	<li>z = 0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(0, 0)</li>
	* </ul>
	*/
	@Test
	void test1() {
		int x = 0;
		int y = 0;
		int z = 0;
		Point expected = new Point(0, 0);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1</li>
	* 	<li>y = 1</li>
	* 	<li>z = 1</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(2, 0)</li>
	* </ul>
	*/
	@Test
	void test2() {
		int x = 1;
		int y = 1;
		int z = 1;
		Point expected = new Point(2, 0);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = -1</li>
	* 	<li>z = -1</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(-2, 0)</li>
	* </ul>
	*/
	@Test
	void test3() {
		int x = -1;
		int y = -1;
		int z = -1;
		Point expected = new Point(-2, 0);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0</li>
	* 	<li>y = 0</li>
	* 	<li>z = 1</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(1, 0)</li>
	* </ul>
	*/
	@Test
	void test4() {
		int x = 0;
		int y = 0;
		int z = 1;
		Point expected = new Point(1, 0);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0</li>
	* 	<li>y = 0</li>
	* 	<li>z = -1</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(-1, 0)</li>
	* </ul>
	*/
	@Test
	void test5() {
		int x = 0;
		int y = 0;
		int z = -1;
		Point expected = new Point(-1, 0);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1</li>
	* 	<li>y = 1</li>
	* 	<li>z = 0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(1, 1)</li>
	* </ul>
	*/
	@Test
	void test6() {
		int x = 1;
		int y = 1;
		int z = 0;
		Point expected = new Point(1, 1);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = -1</li>
	* 	<li>z = 0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void test7() {
		int x = -1;
		int y = -1;
		int z = 0;
		Point expected = new Point(-1, -1);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1</li>
	* 	<li>y = 1</li>
	* 	<li>z = -1</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(0, 1)</li>
	* </ul>
	*/
	@Test
	void test8() {
		int x = 1;
		int y = 1;
		int z = -1;
		Point expected = new Point(0, 1);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = -1</li>
	* 	<li>z = 1</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(0, -1)</li>
	* </ul>
	*/
	@Test
	void test9() {
		int x = -1;
		int y = -1;
		int z = 1;
		Point expected = new Point(0, -1);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link Map#pixelTransform(int, int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1</li>
	* 	<li>y = -1</li>
	* 	<li>z = 1</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(1, -1)</li>
	* </ul>
	*/
	@Test
	void test10() {
		int x = 1;
		int y = -1;
		int z = 1;
		Point expected = new Point(1, -1);
		Point actual = Map.pixelTransform(x, y, z);
		assertEquals(expected, actual);
	}
}

// Map_3Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#worldTransform(float, float)} method.
*/
class Map_3Test {
		
	/**
	* Test case 1 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0.0</li>
	* 	<li>y = 0.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(0, 0)</li>
	* </ul>
	*/
	@Test
	void test1() {
		float x = 0.0f;
		float y = 0.0f;
		Point expected = new Point(0, 0);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1.0</li>
	* 	<li>y = 1.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(16, 8)</li>
	* </ul>
	*/
	@Test
	void test2() {
		float x = 1.0f;
		float y = 1.0f;
		Point expected = new Point(16, 8);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1.0</li>
	* 	<li>y = -1.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(-16, -8)</li>
	* </ul>
	*/
	@Test
	void test3() {
		float x = -1.0f;
		float y = -1.0f;
		Point expected = new Point(-16, -8);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0.0</li>
	* 	<li>y = 1.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(8, 8)</li>
	* </ul>
	*/
	@Test
	void test4() {
		float x = 0.0f;
		float y = 1.0f;
		Point expected = new Point(8, 8);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0.0</li>
	* 	<li>y = -1.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(8, -8)</li>
	* </ul>
	*/
	@Test
	void test5() {
		float x = 0.0f;
		float y = -1.0f;
		Point expected = new Point(8, -8);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1.0</li>
	* 	<li>y = 0.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(16, 0)</li>
	* </ul>
	*/
	@Test
	void test6() {
		float x = 1.0f;
		float y = 0.0f;
		Point expected = new Point(16, 0);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1.0</li>
	* 	<li>y = 0.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(-16, 0)</li>
	* </ul>
	*/
	@Test
	void test7() {
		float x = -1.0f;
		float y = 0.0f;
		Point expected = new Point(-16, 0);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1.0</li>
	* 	<li>y = -1.0</li>
	* </ul>
	* and the expected output value:
	* <ul>
	* 	<li>expected = new Point(8, -16)</li>
	* </ul>
	*/
	@Test
	void test8() {
		float x = 1.0f;
		float y = -1.0f;
		Point expected = new Point(8, -16);
		Point actual = Map.worldTransform"
cmpl-6tthf1fYFnsuV0WeloU25CX9r7oFk,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/Map_3Test.java,39.213865518569946,stop,"// Map.java
/**
 * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties.
 *
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 */
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;

/**
 * The MapEdit implementation of Map. Some things may be altered to
 * work better with the WorldView in the GUI.
 */
public class Map {

    private final static int WORLD_OFFSET_X = 672;

    private final static int WORLD_OFFSET_Y = 32;

    private final static int GRID_OFFSET_X = 14;

    private final static int GRID_OFFSET_Y = -2;

    static final int MAX_NUM_CELLS = 1000;

    public final static int N_LAYERS = 4;

    public final static int PLAYER_LAYER = 2;

    MapCell[][] cell;

    MapTile[] tileList;

    int numOfTiles;

    int[] numOfCells;

    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();

    /**
     * Each tile represents one different kind of tile that can be placed
     * on the map.
     */
    public static class MapTile {

        public String name;

        public Image image;

        private static final Toolkit tk;

        static {
            tk = Toolkit.getDefaultToolkit();
        }

        public MapTile(String fileName) throws IOException {
            name = fileName;
            image = tk.getImage(fileName);
        }
    }

    /**
     * Each cell is the smallest part of the map.
     */
    public static class MapCell {

        float x, y;

        int tile, layer;

        float depthvalue;

        public MapCell(int x, int y, int tile, int layer) {
            this((float) x, (float) y, tile, layer);
        }

        public MapCell(int x, int y, int tile) {
            this(x, y, tile, 0);
        }

        public MapCell(float x, float y, int tile, int layer) {
            this.x = x;
            this.y = y;
            this.tile = tile;
            this.layer = layer;
        }

        public String toString() {
            return String.format(""MapCell[x=%f,y=%f,tile=%d,layer=%d]"", x, y, tile, layer);
        }
    }

    public static class MapPlayerCell extends MapCell {

        Player p;

        public MapPlayerCell(Player p1) {
            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);
            p = p1;
        }
    }

    /**
     * Compares two MapCells and determine their order.
     */
    private class MapCellComparator implements Comparator<MapCell> {

        // MapCellComparator() { /* ... */ }
        public int compare(MapCell src, MapCell dst) {
            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));
        }

        /*if (src.y > src.x) {
		if (src.y > dst.y)
		    return 1;
		if (src.y < dst.y)
		    return -1;
		return 0;
	    }

	    if (src.y < src.x) {
		if (src.x > dst.x)
		    return 1;
		if (src.x < dst.x)
		    return -1;
		return 0;
	    }
	    
	    if (src.x+src.y > dst.x+dst.y)
		return 1;
	    if (src.x+src.y < dst.x+dst.y)
		return -1;
		return 0;
	}*/
        private float depthvalue(MapCell c) {
            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;
        }

        public boolean equals(Object obj) {
            return obj == this;
        }
    }

    /**
     * Creates a new instance of the Map class.
     * @param fileName the name of the map to open.
     */
    public Map(String fileName) throws IOException {
        open(fileName);
    }

    /**
     * Open the specified map fileName.
     * @param fileName the name of the file to open.
     */
    public Map open(String fileName) throws IOException {
        //System.err.println(""Map.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[4];
        //numOfCells = Integer.parseInt(in.readLine());
        numOfCells = new int[N_LAYERS];
        int readNumOfTiles = Integer.parseInt(in.readLine());
        numOfTiles = Integer.parseInt(in.readLine());
        cell = new MapCell[N_LAYERS][];
        for (i = 0; i < N_LAYERS; i++) {
            cell[i] = new MapCell[MAX_NUM_CELLS];
        }
        tileList = new MapTile[numOfTiles];
        for (i = 0; i < numOfTiles; i++) {
            tileList[i] = new MapTile(in.readLine());
        }
        j = 0;
        int[] c = new int[N_LAYERS];
        while (st.nextToken() != st.TT_EOF) {
            if (j > 3) {
                numOfCells[tmp[3]]++;
                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == 4) {
            numOfCells[tmp[3]]++;
            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
            // System.err.println(""Map.open(): Missing end of line!"");
        }
        //if ( != numOfCells) {
        //    System.err.println(""Map.open(): Unable to open file!"");
        //}
        in.close();
        try {
            MediaTracker tracker = new MediaTracker(new Frame());
            for (MapTile t : tileList) {
                tracker.addImage(t.image, 0);
            }
            //System.err.println(""Map.open(): waiting for images!"");
            tracker.waitForAll();
        } catch (InterruptedException e) {
            e.printStackTrace(System.err);
        }
        return this;
    }

    /**
     * Lookup and return the MapCell at the specified x and y coordinates.
     * Returns null if no MapCell is found. This method does a linear
     * search through all the cells. This is considered a bug!
     *
     * @param x the x-coordinate of the MapCell.
     * @param y the y-coordinate of the MapCell.
     * @return The MapCell at the coordinates, or null if not exists.
     */
    public MapCell lookup(int x, int y) {
        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {
            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {
                return cell[PLAYER_LAYER][i];
            }
        }
        return null;
    }

    /**
     * Converts the input coordinats in screen space to their respective
     * coordinates in world space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point pixelTransform(int x, int y, int z) {
        return new Point(x + 2 * (y + z), y - (x + z) / 2);
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in screen space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point worldTransform(float x, float y) {
        //return new Point( (int) ((x - z) / 2 - z - y),
        //		  (int) ((x + 2 * (y - z) + z) / 4));
        x += GRID_OFFSET_X;
        y += GRID_OFFSET_Y;
        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in defined grid.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point gridTransform(int x, int y) {
        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;
	int i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;

	j = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);
	i = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);

	return new Point(j, i);*/
        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);
    }

    public MapCell addPlayerCell(Player p) {
        MapCell c = new MapPlayerCell(p);
        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;
        sortCells(PLAYER_LAYER);
        playercells.put(p, c);
        return c;
    }

    public void updatePlayerCell(Player p) {
        if (p.isDead()) {
            MapCell m = playercells.get(p);
            m.tile = 39;
        } else {
            MapCell m = playercells.get(p);
            m.x = p.getX();
            m.y = p.getY();
        }
    }

    public void sortCells(int layer) {
        //System.err.print(""Sorting... "");
        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());
        //System.err.println(""done!"");
    }

    /**
     * Paints a layer of this map on a Graphics object.
     */
    public void draw(Graphics2D g, int layer) {
        int i, z, w, h;
        float x, y;
        MapTile t;
        Point p;
        i = 0;
        try {
            for (i = 0; i < numOfCells[layer]; i++) {
                x = cell[layer][i].x;
                y = cell[layer][i].y;
                z = cell[layer][i].tile;
                /* check whether this cell should be drawn */
                if (z != -1) {
                    t = tileList[z];
                    w = t.image.getWidth(null);
                    h = t.image.getHeight(null);
                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,
                    //	       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);
                    p = worldTransform(x, y);
                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);
                }
            }
        } catch (Exception e) {
            System.err.printf(""MapGrid.paint(): i=%d l=%d\n"", i, cell.length);
            e.printStackTrace(System.err);
        }
    }

    public String toString() {
        return ""Map[]"";
    }
}
","// Map_3Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#worldTransform(float, float)} method.
*/
class Map_3Test {","// Map_3Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#worldTransform(float, float)} method.
*/
class Map_3Test {

	/**
	* Test case 1 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0</li>
	* 	<li>y = 0</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(0, 0)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_1() {
		float x = 0;
		float y = 0;
		Point expected = new Point(0, 0);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1</li>
	* 	<li>y = 1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(8, 4)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_2() {
		float x = 1;
		float y = 1;
		Point expected = new Point(8, 4);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = -1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-8, -4)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_3() {
		float x = -1;
		float y = -1;
		Point expected = new Point(-8, -4);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0</li>
	* 	<li>y = 1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(0, 4)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_4() {
		float x = 0;
		float y = 1;
		Point expected = new Point(0, 4);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1</li>
	* 	<li>y = 0</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(8, 0)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_5() {
		float x = 1;
		float y = 0;
		Point expected = new Point(8, 0);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = 0</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-8, 0)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_6() {
		float x = -1;
		float y = 0;
		Point expected = new Point(-8, 0);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0</li>
	* 	<li>y = -1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(0, -4)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_7() {
		float x = 0;
		float y = -1;
		Point expected = new Point(0, -4);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 1</li>
	* 	<li>y = -1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(8, -4)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_8() {
		float x = 1;
		float y = -1;
		Point expected = new Point(8, -4);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = 1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-8, 4)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_9() {
		float x = -1;
		float y = 1;
		Point expected = new Point(-8, 4);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link Map#worldTransform(float, float)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = -1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-8, -4)</li>
	* </ul>
	*/
	@Test
	void testWorldTransform_10() {
		float x = -1;
		float y = -1;
		Point expected = new Point(-8, -4);
		Point actual = Map.worldTransform(x, y);
		assertEquals(expected, actual);
	}
}"
cmpl-6ttiirfCQphSAR2PRF1KAVsX2ObAY,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/Map_4Test.java,38.060978174209595,stop,"// Map.java
/**
 * $Id: Map.java,v 1.7 2004/04/22 11:26:42 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties.
 *
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 */
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;

/**
 * The MapEdit implementation of Map. Some things may be altered to
 * work better with the WorldView in the GUI.
 */
public class Map {

    private final static int WORLD_OFFSET_X = 672;

    private final static int WORLD_OFFSET_Y = 32;

    private final static int GRID_OFFSET_X = 14;

    private final static int GRID_OFFSET_Y = -2;

    static final int MAX_NUM_CELLS = 1000;

    public final static int N_LAYERS = 4;

    public final static int PLAYER_LAYER = 2;

    MapCell[][] cell;

    MapTile[] tileList;

    int numOfTiles;

    int[] numOfCells;

    Hashtable<Player, MapCell> playercells = new Hashtable<Player, MapCell>();

    /**
     * Each tile represents one different kind of tile that can be placed
     * on the map.
     */
    public static class MapTile {

        public String name;

        public Image image;

        private static final Toolkit tk;

        static {
            tk = Toolkit.getDefaultToolkit();
        }

        public MapTile(String fileName) throws IOException {
            name = fileName;
            image = tk.getImage(fileName);
        }
    }

    /**
     * Each cell is the smallest part of the map.
     */
    public static class MapCell {

        float x, y;

        int tile, layer;

        float depthvalue;

        public MapCell(int x, int y, int tile, int layer) {
            this((float) x, (float) y, tile, layer);
        }

        public MapCell(int x, int y, int tile) {
            this(x, y, tile, 0);
        }

        public MapCell(float x, float y, int tile, int layer) {
            this.x = x;
            this.y = y;
            this.tile = tile;
            this.layer = layer;
        }

        public String toString() {
            return String.format(""MapCell[x=%f,y=%f,tile=%d,layer=%d]"", x, y, tile, layer);
        }
    }

    public static class MapPlayerCell extends MapCell {

        Player p;

        public MapPlayerCell(Player p1) {
            super(p1.getX(), p1.getY(), 8, PLAYER_LAYER);
            p = p1;
        }
    }

    /**
     * Compares two MapCells and determine their order.
     */
    private class MapCellComparator implements Comparator<MapCell> {

        // MapCellComparator() { /* ... */ }
        public int compare(MapCell src, MapCell dst) {
            return ((Float) depthvalue(src)).compareTo(depthvalue(dst));
        }

        /*if (src.y > src.x) {
		if (src.y > dst.y)
		    return 1;
		if (src.y < dst.y)
		    return -1;
		return 0;
	    }

	    if (src.y < src.x) {
		if (src.x > dst.x)
		    return 1;
		if (src.x < dst.x)
		    return -1;
		return 0;
	    }
	    
	    if (src.x+src.y > dst.x+dst.y)
		return 1;
	    if (src.x+src.y < dst.x+dst.y)
		return -1;
		return 0;
	}*/
        private float depthvalue(MapCell c) {
            return (1000 * (float) c.x + 1001 * (float) c.y) / 1000 * 32;
        }

        public boolean equals(Object obj) {
            return obj == this;
        }
    }

    /**
     * Creates a new instance of the Map class.
     * @param fileName the name of the map to open.
     */
    public Map(String fileName) throws IOException {
        open(fileName);
    }

    /**
     * Open the specified map fileName.
     * @param fileName the name of the file to open.
     */
    public Map open(String fileName) throws IOException {
        //System.err.println(""Map.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[4];
        //numOfCells = Integer.parseInt(in.readLine());
        numOfCells = new int[N_LAYERS];
        int readNumOfTiles = Integer.parseInt(in.readLine());
        numOfTiles = Integer.parseInt(in.readLine());
        cell = new MapCell[N_LAYERS][];
        for (i = 0; i < N_LAYERS; i++) {
            cell[i] = new MapCell[MAX_NUM_CELLS];
        }
        tileList = new MapTile[numOfTiles];
        for (i = 0; i < numOfTiles; i++) {
            tileList[i] = new MapTile(in.readLine());
        }
        j = 0;
        int[] c = new int[N_LAYERS];
        while (st.nextToken() != st.TT_EOF) {
            if (j > 3) {
                numOfCells[tmp[3]]++;
                cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == 4) {
            numOfCells[tmp[3]]++;
            cell[tmp[3]][c[tmp[3]]++] = new MapCell(tmp[0], tmp[1], tmp[2], tmp[3]);
            // System.err.println(""Map.open(): Missing end of line!"");
        }
        //if ( != numOfCells) {
        //    System.err.println(""Map.open(): Unable to open file!"");
        //}
        in.close();
        try {
            MediaTracker tracker = new MediaTracker(new Frame());
            for (MapTile t : tileList) {
                tracker.addImage(t.image, 0);
            }
            //System.err.println(""Map.open(): waiting for images!"");
            tracker.waitForAll();
        } catch (InterruptedException e) {
            e.printStackTrace(System.err);
        }
        return this;
    }

    /**
     * Lookup and return the MapCell at the specified x and y coordinates.
     * Returns null if no MapCell is found. This method does a linear
     * search through all the cells. This is considered a bug!
     *
     * @param x the x-coordinate of the MapCell.
     * @param y the y-coordinate of the MapCell.
     * @return The MapCell at the coordinates, or null if not exists.
     */
    public MapCell lookup(int x, int y) {
        for (int i = numOfCells[PLAYER_LAYER] - 1; i >= 0; --i) {
            if (round(cell[PLAYER_LAYER][i].x) == x && round(cell[PLAYER_LAYER][i].y) == y) {
                return cell[PLAYER_LAYER][i];
            }
        }
        return null;
    }

    /**
     * Converts the input coordinats in screen space to their respective
     * coordinates in world space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point pixelTransform(int x, int y, int z) {
        return new Point(x + 2 * (y + z), y - (x + z) / 2);
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in screen space.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point worldTransform(float x, float y) {
        //return new Point( (int) ((x - z) / 2 - z - y),
        //		  (int) ((x + 2 * (y - z) + z) / 4));
        x += GRID_OFFSET_X;
        y += GRID_OFFSET_Y;
        return new Point((int) (16 * (x - y)), (int) (8 * (y + x)));
    }

    /**
     * Converts the input coordinats in world space to their respective
     * coordinates in defined grid.
     *
     * @param x
     * @param y
     * @param z
     */
    public static Point gridTransform(int x, int y) {
        /*int j = x - WORLD_OFFSET_X + GRID_OFFSET_X;
	int i = y + WORLD_OFFSET_Y + GRID_OFFSET_Y;

	j = (int) (j < 0 ? j / 32 - 0.5 : j / 32 + 1.5);
	i = (int) (i < 0 ? i / 16 - 0.5 : i / 16 + 1.5);

	return new Point(j, i);*/
        return new Point(round((float) x / 32 + (float) y / 16) - GRID_OFFSET_X, round((float) y / 16 - (float) x / 32) - GRID_OFFSET_Y);
    }

    public MapCell addPlayerCell(Player p) {
        MapCell c = new MapPlayerCell(p);
        cell[PLAYER_LAYER][numOfCells[PLAYER_LAYER]++] = c;
        sortCells(PLAYER_LAYER);
        playercells.put(p, c);
        return c;
    }

    public void updatePlayerCell(Player p) {
        if (p.isDead()) {
            MapCell m = playercells.get(p);
            m.tile = 39;
        } else {
            MapCell m = playercells.get(p);
            m.x = p.getX();
            m.y = p.getY();
        }
    }

    public void sortCells(int layer) {
        //System.err.print(""Sorting... "");
        Arrays.sort(cell[layer], 0, numOfCells[layer], new MapCellComparator());
        //System.err.println(""done!"");
    }

    /**
     * Paints a layer of this map on a Graphics object.
     */
    public void draw(Graphics2D g, int layer) {
        int i, z, w, h;
        float x, y;
        MapTile t;
        Point p;
        i = 0;
        try {
            for (i = 0; i < numOfCells[layer]; i++) {
                x = cell[layer][i].x;
                y = cell[layer][i].y;
                z = cell[layer][i].tile;
                /* check whether this cell should be drawn */
                if (z != -1) {
                    t = tileList[z];
                    w = t.image.getWidth(null);
                    h = t.image.getHeight(null);
                    //p = worldTransform(x*32 + WORLD_OFFSET_X - 8 - w/2,
                    //	       y*16 - WORLD_OFFSET_Y - 4 + w/4, 74);
                    p = worldTransform(x, y);
                    g.drawImage(t.image, p.x - w / 2, p.y - h, null);
                }
            }
        } catch (Exception e) {
            System.err.printf(""MapGrid.paint(): i=%d l=%d\n"", i, cell.length);
            e.printStackTrace(System.err);
        }
    }

    public String toString() {
        return ""Map[]"";
    }
}
","// Map_4Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#gridTransform(int, int)} method.
*/
class Map_4Test {","// Map_4Test.java
package gui;

import static java.lang.Math.max;
import static java.lang.Math.round;
import static java.lang.Math.sqrt;
import static java.lang.Math.pow;
import java.util.Comparator;
import java.util.Arrays;
import java.util.Hashtable;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import java.io.IOException;
import java.awt.*;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Map}.
* It contains ten unit test cases for the {@link Map#gridTransform(int, int)} method.
*/
class Map_4Test {

	/**
	* Test case 1 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = 0</li>
	* 	<li>y = 0</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(0, 0)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_1() {
		int x = 0;
		int y = 0;
		Point expected = new Point(0, 0);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -1</li>
	* 	<li>y = -1</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_2() {
		int x = -1;
		int y = -1;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -2</li>
	* 	<li>y = -2</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_3() {
		int x = -2;
		int y = -2;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -3</li>
	* 	<li>y = -3</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_4() {
		int x = -3;
		int y = -3;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -4</li>
	* 	<li>y = -4</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_5() {
		int x = -4;
		int y = -4;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -5</li>
	* 	<li>y = -5</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_6() {
		int x = -5;
		int y = -5;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -6</li>
	* 	<li>y = -6</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_7() {
		int x = -6;
		int y = -6;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -7</li>
	* 	<li>y = -7</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_8() {
		int x = -7;
		int y = -7;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -8</li>
	* 	<li>y = -8</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_9() {
		int x = -8;
		int y = -8;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link Map#gridTransform(int, int)}.
	* It tests the method with the following input values:
	* <ul>
	* 	<li>x = -9</li>
	* 	<li>y = -9</li>
	* </ul>
	* and the expected return value:
	* <ul>
	* 	<li>expected = new Point(-1, -1)</li>
	* </ul>
	*/
	@Test
	void testGridTransform_10() {
		int x = -9;
		int y = -9;
		Point expected = new Point(-1, -1);
		Point actual = Map.gridTransform(x, y);
		assertEquals(expected, actual);
	}
}"
cmpl-6ttjlmL6K0Anb1xZlkpTzixTaANOD,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/PlayerTreeModel_2Test.java,22.135167598724365,stop,"// PlayerTreeModel.java
/* $Id: PlayerTreeModel.java,v 1.3 2004/05/02 01:52:45 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package gui;

import javax.swing.tree.*;
import javax.swing.event.*;
import state.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.Observer;
import java.util.Observable;

/**
 * Provides a TreeModel representingen the GameState, to used in
 * the GroupPanel.
 */
public class PlayerTreeModel implements TreeModel, Observer {

    private GameState state;

    // basically a place holder
    private Party root = new Party();

    private Vector<TreeModelListener> treeModelListeners;

    /**
     * Creates a new TreeModel for the underlying GameState.
     *
     * @param state The underlying state.
     * @param root The initial root.
     */
    public PlayerTreeModel() {
        treeModelListeners = new Vector<TreeModelListener>();
    }

    /**
     * Sets the state for this treemodel.
     *
     * @param state the game state.
     * @see GameState
     */
    public void setState(GameState s) {
        state = s;
    }

    /**
     * Update defined in Observer interface.
     *
     * @param o The observable object.
     * @param arg The argument passed to notifyObservers.
     */
    public void update(Observable o, Object arg) {
        System.err.println(""reloading grouptree"");
        reload();
        if (state != o)
            System.err.println(""ALERT! state != o in PTM.update()"");
    }

    /**
     * Call this whenever the tree structure of GameState has been
     * changed.
     *
     * @param changed The Player from which the change
     * started. To be sure, use the root :).
     */
    protected void fireTreeStructureChanged(Party changed) {
        TreeModelEvent e = new TreeModelEvent(this, new Object[] { changed });
        for (TreeModelListener l : treeModelListeners) {
            l.treeStructureChanged(e);
        }
    }

    /**
     * Call this when the tree structure has been changed.
     */
    public void reload() {
        fireTreeStructureChanged(root);
    }

    // --- TreeModel interface ---
    public void addTreeModelListener(TreeModelListener l) {
        treeModelListeners.addElement(l);
    }

    public void removeTreeModelListener(TreeModelListener l) {
        treeModelListeners.removeElement(l);
    }

    public Object getChild(Object parent, int index) {
        // give the root special treatment
        if (state == null)
            return null;
        if (parent == root) {
            int i = 0;
            for (Player player : state.players()) {
                if (player != null && player.isBoss() && i++ == index) {
                    return player;
                }
            }
        } else {
            LinkedList<Party> l = ((Party) parent).getSubparty();
            l.remove(parent);
            return l.get(index);
        }
        return null;
    }

    public int getChildCount(Object parent) {
        if (state == null)
            return 0;
        // give the root special treatment
        if (parent == root) {
            int c = 0;
            for (Player player : state.players()) {
                if (player != null && player.isBoss()) {
                    c++;
                }
            }
            return c;
        } else {
            LinkedList<Party> l = ((Party) parent).getSubparty();
            l.remove(parent);
            return l.size();
        }
    }

    /**
     * Note: Does not follow standard. Should return -1 if either
     * child or parent is not part of this model, which is never
     * checked.
     */
    public int getIndexOfChild(Object parent, Object child) {
        if (state == null || parent == null || child == null)
            return -1;
        if (parent == root) {
            int i = 0;
            for (Player player : state.players()) {
                if (player != null && player.isBoss()) {
                    if (player == child)
                        return i;
                    i++;
                }
            }
        } else {
            LinkedList<Party> l = ((Party) parent).getSubparty();
            l.remove(parent);
            return l.indexOf(child);
        }
        return -1;
    }

    public Object getRoot() {
        return root;
    }

    public boolean isLeaf(Object node) {
        Party p = (Party) node;
        return (!p.isBoss() || (p.head == null && p != root));
    }

    /**
     * Messaged when the user has altered the value for the item
     * identified by path to newValue.  Not used by this model.
     *
     * FIX: Ripped from JAVA API EXAMPLE.
     */
    public void valueForPathChanged(TreePath path, Object newValue) {
        System.out.println(""*** valueForPathChanged : "" + path + "" --> "" + newValue);
    }
}
","// PlayerTreeModel_2Test.java
package gui;

import javax.swing.tree.*;
import javax.swing.event.*;
import state.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.Observer;
import java.util.Observable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlayerTreeModel}.
* It contains ten unit test cases for the {@link PlayerTreeModel#getIndexOfChild(Object, Object)} method.
*/
class PlayerTreeModel_2Test {","// PlayerTreeModel_2Test.java
package gui;

import javax.swing.tree.*;
import javax.swing.event.*;
import state.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.Observer;
import java.util.Observable;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlayerTreeModel}.
* It contains ten unit test cases for the {@link PlayerTreeModel#getIndexOfChild(Object, Object)} method.
*/
class PlayerTreeModel_2Test {

		/**
		* Test case 1 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the parent is null.
		*/
		@Test
		void testGetIndexOfChild_1() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				assertEquals(-1, ptm.getIndexOfChild(null, null));
		}
		
		/**
		* Test case 2 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the child is null.
		*/
		@Test
		void testGetIndexOfChild_2() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				assertEquals(-1, ptm.getIndexOfChild(new Party(), null));
		}
		
		/**
		* Test case 3 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the parent is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_3() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				assertEquals(-1, ptm.getIndexOfChild(new Party(), new Party()));
		}
		
		/**
		* Test case 4 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the child is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_4() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				Party p = new Party();
				ptm.setState(new GameState());
				assertEquals(-1, ptm.getIndexOfChild(p, new Party()));
		}
		
		/**
		* Test case 5 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the parent is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_5() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				Party p = new Party();
				ptm.setState(new GameState());
				assertEquals(-1, ptm.getIndexOfChild(new Party(), p));
		}
		
		/**
		* Test case 6 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the child is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_6() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				Party p = new Party();
				ptm.setState(new GameState());
				assertEquals(-1, ptm.getIndexOfChild(p, new Party()));
		}
		
		/**
		* Test case 7 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the parent is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_7() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				Party p = new Party();
				ptm.setState(new GameState());
				assertEquals(-1, ptm.getIndexOfChild(new Party(), p));
		}
		
		/**
		* Test case 8 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the child is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_8() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				Party p = new Party();
				ptm.setState(new GameState());
				assertEquals(-1, ptm.getIndexOfChild(p, new Party()));
		}
		
		/**
		* Test case 9 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the parent is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_9() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				Party p = new Party();
				ptm.setState(new GameState());
				assertEquals(-1, ptm.getIndexOfChild(new Party(), p));
		}
		
		/**
		* Test case 10 for {@link PlayerTreeModel#getIndexOfChild(Object, Object)}.
		* This test case checks if the method returns -1 when the child is not part of the model.
		*/
		@Test
		void testGetIndexOfChild_10() {
				PlayerTreeModel ptm = new PlayerTreeModel();
				Party p = new Party();
				ptm.setState(new GameState());
				assertEquals(-1, ptm.getIndexOfChild(p, new Party()));
		}
}"
cmpl-6ttkoV9d3FsOTBge4xMWw5H6j9wZT,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/PlayerTreeRenderer.java,33.958316802978516,stop,"// PlayerTreeRenderer.java
/* $Id: PlayerTreeRenderer.java,v 1.4 2004/04/22 11:26:42 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.4 $
 *
 */
package gui;

import javax.swing.ListModel;
import java.util.Observer;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import java.awt.Component;
import javax.swing.tree.*;
import javax.swing.JTree;
import java.awt.Color;
import state.*;

/**
 * Provides a tree renderer to correctly set player icons in the gang
 * tree.
 */
public class PlayerTreeRenderer extends DefaultTreeCellRenderer {

    private Icon player_icon;

    private Icon player_bossicon;

    private Icon player_deadicon;

    private GameState state;

    /**
     * Creates a new PlayerTreeRenderer.
     */
    public PlayerTreeRenderer() {
        player_icon = new ImageIcon(""dat/gfx/player_icon.png"");
        player_bossicon = new ImageIcon(""dat/gfx/player_bossicon.png"");
        player_deadicon = new ImageIcon(""dat/gfx/player_deadicon.png"");
    }

    public void setState(GameState s) {
        state = s;
    }

    /**
     * Called by the JTree whenever a cell is to be rendered.
     * Modified to set icons correctly.
     */
    public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {
        super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
        if (value instanceof Player) {
            if (((Player) value).isDead()) {
                setIcon(player_deadicon);
            } else if (((Player) value).isBoss()) {
                setIcon(player_bossicon);
            } else {
                setIcon(player_icon);
            }
            if (state.getMe() == value) {
                setForeground(Color.BLUE);
            }
        } else {
            setIcon(null);
        }
        return this;
    }
}
","// PlayerTreeRendererTest.java
package gui;

import javax.swing.ListModel;
import java.util.Observer;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import java.awt.Component;
import javax.swing.tree.*;
import javax.swing.JTree;
import java.awt.Color;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlayerTreeRenderer}.
* It contains ten unit test cases for the {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)} method.
*/
class PlayerTreeRendererTest {","// PlayerTreeRendererTest.java
package gui;

import javax.swing.ListModel;
import java.util.Observer;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import java.awt.Component;
import javax.swing.tree.*;
import javax.swing.JTree;
import java.awt.Color;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link PlayerTreeRenderer}.
* It contains ten unit test cases for the {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)} method.
*/
class PlayerTreeRendererTest {

		/**
		* Test case 1 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent1() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 2 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent2() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 3 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent3() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 4 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent4() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 5 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent5() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 6 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent6() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 7 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent7() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 8 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent8() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 9 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent9() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
		
		/**
		* Test case 10 for {@link PlayerTreeRenderer#getTreeCellRendererComponent(JTree, Object, boolean, boolean, boolean, int, boolean)}.
		* This test case checks if the method returns a component.
		*/
		@Test
		void testGetTreeCellRendererComponent10() {
				PlayerTreeRenderer p = new PlayerTreeRenderer();
				JTree tree = new JTree();
				Object value = new Object();
				boolean sel = true;
				boolean expanded = true;
				boolean leaf = true;
				int row = 1;
				boolean hasFocus = true;
				assertNotNull(p.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus));
		}
}"
30cffd7f-a702-4b6c-81af-67681ef26490,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Actor.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8533 tokens (4533 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Actor.java
/* $Id: Actor.java,v 1.11 2004/05/04 21:33:58 emill Exp $ */
package gui.gl;

import static java.lang.Math.abs;
import static java.lang.Math.sin;
import static java.lang.Math.cos;
import static java.lang.Math.atan2;
import static java.lang.Math.PI;
import static com.xith3d.image.DirectBufferedImage.getDirectImageRGBA;
import java.io.FileInputStream;
import java.awt.geom.*;
import java.util.Enumeration;
import java.util.Vector;
import javax.vecmath.*;
import state.Player;
import com.xith3d.image.DirectBufferedImage;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.Coord3f;
import com.xith3d.utility.interpolate.*;
import com.xith3d.loaders.texture.*;
import org.newdawn.xith3d.obj.OBJLoader;
import org.newdawn.xith3d.loaders.md2.MD2Loader;
import org.newdawn.xith3d.loaders.md2.MD2Model;
import org.newdawn.xith3d.loaders.md2.MD2ModelInstance;
import org.newdawn.xith3d.loaders.ModelLoadingException;

/**
 * This class represents an actor, i.e. moving object, in the world.
 */
public class Actor extends TransformGroup {

    /* implements GeometryUpdater */
    /**
     * The shape representing this actor.
     */
    private Shape3D shape;

    /**
     * The model associated with this actor.
     */
    private MD2ModelInstance modelInstance;

    /**
     * The associated transform.
     */
    private Transform3D transform;

    /**
     * The scale of the associated model.
     */
    private float scale;

    /**
     * The position of this actor.
     */
    private Coord3f pos;

    private static final float PLAYER_SPEED = 0.8f;

    /**
     * The heading of this actor.
     */
    private Vector3f heading;

    /**
     * The destination of this actor.
     */
    private Point3f destination;

    /**
     * Specifies how close to the destination actor must get.
     */
    private float epsilon;

    /**
     * The speed of this actor.
     */
    private float speed;

    /**
     * The name of this actor.
     */
    private String name;

    /**
     * The player object corresponding to this actor.
     */
    private Player player;

    /**
     * A reference to the world this actor belongs to.
     */
    private World world;

    private long removeTime = 0;

    public boolean dead = false;

    /**
     * The current waypoint this actor is moving towards.
     */
    private int currentWaypointIndex;

    /**
     * The list of waypoints associated with this actor.
     */
    private Vector<Point3f> waypoints;

    /**
     * Debug waypoints.
     */
    private Shape3D waypointsShape;

    private boolean waypointsVisible;

    private Point3f targetPosition;

    private Transform3D targetTransform;

    private NodeTextOverlay playerText;

    private static MD2Model sharedModel = null;

    /**
     * Creates a new instance of the Actor class. An actor is any object
     * that may change its appearance or transform during it's life time.
     *
     * @param player the player associated with this actor.
     * @param modelname the model used by this actor.
     * @param skin the skin to use with the model.
     */
    public Actor(Player player, String modelname, String skin) throws Exception {
        this(player.getName(), modelname, skin);
        this.player = player;
    }

    /**
     * Creates a new instance of the Actor class. An actor is any object
     * that may change its appearance or transform during it's life time.
     *
     * @param name the name associated with this actor.
     * @param modelname the model used by this actor.
     * @param skin the skin to use with the model.
     */
    public Actor(String name, String modelname, String skin) throws Exception {
        this(name);
        addChild(loadMD2Model(modelname, skin));
        updateBounds(true);
        setPickable(name);
    }

    /**
     * load obj model
     * @deprecated cleanup this design!
     */
    public Actor(String name, String modelname) throws Exception {
        this(name, new OBJLoader().load(name));
    }

    /**
     * load obj model
     * @deprecated cleanup this design!
     */
    public Actor(String name, Node model) {
        this(name);
        addChild(model);
        setPickable(name);
    }

    /**
     * Creates a new instance of the Actor class. An actor is any object
     * that may change its appearance or transform during it's life time.
     */
    public Actor(String name) {
        transform = getTransform();
        this.name = name;
        this.world = null;
        scale = transform.getScale();
        waypoints = new Vector<Point3f>();
        pos = new Coord3f();
        heading = new Vector3f();
        destination = new Point3f();
        targetTransform = new Transform3D();
        targetPosition = new Point3f();
        speed = 0.0f;
        epsilon = 0.1f;
        playerText = new NodeTextOverlay(this);
        //addChild(new Shape3D(Util3D.createCoordAxes(0.1f)));
    }

    private BranchGroup loadMD2Model(String name, String skin) throws Exception {
        BranchGroup group;
        // TextureLoader.registerPath(""./dat/mdl"");
        // TextureLoader.registerPath(""./dat/tex"");
        if (sharedModel == null) {
            System.err.println(""CREATE MD2 LOADER"");
            MD2Loader loader = new MD2Loader();
            System.err.println(""BEGIN MD2 LOAD"");
            sharedModel = loader.load(new FileInputStream(name), skin);
            System.err.println(""END MD2 LOAD"");
        }
        System.err.println(""GET MD2 INSTANCE"");
        modelInstance = sharedModel.getInstance();
        // modelInstance.setAnimation(anim);
        // fix for test model (marvin)
        TransformGroup tg = new TransformGroup();
        Transform3D tf = new Transform3D();
        tf.rotXYZ((float) PI / 2, 0.0f, 0.0f);
        //tf.rotY(-90.0f);
        //tf.setScale(0.15f);
        tf.setTranslation(new Vector3f(0f, 0.15f, 0f));
        tg.setTransform(tf);
        System.err.println(""ADD MD2 INSTANCE TO TRANSFORMGROUP"");
        tg.addChild(modelInstance);
        System.err.println(""ADD MD2 INSTANCE TO SCENE"");
        group = new BranchGroup();
        group.addChild(tg);
        return group;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public NodeTextOverlay getPlayerText() {
        return playerText;
    }

    public Player getPlayer() {
        return player;
    }

    public void setPlayer(Player player) {
        this.player = player;
    }

    public void setX(float x) {
        pos.x = x;
    }

    public void setY(float y) {
        pos.y = y;
    }

    public void setZ(float z) {
        pos.z = z;
    }

    public void die(Actor attacker) {
        heading.y = getBearing(attacker.pos);
        if (modelInstance != null) {
            modelInstance.setAnimation(""death"");
            removeTime = System.currentTimeMillis() + 1000;
        }
    }

    public void die() {
        if (modelInstance != null) {
            modelInstance.setAnimation(""death"");
            removeTime = System.currentTimeMillis() + 1000;
        }
    }

    public void shoot(Actor target) {
        heading.y = getBearing(target.pos);
        if (modelInstance != null) {
            modelInstance.setAnimation(""attack"");
        }
    }

    public Point3f getPosition() {
        return new Point3f(pos);
    }

    public void getPosition(Tuple3f res) {
        res.set(pos);
    }

    public void setPosition(Point3f pos) {
        this.pos.set(pos);
    }

    public Vector3f getHeading() {
        return new Vector3f(heading);
    }

    public void setHeading(Vector3f heading) {
        this.heading.set(heading);
    }

    public float getSpeed() {
        return speed;
    }

    public void setSpeed(float speed) {
        this.speed = speed;
    }

    public World getWorld() {
        return world;
    }

    /**
     * Sets the world this player belong to. A player can belong to at most
     * one world at any given time.
     *
     * @param w the world this player belong to.
     */
    public void setWorld(World w) {
        if (w != null) {
            w.removeActor(this);
        }
        this.world = w;
    }

    /**
     * Calculates the bearing of the specified point from the actor's
     * point of view.
     *
     * @param target the point to which bearing is to be calculated.
     */
    public float getBearing(Tuple3f target) {
        targetTransform.invert(getTransform());
        targetPosition.set(target);
        targetTransform.transform(targetPosition);
        return (float) atan2(targetPosition.x, targetPosition.z);
    }

    public void move(float dt) {
        targetPosition.set(pos);
        targetPosition.y = 0;
        float distance = targetPosition.distance(destination);
        float bearing = getBearing(destination);
        if (waypoints.isEmpty()) {
            if (distance < 10.0f * epsilon) {
                if (distance < epsilon) {
                    if (modelInstance != null && speed != 0.0f) {
                        modelInstance.setAnimation(""stand"");
                    }
                    setSpeed(0.0f);
                } else {
                    setSpeed(distance);
                    if (modelInstance != null) {
                        modelInstance.setAnimation(""walk"");
                    }
                }
            }
        } else if (distance < epsilon) {
            moveTo(waypoints.remove(0));
        }
        if (modelInstance != null)
            modelInstance.interpolateAnim(0.05f);
        if (Math.abs(bearing - heading.y) > 0.001 && speed > 0.0f) {
            heading.y += (float) (bearing / PI * 0.1);
        }
        if (heading.y > 2 * PI) {
            heading.y -= 2 * PI;
        } else if (heading.y < 0) {
            heading.y += 2 * PI;
        }
        float speedScale = 1f - (float) (abs(bearing) / PI);
        pos.x += dt * speedScale * speed * sin(heading.y);
        pos.z += dt * speedScale * speed * cos(heading.y);
    }

    public void clearWaypoints() {
        waypoints.removeAllElements();
        //removeChild(waypointsShape);
    }

    public void gotoWaypoint(int index) {
        try {
            moveTo(waypoints.get(index));
            System.err.println(""Actor.gotoWaypoint() "");
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.printf(""Actor.gotoWaypoint(): index out of range: %d"", index);
        }
    }

    public void addWaypoint(Point3f p) {
        System.err.println(""adding waypoint: "" + p.x + "" "" + p.z);
        System.err.println(""(start pos: "" + pos.x + "" "" + pos.z + "")"");
        waypoints.add(new Point3f(p));
    }

    public void updateWaypointsShape() {
        if (waypointsShape != null) {
            getWorld().removeChild(waypointsShape);
        }
        LineStripArray lines = new LineStripArray(waypoints.size() + 1, GeometryArray.COORDINATES, new int[] { waypoints.size() + 1 });
        Point3f[] coords = new Point3f[waypoints.size()];
        waypoints.toArray(coords);
        Point3f start = new Point3f(pos);
        start.y = 0;
        lines.setCoordinate(0, start);
        lines.setCoordinates(1, coords);
        Appearance appearance = new Appearance();
        appearance.setRenderingAttributes(new RenderingAttributes(false, true, 0, 0));
        waypointsShape = new Shape3D(lines);
        getWorld().addChild(waypointsShape);
    }

    public void setWaypointsVisible(boolean visible) {
        waypointsVisible = visible;
        if (visible) {
            updateWaypointsShape();
        }
    }

    /**
     * Sets the destination of this actor to the given coordinates.
     * @param x the x coordinate of the destination point.
     * @param y the y coordinate of the destination point.
     * @param z the z coordinate of the destination point.
     */
    public void moveTo(float x, float y, float z) {
        moveTo(new Point3f(x, y, z));
    }

    /**
     * Sets the destination of this actor.
     * @param dst the destination point.
     */
    public void moveTo(Tuple3f dst) {
        destination.set(dst);
        setSpeed(pos.distance(destination));
        if (modelInstance != null)
            modelInstance.setAnimation(""run"");
        System.err.println(""distance: "" + pos.distance(destination));
        if (getSpeed() > PLAYER_SPEED) {
            setSpeed(PLAYER_SPEED);
        }
    }

    /**
     * Returns the shape associated with this actor.
     * @return the shape associated with this actor.
     */
    public Shape3D getShape() {
        return shape;
    }

    /**
     * Changes are performed here so that nothing breaks if methods are
     * invoked from another thread. This method has to be called from the
     * main rendering thread.
     */
    public void update(float dt) {
        if (dead)
            return;
        transform.setEuler(heading);
        transform.setTranslation(pos);
        move(dt);
        setTransform(transform);
        if (removeTime != 0 && System.currentTimeMillis() > removeTime) {
            System.err.println(""BALEETED"");
            ((Group) getParent()).removeChild(this);
            dead = true;
        }
    }

    /**
     * Enable picking of this node.
     * @param name the name used to identify this node.
     */
    public void setPickable(String name) {
        Node g = getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        setPickableRecursive(this, name);
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// ActorTest.java
package gui.gl;

import static java.lang.Math.abs;
import static java.lang.Math.sin;
import static java.lang.Math.cos;
import static java.lang.Math.atan2;
import static java.lang.Math.PI;
import static com.xith3d.image.DirectBufferedImage.getDirectImageRGBA;
import java.io.FileInputStream;
import java.awt.geom.*;
import java.util.Enumeration;
import java.util.Vector;
import javax.vecmath.*;
import state.Player;
import com.xith3d.image.DirectBufferedImage;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.Coord3f;
import com.xith3d.utility.interpolate.*;
import com.xith3d.loaders.texture.*;
import org.newdawn.xith3d.obj.OBJLoader;
import org.newdawn.xith3d.loaders.md2.MD2Loader;
import org.newdawn.xith3d.loaders.md2.MD2Model;
import org.newdawn.xith3d.loaders.md2.MD2ModelInstance;
import org.newdawn.xith3d.loaders.ModelLoadingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Actor}.
* It contains ten unit test cases for the {@link Actor#getBearing(Tuple3f)} method.
*/
class ActorTest {","// ActorTest.java
package gui.gl;

import static java.lang.Math.abs;
import static java.lang.Math.sin;
import static java.lang.Math.cos;
import static java.lang.Math.atan2;
import static java.lang.Math.PI;
import static com.xith3d.image.DirectBufferedImage.getDirectImageRGBA;
import java.io.FileInputStream;
import java.awt.geom.*;
import java.util.Enumeration;
import java.util.Vector;
import javax.vecmath.*;
import state.Player;
import com.xith3d.image.DirectBufferedImage;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.Coord3f;
import com.xith3d.utility.interpolate.*;
import com.xith3d.loaders.texture.*;
import org.newdawn.xith3d.obj.OBJLoader;
import org.newdawn.xith3d.loaders.md2.MD2Loader;
import org.newdawn.xith3d.loaders.md2.MD2Model;
import org.newdawn.xith3d.loaders.md2.MD2ModelInstance;
import org.newdawn.xith3d.loaders.ModelLoadingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Actor}.
* It contains ten unit test cases for the {@link Actor#getBearing(Tuple3f)} method.
*/
class ActorTest {
"
b11571ee-cb1d-4155-a54c-3af72f1bdfec,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/HeadUpDisplay.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8202 tokens (4202 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// HeadUpDisplay.java
/* $Id: HeadUpDisplay.java,v 1.4 2004/05/04 21:33:58 emill Exp $
 *
 * Based on Jens Lehmann's excellent tutorial found at 
 * http://xith.org/tutes/GettingStarted/html/simple_header.html
 *
 * @author Joel Andersson <bja@kth.se>
 * @version $Revision: 1.4 $
 */
package gui.gl;

import com.xith3d.scenegraph.Node;
import com.xith3d.scenegraph.BoundingSphere;
import com.xith3d.scenegraph.Canvas3D;
import com.xith3d.scenegraph.Shape3D;
import com.xith3d.userinterface.UIOverlay;
import com.xith3d.userinterface.UIOverlayInterface;
import com.xith3d.userinterface.UIWindow;
import com.xith3d.userinterface.UIWindowManager;
import com.xith3d.userinterface.UIPositionedWindow;
import javax.vecmath.Point3f;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.BorderLayout;
import javax.swing.JTextArea;
import javax.swing.JPanel;

/**
 */
public class HeadUpDisplay extends UIWindowManager {

    /**
     */
    private Canvas3D canvas;

    /**
     */
    public HeadUpDisplay(Canvas3D c) {
        super(c);
        this.canvas = c;
    }

    /**
     */
    public UIPositionedWindow addOverlay(UIOverlayInterface o) {
        if (o instanceof Overlay) {
            ((Overlay) o).setWindowManager(this);
        }
        if (o instanceof NodeOverlay) {
            ((NodeOverlay) o).setCanvas(canvas);
        }
        setPosition(o, 0, 0);
        setVisible(o, true);
        return super.addOverlay(o);
    }
}

/**
 */
class SwingTextOverlay extends UIWindow {

    /**
     */
    private JTextArea textArea;

    /**
     */
    private JPanel root;

    /**
     */
    private Color background;

    /**
     */
    private Color foreground;

    /**
     * @param width
     * @param height
     */
    public SwingTextOverlay(int width, int height) {
        super(width, height, true, true);
        background = new Color(0.0f, 0.0f, 0.0f, 0.0f);
        foreground = new Color(1.0f, 1.0f, 1.0f, 1.0f);
        textArea = new JTextArea();
        textArea.setForeground(foreground);
        textArea.setBackground(background);
        root = new JPanel();
        root.setLayout(new BorderLayout());
        root.setBackground(background);
        root.setSize(new Dimension(width, height));
        root.add(BorderLayout.CENTER, textArea);
        setRoot(root);
    }

    /**
     * @param text
     */
    public void setText(String text) {
        textArea.setText(text);
    }

    public void append(String text) {
        textArea.append(text);
    }

    public void clear() {
        setText("""");
    }
}

class TextOverlay implements Overlay {

    public static final Font FONT_PLAIN;

    static {
        FONT_PLAIN = new Font(""SansSerif"", Font.PLAIN, 12);
    }

    private static final Color transparent = new Color(0, 0, 0, 0);

    private UIOverlay overlay;

    private FontMetrics fontMetrics;

    private String text;

    private Font font;

    private Graphics2D gfx = null;

    private int width = 0;

    private int height = 0;

    private UIWindowManager uiWinMgr;

    private Color foreground;

    private Color background;

    private Color shadow;

    private Color outline;

    /**
     * Creates a new TextOverlay with the specified text.
     * @param text the text associated with this overlay.
     */
    TextOverlay(String text) {
        setFont(""SansSerif"", Font.PLAIN, 12);
        setBackground(transparent);
        setForeground(Color.WHITE);
        setShadow(transparent);
        setOutline(Color.black);
        setText(text);
        setVisible(true);
        setPosition(0, 0);
    }

    public void setFont(String name, int style, int size) {
        try {
            font = new Font(name, style, size);
            fontMetrics = getFontMetrics(font);
            overlay.repaint();
        } catch (NullPointerException e) {
            // text not set, ignore this exception.
        }
    }

    public String getText() {
        return text;
    }

    public void setText(String text) {
        this.text = text;
        int w = fontMetrics.stringWidth(text);
        int h = fontMetrics.getMaxDescent() + fontMetrics.getMaxAscent();
        if (w > width || h > height) {
            // add space for round edge
            width = w + h;
            height = h;
            overlay = new UIOverlay(width, height + 2, true, false) {

                public void paint(Graphics2D g) {
                    int ascent = fontMetrics.getMaxAscent();
                    // background
                    g.setColor(background);
                    g.fillArc(0, 0, height, height, 90, 180);
                    g.fillArc(width - height, 0, height, height, 270, 180);
                    g.fillRect(height / 2, 0, width - height, height);
                    // border
                    /*
			g.setColor(outline);
			g.drawArc(0,0,height-1,height,90,180);
			g.drawArc(width-height,0,height-1,height,270,180);
			g.drawLine(height/2,0,width-height/2,0);
			g.drawLine(height/2,height-1,width-height/2,height-1);
			g.drawArc(2,2,height-3,height-3,90,180);
			g.drawArc(width-height-2,2,height-3,height-3,270,180);
			g.drawLine(height/2,2,width-height/2,2);
			g.drawLine(height/2,height-3,width-height/2,height-3);
			g.setColor(foreground);
			g.drawArc(1,1,height-2,height-2,90,180);
			g.drawArc(width-height-1,1,height-2,height-2,270,180);
			g.drawLine(height/2,1,width-height/2,1);
			g.drawLine(height/2,height-2,width-height/2,height-2);
			*/
                    // outlined
                    g.setColor(outline);
                    g.drawString(getText(), height / 2, ascent - 1);
                    g.drawString(getText(), height / 2, ascent + 1);
                    g.drawString(getText(), height / 2 - 1, ascent);
                    g.drawString(getText(), height / 2 + 1, ascent);
                    // shadowed
                    g.setColor(shadow);
                    g.drawString(getText(), height / 2 + 1, ascent + 1);
                    g.drawString(getText(), height / 2 + 2, ascent + 2);
                    // foreground
                    g.setColor(foreground);
                    g.drawString(getText(), height / 2, ascent);
                }
            };
            BufferedImage img = overlay.getBackgroundImage();
            overlay.setBackgroundMode(UIOverlay.BACKGROUND_COPY);
            overlay.setBackgroundImage(img);
            gfx = img.createGraphics();
            if (uiWinMgr != null) {
                uiWinMgr.removeOverlay(this);
                uiWinMgr.addOverlay(this);
            }
        }
        overlay.repaint();
    }

    public void setForeground(Color color) {
        try {
            this.foreground = color;
            overlay.repaint();
        } catch (NullPointerException e) {
            // text not set, ignore this.
        }
    }

    public void setBackground(Color color) {
        try {
            this.background = color;
            overlay.repaint();
        } catch (NullPointerException e) {
            // text not set, ignore this.
        }
    }

    public void setShadow(Color color) {
        try {
            this.shadow = color;
            overlay.repaint();
        } catch (NullPointerException e) {
            // text not set, ignore this.
        }
    }

    public void setOutline(Color color) {
        try {
            this.outline = color;
            overlay.repaint();
        } catch (NullPointerException e) {
            // text not set, ignore this.
        }
    }

    public void setPosition(int x, int y) {
        if (uiWinMgr != null) {
            uiWinMgr.setPosition(this, x - width / 2, y - height / 2);
        } else {
            overlay.setPosition(x, y);
        }
    }

    public void setVisible(boolean visible) {
        if (uiWinMgr != null) {
            uiWinMgr.setVisible(this, visible);
        } else {
            overlay.setVisible(visible);
        }
    }

    public void setWindowManager(UIWindowManager mgr) {
        this.uiWinMgr = mgr;
    }

    public Node getRoot() {
        return overlay.getRoot();
    }

    public void getSize(Dimension dim) {
        overlay.getSize(dim);
    }

    public boolean isOpaque() {
        return overlay.isOpaque();
    }

    public void update() {
        overlay.update();
    }

    private static FontMetrics getFontMetrics(Font font) {
        GraphicsEnvironment env = GraphicsEnvironment.getLocalGraphicsEnvironment();
        GraphicsDevice dev = env.getDefaultScreenDevice();
        GraphicsConfiguration cfg = dev.getDefaultConfiguration();
        Graphics2D g = cfg.createCompatibleImage(1, 1).createGraphics();
        return g.getFontMetrics(font);
    }
}

class NodeTextOverlay extends TextOverlay implements NodeOverlay {

    private Canvas3D canvas;

    private Node node;

    NodeTextOverlay(Node node) {
        this(node, node.getName());
    }

    NodeTextOverlay(Node node, String text) {
        super(text);
        this.node = node;
    }

    public void update() {
        BoundingSphere sphere = (BoundingSphere) node.getBounds();
        javax.vecmath.Point3f q = sphere.getCenter();
        q.y = 0.6f;
        node.getLocalToVworld().transform(q);
        q = Util3D.toScreen(canvas, q);
        setPosition((int) q.x, (int) q.y);
        if (node instanceof Actor) {
            if (((Actor) node).dead)
                setPosition(1000, 1000);
        }
        super.update();
    }

    public void setCanvas(Canvas3D canvas) {
        this.canvas = canvas;
    }
}

class ImageOverlay implements Overlay {

    private Graphics2D gfx;

    private BufferedImage image;

    private UIOverlay overlay;

    private UIWindowManager uiWinMgr;

    public ImageOverlay() {
    }

    public ImageOverlay(BufferedImage img) {
        setImage(img);
    }

    public void setImage(BufferedImage img) {
        overlay = new UIOverlay(img.getWidth(), img.getHeight(), true, false);
        overlay.setBackgroundMode(UIOverlay.BACKGROUND_COPY);
        image = overlay.getBackgroundImage();
        overlay.setBackgroundImage(img);
        gfx = image.createGraphics();
        gfx.drawImage(img, null, 0, 0);
        if (uiWinMgr != null) {
            uiWinMgr.removeOverlay(this);
            uiWinMgr.addOverlay(this);
        }
        //	overlay.repaint();
    }

    public BufferedImage getImage() {
        return image;
    }

    public Graphics2D getGraphics() {
        return gfx;
    }

    public void setPosition(int x, int y) {
        if (uiWinMgr != null) {
            uiWinMgr.setPosition(this, x - image.getWidth() / 2, y - image.getHeight() / 2);
        } else {
            overlay.setPosition(x, y);
        }
    }

    public void setWindowManager(UIWindowManager mgr) {
        this.uiWinMgr = mgr;
    }

    public Node getRoot() {
        return overlay.getRoot();
    }

    public void getSize(Dimension dim) {
        overlay.getSize(dim);
    }

    public boolean isOpaque() {
        return overlay.isOpaque();
    }

    public void update() {
        overlay.update();
    }
}

class NodeImageOverlay extends ImageOverlay implements NodeOverlay {

    private Node node;

    private Canvas3D canvas;

    public NodeImageOverlay(Node node, BufferedImage img) {
        super(img);
        this.node = node;
    }

    public void update() {
        BoundingSphere sphere = (BoundingSphere) node.getBounds();
        Point3f q = sphere.getCenter();
        q.y = sphere.getRadius();
        node.getLocalToVworld().transform(q);
        q = Util3D.toScreen(canvas, q);
        setPosition((int) q.x, (int) q.y);
        super.update();
    }

    public void setCanvas(Canvas3D canvas) {
        this.canvas = canvas;
    }
}

interface Overlay extends UIOverlayInterface {

    public void setWindowManager(UIWindowManager mgr);
}

interface NodeOverlay extends Overlay {

    public void setCanvas(Canvas3D canvas);
}

class HudOverlay extends UIOverlay implements UIOverlayInterface {

    HudOverlay(int w, int h, boolean clip, boolean blend) {
        super(w, h, clip, blend);
    }

    public void paint(Graphics2D g) {
    }
}
","// HeadUpDisplayTest.java
package gui.gl;

import com.xith3d.scenegraph.Node;
import com.xith3d.scenegraph.BoundingSphere;
import com.xith3d.scenegraph.Canvas3D;
import com.xith3d.scenegraph.Shape3D;
import com.xith3d.userinterface.UIOverlay;
import com.xith3d.userinterface.UIOverlayInterface;
import com.xith3d.userinterface.UIWindow;
import com.xith3d.userinterface.UIWindowManager;
import com.xith3d.userinterface.UIPositionedWindow;
import javax.vecmath.Point3f;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.BorderLayout;
import javax.swing.JTextArea;
import javax.swing.JPanel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HeadUpDisplay}.
* It contains ten unit test cases for the {@link HeadUpDisplay#addOverlay(UIOverlayInterface)} method.
*/
class HeadUpDisplayTest {","// HeadUpDisplayTest.java
package gui.gl;

import com.xith3d.scenegraph.Node;
import com.xith3d.scenegraph.BoundingSphere;
import com.xith3d.scenegraph.Canvas3D;
import com.xith3d.scenegraph.Shape3D;
import com.xith3d.userinterface.UIOverlay;
import com.xith3d.userinterface.UIOverlayInterface;
import com.xith3d.userinterface.UIWindow;
import com.xith3d.userinterface.UIWindowManager;
import com.xith3d.userinterface.UIPositionedWindow;
import javax.vecmath.Point3f;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.GraphicsDevice;
import java.awt.GraphicsEnvironment;
import java.awt.image.BufferedImage;
import java.awt.Dimension;
import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.BorderLayout;
import javax.swing.JTextArea;
import javax.swing.JPanel;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link HeadUpDisplay}.
* It contains ten unit test cases for the {@link HeadUpDisplay#addOverlay(UIOverlayInterface)} method.
*/
class HeadUpDisplayTest {
"
cmpl-6ttnoAwkroGydsI7EjivAVWxHvBqH,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Particle.java,34.832183837890625,stop,"// Particle.java
/* $Id: Particle.java,v 1.1 2004/04/25 15:05:31 emill Exp $
 *
 *
 * @author Emil Lundstrï¿½m <emill@kth.se>
 */
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;

/**
 * A single particle in the particle engine.
 */
public class Particle {

    /**
     * The particle location in the world.
     */
    Coord3f location = new Coord3f();

    /**
     * The particle speed.
     */
    Vector3f speed = new Vector3f();

    /**
     * The particle acceleration.
     */
    Vector3f acceleration = new Vector3f();

    /**
     * The particle color.
     */
    Color4f color = new Color4f();

    Point3f[] particleCoordinates = { new Point3f(), new Point3f(), new Point3f(), new Point3f() };

    /**
     * The total lifetime of this particle.
     */
    private int lifetime = 1;

    /**
     * The speed that this particle fades away with. A high value
     *        makes it fade away slow at first, then quickly in the end. A
     *        value of one makes it fade away linearly.
     */
    private float fadeSpeed = 1f;

    /**
     * The age of this particle.
     */
    private int age = 0;

    private ParticleSystem system;

    private static Coord3f randomPoint = new Coord3f();

    /**
     * Creates a new particle. Its parameters are all set to zero.
     */
    public Particle() {
    }

    /**
     * Creates a new particle and sets its parameters to the passed
     * arguments.
     *
     * @see newParticle()
     */
    public Particle(ParticleSystem m, Coord3f l, Vector3f s, Vector3f a, Color4f c, int lt, float fs) {
        newParticle(m, l, s, a, c, lt, fs);
    }

    /**
     * Sets this particle to a new particle, for re-usability.
     *
     * @param m The parent particle system for this particle.
     * @param l The location of the particle.
     * @param s The speed vector of the particle.
     * @param a The acceleration vector of the particle.
     * @param c The color of the particle.
     * @param lt The lifetime, in update ticks, of the particle.
     */
    public void newParticle(ParticleSystem m, Coord3f l, Vector3f s, Vector3f a, Color4f c, int lt, float fs) {
        system = m;
        location.set(l);
        speed.set(s);
        acceleration.set(a);
        color.set(c);
        lifetime = lt + (int) (system.particleLifetimeRandomness * (system.random.nextFloat() - 0.5f));
        fadeSpeed = fs;
        age = 0;
        updateParticleLocation();
        addRandomness(speed, system.particleSpeedRandomness);
        addRandomness(acceleration, system.particleAccelerationRandomness);
    }

    private void addRandomness(Tuple3f point, float scale) {
        randomPoint.set(system.random.nextFloat() - 0.5f, system.random.nextFloat() - 0.5f, system.random.nextFloat() - 0.5f);
        randomPoint.scale(scale);
        point.add(randomPoint);
    }

    /**
     * Executes one update on this particle by updating its speed,
     * location and color. To be called once every update tick from
     * the state loop.
     *
     * @return true if particle is still alive. false otherwise.
     */
    public boolean updateParticle() {
        speed.add(acceleration);
        location.add(speed);
        addRandomness(location, system.particleLocationRandomness);
        updateParticleLocation();
        age++;
        color.w = 1f - (float) Math.pow(age / (float) lifetime, fadeSpeed);
        if (age < lifetime)
            return true;
        return false;
    }

    public void updateParticleLocation() {
        for (int i = 0; i < 4; i++) particleCoordinates[i].scaleAdd(system.particleSize, system.sharedGeometryData[i], location);
    }
}
","// ParticleTest.java
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Particle}.
* It contains ten unit test cases for the {@link Particle#updateParticle()} method.
*/
class ParticleTest {","// ParticleTest.java
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Particle}.
* It contains ten unit test cases for the {@link Particle#updateParticle()} method.
*/
class ParticleTest {

		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after one update tick.
		*/
		@Test
		void testUpdateParticle() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 1, 1);
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after two update ticks.
		*/
		@Test
		void testUpdateParticle2() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 2, 1);
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after three update ticks.
		*/
		@Test
		void testUpdateParticle3() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 3, 1);
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after four update ticks.
		*/
		@Test
		void testUpdateParticle4() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 4, 1);
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after five update ticks.
		*/
		@Test
		void testUpdateParticle5() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 5, 1);
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after six update ticks.
		*/
		@Test
		void testUpdateParticle6() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 6, 1);
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after seven update ticks.
		*/
		@Test
		void testUpdateParticle7() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 7, 1);
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after eight update ticks.
		*/
		@Test
		void testUpdateParticle8() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 8, 1);
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after nine update ticks.
		*/
		@Test
		void testUpdateParticle9() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 9, 1);
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()}.
		* It tests if the particle is still alive after ten update ticks.
		*/
		@Test
		void testUpdateParticle10() {
				Particle particle = new Particle();
				particle.newParticle(new ParticleSystem(), new Coord3f(), new Vector3f(), new Vector3f(), new Color4f(), 10, 1);
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				particle.updateParticle();
				assertTrue(particle.updateParticle());
		}
}"
cmpl-6ttorNClE4UVQYbXOrFo3648n2ne4,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/ParticleManager.java,72.75018906593323,length,"// ParticleManager.java
/* $Id: ParticleManager.java,v 1.4 2004/05/04 19:42:07 emill Exp $
 *
 *
 * @author Emil Lundstrï¿½m <emill@kth.se>
 */
package gui.gl;

import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import java.util.LinkedList;
import java.util.Stack;

/**
 * A particle manages all particle systems.
 */
public class ParticleManager {

    // milliseconds between updates
    public static final int UPDATE_FREQUENCY = 10;

    private long nextTime = 0;

    private LinkedList<ParticleSystem> stock;

    //private LinkedList<ParticleSystem> systemList =
    //	new LinkedList<ParticleSystem>();
    private TransformGroup systemGroup = new TransformGroup();

    public ParticleManager() {
        stock = new LinkedList<ParticleSystem>();
    }

    /**
     * Update all systems this manager manages.
     *
     * @param c The transformation used for particle
     * billboarding. Translation is omitted.
     */
    public void updateSystems(Transform3D c) {
        long currentTime = System.currentTimeMillis();
        if (currentTime > nextTime) {
            LinkedList tmp = new LinkedList(systemGroup.getChildren());
            for (Object p : tmp) {
                ParticleSystem s = (ParticleSystem) p;
                if (!s.updateSystem(c)) {
                    systemGroup.removeChild(s);
                    systemGroup.updateBounds(false);
                    stock.add(s);
                }
            }
            nextTime = currentTime + UPDATE_FREQUENCY;
        }
    }

    /**
     * Returns a TransformGroup containing all particles of this
     * particle system.
     */
    public TransformGroup getParticles() {
        return systemGroup;
    }

    /**
     * Adds a new particle system.
     *
     * DEPRECATED: Preferred way to create a particle system is by
     * using built in methods of ParticleManager, which incidentally
     * haven't been written yet. This function will soon be private.
     */
    public void addParticleSystem(ParticleSystem s) {
        systemGroup.addChild(s);
        systemGroup.updateBounds(false);
    }

    /**
     * Creates a new particle system.
     *
     * @param type The type of the new system, as specified in
     * ParticleSystem constants.
     * @param l The coordinate of this the new ParticleSystem in this
     * ParticleManager's coordinate system, which typically should be
     * equal to the world system.
     * @param pc The desired particle count. If a unused particle
     * system with the correct particle count is found, it will be
     * used. Otherwise, a new one is allocated.
     * @param lt The lifetime of the particle system.
     */
    public ParticleSystem createParticleSystem(int type, Coord3f l, int pc, int lt) {
        ParticleSystem found = null;
        for (ParticleSystem s : stock) {
            if (s.getParticleCount() == pc) {
                found = s;
                break;
            }
        }
        if (found == null) {
            found = new ParticleSystem(this, type, l, pc, lt);
        } else {
            stock.remove(found);
            found.newSystem(type, l, lt);
        }
        addParticleSystem(found);
        return found;
    }
}
","// ParticleManagerTest.java
package gui.gl;

import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import java.util.LinkedList;
import java.util.Stack;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParticleManager}.
* It contains ten unit test cases for the {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)} method.
*/
class ParticleManagerTest {","// ParticleManagerTest.java
package gui.gl;

import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import java.util.LinkedList;
import java.util.Stack;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParticleManager}.
* It contains ten unit test cases for the {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)} method.
*/
class ParticleManagerTest {

		/**
		* Test case 1 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object.
		*/
		@Test
		void testCreateParticleSystem1() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertTrue(ps instanceof ParticleSystem);
		}
		
		/**
		* Test case 2 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testCreateParticleSystem2() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_SMOKE, ps.getType());
		}
		
		/**
		* Test case 3 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct location.
		*/
		@Test
		void testCreateParticleSystem3() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(new Coord3f(0, 0, 0), ps.getLocation());
		}
		
		/**
		* Test case 4 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct particle count.
		*/
		@Test
		void testCreateParticleSystem4() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(100, ps.getParticleCount());
		}
		
		/**
		* Test case 5 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct lifetime.
		*/
		@Test
		void testCreateParticleSystem5() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(100, ps.getLifetime());
		}
		
		/**
		* Test case 6 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testCreateParticleSystem6() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_FIRE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_FIRE, ps.getType());
		}
		
		/**
		* Test case 7 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testCreateParticleSystem7() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_EXPLOSION, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_EXPLOSION, ps.getType());
		}
		
		/**
		* Test case 8 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testCreateParticleSystem8() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SPARK, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_SPARK, ps.getType());
		}
		
		/**
		* Test case 9 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testCreateParticleSystem9() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SMOKE_TRAIL, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_SMOKE_TRAIL, ps.getType());
		}
		
		/**
		* Test case 10 for {@link ParticleManager#createParticleSystem(int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testCreateParticleSystem10() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = pm.createParticleSystem(ParticleSystem.TYPE_SPARK_TRAIL, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_SPARK_TRAIL, ps.getType());
		}
}

// ParticleSystem.java
/* $Id: ParticleSystem.java,v 1.4 2004/05/04 19:42:07 emill Exp $
 *
 *
 * @author Emil Lundstrï¿½m <emill@kth.se>
 */
package gui.gl;

import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import java.util.LinkedList;
import java.util.Stack;

/**
 * A particle system manages a set of particles.
 */
public class ParticleSystem extends TransformGroup {

    public static final int TYPE_SMOKE = 0;
    public static final int TYPE_FIRE = 1;
    public static final int TYPE_EXPLOSION = 2;
    public static final int TYPE_SPARK = 3;
    public static final int TYPE_SMOKE_TRAIL = 4;
    public static final int TYPE_SPARK_TRAIL = 5;

    private ParticleManager manager;

    private int type;
    private Coord3f location;
    private int particleCount;
    private int lifetime;

    private LinkedList<Particle> particles;

    private TransformGroup particleGroup = new TransformGroup();

    /**
     * Creates a new particle system.
     *
     * @param m The particle manager that manages this system.
     * @param type The type of the new system, as specified in
     * ParticleSystem constants.
     * @param l The coordinate of this the new ParticleSystem in this
     * ParticleManager's coordinate system, which typically should be
     * equal to the world system.
     * @param pc The desired particle count. If a unused particle
     * system with the correct particle count is found, it will be
     * used. Otherwise, a new one is allocated.
     * @param lt The lifetime of the particle system.
     */
    public ParticleSystem(ParticleManager m, int type, Coord3f l, int pc, int lt) {
        manager = m;
        newSystem(type, l, lt);
        particles = new LinkedList<Particle>();
        for (int i = 0; i < pc; i++) {
            particles.add(new Particle(this));
        }
        particleGroup.addChildren(particles);
        addChild(particleGroup);
    }

    /**
     * Creates a new particle system.
     *
     * @param type The type of the new system, as specified in
     * ParticleSystem constants.
     * @param l The coordinate of this the new ParticleSystem in this
     * ParticleManager's coordinate system, which typically should be
     * equal to the world system.
     * @param lt The lifetime of the particle system.
     */
    public void newSystem(int type, Coord3f l, int lt) {
        this.type = type;
        location = l;
        lifetime = lt;
        setTransform(new Transform3D(new Matrix4f(1, 0, 0, l.x,
                0, 1, 0, l.y,
                0, 0, 1, l.z,
                0, 0, 0, 1)));
    }

    /**
     * Returns the type of this particle system.
     */
    public int getType() {
        return type;
    }

    /**
     * Returns the location of this particle system.
     */
    public Coord3f getLocation() {
        return location;
    }

    /**
     * Returns the particle count of this particle system.
     */
    public int getParticleCount() {
        return particleCount;
    }

    /**
     * Returns the lifetime of this particle system.
     */
    public int getLifetime() {
        return lifetime;
    }

    /**
     * Updates the particle system.
     *
     * @param c The transformation used for particle
     * billboarding. Translation is omitted.
     * @return True if the system is still alive, false otherwise.
     */
    public boolean updateSystem(Transform3D c) {
        for (Particle p : particles) {
            p.updateParticle(c);
        }
        lifetime--;
        return lifetime > 0;
    }
}

// ParticleSystemTest.java
package gui.gl;

import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import java.util.LinkedList;
import java.util.Stack;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParticleSystem}.
* It contains ten unit test cases for the {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)} method.
*/
class ParticleSystemTest {
		
		/**
		* Test case 1 for {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object.
		*/
		@Test
		void testParticleSystem1() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(pm, ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertTrue(ps instanceof ParticleSystem);
		}
		
		/**
		* Test case 2 for {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testParticleSystem2() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(pm, ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_SMOKE, ps.getType());
		}
		
		/**
		* Test case 3 for {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct location.
		*/
		@Test
		void testParticleSystem3() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(pm, ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(new Coord3f(0, 0, 0), ps.getLocation());
		}
		
		/**
		* Test case 4 for {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct particle count.
		*/
		@Test
		void testParticleSystem4() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(pm, ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(100, ps.getParticleCount());
		}
		
		/**
		* Test case 5 for {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct lifetime.
		*/
		@Test
		void testParticleSystem5() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(pm, ParticleSystem.TYPE_SMOKE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(100, ps.getLifetime());
		}
		
		/**
		* Test case 6 for {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testParticleSystem6() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(pm, ParticleSystem.TYPE_FIRE, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_FIRE, ps.getType());
		}
		
		/**
		* Test case 7 for {@link ParticleSystem#ParticleSystem(ParticleManager, int, Coord3f, int, int)}.
		* It tests if the method returns a {@link ParticleSystem} object with the correct type.
		*/
		@Test
		void testParticleSystem7() {
				ParticleManager pm = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(pm, ParticleSystem.TYPE_EXPLOSION, new Coord3f(0, 0, 0), 100, 100);
				assertEquals(ParticleSystem.TYPE_EXPLOSION, ps.getType());
		}
		
	"
cmpl-6ttq2R1kxLvwpMwYKsxY8nUtgXtQs,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/ParticleSystem.java,87.27836585044861,length,"// ParticleSystem.java
/* $Id: ParticleSystem.java,v 1.6 2004/05/05 11:55:12 emill Exp $
 *
 *
 * @author Emil Lundstrï¿½m <emill@kth.se>
 */
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import com.xith3d.loaders.texture.TextureLoader;
import com.xith3d.image.*;
import java.util.Random;
import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.awt.image.BufferedImage;

/**
 * A particle system in the partice engine. One particle system is the
 * same as one source of particles, e.g. one puff of smoke, one
 * explosion, etc.
 */
public class ParticleSystem extends TransformGroup {

    private ParticleManager manager;

    private int particle_count;

    private Particle[] particles;

    private Shape3D shape;

    // this is used to build a shape3d
    private TriangleStripArray particleGeometry;

    // facing stuff for each particle
    Coord3f[] sharedGeometryData = { new Coord3f(-1.0f, -1.0f, 0.0f), new Coord3f(1.0f, -1.0f, 0.0f), new Coord3f(-1.0f, 1.0f, 0.0f), new Coord3f(1.0f, 1.0f, 0.0f) };

    // default geometry data, used only to recalculate
    // sharedGeometryData when billboarding
    private static final Coord3f[] defaultGeometryData = { new Coord3f(-1.0f, -1.0f, 0.0f), new Coord3f(1.0f, -1.0f, 0.0f), new Coord3f(-1.0f, 1.0f, 0.0f), new Coord3f(1.0f, 1.0f, 0.0f) };

    private TexCoord2f[] sharedTextureData = { new TexCoord2f(0, 0), new TexCoord2f(1, 0), new TexCoord2f(0, 1), new TexCoord2f(1, 1) };

    // holds geometry coords for all particles (4 for each)
    private Point3f[] geometryCoordinates;

    private Color4f[] appearanceColors;

    // particle system specific data
    private int lifetime = 100000;

    private int age = 0;

    private int type = 0;

    public static final int TYPE_FLAME = 0;

    public static final int TYPE_SMOKE = 1;

    public static final int TYPE_EXPLOSION = 2;

    public static final int TYPE_MUZZLE = 3;

    public static final int TYPE_BLOOD = 4;

    public static final int TYPE_SUPERNOVA = 5;

    // IMPORTANT: Update this if another system type is added.
    static final int PARTICLE_SYSTEM_COUNT = 6;

    // default values for newly spawned particles for this particle
    // system.
    private Coord3f particleSpawnLocation = new Coord3f();

    private Vector3f particleSpeed = new Vector3f();

    private Vector3f particleAcceleration = new Vector3f();

    private Color4f particleColor = new Color4f();

    private int particleLifetime = 0;

    private float particleFadeSpeed = 1f;

    // values used by the particles of this system
    public float particleSpeedRandomness = 0f;

    public float particleAccelerationRandomness = 0f;

    public float particleLocationRandomness = 0.1f;

    public float particleLifetimeRandomness = 0.1f;

    public float particleSize = 1f;

    public Random random = new Random();

    /**
     * Creates a new particle system using the given preset.
     *
     * @param m The particle manager.
     * @param type The preset type for this particle system.
     * @param loc The world coordinate where new particles spawn.
     * @param pc Number of particles.
     * @param lt The lifetime of this system.
     */
    public ParticleSystem(ParticleManager m, int t, Coord3f loc, int pc, int lt) {
        particle_count = pc;
        manager = m;
        setUpSystem();
        newSystem(t, loc, lt);
    }

    /**
     * Sets up variables for a new system. If an old particle system
     * needs to be reused, calling this function should be
     * enough. I.e., there's no need to call setUpSystem().
     *
     * @param type The preset type for this particle system.
     * @param loc The world coordinate where new particles spawn.
     * @param lt The lifetime of this system.
     */
    public void newSystem(int t, Coord3f loc, int lt) {
        setTranslation(loc);
        lifetime = lt;
        age = 0;
        type = t;
        switch(type) {
            case TYPE_FLAME:
                particleSpawnLocation.set(0f, 0f, 0f);
                particleSpeed.set(0f, 0.03f, 0f);
                particleAcceleration.set(0f, 0f, 0f);
                particleColor.set(1f, 0.4f, 0.1f, 1f);
                particleLifetime = 30;
                particleFadeSpeed = 1f;
                particleSize = 0.2f;
                particleSpeedRandomness = 0.001f;
                particleAccelerationRandomness = 0f;
                particleLocationRandomness = 0.05f;
                particleLifetimeRandomness = 30f;
                break;
            case TYPE_BLOOD:
                particleSpawnLocation.set(0f, 0f, 0f);
                particleSpeed.set(0f, 0.01f, 0f);
                particleAcceleration.set(0f, -0.002f, 0f);
                particleColor.set(0.5f, 0.01f, 0.01f, 1f);
                particleLifetime = 40;
                particleFadeSpeed = 2f;
                particleSize = 0.03f;
                particleSpeedRandomness = 0f;
                particleAccelerationRandomness = 0f;
                particleLocationRandomness = 0.01f;
                particleLifetimeRandomness = 30f;
                break;
            case TYPE_MUZZLE:
                particleSpawnLocation.set(0f, 0f, 0f);
                particleSpeed.set(0f, 0.01f, 0f);
                particleAcceleration.set(0f, -0.001f, 0f);
                particleColor.set(0.7f, 0.4f, 0.03f, 1f);
                particleLifetime = 5;
                particleFadeSpeed = 1f;
                particleSize = 0.03f;
                particleSpeedRandomness = 0.01f;
                particleAccelerationRandomness = 0f;
                particleLocationRandomness = 0.01f;
                particleLifetimeRandomness = 0f;
                break;
            case TYPE_SMOKE:
                particleSpawnLocation.set(0f, 0f, 0f);
                particleSpeed.set(0f, 0.02f, 0f);
                particleAcceleration.set(0f, 0f, 0f);
                particleColor.set(0.1f, 0.1f, 0.1f, 1f);
                particleLifetime = 150;
                particleFadeSpeed = 1f;
                particleSize = 0.4f;
                particleSpeedRandomness = 0.001f;
                particleAccelerationRandomness = 0f;
                particleLocationRandomness = 0.001f;
                particleLifetimeRandomness = 150f;
                break;
            case TYPE_EXPLOSION:
                particleSpawnLocation.set(0f, 0f, 0f);
                particleSpeed.set(0f, 0f, 0f);
                particleAcceleration.set(0f, 0f, 0f);
                particleColor.set(0.5f, 0.3f, 0.1f, 1f);
                particleLifetime = 100;
                particleFadeSpeed = 0.5f;
                particleSize = 0.1f;
                particleSpeedRandomness = 0f;
                particleAccelerationRandomness = 0.1f;
                particleLocationRandomness = 0.02f;
                particleLifetimeRandomness = 0f;
                break;
            case TYPE_SUPERNOVA:
                particleSpeed.set(0f, 0f, 0f);
                particleAcceleration.set(0f, 0f, 0f);
                particleColor.set(0.8f, 0.8f, 0.6f, 1f);
                particleLifetime = 200;
                particleFadeSpeed = 1f;
                particleSize = 5f;
                particleSpeedRandomness = 0f;
                particleAccelerationRandomness = 0.1f;
                particleLocationRandomness = 0.5f;
                particleLifetimeRandomness = 0f;
                break;
        }
        updateAllParticles();
    }

    /**
     * Sets this particle system's translation.
     */
    public void setTranslation(Vector3f loc) {
        Transform3D t = new Transform3D();
        t.setTranslation(loc);
        setTransform(t);
    }

    /**
     * Returns this particle system's type.
     */
    public int getType() {
        return type;
    }

    /**
     * Returns the number of particles in this particle system.
     */
    public int getParticleCount() {
        return particle_count;
    }

    private void setUpSystem() {
        // set up so each triangle strip consists of 4 vertice, i.e.
        // two triangles.
        int[] strips = new int[particle_count];
        for (int i = 0; i < particle_count; i++) {
            strips[i] = 4;
        }
        particles = new Particle[particle_count];
        geometryCoordinates = new Point3f[particle_count * 4];
        appearanceColors = new Color4f[particle_count * 4];
        // borrowed from javacooldude's particle engine example.
        // creates a trianglestriparray with 4 vertice per particle
        particleGeometry = new TriangleStripArray(particle_count * 4, GeometryArray.TEXTURE_COORDINATE_2 | GeometryArray.COORDINATES | GeometryArray.COLOR_4, strips);
        particleGeometry.setCapability(GeometryArray.ALLOW_COORDINATE_WRITE);
        particleGeometry.setCapability(GeometryArray.ALLOW_COLOR_WRITE);
        createShape3D();
    }

    /**
     * Returns a Shape3D object for the particles in this particle
     * system.
     */
    private void createShape3D() {
        ParticleAppearanceManager am = new ParticleAppearanceManager(""./dat/gfx/star2.png"");
        shape = new Shape3D(particleGeometry, am.texturedAppearance);
        addChild(shape);
    }

    private void updateAllParticles() {
        for (int i = 0; i < particle_count; i++) {
            particles[i] = new Particle();
            particles[i].newParticle(this, particleSpawnLocation, particleSpeed, particleAcceleration, particleColor, particleLifetime, particleFadeSpeed);
            for (int j = 0; j < 4; j++) {
                particleGeometry.setTextureCoordinate(0, i * 4 + j, sharedTextureData[j]);
                geometryCoordinates[i * 4 + j] = particles[i].particleCoordinates[j];
                appearanceColors[i * 4 + j] = particles[i].color;
            }
            particles[i].updateParticle();
        }
    }

    /**
     * Makes the particles in this particle system face the correct
     * way. The correct way in this system is a plane perpendicular to
     * the camera direction vector, i.e. the particles use the same
     * transform as the camera.
     *
     * @param camera The camera transform.
     */
    public void billboardParticles(Transform3D camera) {
        Transform3D t = new Transform3D(camera);
        t.setTranslation(new Vector3f(0f, 0f, 0f));
        for (int i = 0; i < 4; i++) {
            sharedGeometryData[i].set(defaultGeometryData[i]);
            t.transform(sharedGeometryData[i]);
        }
    }

    /**
     * Updates this system and all particles in it.
     */
    public boolean updateSystem(Transform3D c) {
        for (int i = 0; i < particle_count; i++) {
            if (!particles[i].updateParticle()) {
                particles[i].newParticle(this, particleSpawnLocation, particleSpeed, particleAcceleration, particleColor, particleLifetime, particleFadeSpeed);
            }
        }
        particleGeometry.setCoordinates(0, geometryCoordinates);
        particleGeometry.setColors(0, appearanceColors);
        billboardParticles(c);
        if (lifetime == 0 || age++ < lifetime)
            return true;
        return false;
    }

    private static class ParticleAppearanceManager {

        public TransparencyAttributes transparencyAttributes = new TransparencyAttributes();

        public RenderingAttributes renderingAttributes = new RenderingAttributes();

        public TextureAttributes textureAttributes = new TextureAttributes();

        public Appearance texturedAppearance = new Appearance();

        public Texture2D texture;

        /**
         * Creates a new appearance manager for particle systems.
         *
         * @param textureFilename The initial texture file name.
         */
        public ParticleAppearanceManager(String textureFilename) {
            renderingAttributes.setDepthBufferEnable(false);
            transparencyAttributes.setTransparencyMode(transparencyAttributes.BLENDED);
            transparencyAttributes.setTransparency(0);
            transparencyAttributes.setDstBlendFunction(transparencyAttributes.BLEND_ONE);
            transparencyAttributes.setSrcBlendFunction(transparencyAttributes.BLEND_SRC_ALPHA);
            textureAttributes.setTextureMode(TextureAttributes.MODULATE);
            textureAttributes.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            texturedAppearance.setTransparencyAttributes(transparencyAttributes);
            texturedAppearance.setRenderingAttributes(renderingAttributes);
            texturedAppearance.setTextureAttributes(textureAttributes);
            loadTexture(textureFilename);
        }

        /**
         * Loads a texture to this manager's texturedAppearance.
         *
         * @param textureFilename Path to the texture file image.
         */
        public void loadTexture(String textureFilename) {
            File textureFile = new File(textureFilename);
            BufferedImage textureImage = null;
            try {
                textureImage = ImageIO.read(textureFile);
                texture = (Texture2D) TextureLoader.getInstance().constructTexture(DirectBufferedImage.make(textureImage, false), ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
                texturedAppearance.setTexture(texture);
            } catch (IOException e) {
                System.err.println(""error loading texture"");
            }
        }
    }
}
","// ParticleSystemTest.java
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import com.xith3d.loaders.texture.TextureLoader;
import com.xith3d.image.*;
import java.util.Random;
import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParticleSystem}.
* It contains ten unit test cases for the {@link ParticleSystem#updateSystem(Transform3D)} method.
*/
class ParticleSystemTest {","// ParticleSystemTest.java
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import com.xith3d.loaders.texture.TextureLoader;
import com.xith3d.image.*;
import java.util.Random;
import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ParticleSystem}.
* It contains ten unit test cases for the {@link ParticleSystem#updateSystem(Transform3D)} method.
*/
class ParticleSystemTest {

		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is less than the lifetime.
		*/
		@Test
		void testUpdateSystem_ageLessThanLifetime() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, 100);
				ps.age = 99;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns false when the age is equal to the lifetime.
		*/
		@Test
		void testUpdateSystem_ageEqualToLifetime() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, 100);
				ps.age = 100;
				assertFalse(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns false when the age is greater than the lifetime.
		*/
		@Test
		void testUpdateSystem_ageGreaterThanLifetime() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, 100);
				ps.age = 101;
				assertFalse(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is less than the lifetime and the lifetime is 0.
		*/
		@Test
		void testUpdateSystem_ageLessThanLifetime_lifetimeZero() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, 0);
				ps.age = 99;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is equal to the lifetime and the lifetime is 0.
		*/
		@Test
		void testUpdateSystem_ageEqualToLifetime_lifetimeZero() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, 0);
				ps.age = 100;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is greater than the lifetime and the lifetime is 0.
		*/
		@Test
		void testUpdateSystem_ageGreaterThanLifetime_lifetimeZero() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, 0);
				ps.age = 101;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is less than the lifetime and the lifetime is -1.
		*/
		@Test
		void testUpdateSystem_ageLessThanLifetime_lifetimeMinusOne() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, -1);
				ps.age = 99;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is equal to the lifetime and the lifetime is -1.
		*/
		@Test
		void testUpdateSystem_ageEqualToLifetime_lifetimeMinusOne() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, -1);
				ps.age = 100;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is greater than the lifetime and the lifetime is -1.
		*/
		@Test
		void testUpdateSystem_ageGreaterThanLifetime_lifetimeMinusOne() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, -1);
				ps.age = 101;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is less than the lifetime and the lifetime is -2.
		*/
		@Test
		void testUpdateSystem_ageLessThanLifetime_lifetimeMinusTwo() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, -2);
				ps.age = 99;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is equal to the lifetime and the lifetime is -2.
		*/
		@Test
		void testUpdateSystem_ageEqualToLifetime_lifetimeMinusTwo() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, -2);
				ps.age = 100;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
		
		/**
		* Test case for {@link ParticleSystem#updateSystem(Transform3D)} method.
		* It tests if the method returns true when the age is greater than the lifetime and the lifetime is -2.
		*/
		@Test
		void testUpdateSystem_ageGreaterThanLifetime_lifetimeMinusTwo() {
				ParticleManager m = new ParticleManager();
				ParticleSystem ps = new ParticleSystem(m, 0, new Coord3f(), 1, -2);
				ps.age = 101;
				assertTrue(ps.updateSystem(new Transform3D()));
		}
}

// Particle.java
/* $Id: Particle.java,v 1.6 2004/05/05 11:55:12 emill Exp $
 *
 *
 * @author Emil Lundstrï¿½m <emill@kth.se>
 */
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import com.xith3d.loaders.texture.TextureLoader;
import com.xith3d.image.*;
import java.util.Random;
import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.awt.image.BufferedImage;

/**
 * A particle in the particle engine.
 */
public class Particle {

    public Point3f[] particleCoordinates = { new Point3f(), new Point3f(), new Point3f(), new Point3f() };

    public Color4f color = new Color4f();

    public Vector3f speed = new Vector3f();

    public Vector3f acceleration = new Vector3f();

    public int lifetime = 0;

    public int age = 0;

    public float fadeSpeed = 1f;

    /**
     * Creates a new particle.
     */
    public Particle() {
    }

    /**
     * Sets up a new particle.
     *
     * @param ps The particle system this particle belongs to.
     * @param loc The world coordinate where this particle spawns.
     * @param sp The initial speed of this particle.
     * @param ac The acceleration of this particle.
     * @param c The color of this particle.
     * @param lt The lifetime of this particle.
     * @param fs The fade speed of this particle.
     */
    public void newParticle(ParticleSystem ps, Coord3f loc, Vector3f sp, Vector3f ac, Color4f c, int lt, float fs) {
        speed.set(sp);
        acceleration.set(ac);
        color.set(c);
        lifetime = lt;
        age = 0;
        fadeSpeed = fs;
        particleCoordinates[0].set(loc.x + ps.particleSize, loc.y + ps.particleSize, loc.z);
        particleCoordinates[1].set(loc.x - ps.particleSize, loc.y + ps.particleSize, loc.z);
        particleCoordinates[2].set(loc.x + ps.particleSize, loc.y - ps.particleSize, loc.z);
        particleCoordinates[3].set(loc.x - ps.particleSize, loc.y - ps.particleSize, loc.z);
    }

    /**
     * Updates this particle.
     */
    public boolean updateParticle() {
        if (lifetime == 0 || age++ < lifetime) {
            speed.add(acceleration);
            for (int i = 0; i < 4; i++) {
                particleCoordinates[i].add(speed);
            }
            color.w -= fadeSpeed;
            return true;
        }
        return false;
    }
}

// ParticleTest.java
package gui.gl;

import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.datatypes.*;
import com.xith3d.loaders.texture.TextureLoader;
import com.xith3d.image.*;
import java.util.Random;
import javax.imageio.ImageIO;
import java.io.File;
import java.io.IOException;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Particle}.
* It contains ten unit test cases for the {@link Particle#updateParticle()} method.
*/
class ParticleTest {
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns true when the age is less than the lifetime.
		*/
		@Test
		void testUpdateParticle_ageLessThanLifetime() {
				Particle p = new Particle();
				p.lifetime = 100;
				p.age = 99;
				assertTrue(p.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns false when the age is equal to the lifetime.
		*/
		@Test
		void testUpdateParticle_ageEqualToLifetime() {
				Particle p = new Particle();
				p.lifetime = 100;
				p.age = 100;
				assertFalse(p.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns false when the age is greater than the lifetime.
		*/
		@Test
		void testUpdateParticle_ageGreaterThanLifetime() {
				Particle p = new Particle();
				p.lifetime = 100;
				p.age = 101;
				assertFalse(p.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns true when the age is less than the lifetime and the lifetime is 0.
		*/
		@Test
		void testUpdateParticle_ageLessThanLifetime_lifetimeZero() {
				Particle p = new Particle();
				p.lifetime = 0;
				p.age = 99;
				assertTrue(p.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns true when the age is equal to the lifetime and the lifetime is 0.
		*/
		@Test
		void testUpdateParticle_ageEqualToLifetime_lifetimeZero() {
				Particle p = new Particle();
				p.lifetime = 0;
				p.age = 100;
				assertTrue(p.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns true when the age is greater than the lifetime and the lifetime is 0.
		*/
		@Test
		void testUpdateParticle_ageGreaterThanLifetime_lifetimeZero() {
				Particle p = new Particle();
				p.lifetime = 0;
				p.age = 101;
				assertTrue(p.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns true when the age is less than the lifetime and the lifetime is -1.
		*/
		@Test
		void testUpdateParticle_ageLessThanLifetime_lifetimeMinusOne() {
				Particle p = new Particle();
				p.lifetime = -1;
				p.age = 99;
				assertTrue(p.updateParticle());
		}
		
		/**
		* Test case for {@link Particle#updateParticle()} method.
		* It tests if the method returns true when the age is equal to the lifetime and the lifetime is -1.
		*/
		@Test
		void testUpdateParticle_ageEqualToLifetime_lifetimeMinusOne() {
				Particle p = new Particle();
				p.lifetime = -1;
				p.age = 100;
				assertTrue(p.updateParticle());
	"
682873a3-7c0d-438f-8ece-e2d50e041503,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_10Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8500 tokens (4500 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_10Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#toScreen(Canvas3D, Point3f)} method.
*/
class Util3D_10Test {","// Util3D_10Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#toScreen(Canvas3D, Point3f)} method.
*/
class Util3D_10Test {
"
ff247fcb-7b51-44e7-9732-313e3c262fcc,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_12Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8500 tokens (4500 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_12Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#castRay(Canvas3D, int, int)} method.
*/
class Util3D_12Test {","// Util3D_12Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#castRay(Canvas3D, int, int)} method.
*/
class Util3D_12Test {
"
bf828e66-8142-4aa5-b1d0-646f14963c1b,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_13Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8495 tokens (4495 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_13Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#getBufferedImage(String)} method.
*/
class Util3D_13Test {","// Util3D_13Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#getBufferedImage(String)} method.
*/
class Util3D_13Test {
"
06f69392-8456-4016-a5fb-dc0071ee1794,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8496 tokens (4496 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_2Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createPlane(float, float)} method.
*/
class Util3D_2Test {","// Util3D_2Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createPlane(float, float)} method.
*/
class Util3D_2Test {
"
69d80fc0-5b3a-4512-b86b-6dac91d34efc,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8500 tokens (4500 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_4Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createTexturedPlane(String, float, float)} method.
*/
class Util3D_4Test {","// Util3D_4Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createTexturedPlane(String, float, float)} method.
*/
class Util3D_4Test {
"
bf72c379-cb70-4c8c-badf-23ff88ff150d,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8496 tokens (4496 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_6Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createCoordAxes(float)} method.
*/
class Util3D_6Test {","// Util3D_6Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createCoordAxes(float)} method.
*/
class Util3D_6Test {
"
f0061898-6a99-4a4d-b44d-de60d91f7895,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_7Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8497 tokens (4497 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_7Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createGrid(int, int, float)} method.
*/
class Util3D_7Test {","// Util3D_7Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#createGrid(int, int, float)} method.
*/
class Util3D_7Test {
"
44bb20ec-a0cc-4258-a63e-a267729734a5,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_8Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8500 tokens (4500 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_8Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#toWorld(Canvas3D, int, int)} method.
*/
class Util3D_8Test {","// Util3D_8Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#toWorld(Canvas3D, int, int)} method.
*/
class Util3D_8Test {
"
6ded84be-227e-4a2a-af5a-ead21f0b52c9,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/Util3D_9Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8502 tokens (4502 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Util3D.java
/* $Id: Util3D.java,v 1.6 2004/04/27 19:26:21 bja Exp $ */
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;

public class Util3D {

    public static final float rad(float ang) {
        return (float) (ang / 180.0 * PI);
    }

    public static final float deg(float ang) {
        return (float) (ang / PI * 180.0);
    }

    /**
     * Creates a size-by-size wu sized plane with assigned texture
     * coordinates. Texture coordinates are generated for two layers.
     *
     * @param size the size of the plane.
     *
     * @return the plane with the given normal and size.
     */
    public static Geometry createPlane(float size, float r) {
        return createQuad(0, 0, size, r, r);
    }

    public static Geometry createQuad(float x, float y, float size, float s, float t) {
        Point3f[] coords = new Point3f[] { new Point3f(x, 0f, y), new Point3f(x + size, 0f, y), new Point3f(x + size, 0f, y + size), new Point3f(x, 0f, y + size) };
        TexCoord2f[] texcoords = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(s, 0f), new TexCoord2f(s, s), new TexCoord2f(0f, s) };
        TexCoord2f[] texcoords2 = new TexCoord2f[] { new TexCoord2f(0f, 0f), new TexCoord2f(t, 0f), new TexCoord2f(t, t), new TexCoord2f(0f, t) };
        QuadArray plane = new QuadArray(coords.length, GeometryArray.COORDINATES | GeometryArray.TEXTURE_COORDINATE_2, 2, new int[] { 0, 1 });
        plane.setCoordinates(0, coords);
        plane.setTextureCoordinates(0, 0, texcoords);
        plane.setTextureCoordinates(1, 0, texcoords2);
        return plane;
    }

    /**
     * Create a new textured plane shape node.
     *
     * @param path the texture to apply to the plane.
     * @param s the size of the plane.
     * @param r the number of repetitions.
     */
    public static Shape3D createTexturedPlane(String path, float s, float r) {
        TextureLoader loader = TextureLoader.getInstance();
        // fixa
        loader.registerPath(""./"");
        // fixa
        loader.registerPath(""./dat/tex/"");
        // fixa
        loader.registerPath(""./dat/mdl/"");
        // fixa
        loader.registerPath(""./dat/gfx/"");
        Appearance appearance = new Appearance();
        appearance.setTexture((Texture2D) loader.getMinMapTexture(path));
        // Set polygon offset so that we can see objects lying in the
        // same plane as the grid.
        PolygonAttributes polyAttr = new PolygonAttributes();
        polyAttr.setPolygonOffset(10.0f);
        polyAttr.setPolygonOffsetFactor(20.0f);
        appearance.setPolygonAttributes(polyAttr);
        return new Shape3D(createPlane(s, r), appearance);
    }

    public static Geometry createRectangle(float w, float h, Color3f color) {
        Point3f[] coords = new Point3f[] { new Point3f(0f, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, 0f), new Point3f(w, 0f, h), new Point3f(w, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, h), new Point3f(0f, 0f, 0f) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        Color3f[] colors = new Color3f[] { new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z), new Color3f(color.x, color.y, color.z) };
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates the default coordinate axes with specified length.
     * @param size the length of the axes.
     */
    public static Geometry createCoordAxes(float size) {
        Point3f[] coords = new Point3f[] { new Point3f(0, 0, 0), new Point3f(size, 0, 0), new Point3f(0, 0, 0), new Point3f(0, size, 0), new Point3f(0, 0, 0), new Point3f(0, 0, size) };
        Color3f[] colors = new Color3f[] { new Color3f(0, 0, 1), new Color3f(0, 0, 1), new Color3f(1, 0, 0), new Color3f(1, 0, 0), new Color3f(0, 1, 0), new Color3f(0, 1, 0) };
        LineArray lines = new LineArray(coords.length, GeometryArray.COORDINATES | GeometryArray.COLOR_3);
        lines.setCoordinates(0, coords);
        lines.setColors(0, colors);
        return lines;
    }

    /**
     * Creates a new grid with the specified number of rows and columns,
     * and with the specified cell size.
     *
     * @param cols the number of cols in the grid.
     * @param rows the number of rows in the grid.
     * @param size the size of a single cell.
     */
    public static Shape3D createGrid(int cols, int rows, float size) {
        rows++;
        cols++;
        Point3f[] coords = new Point3f[2 * (rows + cols)];
        LineArray grid = new LineArray(coords.length, GeometryArray.COORDINATES);
        for (int i = 1; i < 2 * rows; i += 2) {
            coords[i - 1] = new Point3f(0, 0.01f, .5f * size * (i - 1));
            coords[i] = new Point3f((cols - 1) * size, 0.01f, .5f * size * (i - 1));
        }
        for (int j = 1; j < 2 * cols; j += 2) {
            coords[2 * rows + j - 1] = new Point3f(.5f * size * (j - 1), 0.01f, 0);
            coords[2 * rows + j] = new Point3f(.5f * size * (j - 1), 0.01f, (rows - 1) * size);
        }
        grid.setCoordinates(0, coords);
        return new Shape3D(grid);
    }

    /* The following methods are for converting screen coordinates to     
     * world coordinates. They are taken from the xith3d forum and 
     * modified to fit the application.
     *                                                                    
     * Reference: kevglass                                                
     *                                                                    
     * http://www.javagaming.org/cgi-bin/JGNetForums/YaBB.cgi?            
     *        board=xith3d;action=display;num=1068252077;start=15         
     */
    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y) {
        return toWorld(c, x, y, c.getView().getFrontClipDistance());
    }

    /**
     * Returns the point in world space corresponding to the given
     * coordinates in screen space.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @param z the z coordinate (depth).
     * @return the point in world space at the given depth.
     */
    public static Point3f toWorld(Canvas3D c, int x, int y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        float panelY = (float) (tan(fov) * z);
        float panelX = panelY * (width / height);
        float xp = x / (width / 2);
        float yp = y / (height / 2);
        Point3f pt = new Point3f((xp - 1) * panelX, (1 - yp) * panelY, -z);
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        v.transform(pt);
        return pt;
    }

    /**
     * Returns the point in screen space corresponding to the given
     * coordinates in world space.
     *
     * @param c the associated canvas.
     * @param x the world x coordinate.
     * @param y the world y coordinate.
     * @param z the world z coordinate.
     * @return the corresponding point in screen space.
     */
    public static Point3f toScreen(Canvas3D c, Point3f p) {
        return toScreen(c, p.x, p.y, p.z);
    }

    public static Point3f toScreen(Canvas3D c, float x, float y, float z) {
        float fov = c.getView().getFieldOfView();
        float width = c.getWidth();
        float height = c.getHeight();
        Transform3D v = new Transform3D();
        c.getView().getTransform(v);
        Point3f p = new Point3f(x, y, z);
        v.invert();
        v.transform(p);
        float panelY = (float) (tan(fov) * p.z);
        float panelX = panelY * (width / height);
        Point3f pt = new Point3f(p.x / panelX + 1, -p.y / panelY + 1, p.z);
        pt.x = width - pt.x * (width / 2);
        pt.y = height - pt.y * (height / 2);
        return pt;
    }

    /**
     * Returns the ray eminating from the point (x, y) in screen space
     * directed along the screen z-axis.
     *
     * @param c the associated canvas.
     * @param x the x coordinate.
     * @param y the y coordinate.
     * @return the ray eminating from x, y in screen space.
     */
    public static PickRay castRay(Canvas3D c, int x, int y) {
        Point3f center = toWorld(c, x, y);
        Point3f d = toWorld(c, x, y, c.getView().getFrontClipDistance() + 0.1f);
        Vector3f forward = new Vector3f(center);
        forward.sub(d);
        return new PickRay(center, forward);
    }

    /**
     * @param path the path to the image to open.
     */
    public static BufferedImage getBufferedImage(String path) {
        BufferedImage bufferedImage = null;
        try {
            bufferedImage = ImageIO.read(path.getClass().getResource(path));
        } catch (Exception e) {
            try {
                bufferedImage = ImageIO.read(new File(path));
            } catch (Exception x) {
                System.err.println(""craps!"");
                x.printStackTrace(System.err);
            }
        }
        return bufferedImage;
    }

    /**
     * Sets the specified texture to the specified appearance. The texture
     * mode is set to modulated.
     *
     * reference: Java Cool Dude
     */
    public static void setTexture2D(Shape3D shape, String path) {
        setTexture2D(shape, path, false, true, true);
    }

    public static void setTexture2D(Shape3D shape, String path, boolean clip, boolean blend, boolean depth) {
        Appearance appr = shape.getAppearance();
        if (appr == null) {
            appr = new Appearance();
            shape.setAppearance(appr);
        }
        setTexture2D(path, appr, clip, blend, depth);
    }

    public static void setTexture2D(String path, Appearance appr) {
        setTexture2D(path, appr, false, false, false);
    }

    public static void setTexture2D(String path, Appearance appr, boolean clip, boolean blend, boolean depth) {
        BufferedImage bufferedImage = getBufferedImage(path);
        TextureLoader tl = TextureLoader.getInstance();
        if (!depth) {
            RenderingAttributes rendattr = new RenderingAttributes();
            rendattr.setDepthBufferEnable(false);
            appr.setRenderingAttributes(rendattr);
        }
        if (blend) {
            TransparencyAttributes aattr = new TransparencyAttributes();
            aattr.setTransparencyMode(TransparencyAttributes.BLENDED);
            aattr.setTransparency(0.0f);
            aattr.setDstBlendFunction(TransparencyAttributes.BLEND_ONE);
            aattr.setSrcBlendFunction(TransparencyAttributes.BLEND_SRC_ALPHA);
            appr.setTransparencyAttributes(aattr);
        }
        if (clip) {
            TextureAttributes texattr = new TextureAttributes();
            texattr.setTextureMode(TextureAttributes.MODULATE);
            texattr.setPerspectiveCorrectionMode(TextureAttributes.FASTEST);
            appr.setTextureAttributes(texattr);
        }
        bufferedImage = DirectBufferedImage.make(bufferedImage, false);
        Texture2D texture = (Texture2D) tl.constructTexture(bufferedImage, ""RGB"", false, Texture.BASE_LEVEL_LINEAR, Texture.BASE_LEVEL_LINEAR, Texture.WRAP, false, TextureLoader.SCALE_DRAW_BEST);
        appr.setTexture(texture);
    }

    /**
     * Enable picking of this node by traversing the scenegraph to the
     * root and setting each node to be pickable.
     *
     * @param name the name used to identify this node.
     */
    public static void setPickable(Node node, String name) {
        Node g = node.getParent();
        while (g != null) {
            g.setPickable(true);
            g = g.getParent();
        }
        if (node instanceof Group) {
            setPickableRecursive((Group) node, name);
        }
    }

    /**
     * Set all children of the specified group to be pickable.
     *
     * @param group the node at which to start.
     * @param name the name used to identify the nodes.
     */
    public static void setPickableRecursive(Group group, String name) {
        if (group == null) {
            return;
        }
        group.setPickable(true);
        java.util.Enumeration e = group.getAllChildren();
        while (e.hasMoreElements()) {
            Node node = (Node) e.nextElement();
            // if it's a group rename all children
            if (node instanceof Group) {
                setPickableRecursive((Group) node, name);
            } else {
                node.setPickable(true);
                if (node instanceof Shape3D) {
                    node.setName(name);
                }
            }
        }
    }
}
","// Util3D_9Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#toWorld(Canvas3D, int, int, float)} method.
*/
class Util3D_9Test {","// Util3D_9Test.java
package gui.gl;

import static java.lang.Math.PI;
import static java.lang.Math.tan;
import static java.lang.Math.cos;
import static java.lang.Math.sin;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import com.xith3d.render.*;
import com.xith3d.render.jogl.*;
import javax.imageio.ImageIO;
import java.io.*;
import com.xith3d.image.DirectBufferedImage;
import java.awt.image.BufferedImage;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Util3D}.
* It contains ten unit test cases for the {@link Util3D#toWorld(Canvas3D, int, int, float)} method.
*/
class Util3D_9Test {
"
efabeb41-74b9-4a51-916d-12b64b0e36a0,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/World_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9027 tokens (5027 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// World.java
/* $Id: World.java,v 1.7 2004/05/02 23:01:54 emill Exp $ */
package gui.gl;

import static java.lang.Math.round;
import static gui.gl.Util3D.*;
import java.awt.geom.*;
import java.awt.Point;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import java.util.Iterator;
import map.TileMap;
import map.Path;
import map.PathNotFoundException;
import org.newdawn.xith3d.obj.OBJLoader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;

/**
 * This class represents the world. All objects in the world are children
 * of this class.
 */
public class World extends TransformGroup {

    /**
     * The transform associated with this grid.
     */
    // private Transform3D transform;
    /**
     * The map associated with this world object.
     */
    private TileMap map;

    /**
     * The cells of the grid.
     */
    private TransformGroup[][] cells;

    /**
     * The geometry that make up the grid.
     */
    private Shape3D grid;

    private int rows;

    private int cols;

    private float size;

    private Node[] models;

    /**
     * The active cell marker.
     */
    private TransformGroup selected;

    private TransformGroup actors;

    private TransformGroup objects;

    /**
     * This is the offset vector used to center the grid.
     */
    private Vector3f offset;

    private Transform3D center;

    /**
     * The physical bounds of this grid.
     */
    private Rectangle2D.Float bounds;

    /**
     */
    private float roll = 0;

    private float pitch = 0;

    private float yaw = 0;

    /**
     */
    //private float posX = 0;
    //private float posY = 0;
    //private float posZ = 0;
    /**
     * Create a new instance of the Grid class. The grid lies in the xz-plane,
     * with origo at the bottom left corner.
     *
     * @param rows
     * @param cols
     * @param size
     */
    public World(int rows, int cols, float size) {
        this.rows = rows;
        this.cols = cols;
        this.size = size;
        cells = new TransformGroup[rows][cols];
        actors = new TransformGroup();
        objects = new TransformGroup();
        /* Create the a visible grid system. */
        grid = createGrid(rows, cols, size);
        /* Compute grid bounds and use them to center the grid. */
        bounds = new Rectangle2D.Float(0, 0, (cols) * size, (rows) * size);
        offset = new Vector3f(-.5f * bounds.width, 0, -.5f * bounds.height);
        center = new Transform3D();
        center.setTranslation(offset);
        setGridVisible(false);
        addChild(grid);
        addChild(actors);
        addChild(objects);
        actors.setPickable(true);
        try {
            map = new TileMap(0, 2, ""./dat/maps/test.map"", 1);
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    map.Node n = map.getNodeAt(j, i);
                    // System.err.print(n.getCost() + "" "");
                    if (n.getCost() > 1.0f) {
                        //System.err.println(""x="" + n.getX() + "" y=""+ n.getY());
                        //setCellTexture((int)(n.getX()+0.5f),
                        //	       (int)(n.getY()+0.5f),""dirt.png"");
                    }
                }
                // System.err.println();
            }
        } catch (java.io.IOException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Adds an actor to the this world object.
     * @param a the actor to add.
     */
    public void addActor(Actor a) {
        a.setWorld(this);
        actors.addChild(a);
    }

    //public void addChild(Actor actor) {
    //actor.setWorld(this);
    //actors.addChild(actor);
    //}
    /**
     * Removes the specified actor from this world.
     * @param a the actor to remove.
     */
    public void removeActor(Actor a) {
        actors.removeChild(a);
        a.setWorld(null);
    }

    public void removeAllActors() {
        removeChild(actors);
        actors = new TransformGroup();
        addChild(actors);
        actors.setPickable(true);
    }

    /**
     * Loads the scene from the specified file.
     * @param path the file from which to load the scene.
     */
    public void load(String path) {
        //throws java.io.IOException {
    }

    public void save(String path) {
        //throws java.io.IOException {
    }

    public Path findPath(int srcX, int srcY, int dstX, int dstY) throws PathNotFoundException {
        map.Node src = map.getNodeAt(srcX, srcY);
        map.Node dst = map.getNodeAt(dstX, dstY);
        map.reset();
        return map.coalescePath(map.search(src, dst));
    }

    /**
     * Rotates the grid the specified number of degrees around
     * the given axes.
     *
     * @param rotx
     * @param roty
     * @param rotz
     */
    public void rotXYZ(float rotx, float roty, float rotz) {
        roll = rotx;
        yaw = roty;
        pitch = rotz;
    }

    public void panX(float dist) {
        offset.x += dist;
    }

    public void panY(float dist) {
        offset.y += dist;
    }

    public void panZ(float dist) {
        offset.z += dist;
    }

    /**
     * Returns the position of this grid.
     * @return the position of this grid.
     */
    public Point3f getPosition() {
        return new Point3f(offset);
    }

    /**
     * Returns the orientation of this grid.
     * @return the orientation of this grid.
     */
    public Vector3f getOrientation() {
        return new Vector3f(roll, yaw, pitch);
    }

    /**
     * Sets the orienation of this grid to the specified vector.
     * @param v the new orientation of this grid.
     */
    public void setOrientation(Vector3f v) {
        roll = v.x;
        yaw = v.y;
        pitch = v.z;
    }

    /**
     * Calculate the intersection point of the specified ray with
     * this Grid.
     *
     * @param r the intersecting ray.
     * @return the intersection point of the ray and this grid or null
     *         if the ray is paralell to the grid.
     */
    public Point3f intersect(PickRay r) {
        // ray direction in world space.
        Vector3f v = r.getDirection();
        // ray origin in world space.
        Point3f p = r.getOrigin();
        // intersection point in grid space.
        Point3f q = null;
        // world to grid transform.
        Transform3D tf = null;
        // Get a copy of the grid transform.
        tf = new Transform3D(getTransform());
        // Transform the ray by the inverse grid transform. This way we
        // get the ray in grid coordinate space.
        tf.invert();
        tf.transform(p);
        tf.transform(v);
        // Check that the ray is not parallell to the grid.
        if (v.y != 0) {
            // Assume that the grid lies in the xz-plane. It will always
            // lie in the xz-plane!
            float t = (offset.y - p.y) / v.y;
            q = new Point3f(p.x + t * v.x, 0.0f, p.z + t * v.z);
        }
        return q;
    }

    /**
     * Returns the grid cell corresponding to the given grid coordinate.
     * @return the grid cell corresponding to the given grid coordinate.
     */
    public Point gridCoordToCell(Point3f p) {
        return new Point(round(p.x / size - 0.5f), round(p.z / size - 0.5f));
    }

    /**
     * Sets the background texture of this grid.
     * @param tex the texture to set as background.
     */
    public void setTexture(String tex) {
        TextureAttributes[] textureAttrs = new TextureAttributes[2];
        TextureUnitState[] textureUnitStates = new TextureUnitState[2];
        Texture2D[] textures = new Texture2D[2];
        try {
            TextureLoader tl = TextureLoader.getInstance();
            // these paths should be registered elsewhere.
            tl.registerPath(""./"");
            tl.registerPath(""./dat/mdl"");
            tl.registerPath(""./dat/tex"");
            tl.registerPath(""./dat/gfx"");
            textures[0] = (Texture2D) tl.getMinMapTexture(""grass2.png"");
            textures[1] = (Texture2D) tl.getMinMapTexture(""stone.png"");
            textureAttrs[0] = new TextureAttributes();
            textureAttrs[0].setTextureMode(TextureAttributes.DECAL);
            textureAttrs[1] = new TextureAttributes();
            textureAttrs[1].setTextureMode(TextureAttributes.MODULATE);
            textureUnitStates[0] = new TextureUnitState(textures[0], textureAttrs[0], null);
            textureUnitStates[1] = new TextureUnitState(textures[1], textureAttrs[1], null);
            // Set polygon offset so that we can see objects lying in the
            // same plane as the grid.
            PolygonAttributes polyAttr = new PolygonAttributes();
            polyAttr.setPolygonOffset(10.0f);
            polyAttr.setPolygonOffsetFactor(20.0f);
            Appearance a = new Appearance();
            a.setTextureUnitState(textureUnitStates);
            a.setPolygonAttributes(polyAttr);
            addChild(new Shape3D(createQuad(0f, 0f, cols * size, 1f, 2 * cols), a));
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Sets the texture of the cell at the specified coordinates
     * given in grid space. If name is null or empty string, then
     * the specified cell's texture will be removed.
     *
     * @param row the cell row coordinate.
     * @param col the cell column coordinate.
     * @param name the texture to set to the cell. If it is null then
     *             the current texture will be removed from the cell.
     */
    public void setCellTexture(int row, int col, String name, boolean blend) {
        TransformGroup tg = null;
        Shape3D sh = null;
        try {
            tg = getCellNode(row, col);
        } catch (ArrayIndexOutOfBoundsException e) {
            // craps!
            return;
        }
        if (name == null || name.length() == 0) {
            removeChild(tg);
            setCellNode(row, col, null);
            return;
        }
        if (tg == null) {
            tg = new TransformGroup();
            //sh = new Shape3D(createPlane(size, 1));
            //setTexture2D(sh, ""./dat/tex/"" + name,blend,blend,true);
            sh = createTexturedPlane(name, size, 1);
            tg.addChild(sh);
            setCellNode(row, col, tg);
            addChild(tg);
        } else {
            sh = (Shape3D) tg.getChild(0);
            TextureLoader tl = TextureLoader.getInstance();
            Texture2D tex = (Texture2D) tl.getMinMapTexture(name);
            //setTexture2D(sh,""./dat/tex/"" + name,blend,blend,true);
        }
        Vector3f pos = new Vector3f(row * size, 0.01f, col * size);
        Transform3D tf = tg.getTransform();
        tf.setTranslation(pos);
        tg.setTransform(tf);
    }

    public void setCellTexture(int row, int col, String name) {
        setCellTexture(row, col, name, false);
    }

    public void setCellNode(int row, int col, TransformGroup tg) {
        cells[row][col] = tg;
    }

    public TransformGroup getCellNode(int row, int col) {
        return cells[row][col];
    }

    /**
     * Sets the active cell given by the row and col coordinates.
     *
     * @param row the active cell row coordinate.
     * @param col the active cell column coordinate.
     */
    public void setActiveCell(int row, int col) {
        if (selected != null) {
            Transform3D tf = selected.getTransform();
            tf.setTranslation(new Vector3f(row * size, 0.01f, col * size));
        } else {
            // create the active cell marker
            selected = new TransformGroup();
            Vector3f pos = new Vector3f(row * size, 0.01f, col * size);
            Appearance ap = new Appearance();
            setTexture2D(""dat/tex/active.png"", ap);
            selected.getTransform().setTranslation(pos);
            selected.addChild(new Shape3D(createPlane(size, 1.0f), ap));
            addChild(selected);
            /*

	    // enable transparency.
	    TransparencyAttributes tcattr = new TransparencyAttributes();
	    tcattr.setTransparency(0.5f);
	    tcattr.setMode(TransparencyAttributes.BLENDED);
	    a.setTransparencyAttributes(tcattr);
	    sh.setAppearance(a);

	    // set the line width
	    LineAttributes attr = new LineAttributes();
	    attr.setLineWidth(1f);
	    attr.setLineAntialiasingEnable(true);
	    //a.setLineAttributes(attr);

	    // disable depth buffer test for this shape
	    RenderingAttributes attr1 = new RenderingAttributes();
	    attr1.setDepthBufferEnable(false);
	    a.setRenderingAttributes(attr1);

	    Color3f lineColor = new Color3f(1,1,0);
	    Shape3D rect = new Shape3D(createRectangle(size,size,lineColor)));
	    selected.addChild(rect);
				          
            */
        }
    }

    /**
     * Updates and renders the grid. Since scene graph operations must
     * be carried out from the same thread, we keep all such operations
     * in this method and call it once from the main rendering loop.
     */
    public void render() {
        Transform3D tf = getTransform();
        Transform3D centering = new Transform3D();
        centering.setTranslation(offset);
        //center.getTranslation(pos);
        //pos.x = posX;
        //pos.y = posY;
        //pos.z = posZ;
        //center.setTranslation(offset);
        tf.rotXYZ(roll, yaw, pitch);
        tf.mul(centering);
        setTransform(tf);
    }

    /**
     * Enables or disables the display of the grid.
     * @param enable true if the grid should be visible otherwise false.
     */
    public void setGridVisible(boolean enable) {
        Appearance ap = null;
        RenderingAttributes attr = null;
        try {
            ap = grid.getAppearance();
            attr = ap.getRenderingAttributes();
            attr.setVisible(enable);
        } catch (NullPointerException e) {
            if (ap == null) {
                ap = new Appearance();
                grid.setAppearance(ap);
            }
            if (attr == null) {
                attr = new RenderingAttributes();
                attr.setVisible(enable);
            }
        }
        ap.setRenderingAttributes(attr);
    }

    /**
     * Returns true if the grid is visible otherwise false.
     * @return true if the grid is visible otherwise false.
     */
    public boolean getGridVisible() {
        boolean visible = false;
        try {
            Appearance ap = grid.getAppearance();
            RenderingAttributes attr = ap.getRenderingAttributes();
            visible = attr.getVisible();
        } catch (NullPointerException e) {
            // e.printStackTrace(System.err);
        }
        return visible;
    }

    protected void open(String fileName) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[3];
        // throw away tile info
        int numOfTiles = Integer.parseInt(in.readLine());
        models = new Node[numOfTiles];
        for (i = 0; i < numOfTiles; i++) {
            String modelname = in.readLine();
            BranchGroup mdl = new OBJLoader().load(modelname);
            models[i] = mdl.getChild(0);
        }
        int numOfObjs = Integer.parseInt(in.readLine());
        i = j = 0;
        while (st.nextToken() != st.TT_EOF && i++ < numOfObjs * tmp.length + 1) {
            if (j >= tmp.length) {
                TransformGroup tg = new TransformGroup();
                Transform3D t = new Transform3D();
                Node model = new Shape3D();
                tg.getTransform(t);
                model = model.sharedCopy(models[tmp[2]]);
                t.setTranslation(new Vector3f((float) tmp[0] * size + 0.5f, 0.0f, (float) tmp[1] * size + 0.5f));
                System.err.println(new Vector3f((float) tmp[0] * size, 0.0f, (float) tmp[1] * size));
                tg.setTransform(t);
                tg.addChild(model);
                objects.addChild(tg);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        in.close();
        objects.updateBounds(true);
    }
}
","// World_1Test.java
package gui.gl;

import static java.lang.Math.round;
import static gui.gl.Util3D.*;
import java.awt.geom.*;
import java.awt.Point;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import java.util.Iterator;
import map.TileMap;
import map.Path;
import map.PathNotFoundException;
import org.newdawn.xith3d.obj.OBJLoader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link World}.
* It contains ten unit test cases for the {@link World#intersect(PickRay)} method.
*/
class World_1Test {","// World_1Test.java
package gui.gl;

import static java.lang.Math.round;
import static gui.gl.Util3D.*;
import java.awt.geom.*;
import java.awt.Point;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import java.util.Iterator;
import map.TileMap;
import map.Path;
import map.PathNotFoundException;
import org.newdawn.xith3d.obj.OBJLoader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link World}.
* It contains ten unit test cases for the {@link World#intersect(PickRay)} method.
*/
class World_1Test {
"
c5cd9604-2679-4ffa-b836-f2e5a0b6ef79,/EvoSuiteBenchmark/27_gangup/src/main/java/gui/gl/World_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 9031 tokens (5031 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// World.java
/* $Id: World.java,v 1.7 2004/05/02 23:01:54 emill Exp $ */
package gui.gl;

import static java.lang.Math.round;
import static gui.gl.Util3D.*;
import java.awt.geom.*;
import java.awt.Point;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import java.util.Iterator;
import map.TileMap;
import map.Path;
import map.PathNotFoundException;
import org.newdawn.xith3d.obj.OBJLoader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;

/**
 * This class represents the world. All objects in the world are children
 * of this class.
 */
public class World extends TransformGroup {

    /**
     * The transform associated with this grid.
     */
    // private Transform3D transform;
    /**
     * The map associated with this world object.
     */
    private TileMap map;

    /**
     * The cells of the grid.
     */
    private TransformGroup[][] cells;

    /**
     * The geometry that make up the grid.
     */
    private Shape3D grid;

    private int rows;

    private int cols;

    private float size;

    private Node[] models;

    /**
     * The active cell marker.
     */
    private TransformGroup selected;

    private TransformGroup actors;

    private TransformGroup objects;

    /**
     * This is the offset vector used to center the grid.
     */
    private Vector3f offset;

    private Transform3D center;

    /**
     * The physical bounds of this grid.
     */
    private Rectangle2D.Float bounds;

    /**
     */
    private float roll = 0;

    private float pitch = 0;

    private float yaw = 0;

    /**
     */
    //private float posX = 0;
    //private float posY = 0;
    //private float posZ = 0;
    /**
     * Create a new instance of the Grid class. The grid lies in the xz-plane,
     * with origo at the bottom left corner.
     *
     * @param rows
     * @param cols
     * @param size
     */
    public World(int rows, int cols, float size) {
        this.rows = rows;
        this.cols = cols;
        this.size = size;
        cells = new TransformGroup[rows][cols];
        actors = new TransformGroup();
        objects = new TransformGroup();
        /* Create the a visible grid system. */
        grid = createGrid(rows, cols, size);
        /* Compute grid bounds and use them to center the grid. */
        bounds = new Rectangle2D.Float(0, 0, (cols) * size, (rows) * size);
        offset = new Vector3f(-.5f * bounds.width, 0, -.5f * bounds.height);
        center = new Transform3D();
        center.setTranslation(offset);
        setGridVisible(false);
        addChild(grid);
        addChild(actors);
        addChild(objects);
        actors.setPickable(true);
        try {
            map = new TileMap(0, 2, ""./dat/maps/test.map"", 1);
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < cols; j++) {
                    map.Node n = map.getNodeAt(j, i);
                    // System.err.print(n.getCost() + "" "");
                    if (n.getCost() > 1.0f) {
                        //System.err.println(""x="" + n.getX() + "" y=""+ n.getY());
                        //setCellTexture((int)(n.getX()+0.5f),
                        //	       (int)(n.getY()+0.5f),""dirt.png"");
                    }
                }
                // System.err.println();
            }
        } catch (java.io.IOException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Adds an actor to the this world object.
     * @param a the actor to add.
     */
    public void addActor(Actor a) {
        a.setWorld(this);
        actors.addChild(a);
    }

    //public void addChild(Actor actor) {
    //actor.setWorld(this);
    //actors.addChild(actor);
    //}
    /**
     * Removes the specified actor from this world.
     * @param a the actor to remove.
     */
    public void removeActor(Actor a) {
        actors.removeChild(a);
        a.setWorld(null);
    }

    public void removeAllActors() {
        removeChild(actors);
        actors = new TransformGroup();
        addChild(actors);
        actors.setPickable(true);
    }

    /**
     * Loads the scene from the specified file.
     * @param path the file from which to load the scene.
     */
    public void load(String path) {
        //throws java.io.IOException {
    }

    public void save(String path) {
        //throws java.io.IOException {
    }

    public Path findPath(int srcX, int srcY, int dstX, int dstY) throws PathNotFoundException {
        map.Node src = map.getNodeAt(srcX, srcY);
        map.Node dst = map.getNodeAt(dstX, dstY);
        map.reset();
        return map.coalescePath(map.search(src, dst));
    }

    /**
     * Rotates the grid the specified number of degrees around
     * the given axes.
     *
     * @param rotx
     * @param roty
     * @param rotz
     */
    public void rotXYZ(float rotx, float roty, float rotz) {
        roll = rotx;
        yaw = roty;
        pitch = rotz;
    }

    public void panX(float dist) {
        offset.x += dist;
    }

    public void panY(float dist) {
        offset.y += dist;
    }

    public void panZ(float dist) {
        offset.z += dist;
    }

    /**
     * Returns the position of this grid.
     * @return the position of this grid.
     */
    public Point3f getPosition() {
        return new Point3f(offset);
    }

    /**
     * Returns the orientation of this grid.
     * @return the orientation of this grid.
     */
    public Vector3f getOrientation() {
        return new Vector3f(roll, yaw, pitch);
    }

    /**
     * Sets the orienation of this grid to the specified vector.
     * @param v the new orientation of this grid.
     */
    public void setOrientation(Vector3f v) {
        roll = v.x;
        yaw = v.y;
        pitch = v.z;
    }

    /**
     * Calculate the intersection point of the specified ray with
     * this Grid.
     *
     * @param r the intersecting ray.
     * @return the intersection point of the ray and this grid or null
     *         if the ray is paralell to the grid.
     */
    public Point3f intersect(PickRay r) {
        // ray direction in world space.
        Vector3f v = r.getDirection();
        // ray origin in world space.
        Point3f p = r.getOrigin();
        // intersection point in grid space.
        Point3f q = null;
        // world to grid transform.
        Transform3D tf = null;
        // Get a copy of the grid transform.
        tf = new Transform3D(getTransform());
        // Transform the ray by the inverse grid transform. This way we
        // get the ray in grid coordinate space.
        tf.invert();
        tf.transform(p);
        tf.transform(v);
        // Check that the ray is not parallell to the grid.
        if (v.y != 0) {
            // Assume that the grid lies in the xz-plane. It will always
            // lie in the xz-plane!
            float t = (offset.y - p.y) / v.y;
            q = new Point3f(p.x + t * v.x, 0.0f, p.z + t * v.z);
        }
        return q;
    }

    /**
     * Returns the grid cell corresponding to the given grid coordinate.
     * @return the grid cell corresponding to the given grid coordinate.
     */
    public Point gridCoordToCell(Point3f p) {
        return new Point(round(p.x / size - 0.5f), round(p.z / size - 0.5f));
    }

    /**
     * Sets the background texture of this grid.
     * @param tex the texture to set as background.
     */
    public void setTexture(String tex) {
        TextureAttributes[] textureAttrs = new TextureAttributes[2];
        TextureUnitState[] textureUnitStates = new TextureUnitState[2];
        Texture2D[] textures = new Texture2D[2];
        try {
            TextureLoader tl = TextureLoader.getInstance();
            // these paths should be registered elsewhere.
            tl.registerPath(""./"");
            tl.registerPath(""./dat/mdl"");
            tl.registerPath(""./dat/tex"");
            tl.registerPath(""./dat/gfx"");
            textures[0] = (Texture2D) tl.getMinMapTexture(""grass2.png"");
            textures[1] = (Texture2D) tl.getMinMapTexture(""stone.png"");
            textureAttrs[0] = new TextureAttributes();
            textureAttrs[0].setTextureMode(TextureAttributes.DECAL);
            textureAttrs[1] = new TextureAttributes();
            textureAttrs[1].setTextureMode(TextureAttributes.MODULATE);
            textureUnitStates[0] = new TextureUnitState(textures[0], textureAttrs[0], null);
            textureUnitStates[1] = new TextureUnitState(textures[1], textureAttrs[1], null);
            // Set polygon offset so that we can see objects lying in the
            // same plane as the grid.
            PolygonAttributes polyAttr = new PolygonAttributes();
            polyAttr.setPolygonOffset(10.0f);
            polyAttr.setPolygonOffsetFactor(20.0f);
            Appearance a = new Appearance();
            a.setTextureUnitState(textureUnitStates);
            a.setPolygonAttributes(polyAttr);
            addChild(new Shape3D(createQuad(0f, 0f, cols * size, 1f, 2 * cols), a));
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Sets the texture of the cell at the specified coordinates
     * given in grid space. If name is null or empty string, then
     * the specified cell's texture will be removed.
     *
     * @param row the cell row coordinate.
     * @param col the cell column coordinate.
     * @param name the texture to set to the cell. If it is null then
     *             the current texture will be removed from the cell.
     */
    public void setCellTexture(int row, int col, String name, boolean blend) {
        TransformGroup tg = null;
        Shape3D sh = null;
        try {
            tg = getCellNode(row, col);
        } catch (ArrayIndexOutOfBoundsException e) {
            // craps!
            return;
        }
        if (name == null || name.length() == 0) {
            removeChild(tg);
            setCellNode(row, col, null);
            return;
        }
        if (tg == null) {
            tg = new TransformGroup();
            //sh = new Shape3D(createPlane(size, 1));
            //setTexture2D(sh, ""./dat/tex/"" + name,blend,blend,true);
            sh = createTexturedPlane(name, size, 1);
            tg.addChild(sh);
            setCellNode(row, col, tg);
            addChild(tg);
        } else {
            sh = (Shape3D) tg.getChild(0);
            TextureLoader tl = TextureLoader.getInstance();
            Texture2D tex = (Texture2D) tl.getMinMapTexture(name);
            //setTexture2D(sh,""./dat/tex/"" + name,blend,blend,true);
        }
        Vector3f pos = new Vector3f(row * size, 0.01f, col * size);
        Transform3D tf = tg.getTransform();
        tf.setTranslation(pos);
        tg.setTransform(tf);
    }

    public void setCellTexture(int row, int col, String name) {
        setCellTexture(row, col, name, false);
    }

    public void setCellNode(int row, int col, TransformGroup tg) {
        cells[row][col] = tg;
    }

    public TransformGroup getCellNode(int row, int col) {
        return cells[row][col];
    }

    /**
     * Sets the active cell given by the row and col coordinates.
     *
     * @param row the active cell row coordinate.
     * @param col the active cell column coordinate.
     */
    public void setActiveCell(int row, int col) {
        if (selected != null) {
            Transform3D tf = selected.getTransform();
            tf.setTranslation(new Vector3f(row * size, 0.01f, col * size));
        } else {
            // create the active cell marker
            selected = new TransformGroup();
            Vector3f pos = new Vector3f(row * size, 0.01f, col * size);
            Appearance ap = new Appearance();
            setTexture2D(""dat/tex/active.png"", ap);
            selected.getTransform().setTranslation(pos);
            selected.addChild(new Shape3D(createPlane(size, 1.0f), ap));
            addChild(selected);
            /*

	    // enable transparency.
	    TransparencyAttributes tcattr = new TransparencyAttributes();
	    tcattr.setTransparency(0.5f);
	    tcattr.setMode(TransparencyAttributes.BLENDED);
	    a.setTransparencyAttributes(tcattr);
	    sh.setAppearance(a);

	    // set the line width
	    LineAttributes attr = new LineAttributes();
	    attr.setLineWidth(1f);
	    attr.setLineAntialiasingEnable(true);
	    //a.setLineAttributes(attr);

	    // disable depth buffer test for this shape
	    RenderingAttributes attr1 = new RenderingAttributes();
	    attr1.setDepthBufferEnable(false);
	    a.setRenderingAttributes(attr1);

	    Color3f lineColor = new Color3f(1,1,0);
	    Shape3D rect = new Shape3D(createRectangle(size,size,lineColor)));
	    selected.addChild(rect);
				          
            */
        }
    }

    /**
     * Updates and renders the grid. Since scene graph operations must
     * be carried out from the same thread, we keep all such operations
     * in this method and call it once from the main rendering loop.
     */
    public void render() {
        Transform3D tf = getTransform();
        Transform3D centering = new Transform3D();
        centering.setTranslation(offset);
        //center.getTranslation(pos);
        //pos.x = posX;
        //pos.y = posY;
        //pos.z = posZ;
        //center.setTranslation(offset);
        tf.rotXYZ(roll, yaw, pitch);
        tf.mul(centering);
        setTransform(tf);
    }

    /**
     * Enables or disables the display of the grid.
     * @param enable true if the grid should be visible otherwise false.
     */
    public void setGridVisible(boolean enable) {
        Appearance ap = null;
        RenderingAttributes attr = null;
        try {
            ap = grid.getAppearance();
            attr = ap.getRenderingAttributes();
            attr.setVisible(enable);
        } catch (NullPointerException e) {
            if (ap == null) {
                ap = new Appearance();
                grid.setAppearance(ap);
            }
            if (attr == null) {
                attr = new RenderingAttributes();
                attr.setVisible(enable);
            }
        }
        ap.setRenderingAttributes(attr);
    }

    /**
     * Returns true if the grid is visible otherwise false.
     * @return true if the grid is visible otherwise false.
     */
    public boolean getGridVisible() {
        boolean visible = false;
        try {
            Appearance ap = grid.getAppearance();
            RenderingAttributes attr = ap.getRenderingAttributes();
            visible = attr.getVisible();
        } catch (NullPointerException e) {
            // e.printStackTrace(System.err);
        }
        return visible;
    }

    protected void open(String fileName) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[3];
        // throw away tile info
        int numOfTiles = Integer.parseInt(in.readLine());
        models = new Node[numOfTiles];
        for (i = 0; i < numOfTiles; i++) {
            String modelname = in.readLine();
            BranchGroup mdl = new OBJLoader().load(modelname);
            models[i] = mdl.getChild(0);
        }
        int numOfObjs = Integer.parseInt(in.readLine());
        i = j = 0;
        while (st.nextToken() != st.TT_EOF && i++ < numOfObjs * tmp.length + 1) {
            if (j >= tmp.length) {
                TransformGroup tg = new TransformGroup();
                Transform3D t = new Transform3D();
                Node model = new Shape3D();
                tg.getTransform(t);
                model = model.sharedCopy(models[tmp[2]]);
                t.setTranslation(new Vector3f((float) tmp[0] * size + 0.5f, 0.0f, (float) tmp[1] * size + 0.5f));
                System.err.println(new Vector3f((float) tmp[0] * size, 0.0f, (float) tmp[1] * size));
                tg.setTransform(t);
                tg.addChild(model);
                objects.addChild(tg);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        in.close();
        objects.updateBounds(true);
    }
}
","// World_2Test.java
package gui.gl;

import static java.lang.Math.round;
import static gui.gl.Util3D.*;
import java.awt.geom.*;
import java.awt.Point;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import java.util.Iterator;
import map.TileMap;
import map.Path;
import map.PathNotFoundException;
import org.newdawn.xith3d.obj.OBJLoader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link World}.
* It contains ten unit test cases for the {@link World#gridCoordToCell(Point3f)} method.
*/
class World_2Test {","// World_2Test.java
package gui.gl;

import static java.lang.Math.round;
import static gui.gl.Util3D.*;
import java.awt.geom.*;
import java.awt.Point;
import javax.vecmath.*;
import com.xith3d.scenegraph.*;
import com.xith3d.loaders.texture.*;
import java.util.Iterator;
import map.TileMap;
import map.Path;
import map.PathNotFoundException;
import org.newdawn.xith3d.obj.OBJLoader;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.StreamTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link World}.
* It contains ten unit test cases for the {@link World#gridCoordToCell(Point3f)} method.
*/
class World_2Test {
"
cmpl-6tu27WRjSKpaXSgNY2CQugIIL6UxH,/EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNode_0Test.java,89.8888692855835,length,"// DefaultNode.java
/* MapNode.java v0.1 (06/16/2002)
 *
 * Copyright (C) 2002, Joel Andersson <bja@kth.se>
 * 
 * This software is hereby expressly placed in the public domain.
 * Share and enjoy.
 */
package map;

import java.util.Vector;

/**
 * The <code>DefaultNode</code> class represents an internal map node. Each
 * cell in the map consists of a <code>DefaultNode</code>.
 */
public class DefaultNode implements Node {

    /**
     * The bitmask associated with this node.
     */
    public long bits;

    /**
     * The parent of this node.
     */
    protected Node parent;

    /**
     * The child nodes of this node.
     */
    protected Vector children;

    /**
     * The cost associated with this node.
     */
    protected float cost;

    /**
     * The total cost associate with this node.
     */
    protected float total;

    /**
     * The score associated with this node.
     */
    protected float score;

    /**
     * The current state of this node.
     */
    protected int state;

    /**
     * The horizontal component of this node.
     */
    protected float x;

    /**
     * The vertical component of this node.
     */
    protected float y;

    /**
     * The z coordinate of this node.
     */
    protected float z;

    /**
     * Specifies whether this node is currently visible.
     */
    protected float visibility;

    /**
     * Creates a new <code>DefaultNode</code>.
     */
    public DefaultNode() {
        this(null);
    }

    /**
     * Creates a new <code>DefaultNode</code> with the specified
     * parent node. The node is initially positionend at (0,0) and
     * is not solid.
     *
     * @param parent The parent of this node.
     */
    public DefaultNode(Node parent) {
        this(null, 0, 0, 0);
    }

    /**
     * Creates a new <code>DefaultNode</code> with the specified
     * parent and attributes.
     *
     * @param parent The parent of this node.
     * @param bits The flags associated with this node.
     * @param x The horizontal component of this node.
     * @param y The vertical component of this node.
     */
    public DefaultNode(Node parent, long bits, int x, int y) {
        this.parent = parent;
        this.bits = bits;
        this.x = x;
        this.y = y;
        this.state = UNSET;
        this.total = score = cost = 0;
        children = new Vector();
    }

    /**
     * Adds a child node to this node.
     * @param n The node to add.
     */
    public void addChildNode(Node n) {
        children.add(n);
    }

    /**
     * Sets a specific child node given by index to the Node
     * given by n.
     *
     * @param index The index of the child to change.
     * @param n The node to set in the place of index.
     */
    public void setChildNode(int index, Node node) {
        children.set(index, node);
    }

    /**
     * Returns the child at the specified location <code>index</code>.
     * @return The child at the specified location <code>index</code>.
     */
    public Node getChildNode(int index) {
        return (Node) children.get(index);
    }

    /**
     * Returns the children of this <code>Node</code>.
     * @return The children of this <code>Node</code>.
     */
    public Node[] getAllChildren() {
        Node[] temp = new Node[children.size()];
        children.copyInto(temp);
        return temp;
    }

    /**
     * Sets the parent of this node to the specified node.
     * @param n The new parent node.
     */
    public void setParent(Node n) {
        parent = n;
    }

    /**
     * Returns this nodes parent.
     * @return this nodes parent.
     */
    public Node getParent() {
        return parent;
    }

    /**
     * Sets the positional coordinates of this node to the
     * specified values.
     *
     * @param x The horizontal component.
     * @param y The vertical component.
     */
    public void setLocation(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void setLocation(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Returns the horizontal component of this node.
     * @return the horizontal component of this node.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns the vertical component of this node.
     * @return the vettical component of this node.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns the z coordinate of this node.
     * @return the z coordinate of this node.
     */
    public float getZ() {
        return z;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void setZ(float z) {
        this.z = z;
    }

    /**
     * Sets the cost associated with entering this node.
     * @param cost the cost associated with entering this node.
     */
    public void setCost(float cost) {
        this.cost = cost;
    }

    /**
     * Returns the cost associated with entering this node.
     * @return The cost associated with entering this node.
     */
    public float getCost() {
        return cost;
    }

    /**
     * Sets the total cost associated with this node. The
     * total cost is the cost of travelling from the start
     * node to this node.
     *
     * @param total The total cost to be associated with
     *              this node.
     */
    public void setTotal(float total) {
        this.total = total;
    }

    /**
     * Returns the total cost associated with this node.
     * @return The total cost associated with this node.
     */
    public float getTotal() {
        return total;
    }

    /**
     * Sets the score associated with this node. The score
     * determines how good this node is in relation to other
     * nodes and is used for ordering them amongst each other.
     *
     * @param score The score to be associated with this node.
     */
    public void setScore(float score) {
        this.score = score;
    }

    /**
     * Returns the score associated with this node.
     * @return the score associated with this node.
     */
    public float getScore() {
        return score;
    }

    /**
     * Specifies whether this node has already been processed
     * and no longer is considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node has been processed.
     */
    public void setClosed(boolean b) {
        state = b ? state | CLOSED : state & ~CLOSED;
    }

    /**
     * Returns true if this node has been processed.
     * @return True if this node has been processed.
     */
    public boolean isClosed() {
        return (state & CLOSED) > 0;
    }

    /**
     * Specifies whether this node is currently being
     * considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently open.
     */
    public void setOpen(boolean b) {
        state = b ? state | OPEN : state & ~OPEN;
    }

    /**
     * Returns true if this node is currently being
     * considered for further processing.
     *
     * @return True if this node is open.
     */
    public boolean isOpen() {
        return (state & OPEN) > 0;
    }

    /**
     * Sets the data associated with this node. The handles
     * the way the node is displayed.
     *
     * @param data The data to be associated with this node.
     */
    public void setData(long data) {
        this.bits = data;
    }

    /**
     * Retrieves the data associated with this node.
     * @return the data associated with this node.
     */
    public long getData() {
        return bits;
    }

    /**
     * Specifies whether this node is solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @param b A boolean value that specifies whether
     *          this node is solid.
     */
    public void setSolid(boolean b) {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Returns whether this node is considered solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @return True if this node is solid.
     */
    public boolean isSolid() {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Specifies whether this node is currently visible.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently visible.
     */
    public void setVisible(boolean b) {
        this.visibility = b ? 1.0f : 0.0f;
    }

    /**
     * Returns whether this node is considered visible.
     * @return True if this node is visible.
     */
    public boolean isVisible() {
        return visibility > 0.0f;
    }

    /**
     * Sets the degree of visibility of this node.
     * @param value the degree of visibility.
     */
    public void setVisibility(float value) {
        this.visibility = value;
    }

    /**
     * Returns the current degree of visibility of this node.
     * @return the current degree of visibility of this node.
     */
    public float getVisibility() {
        return visibility;
    }

    /**
     * Compares this Node with the specified Object for order.
     * Note: This method imposes ordering which is inconsistant
     * with equals.
     *
     * @param obj The object which is to be compared.
     * @return An integer value of -1, 0, or 1, as this node
     *         is less than, equal to, or greater than obj.
     *
     * @throws ClassCastException if obj is not of type Node.
     */
    public int compareTo(Object obj) {
        return compareTo((DefaultNode) obj);
    }

    public int compareTo(DefaultNode n) {
        return score < n.score ? -1 : (score > n.score ? 1 : 0);
    }

    public String toString() {
        return ""DefaultNode[x="" + x + "",y="" + y + "",score="" + score + ""]"";
    }
}
","// DefaultNode_0Test.java
package map;

import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNode}.
* It contains ten unit test cases for the {@link DefaultNode#getChildNode(int)} method.
*/
class DefaultNode_0Test {","// DefaultNode_0Test.java
package map;

import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNode}.
* It contains ten unit test cases for the {@link DefaultNode#getChildNode(int)} method.
*/
class DefaultNode_0Test {

	/**
	* Test case 1 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_1() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(0));
	}
	
	/**
	* Test case 2 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_2() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(9));
	}
	
	/**
	* Test case 3 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_3() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(5));
	}
	
	/**
	* Test case 4 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_4() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(3));
	}
	
	/**
	* Test case 5 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_5() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(7));
	}
	
	/**
	* Test case 6 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_6() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(1));
	}
	
	/**
	* Test case 7 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_7() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(8));
	}
	
	/**
	* Test case 8 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_8() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(4));
	}
	
	/**
	* Test case 9 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_9() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(6));
	}
	
	/**
	* Test case 10 for {@link DefaultNode#getChildNode(int)}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetChildNode_10() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getChildNode(2));
	}
}

// DefaultNode_1Test.java
package map;

import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNode}.
* It contains ten unit test cases for the {@link DefaultNode#getAllChildren()} method.
*/
class DefaultNode_1Test {
		
	/**
	* Test case 1 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_1() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 2 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_2() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 3 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_3() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 4 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_4() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 5 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_5() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 6 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_6() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 7 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_7() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 8 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_8() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		node.addChildNode(new DefaultNode());
		assertNotNull(node.getAllChildren());
	}
	
	/**
	* Test case 9 for {@link DefaultNode#getAllChildren()}.
	* It tests the method with a valid index.
	*/
	@Test
	void testGetAllChildren_9() {
		DefaultNode node = new DefaultNode();
		node.addChildNode(new DefaultNode());"
cmpl-6tu3ZtG3pil9Q2aPr2n7BBKbvJUBX,/EvoSuiteBenchmark/27_gangup/src/main/java/map/DefaultNode_1Test.java,86.05198645591736,length,"// DefaultNode.java
/* MapNode.java v0.1 (06/16/2002)
 *
 * Copyright (C) 2002, Joel Andersson <bja@kth.se>
 * 
 * This software is hereby expressly placed in the public domain.
 * Share and enjoy.
 */
package map;

import java.util.Vector;

/**
 * The <code>DefaultNode</code> class represents an internal map node. Each
 * cell in the map consists of a <code>DefaultNode</code>.
 */
public class DefaultNode implements Node {

    /**
     * The bitmask associated with this node.
     */
    public long bits;

    /**
     * The parent of this node.
     */
    protected Node parent;

    /**
     * The child nodes of this node.
     */
    protected Vector children;

    /**
     * The cost associated with this node.
     */
    protected float cost;

    /**
     * The total cost associate with this node.
     */
    protected float total;

    /**
     * The score associated with this node.
     */
    protected float score;

    /**
     * The current state of this node.
     */
    protected int state;

    /**
     * The horizontal component of this node.
     */
    protected float x;

    /**
     * The vertical component of this node.
     */
    protected float y;

    /**
     * The z coordinate of this node.
     */
    protected float z;

    /**
     * Specifies whether this node is currently visible.
     */
    protected float visibility;

    /**
     * Creates a new <code>DefaultNode</code>.
     */
    public DefaultNode() {
        this(null);
    }

    /**
     * Creates a new <code>DefaultNode</code> with the specified
     * parent node. The node is initially positionend at (0,0) and
     * is not solid.
     *
     * @param parent The parent of this node.
     */
    public DefaultNode(Node parent) {
        this(null, 0, 0, 0);
    }

    /**
     * Creates a new <code>DefaultNode</code> with the specified
     * parent and attributes.
     *
     * @param parent The parent of this node.
     * @param bits The flags associated with this node.
     * @param x The horizontal component of this node.
     * @param y The vertical component of this node.
     */
    public DefaultNode(Node parent, long bits, int x, int y) {
        this.parent = parent;
        this.bits = bits;
        this.x = x;
        this.y = y;
        this.state = UNSET;
        this.total = score = cost = 0;
        children = new Vector();
    }

    /**
     * Adds a child node to this node.
     * @param n The node to add.
     */
    public void addChildNode(Node n) {
        children.add(n);
    }

    /**
     * Sets a specific child node given by index to the Node
     * given by n.
     *
     * @param index The index of the child to change.
     * @param n The node to set in the place of index.
     */
    public void setChildNode(int index, Node node) {
        children.set(index, node);
    }

    /**
     * Returns the child at the specified location <code>index</code>.
     * @return The child at the specified location <code>index</code>.
     */
    public Node getChildNode(int index) {
        return (Node) children.get(index);
    }

    /**
     * Returns the children of this <code>Node</code>.
     * @return The children of this <code>Node</code>.
     */
    public Node[] getAllChildren() {
        Node[] temp = new Node[children.size()];
        children.copyInto(temp);
        return temp;
    }

    /**
     * Sets the parent of this node to the specified node.
     * @param n The new parent node.
     */
    public void setParent(Node n) {
        parent = n;
    }

    /**
     * Returns this nodes parent.
     * @return this nodes parent.
     */
    public Node getParent() {
        return parent;
    }

    /**
     * Sets the positional coordinates of this node to the
     * specified values.
     *
     * @param x The horizontal component.
     * @param y The vertical component.
     */
    public void setLocation(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void setLocation(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Returns the horizontal component of this node.
     * @return the horizontal component of this node.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns the vertical component of this node.
     * @return the vettical component of this node.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns the z coordinate of this node.
     * @return the z coordinate of this node.
     */
    public float getZ() {
        return z;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void setZ(float z) {
        this.z = z;
    }

    /**
     * Sets the cost associated with entering this node.
     * @param cost the cost associated with entering this node.
     */
    public void setCost(float cost) {
        this.cost = cost;
    }

    /**
     * Returns the cost associated with entering this node.
     * @return The cost associated with entering this node.
     */
    public float getCost() {
        return cost;
    }

    /**
     * Sets the total cost associated with this node. The
     * total cost is the cost of travelling from the start
     * node to this node.
     *
     * @param total The total cost to be associated with
     *              this node.
     */
    public void setTotal(float total) {
        this.total = total;
    }

    /**
     * Returns the total cost associated with this node.
     * @return The total cost associated with this node.
     */
    public float getTotal() {
        return total;
    }

    /**
     * Sets the score associated with this node. The score
     * determines how good this node is in relation to other
     * nodes and is used for ordering them amongst each other.
     *
     * @param score The score to be associated with this node.
     */
    public void setScore(float score) {
        this.score = score;
    }

    /**
     * Returns the score associated with this node.
     * @return the score associated with this node.
     */
    public float getScore() {
        return score;
    }

    /**
     * Specifies whether this node has already been processed
     * and no longer is considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node has been processed.
     */
    public void setClosed(boolean b) {
        state = b ? state | CLOSED : state & ~CLOSED;
    }

    /**
     * Returns true if this node has been processed.
     * @return True if this node has been processed.
     */
    public boolean isClosed() {
        return (state & CLOSED) > 0;
    }

    /**
     * Specifies whether this node is currently being
     * considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently open.
     */
    public void setOpen(boolean b) {
        state = b ? state | OPEN : state & ~OPEN;
    }

    /**
     * Returns true if this node is currently being
     * considered for further processing.
     *
     * @return True if this node is open.
     */
    public boolean isOpen() {
        return (state & OPEN) > 0;
    }

    /**
     * Sets the data associated with this node. The handles
     * the way the node is displayed.
     *
     * @param data The data to be associated with this node.
     */
    public void setData(long data) {
        this.bits = data;
    }

    /**
     * Retrieves the data associated with this node.
     * @return the data associated with this node.
     */
    public long getData() {
        return bits;
    }

    /**
     * Specifies whether this node is solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @param b A boolean value that specifies whether
     *          this node is solid.
     */
    public void setSolid(boolean b) {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Returns whether this node is considered solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @return True if this node is solid.
     */
    public boolean isSolid() {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Specifies whether this node is currently visible.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently visible.
     */
    public void setVisible(boolean b) {
        this.visibility = b ? 1.0f : 0.0f;
    }

    /**
     * Returns whether this node is considered visible.
     * @return True if this node is visible.
     */
    public boolean isVisible() {
        return visibility > 0.0f;
    }

    /**
     * Sets the degree of visibility of this node.
     * @param value the degree of visibility.
     */
    public void setVisibility(float value) {
        this.visibility = value;
    }

    /**
     * Returns the current degree of visibility of this node.
     * @return the current degree of visibility of this node.
     */
    public float getVisibility() {
        return visibility;
    }

    /**
     * Compares this Node with the specified Object for order.
     * Note: This method imposes ordering which is inconsistant
     * with equals.
     *
     * @param obj The object which is to be compared.
     * @return An integer value of -1, 0, or 1, as this node
     *         is less than, equal to, or greater than obj.
     *
     * @throws ClassCastException if obj is not of type Node.
     */
    public int compareTo(Object obj) {
        return compareTo((DefaultNode) obj);
    }

    public int compareTo(DefaultNode n) {
        return score < n.score ? -1 : (score > n.score ? 1 : 0);
    }

    public String toString() {
        return ""DefaultNode[x="" + x + "",y="" + y + "",score="" + score + ""]"";
    }
}
","// DefaultNode_1Test.java
package map;

import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNode}.
* It contains ten unit test cases for the {@link DefaultNode#compareTo(Object)} method.
*/
class DefaultNode_1Test {","// DefaultNode_1Test.java
package map;

import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNode}.
* It contains ten unit test cases for the {@link DefaultNode#compareTo(Object)} method.
*/
class DefaultNode_1Test {

	/**
	* Test case 1 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with the same score.
	* The expected result is that the method returns 0.
	*/
	@Test
	void testCompareTo_1() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(1);
		assertEquals(0, node1.compareTo(node2));
	}
	
	/**
	* Test case 2 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_2() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 3 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_3() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 4 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_4() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 5 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_5() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 6 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_6() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 7 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_7() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 8 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_8() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 9 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_9() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 10 for {@link DefaultNode#compareTo(Object)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_10() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
}

// DefaultNode_2Test.java
package map;

import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNode}.
* It contains ten unit test cases for the {@link DefaultNode#compareTo(DefaultNode)} method.
*/
class DefaultNode_2Test {
		
	/**
	* Test case 1 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with the same score.
	* The expected result is that the method returns 0.
	*/
	@Test
	void testCompareTo_1() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(1);
		assertEquals(0, node1.compareTo(node2));
	}
	
	/**
	* Test case 2 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_2() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 3 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_3() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 4 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_4() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 5 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_5() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 6 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_6() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 7 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_7() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 8 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_8() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 9 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_9() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 10 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_10() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
}

// DefaultNode_3Test.java
package map;

import java.util.Vector;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DefaultNode}.
* It contains ten unit test cases for the {@link DefaultNode#compareTo(DefaultNode)} method.
*/
class DefaultNode_3Test {
		
	/**
	* Test case 1 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with the same score.
	* The expected result is that the method returns 0.
	*/
	@Test
	void testCompareTo_1() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(1);
		assertEquals(0, node1.compareTo(node2));
	}
	
	/**
	* Test case 2 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_2() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 3 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_3() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 4 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_4() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 5 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_5() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 6 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_6() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 7 for {@link DefaultNode#compareTo(DefaultNode)}.
	* This test case tests the method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_7() {
		DefaultNode node1 = new DefaultNode();
		DefaultNode node2 = new DefaultNode();
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	"
cmpl-6tu4xDWa9GnIU3EjUQDjrQj6SbWqP,/EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNode_0Test.java,92.63495802879333,length,"// DirtyNode.java
/* DirtyNode.java v0.1 (06/16/2002)
 *
 * Copyright (C) 2002, Joel Andersson <bja@kth.se>
 * 
 * This software is hereby expressly placed in the public domain.
 * Share and enjoy.
 */
package map;

public final class DirtyNode implements Node {

    /**
     * The parent of this node.
     */
    public DirtyNode parent;

    /**
     * The child nodes of this node.
     */
    public DirtyNode[] children;

    /**
     * The cost associated with this node.
     */
    public float cost;

    /**
     * The total cost associate with this node.
     */
    public float total;

    /**
     * The score associated with this node.
     */
    public float score;

    /**
     * The current state of this node.
     */
    public int state;

    /**
     * The bitmask associated with this node.
     */
    public long bits;

    /**
     * The horizontal component of this node.
     */
    public float x;

    /**
     * The vertical component of this node.
     */
    public float y;

    /**
     * The z coordinate of this node.
     */
    public float z;

    /**
     * Specifies whether this node is visible.
     */
    public float visibility;

    /**
     * The number of children of this node.
     */
    private int numOfChildren;

    /**
     * Creates a new DirtyNode with the specified tile.
     * @param tile The tile to be associated with the node.
     */
    public DirtyNode(long bits) {
        this(bits, 0, 0);
    }

    /**
     * Creates a new DirtyNode with the specified attributes.
     * @param tile The tile to be associated with the node.
     * @param bits The bits to be associated with the node.
     * @param x The horizontal component of this node.
     * @param y The vertical component of this node.
     */
    public DirtyNode(long bits, int x, int y) {
        this.bits = bits;
        this.x = x;
        this.y = y;
        this.numOfChildren = 0;
        this.children = new DirtyNode[8];
    }

    /**
     * Adds the specified node as a child to this node.
     * @param n The node to add.
     */
    public void addChildNode(Node n) {
        children[numOfChildren++] = (DirtyNode) n;
    }

    /**
     * Sets the child of this node given by index to the
     * specified Node.
     *
     * @param index The index of the child to change.
     * @param n The node to set in the place of index.
     */
    public void setChildNode(int index, Node n) {
        children[index] = (DirtyNode) n;
    }

    /**
     * Returns the child at the specified location <code>index</code>.
     * @return The child at the specified location <code>index</code>.
     */
    public Node getChildNode(int index) {
        return children[index];
    }

    /**
     * Returns the children of this <code>Node</code>. The order
     * of the child nodes returned is unspecified.
     *
     * @return The children of this <code>Node</code>.
     */
    public Node[] getAllChildren() {
        return children;
    }

    /**
     * Sets the parent of this node to the specified node.
     * @param parent The new parent node.
     */
    public void setParent(Node parent) {
        this.parent = (DirtyNode) parent;
    }

    /**
     * Returns this nodes parent.
     * @return this nodes parent.
     */
    public Node getParent() {
        return parent;
    }

    /**
     * Sets the positional coordinates of this node to the
     * specified values.
     *
     * @param x The horizontal component.
     * @param y The vertical component.
     */
    public void setLocation(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void setLocation(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Returns the horizontal position of this node.
     * @return the horizontal position of this node.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns the vertical position of this node.
     * @return the vettical position of this node.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns the z coordinate of this node.
     * @return the z coordinate of this node.
     */
    public float getZ() {
        return z;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void setZ(float z) {
        this.z = z;
    }

    /**
     * Sets the cost associated with entering this node.
     * @param cost the cost associated with entering this node.
     */
    public void setCost(float cost) {
        this.cost = cost;
    }

    /**
     * Returns the cost associated with entering this node.
     * @return The cost associated with entering this node.
     */
    public float getCost() {
        return cost;
    }

    /**
     * Sets the total cost associated with this node. The
     * total cost is the cost of travelling from the start
     * node to this node.
     *
     * @param total The total cost to be associated with
     *              this node.
     */
    public void setTotal(float total) {
        this.total = total;
    }

    /**
     * Returns the total cost associated with this node.
     * @return The total cost associated with this node.
     */
    public float getTotal() {
        return total;
    }

    /**
     * Sets the score associated with this node. The score
     * determines how good this node is in relation to other
     * nodes and is used for ordering them amongst each other.
     *
     * @param score The score to be associated with this node.
     */
    public void setScore(float score) {
        this.score = score;
    }

    /**
     * Returns the score associated with this node.
     * @return the score associated with this node.
     */
    public float getScore() {
        return score;
    }

    /**
     * Specifies whether this node has already been processed
     * and no longer is considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node has been processed.
     */
    public void setClosed(boolean b) {
        state = b ? state | CLOSED : state & ~CLOSED;
    }

    /**
     * Returns true if this node has been processed.
     * @return True if this node has been processed.
     */
    public boolean isClosed() {
        return (state & CLOSED) > 0;
    }

    /**
     * Specifies whether this node is currently being
     * considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently open.
     */
    public void setOpen(boolean b) {
        state = b ? state | OPEN : state & ~OPEN;
    }

    /**
     * Returns true if this node is currently being
     * considered for further processing.
     *
     * @return True if this node is open.
     */
    public boolean isOpen() {
        return (state & OPEN) > 0;
    }

    /**
     * Sets the data associated with this node. The handles
     * the way the node is displayed.
     *
     * @param data The data to be associated with this node.
     */
    public void setData(long data) {
        this.bits = data;
    }

    /**
     * Retrieves the data associated with this node.
     * @return the data associated with this node.
     */
    public long getData() {
        return bits;
    }

    /**
     * Specifies whether this node is solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @param b A boolean value that specifies whether
     *          this node is solid.
     */
    public void setSolid(boolean b) {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Returns whether this node is considered solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @return True if this node is solid.
     */
    public boolean isSolid() {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Specifies whether this node is currently visible.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently visible.
     */
    public void setVisible(boolean b) {
        this.visibility = b ? 1.0f : 0.0f;
    }

    /**
     * Returns whether this node is considered visible.
     * @return True if this node is visible.
     */
    public boolean isVisible() {
        return visibility > 0.0f;
    }

    /**
     * Sets the degree of visibility of this node.
     * @param value the degree of visibility.
     */
    public void setVisibility(float value) {
        this.visibility = value;
    }

    /**
     * Returns the current degree of visibility of this node.
     * @return the current degree of visibility of this node.
     */
    public float getVisibility() {
        return visibility;
    }

    /**
     * Compares this Node with the specified Object for order.
     * <b>Note</b>: This method imposes ordering which is
     * inconsistant with equals.
     *
     * @param obj The object which is to be compared.
     * @return An integer value of -1, 0, or 1, as this node
     *         is less than, equal to, or greater than obj.
     *
     * @throws ClassCastException if obj is not of type Node.
     */
    public int compareTo(Object obj) {
        return compareTo((DirtyNode) obj);
    }

    public int compareTo(DirtyNode n) {
        return score < n.score ? -1 : (score > n.score ? 1 : 0);
    }

    /**
     * Compares this node with the specified object for equality.
     * Two nodes are considered equal if they have the same map
     * coordinates.
     *
     * @param obj The node which is to be compared.
     * @return True if obj is of type node and has the same map
     *         coordinate as this node. Otherwise return false.
     */
    public boolean equals(Object obj) {
        return equals((DirtyNode) obj);
    }

    public boolean equals(DirtyNode n) {
        return x == n.x && y == n.y;
    }

    /**
     * Returns a string representation of this <code>Node</code>.
     * @return a string representation of this <code>Node</code>.
     */
    public String toString() {
        return ""DirtyNode[x="" + x + "",y="" + y + "",score="" + score + ""]"";
    }
}
","// DirtyNode_0Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#getChildNode(int)} method.
*/
class DirtyNode_0Test {","// DirtyNode_0Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#getChildNode(int)} method.
*/
class DirtyNode_0Test {

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_0() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(0);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_1() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(1);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_2() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(2);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_3() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(3);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_4() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(4);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_5() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(5);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_6() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(6);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_7() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(7);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_8() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(8);
	}

	/**
	* Test case for {@link DirtyNode#getChildNode(int)}.
	*/
	@Test
	void testGetChildNode_9() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getChildNode(9);
	}
}

// DirtyNode_1Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#getAllChildren()} method.
*/
class DirtyNode_1Test {
		
	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_0() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_1() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_2() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_3() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_4() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_5() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_6() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_7() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_8() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}

	/**
	* Test case for {@link DirtyNode#getAllChildren()}.
	*/
	@Test
	void testGetAllChildren_9() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.addChildNode(dirtyNode1);
		dirtyNode0.getAllChildren();
	}
}

// DirtyNode_2Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#setChildNode(int, Node)} method.
*/
class DirtyNode_2Test {
		
	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_0() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(0, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_1() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(1, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_2() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(2, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_3() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(3, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_4() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(4, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_5() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(5, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_6() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(6, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_7() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(7, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_8() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(8, dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setChildNode(int, Node)}.
	*/
	@Test
	void testSetChildNode_9() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setChildNode(9, dirtyNode1);
	}
}

// DirtyNode_3Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#setParent(Node)} method.
*/
class DirtyNode_3Test {
		
	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_0() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setParent(dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_1() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setParent(dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_2() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setParent(dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_3() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setParent(dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_4() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setParent(dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_5() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setParent(dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_6() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
		DirtyNode dirtyNode1 = new DirtyNode(0L);
		dirtyNode0.setParent(dirtyNode1);
	}

	/**
	* Test case for {@link DirtyNode#setParent(Node)}.
	*/
	@Test
	void testSetParent_7() {
		DirtyNode dirtyNode0 = new DirtyNode(0L);
	"
cmpl-6tu6SggESk4Zdk3dkOLinqlpPmMMp,/EvoSuiteBenchmark/27_gangup/src/main/java/map/DirtyNode_1Test.java,96.8670003414154,length,"// DirtyNode.java
/* DirtyNode.java v0.1 (06/16/2002)
 *
 * Copyright (C) 2002, Joel Andersson <bja@kth.se>
 * 
 * This software is hereby expressly placed in the public domain.
 * Share and enjoy.
 */
package map;

public final class DirtyNode implements Node {

    /**
     * The parent of this node.
     */
    public DirtyNode parent;

    /**
     * The child nodes of this node.
     */
    public DirtyNode[] children;

    /**
     * The cost associated with this node.
     */
    public float cost;

    /**
     * The total cost associate with this node.
     */
    public float total;

    /**
     * The score associated with this node.
     */
    public float score;

    /**
     * The current state of this node.
     */
    public int state;

    /**
     * The bitmask associated with this node.
     */
    public long bits;

    /**
     * The horizontal component of this node.
     */
    public float x;

    /**
     * The vertical component of this node.
     */
    public float y;

    /**
     * The z coordinate of this node.
     */
    public float z;

    /**
     * Specifies whether this node is visible.
     */
    public float visibility;

    /**
     * The number of children of this node.
     */
    private int numOfChildren;

    /**
     * Creates a new DirtyNode with the specified tile.
     * @param tile The tile to be associated with the node.
     */
    public DirtyNode(long bits) {
        this(bits, 0, 0);
    }

    /**
     * Creates a new DirtyNode with the specified attributes.
     * @param tile The tile to be associated with the node.
     * @param bits The bits to be associated with the node.
     * @param x The horizontal component of this node.
     * @param y The vertical component of this node.
     */
    public DirtyNode(long bits, int x, int y) {
        this.bits = bits;
        this.x = x;
        this.y = y;
        this.numOfChildren = 0;
        this.children = new DirtyNode[8];
    }

    /**
     * Adds the specified node as a child to this node.
     * @param n The node to add.
     */
    public void addChildNode(Node n) {
        children[numOfChildren++] = (DirtyNode) n;
    }

    /**
     * Sets the child of this node given by index to the
     * specified Node.
     *
     * @param index The index of the child to change.
     * @param n The node to set in the place of index.
     */
    public void setChildNode(int index, Node n) {
        children[index] = (DirtyNode) n;
    }

    /**
     * Returns the child at the specified location <code>index</code>.
     * @return The child at the specified location <code>index</code>.
     */
    public Node getChildNode(int index) {
        return children[index];
    }

    /**
     * Returns the children of this <code>Node</code>. The order
     * of the child nodes returned is unspecified.
     *
     * @return The children of this <code>Node</code>.
     */
    public Node[] getAllChildren() {
        return children;
    }

    /**
     * Sets the parent of this node to the specified node.
     * @param parent The new parent node.
     */
    public void setParent(Node parent) {
        this.parent = (DirtyNode) parent;
    }

    /**
     * Returns this nodes parent.
     * @return this nodes parent.
     */
    public Node getParent() {
        return parent;
    }

    /**
     * Sets the positional coordinates of this node to the
     * specified values.
     *
     * @param x The horizontal component.
     * @param y The vertical component.
     */
    public void setLocation(int x, int y) {
        this.x = x;
        this.y = y;
    }

    public void setLocation(float x, float y, float z) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Returns the horizontal position of this node.
     * @return the horizontal position of this node.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns the vertical position of this node.
     * @return the vettical position of this node.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns the z coordinate of this node.
     * @return the z coordinate of this node.
     */
    public float getZ() {
        return z;
    }

    public void setX(float x) {
        this.x = x;
    }

    public void setY(float y) {
        this.y = y;
    }

    public void setZ(float z) {
        this.z = z;
    }

    /**
     * Sets the cost associated with entering this node.
     * @param cost the cost associated with entering this node.
     */
    public void setCost(float cost) {
        this.cost = cost;
    }

    /**
     * Returns the cost associated with entering this node.
     * @return The cost associated with entering this node.
     */
    public float getCost() {
        return cost;
    }

    /**
     * Sets the total cost associated with this node. The
     * total cost is the cost of travelling from the start
     * node to this node.
     *
     * @param total The total cost to be associated with
     *              this node.
     */
    public void setTotal(float total) {
        this.total = total;
    }

    /**
     * Returns the total cost associated with this node.
     * @return The total cost associated with this node.
     */
    public float getTotal() {
        return total;
    }

    /**
     * Sets the score associated with this node. The score
     * determines how good this node is in relation to other
     * nodes and is used for ordering them amongst each other.
     *
     * @param score The score to be associated with this node.
     */
    public void setScore(float score) {
        this.score = score;
    }

    /**
     * Returns the score associated with this node.
     * @return the score associated with this node.
     */
    public float getScore() {
        return score;
    }

    /**
     * Specifies whether this node has already been processed
     * and no longer is considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node has been processed.
     */
    public void setClosed(boolean b) {
        state = b ? state | CLOSED : state & ~CLOSED;
    }

    /**
     * Returns true if this node has been processed.
     * @return True if this node has been processed.
     */
    public boolean isClosed() {
        return (state & CLOSED) > 0;
    }

    /**
     * Specifies whether this node is currently being
     * considered for further processing.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently open.
     */
    public void setOpen(boolean b) {
        state = b ? state | OPEN : state & ~OPEN;
    }

    /**
     * Returns true if this node is currently being
     * considered for further processing.
     *
     * @return True if this node is open.
     */
    public boolean isOpen() {
        return (state & OPEN) > 0;
    }

    /**
     * Sets the data associated with this node. The handles
     * the way the node is displayed.
     *
     * @param data The data to be associated with this node.
     */
    public void setData(long data) {
        this.bits = data;
    }

    /**
     * Retrieves the data associated with this node.
     * @return the data associated with this node.
     */
    public long getData() {
        return bits;
    }

    /**
     * Specifies whether this node is solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @param b A boolean value that specifies whether
     *          this node is solid.
     */
    public void setSolid(boolean b) {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Returns whether this node is considered solid (ie. the
     * cost of entering the node is infinite.)
     *
     * @return True if this node is solid.
     */
    public boolean isSolid() {
        throw new RuntimeException(""Method not implemented!"");
    }

    /**
     * Specifies whether this node is currently visible.
     *
     * @param b A boolean value that specifies whether
     *          this node is currently visible.
     */
    public void setVisible(boolean b) {
        this.visibility = b ? 1.0f : 0.0f;
    }

    /**
     * Returns whether this node is considered visible.
     * @return True if this node is visible.
     */
    public boolean isVisible() {
        return visibility > 0.0f;
    }

    /**
     * Sets the degree of visibility of this node.
     * @param value the degree of visibility.
     */
    public void setVisibility(float value) {
        this.visibility = value;
    }

    /**
     * Returns the current degree of visibility of this node.
     * @return the current degree of visibility of this node.
     */
    public float getVisibility() {
        return visibility;
    }

    /**
     * Compares this Node with the specified Object for order.
     * <b>Note</b>: This method imposes ordering which is
     * inconsistant with equals.
     *
     * @param obj The object which is to be compared.
     * @return An integer value of -1, 0, or 1, as this node
     *         is less than, equal to, or greater than obj.
     *
     * @throws ClassCastException if obj is not of type Node.
     */
    public int compareTo(Object obj) {
        return compareTo((DirtyNode) obj);
    }

    public int compareTo(DirtyNode n) {
        return score < n.score ? -1 : (score > n.score ? 1 : 0);
    }

    /**
     * Compares this node with the specified object for equality.
     * Two nodes are considered equal if they have the same map
     * coordinates.
     *
     * @param obj The node which is to be compared.
     * @return True if obj is of type node and has the same map
     *         coordinate as this node. Otherwise return false.
     */
    public boolean equals(Object obj) {
        return equals((DirtyNode) obj);
    }

    public boolean equals(DirtyNode n) {
        return x == n.x && y == n.y;
    }

    /**
     * Returns a string representation of this <code>Node</code>.
     * @return a string representation of this <code>Node</code>.
     */
    public String toString() {
        return ""DirtyNode[x="" + x + "",y="" + y + "",score="" + score + ""]"";
    }
}
","// DirtyNode_1Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#compareTo(Object)} method.
*/
class DirtyNode_1Test {","// DirtyNode_1Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#compareTo(Object)} method.
*/
class DirtyNode_1Test {

	/**
	* Test case 1 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with the same score.
	* The expected result is that the method returns 0.
	*/
	@Test
	void testCompareTo_1() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(1);
		node2.setScore(1);
		assertEquals(0, node1.compareTo(node2));
	}
	
	/**
	* Test case 2 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_2() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 3 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_3() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 4 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_4() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 5 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_5() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 6 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_6() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 7 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_7() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 8 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_8() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
	
	/**
	* Test case 9 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns 1.
	*/
	@Test
	void testCompareTo_9() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(2);
		node2.setScore(1);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 10 for {@link DirtyNode#compareTo(Object)}.
	* <p>
	* This test case tests the compareTo method with two nodes with different scores.
	* The expected result is that the method returns -1.
	*/
	@Test
	void testCompareTo_10() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setScore(1);
		node2.setScore(2);
		assertEquals(-1, node1.compareTo(node2));
	}
}

// DirtyNode_2Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#equals(Object)} method.
*/
class DirtyNode_2Test {
		
	/**
	* Test case 1 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with the same coordinates.
	* The expected result is that the method returns true.
	*/
	@Test
	void testEquals_1() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(1, 1);
		assertTrue(node1.equals(node2));
	}
	
	/**
	* Test case 2 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_2() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 3 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_3() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 4 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_4() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 5 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_5() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 6 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_6() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 7 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_7() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 8 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_8() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 9 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_9() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
	
	/**
	* Test case 10 for {@link DirtyNode#equals(Object)}.
	* <p>
	* This test case tests the equals method with two nodes with different coordinates.
	* The expected result is that the method returns false.
	*/
	@Test
	void testEquals_10() {
		DirtyNode node1 = new DirtyNode(0);
		DirtyNode node2 = new DirtyNode(0);
		node1.setLocation(1, 1);
		node2.setLocation(2, 2);
		assertFalse(node1.equals(node2));
	}
}

// DirtyNode_3Test.java
package map;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link DirtyNode}.
* It contains ten unit test cases for the {@link DirtyNode#getAllChildren()} method.
*/
class DirtyNode_3Test {
		
	/**
	* Test case 1 for {@link DirtyNode#getAllChildren()}.
	* <p>
	* This test case tests the getAllChildren method with a node with no children.
	* The expected result is that the method returns an empty array.
	*/
	@Test
	void testGetAllChildren_1() {
		DirtyNode node = new DirtyNode(0);
		assertEquals(0, node.getAllChildren().length);
	}
	
	/**
	* Test case 2 for {@link DirtyNode#getAllChildren()}.
	* <p>
	* This test case tests the getAllChildren method with a node with one child.
	* The expected result is that the method returns an array with one element.
	*/
	@Test
	void testGetAllChildren_2() {
		DirtyNode node = new DirtyNode(0);
		DirtyNode child = new DirtyNode(0);
		node.addChildNode(child);
		assertEquals(1, node.getAllChildren().length);
	}
	
	/**
	* Test case 3 for {@link DirtyNode#getAllChildren()}.
	* <p>
	* This test case tests the getAllChildren method with a node with two children.
	* The expected result is that the method returns an array with two elements.
	*/
	@Test
	void testGetAllChildren_3() {
		DirtyNode node = new DirtyNode(0);
		DirtyNode child1 = new DirtyNode(0);
		DirtyNode child2 = new DirtyNode(0);
		node.addChildNode(child1);
		node.addChildNode(child2);
		assertEquals(2, node.getAllChildren().length);
	}
	
	/**
	* Test case 4 for {@link DirtyNode#getAllChildren()}.
	* <p>
	* This test case tests the getAllChildren method with a node with three children.
	* The expected result is that the method returns an array with three elements.
	*/
	@Test
	void testGetAllChildren_4() {
		DirtyNode node = new DirtyNode(0);
		DirtyNode child1 = new DirtyNode(0);
		DirtyNode child2 = new DirtyNode(0);
		DirtyNode child3 = new DirtyNode(0);
		node.addChildNode(child1);
		node.addChildNode(child2);
		node.addChildNode(child3);
		assertEquals(3, node.getAllChildren().length);
	}
	
	/**
	* Test case 5 for {@link DirtyNode#getAllChildren()}.
	* <p>
	* This test case tests the getAllChildren method with a node with four children.
	* The expected result is that the method returns an array with four elements.
	*/
	@Test
	void testGetAllChildren_5() {
		DirtyNode node = new DirtyNode(0);
		DirtyNode child1 = new DirtyNode(0);
		DirtyNode child2 = new DirtyNode(0);
		DirtyNode child3"
cmpl-6tu81dw77zAA1WIasXEBJsSu7uRU7,/EvoSuiteBenchmark/27_gangup/src/main/java/map/TileMap_0Test.java,95.71376848220825,length,"// TileMap.java
/* TileMap.java v0.2 (06/14/2002)
 *
 * Copyright (C) 2002, Joel Andersson <bja@kth.se>
 * 
 * This software is hereby expressly placed in the public domain.
 * Share and enjoy.
 */
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;

/**
 * The <code>Map</code> class represents an W by H grid area where each cell
 * in the grid can be referenced by two integers, x and y, corresponding to
 * the horizontal position and vertical position of the cell respectively.
 */
public class TileMap extends VisibilityMap {

    /**
     * The internal representation of the map.
     */
    protected Node[][] grid;

    /**
     * The size of the tiles in this map.
     */
    protected int tileSize;

    protected int numOfCols;

    protected int numOfRows;

    /**
     * Creates a new map from the specified fileName with the number
     * of subdivisions given by tileSize.
     *
     * @param fileName The file from which to create the map.
     * @param tileSize The size of the tiles in this map.
     */
    public TileMap(String fileName, int tileSize) throws IOException {
        this(1.0f / 15.0f, 1.0f, fileName, tileSize);
    }

    /**
     * Creates a new map from the specified fileName with the number
     * of subdivisions given by tileSize.
     *
     * @param fileName The file from which to create the map.
     * @param tileSize The size of the tiles in this map.
     */
    public TileMap(float min, float max, String fileName, int tileSize) throws IOException {
        super(min, max);
        this.tileSize = tileSize;
        open(fileName);
    }

    /**
     * Returns the <code>Node</code> at the given coordinates.
     *
     * @param x The horizontal coordinate.
     * @param y The vertical coordinate.
     * @return The <code>Node</code> at the given coordinates.
     */
    public Node getNodeAt(int x, int y) {
        return grid[y][x];
    }

    public Node getNodeAt(float x, float y, float z) {
        return grid[(int) (y / tileSize)][(int) (x / tileSize)];
    }

    /**
     * Returns the width of the map.
     * @return The width of the map.
     */
    public int getWidth() {
        return grid[0].length;
    }

    /**
     * Returns the height of the map.
     * @return The height of the map.
     */
    public int getHeight() {
        return grid.length;
    }

    /**
     * Restores the internal state of each processed node to
     * its default state.
     */
    public final void reset() {
        for (int y = 0; y < grid.length; y++) {
            for (int x = 0; x < grid[0].length; x++) {
                grid[y][x].setParent(null);
                grid[y][x].setTotal(0.0f);
                grid[y][x].setScore(0.0f);
                grid[y][x].setVisible(false);
                grid[y][x].setOpen(false);
                grid[y][x].setClosed(false);
            }
        }
    }

    /**
     * Searches for a path connecting the nodes given by their coordinates.
     *
     * @param x0 The horizontal position of the source node.
     * @param y0 The vertical position of the source node.
     * @param x1 The horizontal position of the destination node.
     * @param y1 The vertical position of the destination node.
     *
     * @return A <code>Path</code> object representing the path between
     *         between the source and destination nodes or <code>null/<code>
     *         if no path was found.
     */
    public Path search(int x0, int y0, int x1, int y1) throws PathNotFoundException {
        return search(getNodeAt(x0, y0), getNodeAt(x1, y1));
    }

    /**
     * Searches for a path connecting the source node with the target
     * node.
     *
     * @param source The node from which to start.
     * @param target The node to which a path is to be found.
     *
     * @return A <code>Path</code> object representing the path between
     *         between the start and destination nodes or <code>null/<code>
     *         if no path was found.
     *
     * @throws PathNotFoundException if no such path could be found.
     * @throws NullPointerException if either start or finish is null.
     */
    public Path search(Node source, Node target) throws PathNotFoundException {
        return aStarSearch2(source, target);
    }

    /**
     * Calculate the Euclidian distance from <code>source</code>
     * to <code>target</code>.
     *
     * @param source The source node.
     * @param target The target node.
     */
    protected float heuristic(Node source, Node target) {
        float dx = target.getX() - source.getX();
        float dy = target.getY() - source.getY();
        return (float) Math.sqrt(dx * dx + dy * dy);
    }

    /**
     * Determines the actual cost of crossing the edge between
     * the given adjectant nodes. If the nodes are not adjectant
     * the returned cost is unspecified.
     *
     * @param source The source node.
     * @param target The target node.
     */
    protected float cost(Node source, Node target) {
        return target.getCost() * heuristic(source, target);
    }

    /**
     * Open and parse the file given by fileName. The file should be in
     * a supported map format.
     *
     * @param fileName The file to read.
     */
    protected void open(String fileName) throws IOException {
        // System.err.println(""TileMap.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[3];
        // throw away tile info
        int numOfTiles = Integer.parseInt(in.readLine());
        for (i = 0; i < numOfTiles; i++) {
            in.readLine();
        }
        // throw away obj info
        int numOfObjs = Integer.parseInt(in.readLine());
        for (i = 0; i < numOfObjs; i++) {
            in.readLine();
        }
        numOfCols = Integer.parseInt(in.readLine());
        numOfRows = Integer.parseInt(in.readLine());
        grid = new Node[numOfRows][numOfCols];
        for (i = 0; i < numOfRows; i++) {
            for (j = 0; j < numOfCols; j++) {
                grid[i][j] = new DefaultNode(null, 0, j, i);
                grid[i][j].setCost(1);
            }
        }
        i = j = 0;
        while (st.nextToken() != st.TT_EOF) {
            if (j >= tmp.length) {
                grid[tmp[1]][tmp[0]].setCost(tmp[2]);
                //		grid[tmp[1]][tmp[0]].setX(tmp[0]);
                //		grid[tmp[1]][tmp[0]].setY(tmp[1]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == tmp.length) {
            grid[tmp[1]][tmp[0]].setCost(tmp[2]);
            //	    grid[tmp[1]][tmp[0]].setX((float)tmp[0]);
            //	    grid[tmp[1]][tmp[0]].setY((float)tmp[1]);
            //	    System.err.println(""TileMap.open(): Missing end of line!"");
        }
        in.close();
        buildGraph();
    }

    private void buildGraph() {
        int i = 0;
        int j = 0;
        grid[i][j].addChildNode(grid[i][j + 1]);
        grid[i][j].addChildNode(grid[i + 1][j]);
        grid[i][j].addChildNode(grid[i + 1][j + 1]);
        i = 0;
        j = numOfCols - 1;
        grid[i][j].addChildNode(grid[i][j - 1]);
        grid[i][j].addChildNode(grid[i + 1][j]);
        grid[i][j].addChildNode(grid[i + 1][j - 1]);
        i = numOfRows - 1;
        j = 0;
        grid[i][j].addChildNode(grid[i][j + 1]);
        grid[i][j].addChildNode(grid[i - 1][j]);
        grid[i][j].addChildNode(grid[i - 1][j + 1]);
        i = numOfRows - 1;
        j = numOfCols - 1;
        grid[i][j].addChildNode(grid[i][j - 1]);
        grid[i][j].addChildNode(grid[i - 1][j]);
        grid[i][j].addChildNode(grid[i - 1][j - 1]);
        for (i = 1; i < numOfRows - 1; i++) {
            grid[i][0].addChildNode(grid[i][1]);
            grid[i][0].addChildNode(grid[i - 1][1]);
            grid[i][0].addChildNode(grid[i + 1][1]);
            grid[i][numOfCols - 1].addChildNode(grid[i][numOfCols - 2]);
            grid[i][numOfCols - 1].addChildNode(grid[i - 1][numOfCols - 2]);
            grid[i][numOfCols - 1].addChildNode(grid[i + 1][numOfCols - 2]);
        }
        for (j = 1; j < numOfCols - 1; j++) {
            grid[0][j].addChildNode(grid[1][j]);
            grid[0][j].addChildNode(grid[1][j + 1]);
            grid[0][j].addChildNode(grid[1][j - 1]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j + 1]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j - 1]);
        }
        for (i = 1; i < numOfRows - 1; i++) {
            for (j = 1; j < numOfCols - 1; j++) {
                grid[i][j].addChildNode(grid[i - 1][j]);
                grid[i][j].addChildNode(grid[i + 1][j]);
                grid[i][j].addChildNode(grid[i - 1][j - 1]);
                grid[i][j].addChildNode(grid[i - 1][j + 1]);
                grid[i][j].addChildNode(grid[i][j - 1]);
                grid[i][j].addChildNode(grid[i][j + 1]);
                grid[i][j].addChildNode(grid[i - 1][j - 1]);
                grid[i][j].addChildNode(grid[i + 1][j + 1]);
            }
        }
    }
}
","// TileMap_0Test.java
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TileMap}.
* It contains ten unit test cases for the {@link TileMap#getNodeAt(int, int)} method.
*/
class TileMap_0Test {","// TileMap_0Test.java
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TileMap}.
* It contains ten unit test cases for the {@link TileMap#getNodeAt(int, int)} method.
*/
class TileMap_0Test {

		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 0</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_0() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 0);
				assertEquals(0, node.getX());
				assertEquals(0, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 1</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_1() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 1);
				assertEquals(0, node.getX());
				assertEquals(1, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 2</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_2() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 2);
				assertEquals(0, node.getX());
				assertEquals(2, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 3</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_3() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 3);
				assertEquals(0, node.getX());
				assertEquals(3, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 4</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_4() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 4);
				assertEquals(0, node.getX());
				assertEquals(4, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 5</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_5() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 5);
				assertEquals(0, node.getX());
				assertEquals(5, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 6</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_6() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 6);
				assertEquals(0, node.getX());
				assertEquals(6, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 7</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_7() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 7);
				assertEquals(0, node.getX());
				assertEquals(7, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 8</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_8() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 8);
				assertEquals(0, node.getX());
				assertEquals(8, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 0</li>
		* <li>y = 9</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_9() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(0, 9);
				assertEquals(0, node.getX());
				assertEquals(9, node.getY());
		}
		
}

// TileMap_1Test.java
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TileMap}.
* It contains ten unit test cases for the {@link TileMap#getNodeAt(int, int)} method.
*/
class TileMap_1Test {
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 0</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_0() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 0);
				assertEquals(1, node.getX());
				assertEquals(0, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 1</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_1() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 1);
				assertEquals(1, node.getX());
				assertEquals(1, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 2</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_2() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 2);
				assertEquals(1, node.getX());
				assertEquals(2, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 3</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_3() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 3);
				assertEquals(1, node.getX());
				assertEquals(3, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 4</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_4() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 4);
				assertEquals(1, node.getX());
				assertEquals(4, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 5</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_5() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 5);
				assertEquals(1, node.getX());
				assertEquals(5, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 6</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_6() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 6);
				assertEquals(1, node.getX());
				assertEquals(6, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 7</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_7() throws IOException {
				TileMap tileMap = new TileMap(""map/test/test.map"", 15);
				Node node = tileMap.getNodeAt(1, 7);
				assertEquals(1, node.getX());
				assertEquals(7, node.getY());
		}
		
		/**
		* Test case for {@link TileMap#getNodeAt(int, int)}.
		* It tests the method with the following parameters:
		* <ul>
		* <li>x = 1</li>
		* <li>y = 8</li>
		* </ul>
		*
		* @throws IOException if an error occurs while reading the map file.
		*/
		@Test
		void testGetNodeAt_8()"
cmpl-6tu9YKIooH2Fm9AhrI81PLWxVx001,/EvoSuiteBenchmark/27_gangup/src/main/java/map/TileMap_2Test.java,28.040894031524658,stop,"// TileMap.java
/* TileMap.java v0.2 (06/14/2002)
 *
 * Copyright (C) 2002, Joel Andersson <bja@kth.se>
 * 
 * This software is hereby expressly placed in the public domain.
 * Share and enjoy.
 */
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;

/**
 * The <code>Map</code> class represents an W by H grid area where each cell
 * in the grid can be referenced by two integers, x and y, corresponding to
 * the horizontal position and vertical position of the cell respectively.
 */
public class TileMap extends VisibilityMap {

    /**
     * The internal representation of the map.
     */
    protected Node[][] grid;

    /**
     * The size of the tiles in this map.
     */
    protected int tileSize;

    protected int numOfCols;

    protected int numOfRows;

    /**
     * Creates a new map from the specified fileName with the number
     * of subdivisions given by tileSize.
     *
     * @param fileName The file from which to create the map.
     * @param tileSize The size of the tiles in this map.
     */
    public TileMap(String fileName, int tileSize) throws IOException {
        this(1.0f / 15.0f, 1.0f, fileName, tileSize);
    }

    /**
     * Creates a new map from the specified fileName with the number
     * of subdivisions given by tileSize.
     *
     * @param fileName The file from which to create the map.
     * @param tileSize The size of the tiles in this map.
     */
    public TileMap(float min, float max, String fileName, int tileSize) throws IOException {
        super(min, max);
        this.tileSize = tileSize;
        open(fileName);
    }

    /**
     * Returns the <code>Node</code> at the given coordinates.
     *
     * @param x The horizontal coordinate.
     * @param y The vertical coordinate.
     * @return The <code>Node</code> at the given coordinates.
     */
    public Node getNodeAt(int x, int y) {
        return grid[y][x];
    }

    public Node getNodeAt(float x, float y, float z) {
        return grid[(int) (y / tileSize)][(int) (x / tileSize)];
    }

    /**
     * Returns the width of the map.
     * @return The width of the map.
     */
    public int getWidth() {
        return grid[0].length;
    }

    /**
     * Returns the height of the map.
     * @return The height of the map.
     */
    public int getHeight() {
        return grid.length;
    }

    /**
     * Restores the internal state of each processed node to
     * its default state.
     */
    public final void reset() {
        for (int y = 0; y < grid.length; y++) {
            for (int x = 0; x < grid[0].length; x++) {
                grid[y][x].setParent(null);
                grid[y][x].setTotal(0.0f);
                grid[y][x].setScore(0.0f);
                grid[y][x].setVisible(false);
                grid[y][x].setOpen(false);
                grid[y][x].setClosed(false);
            }
        }
    }

    /**
     * Searches for a path connecting the nodes given by their coordinates.
     *
     * @param x0 The horizontal position of the source node.
     * @param y0 The vertical position of the source node.
     * @param x1 The horizontal position of the destination node.
     * @param y1 The vertical position of the destination node.
     *
     * @return A <code>Path</code> object representing the path between
     *         between the source and destination nodes or <code>null/<code>
     *         if no path was found.
     */
    public Path search(int x0, int y0, int x1, int y1) throws PathNotFoundException {
        return search(getNodeAt(x0, y0), getNodeAt(x1, y1));
    }

    /**
     * Searches for a path connecting the source node with the target
     * node.
     *
     * @param source The node from which to start.
     * @param target The node to which a path is to be found.
     *
     * @return A <code>Path</code> object representing the path between
     *         between the start and destination nodes or <code>null/<code>
     *         if no path was found.
     *
     * @throws PathNotFoundException if no such path could be found.
     * @throws NullPointerException if either start or finish is null.
     */
    public Path search(Node source, Node target) throws PathNotFoundException {
        return aStarSearch2(source, target);
    }

    /**
     * Calculate the Euclidian distance from <code>source</code>
     * to <code>target</code>.
     *
     * @param source The source node.
     * @param target The target node.
     */
    protected float heuristic(Node source, Node target) {
        float dx = target.getX() - source.getX();
        float dy = target.getY() - source.getY();
        return (float) Math.sqrt(dx * dx + dy * dy);
    }

    /**
     * Determines the actual cost of crossing the edge between
     * the given adjectant nodes. If the nodes are not adjectant
     * the returned cost is unspecified.
     *
     * @param source The source node.
     * @param target The target node.
     */
    protected float cost(Node source, Node target) {
        return target.getCost() * heuristic(source, target);
    }

    /**
     * Open and parse the file given by fileName. The file should be in
     * a supported map format.
     *
     * @param fileName The file to read.
     */
    protected void open(String fileName) throws IOException {
        // System.err.println(""TileMap.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[3];
        // throw away tile info
        int numOfTiles = Integer.parseInt(in.readLine());
        for (i = 0; i < numOfTiles; i++) {
            in.readLine();
        }
        // throw away obj info
        int numOfObjs = Integer.parseInt(in.readLine());
        for (i = 0; i < numOfObjs; i++) {
            in.readLine();
        }
        numOfCols = Integer.parseInt(in.readLine());
        numOfRows = Integer.parseInt(in.readLine());
        grid = new Node[numOfRows][numOfCols];
        for (i = 0; i < numOfRows; i++) {
            for (j = 0; j < numOfCols; j++) {
                grid[i][j] = new DefaultNode(null, 0, j, i);
                grid[i][j].setCost(1);
            }
        }
        i = j = 0;
        while (st.nextToken() != st.TT_EOF) {
            if (j >= tmp.length) {
                grid[tmp[1]][tmp[0]].setCost(tmp[2]);
                //		grid[tmp[1]][tmp[0]].setX(tmp[0]);
                //		grid[tmp[1]][tmp[0]].setY(tmp[1]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == tmp.length) {
            grid[tmp[1]][tmp[0]].setCost(tmp[2]);
            //	    grid[tmp[1]][tmp[0]].setX((float)tmp[0]);
            //	    grid[tmp[1]][tmp[0]].setY((float)tmp[1]);
            //	    System.err.println(""TileMap.open(): Missing end of line!"");
        }
        in.close();
        buildGraph();
    }

    private void buildGraph() {
        int i = 0;
        int j = 0;
        grid[i][j].addChildNode(grid[i][j + 1]);
        grid[i][j].addChildNode(grid[i + 1][j]);
        grid[i][j].addChildNode(grid[i + 1][j + 1]);
        i = 0;
        j = numOfCols - 1;
        grid[i][j].addChildNode(grid[i][j - 1]);
        grid[i][j].addChildNode(grid[i + 1][j]);
        grid[i][j].addChildNode(grid[i + 1][j - 1]);
        i = numOfRows - 1;
        j = 0;
        grid[i][j].addChildNode(grid[i][j + 1]);
        grid[i][j].addChildNode(grid[i - 1][j]);
        grid[i][j].addChildNode(grid[i - 1][j + 1]);
        i = numOfRows - 1;
        j = numOfCols - 1;
        grid[i][j].addChildNode(grid[i][j - 1]);
        grid[i][j].addChildNode(grid[i - 1][j]);
        grid[i][j].addChildNode(grid[i - 1][j - 1]);
        for (i = 1; i < numOfRows - 1; i++) {
            grid[i][0].addChildNode(grid[i][1]);
            grid[i][0].addChildNode(grid[i - 1][1]);
            grid[i][0].addChildNode(grid[i + 1][1]);
            grid[i][numOfCols - 1].addChildNode(grid[i][numOfCols - 2]);
            grid[i][numOfCols - 1].addChildNode(grid[i - 1][numOfCols - 2]);
            grid[i][numOfCols - 1].addChildNode(grid[i + 1][numOfCols - 2]);
        }
        for (j = 1; j < numOfCols - 1; j++) {
            grid[0][j].addChildNode(grid[1][j]);
            grid[0][j].addChildNode(grid[1][j + 1]);
            grid[0][j].addChildNode(grid[1][j - 1]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j + 1]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j - 1]);
        }
        for (i = 1; i < numOfRows - 1; i++) {
            for (j = 1; j < numOfCols - 1; j++) {
                grid[i][j].addChildNode(grid[i - 1][j]);
                grid[i][j].addChildNode(grid[i + 1][j]);
                grid[i][j].addChildNode(grid[i - 1][j - 1]);
                grid[i][j].addChildNode(grid[i - 1][j + 1]);
                grid[i][j].addChildNode(grid[i][j - 1]);
                grid[i][j].addChildNode(grid[i][j + 1]);
                grid[i][j].addChildNode(grid[i - 1][j - 1]);
                grid[i][j].addChildNode(grid[i + 1][j + 1]);
            }
        }
    }
}
","// TileMap_2Test.java
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TileMap}.
* It contains ten unit test cases for the {@link TileMap#search(int, int, int, int)} method.
*/
class TileMap_2Test {","// TileMap_2Test.java
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TileMap}.
* It contains ten unit test cases for the {@link TileMap#search(int, int, int, int)} method.
*/
class TileMap_2Test {

	/**
	* Test case 1 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are the same.
	* The expected result is an empty path.
	*/
	@Test
	void testSearch_1() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 0, 0);
		assertEquals(0, path.getLength());
	}
	
	/**
	* Test case 2 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are adjacent.
	* The expected result is a path of length 1.
	*/
	@Test
	void testSearch_2() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 1, 0);
		assertEquals(1, path.getLength());
	}
	
	/**
	* Test case 3 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 2.
	*/
	@Test
	void testSearch_3() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 1, 1);
		assertEquals(2, path.getLength());
	}
	
	/**
	* Test case 4 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 3.
	*/
	@Test
	void testSearch_4() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 2, 2);
		assertEquals(3, path.getLength());
	}
	
	/**
	* Test case 5 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 4.
	*/
	@Test
	void testSearch_5() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 3, 3);
		assertEquals(4, path.getLength());
	}
	
	/**
	* Test case 6 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 5.
	*/
	@Test
	void testSearch_6() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 4, 4);
		assertEquals(5, path.getLength());
	}
	
	/**
	* Test case 7 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 6.
	*/
	@Test
	void testSearch_7() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 5, 5);
		assertEquals(6, path.getLength());
	}
	
	/**
	* Test case 8 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 7.
	*/
	@Test
	void testSearch_8() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 6, 6);
		assertEquals(7, path.getLength());
	}
	
	/**
	* Test case 9 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 8.
	*/
	@Test
	void testSearch_9() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 7, 7);
		assertEquals(8, path.getLength());
	}
	
	/**
	* Test case 10 for {@link TileMap#search(int, int, int, int)}.
	* It tests the case where the source and destination nodes are not adjacent.
	* The expected result is a path of length 9.
	*/
	@Test
	void testSearch_10() throws IOException {
		TileMap map = new TileMap(""map/test/test1.map"", 32);
		Path path = map.search(0, 0, 8, 8);
		assertEquals(9, path.getLength());
	}
}"
cmpl-6tuAbGgCVHsA0C7aPNpj2x083uxL1,/EvoSuiteBenchmark/27_gangup/src/main/java/map/TileMap_3Test.java,34.37030911445618,stop,"// TileMap.java
/* TileMap.java v0.2 (06/14/2002)
 *
 * Copyright (C) 2002, Joel Andersson <bja@kth.se>
 * 
 * This software is hereby expressly placed in the public domain.
 * Share and enjoy.
 */
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;

/**
 * The <code>Map</code> class represents an W by H grid area where each cell
 * in the grid can be referenced by two integers, x and y, corresponding to
 * the horizontal position and vertical position of the cell respectively.
 */
public class TileMap extends VisibilityMap {

    /**
     * The internal representation of the map.
     */
    protected Node[][] grid;

    /**
     * The size of the tiles in this map.
     */
    protected int tileSize;

    protected int numOfCols;

    protected int numOfRows;

    /**
     * Creates a new map from the specified fileName with the number
     * of subdivisions given by tileSize.
     *
     * @param fileName The file from which to create the map.
     * @param tileSize The size of the tiles in this map.
     */
    public TileMap(String fileName, int tileSize) throws IOException {
        this(1.0f / 15.0f, 1.0f, fileName, tileSize);
    }

    /**
     * Creates a new map from the specified fileName with the number
     * of subdivisions given by tileSize.
     *
     * @param fileName The file from which to create the map.
     * @param tileSize The size of the tiles in this map.
     */
    public TileMap(float min, float max, String fileName, int tileSize) throws IOException {
        super(min, max);
        this.tileSize = tileSize;
        open(fileName);
    }

    /**
     * Returns the <code>Node</code> at the given coordinates.
     *
     * @param x The horizontal coordinate.
     * @param y The vertical coordinate.
     * @return The <code>Node</code> at the given coordinates.
     */
    public Node getNodeAt(int x, int y) {
        return grid[y][x];
    }

    public Node getNodeAt(float x, float y, float z) {
        return grid[(int) (y / tileSize)][(int) (x / tileSize)];
    }

    /**
     * Returns the width of the map.
     * @return The width of the map.
     */
    public int getWidth() {
        return grid[0].length;
    }

    /**
     * Returns the height of the map.
     * @return The height of the map.
     */
    public int getHeight() {
        return grid.length;
    }

    /**
     * Restores the internal state of each processed node to
     * its default state.
     */
    public final void reset() {
        for (int y = 0; y < grid.length; y++) {
            for (int x = 0; x < grid[0].length; x++) {
                grid[y][x].setParent(null);
                grid[y][x].setTotal(0.0f);
                grid[y][x].setScore(0.0f);
                grid[y][x].setVisible(false);
                grid[y][x].setOpen(false);
                grid[y][x].setClosed(false);
            }
        }
    }

    /**
     * Searches for a path connecting the nodes given by their coordinates.
     *
     * @param x0 The horizontal position of the source node.
     * @param y0 The vertical position of the source node.
     * @param x1 The horizontal position of the destination node.
     * @param y1 The vertical position of the destination node.
     *
     * @return A <code>Path</code> object representing the path between
     *         between the source and destination nodes or <code>null/<code>
     *         if no path was found.
     */
    public Path search(int x0, int y0, int x1, int y1) throws PathNotFoundException {
        return search(getNodeAt(x0, y0), getNodeAt(x1, y1));
    }

    /**
     * Searches for a path connecting the source node with the target
     * node.
     *
     * @param source The node from which to start.
     * @param target The node to which a path is to be found.
     *
     * @return A <code>Path</code> object representing the path between
     *         between the start and destination nodes or <code>null/<code>
     *         if no path was found.
     *
     * @throws PathNotFoundException if no such path could be found.
     * @throws NullPointerException if either start or finish is null.
     */
    public Path search(Node source, Node target) throws PathNotFoundException {
        return aStarSearch2(source, target);
    }

    /**
     * Calculate the Euclidian distance from <code>source</code>
     * to <code>target</code>.
     *
     * @param source The source node.
     * @param target The target node.
     */
    protected float heuristic(Node source, Node target) {
        float dx = target.getX() - source.getX();
        float dy = target.getY() - source.getY();
        return (float) Math.sqrt(dx * dx + dy * dy);
    }

    /**
     * Determines the actual cost of crossing the edge between
     * the given adjectant nodes. If the nodes are not adjectant
     * the returned cost is unspecified.
     *
     * @param source The source node.
     * @param target The target node.
     */
    protected float cost(Node source, Node target) {
        return target.getCost() * heuristic(source, target);
    }

    /**
     * Open and parse the file given by fileName. The file should be in
     * a supported map format.
     *
     * @param fileName The file to read.
     */
    protected void open(String fileName) throws IOException {
        // System.err.println(""TileMap.open()"");
        BufferedReader in = new BufferedReader(new FileReader(fileName));
        StreamTokenizer st = new StreamTokenizer(in);
        int j = 0, i = 0;
        int[] tmp = new int[3];
        // throw away tile info
        int numOfTiles = Integer.parseInt(in.readLine());
        for (i = 0; i < numOfTiles; i++) {
            in.readLine();
        }
        // throw away obj info
        int numOfObjs = Integer.parseInt(in.readLine());
        for (i = 0; i < numOfObjs; i++) {
            in.readLine();
        }
        numOfCols = Integer.parseInt(in.readLine());
        numOfRows = Integer.parseInt(in.readLine());
        grid = new Node[numOfRows][numOfCols];
        for (i = 0; i < numOfRows; i++) {
            for (j = 0; j < numOfCols; j++) {
                grid[i][j] = new DefaultNode(null, 0, j, i);
                grid[i][j].setCost(1);
            }
        }
        i = j = 0;
        while (st.nextToken() != st.TT_EOF) {
            if (j >= tmp.length) {
                grid[tmp[1]][tmp[0]].setCost(tmp[2]);
                //		grid[tmp[1]][tmp[0]].setX(tmp[0]);
                //		grid[tmp[1]][tmp[0]].setY(tmp[1]);
                j = 0;
            }
            tmp[j++] = (int) st.nval;
        }
        if (j == tmp.length) {
            grid[tmp[1]][tmp[0]].setCost(tmp[2]);
            //	    grid[tmp[1]][tmp[0]].setX((float)tmp[0]);
            //	    grid[tmp[1]][tmp[0]].setY((float)tmp[1]);
            //	    System.err.println(""TileMap.open(): Missing end of line!"");
        }
        in.close();
        buildGraph();
    }

    private void buildGraph() {
        int i = 0;
        int j = 0;
        grid[i][j].addChildNode(grid[i][j + 1]);
        grid[i][j].addChildNode(grid[i + 1][j]);
        grid[i][j].addChildNode(grid[i + 1][j + 1]);
        i = 0;
        j = numOfCols - 1;
        grid[i][j].addChildNode(grid[i][j - 1]);
        grid[i][j].addChildNode(grid[i + 1][j]);
        grid[i][j].addChildNode(grid[i + 1][j - 1]);
        i = numOfRows - 1;
        j = 0;
        grid[i][j].addChildNode(grid[i][j + 1]);
        grid[i][j].addChildNode(grid[i - 1][j]);
        grid[i][j].addChildNode(grid[i - 1][j + 1]);
        i = numOfRows - 1;
        j = numOfCols - 1;
        grid[i][j].addChildNode(grid[i][j - 1]);
        grid[i][j].addChildNode(grid[i - 1][j]);
        grid[i][j].addChildNode(grid[i - 1][j - 1]);
        for (i = 1; i < numOfRows - 1; i++) {
            grid[i][0].addChildNode(grid[i][1]);
            grid[i][0].addChildNode(grid[i - 1][1]);
            grid[i][0].addChildNode(grid[i + 1][1]);
            grid[i][numOfCols - 1].addChildNode(grid[i][numOfCols - 2]);
            grid[i][numOfCols - 1].addChildNode(grid[i - 1][numOfCols - 2]);
            grid[i][numOfCols - 1].addChildNode(grid[i + 1][numOfCols - 2]);
        }
        for (j = 1; j < numOfCols - 1; j++) {
            grid[0][j].addChildNode(grid[1][j]);
            grid[0][j].addChildNode(grid[1][j + 1]);
            grid[0][j].addChildNode(grid[1][j - 1]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j + 1]);
            grid[numOfRows - 1][j].addChildNode(grid[numOfRows - 2][j - 1]);
        }
        for (i = 1; i < numOfRows - 1; i++) {
            for (j = 1; j < numOfCols - 1; j++) {
                grid[i][j].addChildNode(grid[i - 1][j]);
                grid[i][j].addChildNode(grid[i + 1][j]);
                grid[i][j].addChildNode(grid[i - 1][j - 1]);
                grid[i][j].addChildNode(grid[i - 1][j + 1]);
                grid[i][j].addChildNode(grid[i][j - 1]);
                grid[i][j].addChildNode(grid[i][j + 1]);
                grid[i][j].addChildNode(grid[i - 1][j - 1]);
                grid[i][j].addChildNode(grid[i + 1][j + 1]);
            }
        }
    }
}
","// TileMap_3Test.java
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TileMap}.
* It contains ten unit test cases for the {@link TileMap#search(Node, Node)} method.
*/
class TileMap_3Test {","// TileMap_3Test.java
package map;

import java.io.*;
import java.awt.*;
import java.awt.image.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TileMap}.
* It contains ten unit test cases for the {@link TileMap#search(Node, Node)} method.
*/
class TileMap_3Test {

		/**
		* Test case 1 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_1() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 2 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_2() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 3 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_3() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 4 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_4() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 5 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_5() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 6 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_6() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 7 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_7() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 8 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_8() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 9 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_9() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
		
		/**
		* Test case 10 for {@link TileMap#search(Node, Node)}.
		* It tests the case where the source node is the same as the target node.
		* The expected result is a path with only one node.
		*/
		@Test
		void testSearch_10() throws IOException {
				TileMap map = new TileMap(""map/test/test1.map"", 10);
				Node source = map.getNodeAt(0, 0);
				Node target = map.getNodeAt(0, 0);
				Path path = map.search(source, target);
				assertEquals(1, path.getLength());
		}
}"
cmpl-6tuBe7FW1vhyZov8svUy33mdk1UHU,/EvoSuiteBenchmark/27_gangup/src/main/java/module/ConfigModule_0Test.java,90.15914511680603,length,"// ConfigModule.java
/* $Id: ConfigModule.java,v 1.3 2004/05/05 14:15:47 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 * Reference: http://java.sun.com/xml/jaxp/dist/1.1/docs/tutorial/index.html
 */
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;

@cvs(file = ""$RCSfile: ConfigModule.java,v $"", revision = ""$Revision: 1.3 $"", date = ""$Date: 2004/05/05 14:15:47 $"", author = ""$Author: emill $"", tag = ""$Name:  $"", build = """")
@mod(name = ""ConfigModule"", topics = ""CONFIG"", cmds = ""DUMP READ WRITE RELOAD GET GETS SET SETS"", desc = """")
public class /**
 * This class provides a centralized access point to configuration files
 * for other modules. Currently it is capable of loading and saving a
 * configuration, as well as adding and modifying module variables.
 */
ConfigModule extends AbstractModule {

    /**
     * Reference to the the document containing the configuration.
     */
    private Document config;

    /**
     * The root element of the document.
     */
    private Element root;

    /**
     * Lookup table for quickly accessing XML-nodes.
     */
    private Hashtable<String, Element> table;

    /**
     * Current path to the configuration file.
     */
    private String fileName = null;

    /**
     * Creates a new instance of the ConfigModule class.
     */
    public ConfigModule() throws ModuleRegisterException {
    }

    /**
     * Creates a new instance of the ConfigModule class.
     * @param krn the Kernel associated with this Module.
     */
    public ConfigModule(Kernel krn) throws ModuleRegisterException {
        super(krn);
    }

    /**
     */
    protected void init() {
        table = new Hashtable<String, Element>();
    }

    /**
     * Reads a configuration from the specified file.
     * @param fileName The file name that contains the configuration.
     */
    public void read(String fileName) {
        DocumentBuilder builder;
        DocumentBuilderFactory factory;
        NodeList list;
        try {
            factory = DocumentBuilderFactory.newInstance();
            factory.setValidating(true);
            builder = factory.newDocumentBuilder();
            config = builder.parse(fileName);
            /* hash all variables ... why are we using xml? */
            root = config.getDocumentElement();
            list = config.getElementsByTagName(""variable"");
            for (int i = 0; i < list.getLength(); i++) {
                Element e = (Element) list.item(i);
                Element p = (Element) e.getParentNode();
                table.put(p.getAttribute(""name"") + ""."" + e.getAttribute(""name""), e);
            }
            /* this can of course be done more efficiently */
            list = config.getElementsByTagName(""section"");
            for (int i = 0; i < list.getLength(); i++) {
                Element e = (Element) list.item(i);
                table.put(e.getAttribute(""name""), e);
            }
        } catch (SAXException e) {
            Exception x = e.getException();
            if (x == null) {
                x = e;
            }
            x.printStackTrace();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Writes the configuration to the specified file.
     * @param fileName The name of the file that is to be written.
     */
    public void write(String fileName) {
        try {
            File file = new File(fileName);
            TransformerFactory factory = TransformerFactory.newInstance();
            Transformer transformer = factory.newTransformer();
            DOMSource source = new DOMSource(config);
            StreamResult result = new StreamResult(file);
            transformer.transform(source, result);
            file = null;
        } catch (TransformerConfigurationException e) {
            Throwable x = e;
            if (e.getException() != null) {
                x = e.getException();
            }
            x.printStackTrace();
        } catch (TransformerException e) {
            Throwable x = e;
            if (e.getException() != null) {
                x = e.getException();
            }
            x.printStackTrace();
        }
    }

    /**
     * Returns the value of the specified key in this configuration.
     * @param mod The section that contains the variable.
     * @param var The variable to lookup.
     * @return The value of the specified key.
     */
    public String getCVar(String sec, String var) {
        Element e = table.get(sec + ""."" + var);
        if (e != null) {
            return e.getAttribute(""value"");
        }
        return """";
    }

    /**
     * Returns the values of the specified keys in this configuration,
     * or, if no keys were specified, returns the values of all keys.
     *
     * @param sec The section that contains the variable.
     * @param var The variable to lookup.
     * @return The value of the specified key.
     */
    public String getCVars(String sec, String vars) {
        String vals = """";
        /* Only modulename specified, read all variables! */
        if (vars == null || vars.length() == 0) {
            Element e = table.get(sec);
            NodeList list = e.getElementsByTagName(""variable"");
            for (int i = 0; i < list.getLength(); i++) {
                e = (Element) list.item(i);
                vals += e.getAttribute(""name"") + "":"" + e.getAttribute(""value"") + ""\n"";
            }
        } else {
            /* Both modulename and variables specified */
            String[] vlist = vars.split("","");
            for (int i = 0; i < vlist.length; i++) {
                vals += getCVar(sec, vlist[i]) + ""\n"";
            }
        }
        return vals;
    }

    /**
     * Sets the value of the specified variable to val.
     *
     * @param sec The section that contains the variable.
     * @param var The variable to set.
     * @param val The new value of the variable.
     */
    public void setCVar(String sec, String var, String val) {
        Element e = table.get(sec + ""."" + var);
        if (e == null) {
            Element m = table.get(sec);
            if (m == null) {
                m = config.createElement(""section"");
                m.setAttribute(""name"", sec);
                root.appendChild(m);
            }
            e = config.createElement(""variable"");
            e.setAttribute(""name"", var);
            m.appendChild(e);
        }
        table.put(sec + ""."" + var, e);
        e.setAttribute(""value"", val);
    }

    /**
     * This method is invoked once for every Message in the input queue.
     *
     * @param msg The Message that is to be processed.
     */
    protected void processMessage(Message msg) {
        String[] cmd = ((String) msg.body).split("" "");
        Message r = msg.reply(null);
        System.err.println(""ConfigModule.processMessage(): "" + msg.body);
        /* process module specific messages */
        if (cmd[0].equals(""READ"")) {
            if (cmd.length == 2) {
                fileName = cmd[1];
                read(fileName);
            } else {
                r.header = ""WARNING"";
                r.body = locale.getString(""CFG_READ_WRONG_NARGS"");
                sendMessage(r);
            }
        }
        if (cmd[0].equals(""WRITE"")) {
            if (cmd.length == 2) {
                fileName = cmd[1];
            }
            write(fileName);
        }
        if (cmd[0].equals(""RELOAD"") && fileName != null) {
            read(fileName);
        }
        if (cmd[0].equals(""DUMP"")) {
            System.err.println(table);
        }
        if (cmd[0].trim().equals(""GET"")) {
            String var = getCVar(cmd[1].trim(), cmd[2].trim());
            if (var != null) {
                r.body = var;
                sendMessage(r);
            }
        } else if (cmd[0].trim().equals(""SET"")) {
            setCVar(cmd[1].trim(), cmd[2].trim(), cmd[3].trim());
        }
        /* Get multiple variables in a single request. */
        if (cmd[0].trim().equals(""GETS"")) {
            try {
                String mod = cmd[1].trim();
                String vals;
                if (cmd.length > 2) {
                    vals = getCVars(mod, cmd[2].trim());
                } else {
                    vals = getCVars(mod, null);
                }
                r.body = vals;
                sendMessage(r);
            } catch (IndexOutOfBoundsException e) {
                e.printStackTrace(System.err);
            } catch (Exception e) {
                e.printStackTrace(System.err);
            }
        }
    }
}
","// ConfigModule_0Test.java
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigModule}.
* It contains ten unit test cases for the {@link ConfigModule#getCVar(String, String)} method.
*/
class ConfigModule_0Test {","// ConfigModule_0Test.java
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigModule}.
* It contains ten unit test cases for the {@link ConfigModule#getCVar(String, String)} method.
*/
class ConfigModule_0Test {

		/**
		* Test case 1 for method getCVar(String, String).
		*
		* @throws Exception
		*																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																																											"
cmpl-6tuD70EmD3j04JDmQkSGK5s9L8zyY,/EvoSuiteBenchmark/27_gangup/src/main/java/module/ConfigModule_1Test.java,88.83375763893127,length,"// ConfigModule.java
/* $Id: ConfigModule.java,v 1.3 2004/05/05 14:15:47 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 * Reference: http://java.sun.com/xml/jaxp/dist/1.1/docs/tutorial/index.html
 */
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;

@cvs(file = ""$RCSfile: ConfigModule.java,v $"", revision = ""$Revision: 1.3 $"", date = ""$Date: 2004/05/05 14:15:47 $"", author = ""$Author: emill $"", tag = ""$Name:  $"", build = """")
@mod(name = ""ConfigModule"", topics = ""CONFIG"", cmds = ""DUMP READ WRITE RELOAD GET GETS SET SETS"", desc = """")
public class /**
 * This class provides a centralized access point to configuration files
 * for other modules. Currently it is capable of loading and saving a
 * configuration, as well as adding and modifying module variables.
 */
ConfigModule extends AbstractModule {

    /**
     * Reference to the the document containing the configuration.
     */
    private Document config;

    /**
     * The root element of the document.
     */
    private Element root;

    /**
     * Lookup table for quickly accessing XML-nodes.
     */
    private Hashtable<String, Element> table;

    /**
     * Current path to the configuration file.
     */
    private String fileName = null;

    /**
     * Creates a new instance of the ConfigModule class.
     */
    public ConfigModule() throws ModuleRegisterException {
    }

    /**
     * Creates a new instance of the ConfigModule class.
     * @param krn the Kernel associated with this Module.
     */
    public ConfigModule(Kernel krn) throws ModuleRegisterException {
        super(krn);
    }

    /**
     */
    protected void init() {
        table = new Hashtable<String, Element>();
    }

    /**
     * Reads a configuration from the specified file.
     * @param fileName The file name that contains the configuration.
     */
    public void read(String fileName) {
        DocumentBuilder builder;
        DocumentBuilderFactory factory;
        NodeList list;
        try {
            factory = DocumentBuilderFactory.newInstance();
            factory.setValidating(true);
            builder = factory.newDocumentBuilder();
            config = builder.parse(fileName);
            /* hash all variables ... why are we using xml? */
            root = config.getDocumentElement();
            list = config.getElementsByTagName(""variable"");
            for (int i = 0; i < list.getLength(); i++) {
                Element e = (Element) list.item(i);
                Element p = (Element) e.getParentNode();
                table.put(p.getAttribute(""name"") + ""."" + e.getAttribute(""name""), e);
            }
            /* this can of course be done more efficiently */
            list = config.getElementsByTagName(""section"");
            for (int i = 0; i < list.getLength(); i++) {
                Element e = (Element) list.item(i);
                table.put(e.getAttribute(""name""), e);
            }
        } catch (SAXException e) {
            Exception x = e.getException();
            if (x == null) {
                x = e;
            }
            x.printStackTrace();
        } catch (ParserConfigurationException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Writes the configuration to the specified file.
     * @param fileName The name of the file that is to be written.
     */
    public void write(String fileName) {
        try {
            File file = new File(fileName);
            TransformerFactory factory = TransformerFactory.newInstance();
            Transformer transformer = factory.newTransformer();
            DOMSource source = new DOMSource(config);
            StreamResult result = new StreamResult(file);
            transformer.transform(source, result);
            file = null;
        } catch (TransformerConfigurationException e) {
            Throwable x = e;
            if (e.getException() != null) {
                x = e.getException();
            }
            x.printStackTrace();
        } catch (TransformerException e) {
            Throwable x = e;
            if (e.getException() != null) {
                x = e.getException();
            }
            x.printStackTrace();
        }
    }

    /**
     * Returns the value of the specified key in this configuration.
     * @param mod The section that contains the variable.
     * @param var The variable to lookup.
     * @return The value of the specified key.
     */
    public String getCVar(String sec, String var) {
        Element e = table.get(sec + ""."" + var);
        if (e != null) {
            return e.getAttribute(""value"");
        }
        return """";
    }

    /**
     * Returns the values of the specified keys in this configuration,
     * or, if no keys were specified, returns the values of all keys.
     *
     * @param sec The section that contains the variable.
     * @param var The variable to lookup.
     * @return The value of the specified key.
     */
    public String getCVars(String sec, String vars) {
        String vals = """";
        /* Only modulename specified, read all variables! */
        if (vars == null || vars.length() == 0) {
            Element e = table.get(sec);
            NodeList list = e.getElementsByTagName(""variable"");
            for (int i = 0; i < list.getLength(); i++) {
                e = (Element) list.item(i);
                vals += e.getAttribute(""name"") + "":"" + e.getAttribute(""value"") + ""\n"";
            }
        } else {
            /* Both modulename and variables specified */
            String[] vlist = vars.split("","");
            for (int i = 0; i < vlist.length; i++) {
                vals += getCVar(sec, vlist[i]) + ""\n"";
            }
        }
        return vals;
    }

    /**
     * Sets the value of the specified variable to val.
     *
     * @param sec The section that contains the variable.
     * @param var The variable to set.
     * @param val The new value of the variable.
     */
    public void setCVar(String sec, String var, String val) {
        Element e = table.get(sec + ""."" + var);
        if (e == null) {
            Element m = table.get(sec);
            if (m == null) {
                m = config.createElement(""section"");
                m.setAttribute(""name"", sec);
                root.appendChild(m);
            }
            e = config.createElement(""variable"");
            e.setAttribute(""name"", var);
            m.appendChild(e);
        }
        table.put(sec + ""."" + var, e);
        e.setAttribute(""value"", val);
    }

    /**
     * This method is invoked once for every Message in the input queue.
     *
     * @param msg The Message that is to be processed.
     */
    protected void processMessage(Message msg) {
        String[] cmd = ((String) msg.body).split("" "");
        Message r = msg.reply(null);
        System.err.println(""ConfigModule.processMessage(): "" + msg.body);
        /* process module specific messages */
        if (cmd[0].equals(""READ"")) {
            if (cmd.length == 2) {
                fileName = cmd[1];
                read(fileName);
            } else {
                r.header = ""WARNING"";
                r.body = locale.getString(""CFG_READ_WRONG_NARGS"");
                sendMessage(r);
            }
        }
        if (cmd[0].equals(""WRITE"")) {
            if (cmd.length == 2) {
                fileName = cmd[1];
            }
            write(fileName);
        }
        if (cmd[0].equals(""RELOAD"") && fileName != null) {
            read(fileName);
        }
        if (cmd[0].equals(""DUMP"")) {
            System.err.println(table);
        }
        if (cmd[0].trim().equals(""GET"")) {
            String var = getCVar(cmd[1].trim(), cmd[2].trim());
            if (var != null) {
                r.body = var;
                sendMessage(r);
            }
        } else if (cmd[0].trim().equals(""SET"")) {
            setCVar(cmd[1].trim(), cmd[2].trim(), cmd[3].trim());
        }
        /* Get multiple variables in a single request. */
        if (cmd[0].trim().equals(""GETS"")) {
            try {
                String mod = cmd[1].trim();
                String vals;
                if (cmd.length > 2) {
                    vals = getCVars(mod, cmd[2].trim());
                } else {
                    vals = getCVars(mod, null);
                }
                r.body = vals;
                sendMessage(r);
            } catch (IndexOutOfBoundsException e) {
                e.printStackTrace(System.err);
            } catch (Exception e) {
                e.printStackTrace(System.err);
            }
        }
    }
}
","// ConfigModule_1Test.java
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigModule}.
* It contains ten unit test cases for the {@link ConfigModule#getCVars(String, String)} method.
*/
class ConfigModule_1Test {","// ConfigModule_1Test.java
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigModule}.
* It contains ten unit test cases for the {@link ConfigModule#getCVars(String, String)} method.
*/
class ConfigModule_1Test {

	/**
	* Test case 1 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_1() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 2 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_2() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 3 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_3() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 4 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_4() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 5 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_5() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 6 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_6() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 7 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_7() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 8 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_8() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 9 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_9() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
	
	/**
	* Test case 10 for method {@link ConfigModule#getCVars(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVars_10() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String vars = """";
		String result = fixture.getCVars(sec, vars);
		assertEquals("""", result);
	}
}

// ConfigModule_2Test.java
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigModule}.
* It contains ten unit test cases for the {@link ConfigModule#getCVar(String, String)} method.
*/
class ConfigModule_2Test {
		
	/**
	* Test case 1 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_1() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 2 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_2() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 3 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_3() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 4 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_4() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 5 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_5() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 6 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_6() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 7 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_7() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 8 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_8() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 9 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_9() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
	
	/**
	* Test case 10 for method {@link ConfigModule#getCVar(String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testGetCVar_10() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String result = fixture.getCVar(sec, var);
		assertEquals("""", result);
	}
}

// ConfigModule_3Test.java
package module;

import java.util.Hashtable;
import java.io.IOException;
import java.io.File;
import java.util.ResourceBundle;
import java.util.Locale;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.w3c.dom.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ConfigModule}.
* It contains ten unit test cases for the {@link ConfigModule#setCVar(String, String, String)} method.
*/
class ConfigModule_3Test {
		
	/**
	* Test case 1 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_1() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		fixture.setCVar(sec, var, val);
	}
	
	/**
	* Test case 2 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_2() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		fixture.setCVar(sec, var, val);
	}
	
	/**
	* Test case 3 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_3() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		fixture.setCVar(sec, var, val);
	}
	
	/**
	* Test case 4 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_4() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		fixture.setCVar(sec, var, val);
	}
	
	/**
	* Test case 5 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_5() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		fixture.setCVar(sec, var, val);
	}
	
	/**
	* Test case 6 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_6() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		fixture.setCVar(sec, var, val);
	}
	
	/**
	* Test case 7 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_7() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		fixture.setCVar(sec, var, val);
	}
	
	/**
	* Test case 8 for method {@link ConfigModule#setCVar(String, String, String)}.
	*
	* @throws Exception
	* 	if the test fails for some reason.
	*/
	@Test
	void testSetCVar_8() throws Exception {
		ConfigModule fixture = new ConfigModule();
		String sec = """";
		String var = """";
		String val = """";
		"
4cb34309-a974-4630-8a0c-0200bd1961d0,/EvoSuiteBenchmark/27_gangup/src/main/java/module/GUIModule.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8619 tokens (4619 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GUIModule.java
/* $Id: GUIModule.java,v 1.16 2004/05/05 20:07:00 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.16 $
 *
 */
package module;

// Skin Look and Feel support - http://www.l2fprod.com/
import com.l2fprod.gui.plaf.skin.SkinLookAndFeel;
import java.awt.*;
import java.awt.event.*;
import javax.swing.JTree;
import javax.swing.JFrame;
import javax.swing.ListModel;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.Observer;
import java.util.ResourceBundle;
import java.util.Locale;
import java.io.*;
import gui.GUIFrame;
import state.*;

@cvs(file = ""$RCSfile: GUIModule.java,v $"", revision = ""$Revision: 1.16 $"", date = ""$Date: 2004/05/05 20:07:00 $"", author = ""$Author: emill $"", tag = ""$Name:  $"", build = """")
@mod(name = ""GUIModule"", topics = ""FROM_NETWORK ERROR WARNING FATAL CONNECTED DROPPED"", cmds = ""DUMP"", desc = ""This is the client GUI module for the game."")
public class /**
 * This is an example of a simple module. It's purpose is to demonstrate
 * the basic structure of a module.
 */
GUIModule extends AbstractModule {

    /**
     * The JFrame in which the GUI is drawn.
     */
    private GUIFrame frame;

    private GameState state;

    private String host;

    private String port;

    private String[] picturepaths;

    /**
     * Get a reference to the ActionFactory.
     */
    private ActionFactory af = ActionFactory.getInstance();

    public final String GENERAL_MESSAGE = locale.getString(""_GUI_CHAT_GENERALTAB"");

    public final String GROUP_MESSAGE = locale.getString(""_GUI_CHAT_GANGTAB"");

    /**
     * Creates a new instance of this module. This constructor is usually
     * called from the kernel when it wishes to load a module dynamically.
     *
     * @throws ModuleRegisterException If you have a broken Java interpreter.
     */
    public GUIModule() throws ModuleRegisterException {
    }

    /**
     * Initialization method for modules. Using init() is recommended
     * instead of overloading the constructor.
     */
    protected void init() {
        try {
            host = (String) request(""CONFIG"", ""GET ClientNetwork host"").body;
            port = (String) request(""CONFIG"", ""GET ClientNetwork port"").body;
        } catch (MessageTimeoutException e) {
            sendMessage(new Message(""WARNING"", locale.getString(""_CLIENT_CON_CFG_FAIL"")));
            e.printStackTrace(System.err);
        }
        try {
            String s = (String) request(""CONFIG"", ""GET GUI skinlf_enable"").body;
            if (s.equals(""1"")) {
                s = (String) request(""CONFIG"", ""GET GUI skinlf_themepack"").body;
                SkinLookAndFeel.setSkin(SkinLookAndFeel.loadThemePack(s));
                UIManager.setLookAndFeel(new SkinLookAndFeel());
            }
        } catch (NoClassDefFoundError e) {
            sendMessage(new Message(""WARNING"", locale.getString(""_GUI_WARNING_SKINLF_NOT_FOUND"")));
        } catch (MessageTimeoutException e) {
            sendMessage(new Message(""WARNING"", locale.getString(""_GUI_WARNING_CFG_TIMEOUT"")));
        } catch (UnsupportedLookAndFeelException e) {
            sendMessage(new Message(""WARNING"", locale.getString(""_GUI_WARNING_UNSUPPORTED_LF"")));
        } catch (Exception e) {
            e.printStackTrace();
            System.err.print(e.toString());
            sendMessage(new Message(""WARNING"", locale.getString(""_GUI_WARNING_SKINLF_EXCEPTION"") + e.toString()));
        }
        try {
            String datafile = (String) request(""CONFIG"", ""GET PlayerData playerdatafile"").body;
            BufferedReader br = new BufferedReader(new FileReader(datafile));
            int c = Integer.parseInt(br.readLine());
            for (int i = 0; i < c; i++) {
                // throw away player names, we dont care
                br.readLine();
            }
            c = Integer.parseInt(br.readLine());
            picturepaths = new String[c];
            for (int i = 0; i < c; i++) {
                // read picture paths
                picturepaths[i] = br.readLine();
                System.err.println(picturepaths[i]);
            }
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
        frame = new GUIFrame(this);
        state = new GameState();
        frame.setGameState(state);
    }

    /**
     * Method to run recurrently in the loop of run(). This method
     * should never be blocking, lest the module will not be able to
     * process any messages.
     */
    protected void step() {
    }

    /**
     * Exit method for modules. This method is invoked after a call to
     * the @see exit() method. Modules should overload this method with
     * code to do a proper exit.
     */
    protected void free() {
    }

    /**
     * This method is invoked once for every Message in the input queue.
     * Normally this is where module specific message handling is performed.
     *
     * @param msg The Message that is to be processed.
     */
    protected void processMessage(Message msg) {
        System.err.println(msg);
        if (msg.header.equals(""WARNING"")) {
            frame.displayWarning((String) msg.body);
        } else if (msg.header.equals(""ERROR"")) {
            frame.displayError((String) msg.body);
        } else if (msg.header.equals(""FATAL"")) {
            frame.displayFatal((String) msg.body);
        } else if (msg.header.equals(""FROM_NETWORK"")) {
            decodeNetworkMessage((Packable) msg.body);
        } else if (msg.header.equals(""CONNECTED"")) {
            frame.addChatMessage(GENERAL_MESSAGE, locale.getString(""_CONNECTED_MESSAGE""));
        } else if (msg.header.equals(""DROPPED"")) {
            frame.addChatMessage(GENERAL_MESSAGE, locale.getString(""_DROPPED_MESSAGE""));
        }
        /* process module specific messages */
        if (msg.body.equals(""DUMP"")) {
            System.err.println(modinfo.revision);
        }
    }

    /**
     * Decodes a network message and tries to apply its meaning to the
     * GUI.
     *
     * @param p The packable from the network.
     */
    protected void decodeNetworkMessage(Packable p) {
        try {
            if (p.type() == Packable.GAME_STATE) {
                state = (GameState) p;
                System.err.println(""state received"");
                try {
                    int id = (Integer) request(""CLIENT"", ""ID"").body;
                    state.setMe(state.player(id));
                } catch (MessageTimeoutException e) {
                    sendMessage(new Message(""WARNING"", locale.getString(""_ID_NOT_AVAILABLE"")));
                }
                frame.setGameState(state);
                // to receive players pre-game
            } else if (p.type() == Packable.PLAYER) {
                if (state == null)
                    return;
                Player s = (Player) p;
                // means this player disconnected, ugly way
                if (s.getName() == ""DROPPED"") {
                } else {
                    state.addPlayer(s);
                    frame.addChatMessage(GENERAL_MESSAGE, String.format(locale.getString(""_PLAYER_JOINED_MESSAGE""), s.getName()));
                }
            } else if (p.type() == Packable.GAME_EVENT) {
                if (state == null)
                    return;
                GameEvent g = (GameEvent) p;
                switch(g.getEventType()) {
                    case GameEvent.WARMUP:
                        state.setGameState(GameState.STATE_WARMUP);
                        state.setGamestart(System.currentTimeMillis());
                        frame.addChatMessage(GENERAL_MESSAGE, locale.getString(""_WARMUP_MESSAGE""));
                        break;
                    case GameEvent.START:
                        state.setGameState(GameState.STATE_PLAYING);
                        state.setGamestart(System.currentTimeMillis());
                        frame.addChatMessage(GENERAL_MESSAGE, locale.getString(""_GAMESTART_MESSAGE""));
                        break;
                    case GameEvent.JOIN:
                        state.join(state.player(g.getTarget()), state.player(g.getActor()));
                        frame.addChatMessage(GENERAL_MESSAGE, String.format(locale.getString(""_JOIN_MESSAGE""), state.player(g.getActor()), state.player(g.getTarget())));
                        break;
                    case GameEvent.PART:
                        state.part(state.player(g.getTarget()), state.player(g.getActor()));
                        frame.addChatMessage(GENERAL_MESSAGE, String.format(locale.getString(""_PART_MESSAGE""), state.player(g.getActor()), state.player(g.getTarget())));
                        break;
                    case GameEvent.KICK:
                        state.part(state.player(g.getActor()), state.player(g.getTarget()));
                        frame.addChatMessage(GENERAL_MESSAGE, String.format(locale.getString(""_KICK_MESSAGE""), state.player(g.getTarget()), state.player(g.getActor())));
                        break;
                    case GameEvent.FIGHT:
                        LinkedList<Party> losers = state.player(g.getTarget()).getSubparty();
                        for (Party loser : losers) {
                            state.setDead((Player) loser);
                        }
                        frame.addChatMessage(GENERAL_MESSAGE, String.format(locale.getString(""_BATTLE_MESSAGE""), state.player(g.getActor()), state.player(g.getTarget())));
                        frame.startFight(state.player(g.getActor()), state.player(g.getTarget()));
                        break;
                    case GameEvent.INVITE:
                        // redudant check if gamemodule works correctly
                        if (state.player(g.getTarget()) == state.getMe()) {
                            frame.displayInvite(state.player(g.getActor()));
                        }
                        break;
                    case GameEvent.APPLY:
                        // redudant check if gamemodule works correctly
                        if (state.player(g.getTarget()) == state.getMe()) {
                            frame.displayApply(state.player(g.getActor()));
                        }
                        break;
                    //case GameEvent.MOVE:
                    //state.move(state.player(g.getActor()),g.getTarget());
                    //break;
                    case GameEvent.DROP:
                        frame.addChatMessage(GENERAL_MESSAGE, String.format(locale.getString(""_PLAYER_LEFT_MESSAGE""), state.player(g.getActor()).getName()));
                        state.removePlayer(state.player(g.getActor()));
                        break;
                    case GameEvent.END:
                        state.setGamestart(0);
                        state.setGameState(GameState.STATE_ENDED);
                        frame.addChatMessage(GENERAL_MESSAGE, locale.getString(""_GAMEEND_MESSAGE""));
                        break;
                }
            } else if (p.type() == Packable.TEXT_MESSAGE) {
                if (state == null)
                    return;
                TextMessage t = (TextMessage) p;
                String text;
                if (t.getActor() == -1) {
                    text = ""<"" + locale.getString(""_ADMIN_NAME"") + ""> "" + t.getText();
                } else {
                    text = ""<"" + state.player(t.getActor()) + ""> "" + t.getText();
                }
                switch(t.getMessageType()) {
                    case TextMessage.GENERAL:
                        frame.addChatMessage(GENERAL_MESSAGE, text);
                        break;
                    case TextMessage.GROUP:
                        frame.addChatMessage(GROUP_MESSAGE, text);
                        break;
                    case TextMessage.PRIVATE:
                        if (state.player(t.getActor()) == state.getMe()) {
                            frame.addChatMessage(state.player(t.getTarget()), text);
                        } else {
                            frame.addChatMessage(state.player(t.getActor()), text);
                        }
                        break;
                }
            }
        } catch (Exception e) {
            e.printStackTrace(System.err);
        }
    }

    public void sendConnect() {
        sendMessage(new Message(""CONNECT"", host + "" "" + port));
    }

    public void sendDisconnect() {
        sendMessage(new Message(""DISCONNECT"", null));
    }

    public void sendMoveAction(int direction) {
        Action a = af.createAction(Action.ACTION_MOVE, -1, direction);
        sendMessage(new Message(""NETWORK"", a));
    }

    /**
     * Sends
     * @param x
     * @param y
     * @param z
     */
    public void sendMoveAction(byte x, byte y, byte z) {
        sendMessage(new Message(""NETWORK"", af.createMoveAction(-1, x, y, z)));
    }

    public void sendAction(String action, Object target) {
        if (state == null || state.getGameState() == GameState.STATE_WAITING)
            return;
        Player targ = (Player) target;
        if (action.equals(""join"")) {
            sendMessage(new Message(""NETWORK"", af.createAction(Action.ACTION_JOIN_APPLY, -1, targ.getId())));
        } else if (action.equals(""part"")) {
            sendMessage(new Message(""NETWORK"", new Action(Action.ACTION_PART, -1, -1)));
        } else if (action.equals(""fight"")) {
            sendMessage(new Message(""NETWORK"", new Action(Action.ACTION_ATTACK, -1, targ.getId())));
        } else if (action.equals(""invite"")) {
            sendMessage(new Message(""NETWORK"", new Action(Action.ACTION_JOIN_INVITE, -1, targ.getId())));
        } else if (action.equals(""join_agree"")) {
            sendMessage(new Message(""NETWORK"", new Action(Action.ACTION_JOIN_AGREE, -1, targ.getId())));
        } else if (action.equals(""join_allow"")) {
            sendMessage(new Message(""NETWORK"", new Action(Action.ACTION_JOIN_ALLOW, -1, targ.getId())));
        } else if (action.equals(""kick"")) {
            sendMessage(new Message(""NETWORK"", new Action(Action.ACTION_KICK, -1, targ.getId())));
        }
    }

    /**
     * Returns the picture path correspoding to a picture id.
     */
    public String getPicturePath(int id) {
        return picturepaths[id];
    }

    /**
     * Sends a message to the network module.
     *
     * @param message The message to be sent.
     * @param target The target for this textmessage.
     */
    public void sendTextMessage(String message, Object target) {
        if (target == GENERAL_MESSAGE) {
            sendMessage(new Message(""NETWORK"", new TextMessage(0, -1, TextMessage.GENERAL, message)));
        } else if (target == GROUP_MESSAGE) {
            sendMessage(new Message(""NETWORK"", new TextMessage(0, -1, TextMessage.GROUP, message)));
        } else {
            Player targ = (Player) target;
            sendMessage(new Message(""NETWORK"", new TextMessage(0, targ.getId(), TextMessage.PRIVATE, message)));
        }
    }
}
","// GUIModuleTest.java
package module;

// Skin Look and Feel support - http://www.l2fprod.com/
import com.l2fprod.gui.plaf.skin.SkinLookAndFeel;
import java.awt.*;
import java.awt.event.*;
import javax.swing.JTree;
import javax.swing.JFrame;
import javax.swing.ListModel;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.Observer;
import java.util.ResourceBundle;
import java.util.Locale;
import java.io.*;
import gui.GUIFrame;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GUIModule}.
* It contains ten unit test cases for the {@link GUIModule#getPicturePath(int)} method.
*/
class GUIModuleTest {","// GUIModuleTest.java
package module;

// Skin Look and Feel support - http://www.l2fprod.com/
import com.l2fprod.gui.plaf.skin.SkinLookAndFeel;
import java.awt.*;
import java.awt.event.*;
import javax.swing.JTree;
import javax.swing.JFrame;
import javax.swing.ListModel;
import javax.swing.Icon;
import javax.swing.ImageIcon;
import javax.swing.UIManager;
import javax.swing.UnsupportedLookAndFeelException;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.util.Vector;
import java.util.LinkedList;
import java.util.Observer;
import java.util.ResourceBundle;
import java.util.Locale;
import java.io.*;
import gui.GUIFrame;
import state.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GUIModule}.
* It contains ten unit test cases for the {@link GUIModule#getPicturePath(int)} method.
*/
class GUIModuleTest {
"
6454a1ec-c7c1-4cc6-8651-4f70d2099aaa,/EvoSuiteBenchmark/27_gangup/src/main/java/module/Kernel_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8126 tokens (4126 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Kernel.java
/* $Id: Kernel.java,v 1.7 2004/05/01 23:20:45 bja Exp $ 
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 *
 */
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;

@cvs(file = ""$RCSfile: Kernel.java,v $"", revision = ""$Revision: 1.7 $"", date = ""$Date: 2004/05/01 23:20:45 $"", author = ""$Author: bja $"", tag = ""$Name:  $"", build = """")
@mod(name = ""Kernel"", topics = ""KERNEL"", cmds = ""DUMP LOAD UNLOAD LIST EXISTS"", desc = ""This class provides a message delivery system. It's primary task is "" + ""to manage loaded modules. It has methods for loading and unloading "" + ""modules, subscribing and unsubscribing modules to specified topics, "" + ""and for creating and destroying sessions."")
public class /**
 * This class provides a message delivery system. It's primary task is to
 * manage loaded modules. It has methods for loading and unloading modules,
 * subscribing and unsubscribing modules to specified topics, and for creating
 * and destroying sessions.
 */
Kernel implements Module {

    /**
     * Topic to subcribers lookup table.
     */
    private Hashtable<String, Vector<Module>> subscribers;

    /**
     * Module name lookup table.
     */
    private Hashtable<String, Module> modules;

    /**
     * Message queue.
     */
    private List<Message> messages;

    /**
     * The thread associated with this module.
     */
    private Thread thread;

    /**
     * Contains module specific information.
     */
    private ModuleInfo modinfo = new ModuleInfo(this);

    /**
     * Specifies whether the Kernel should stop running.
     */
    private boolean done = false;

    /**
     * Create a new instance of the Kernel module. There has to be at least
     * one kernel up and running in order to have messages processed.
     */
    public Kernel() {
        /* Create the lookup table of module subscriptions */
        subscribers = new Hashtable<String, Vector<Module>>();
        /* Create the table of registered modules */
        modules = new Hashtable<String, Module>();
        /* Initialize message queue */
        messages = Collections.synchronizedList(new LinkedList<Message>());
        /* fixme - for now! */
        start();
    }

    /**
     * Start executing the run method in a separate thread. This method
     * is invoked automatically be the Kernel when the module is loaded
     * and should not be invoked manually.
     */
    public void start() {
        thread = new Thread(this, modinfo.name);
        thread.start();
    }

    /**
     * This is the kernels main thread routine. Its sole purpose is to
     * regularly process the messagequeue.
     */
    public void run() {
        while (!done) {
            try {
                processMessages();
                thread.sleep(10);
            } catch (Exception e) {
                System.err.println(e);
            }
        }
    }

    /**
     * Load and register the specified module. This method provides
     * a mechanism for dynamically loading modules to the runtime.
     *
     * @param name The name of the module that is to be loaded.
     * @throws ModuleLoadException If an exception occurred.
     */
    public void loadModule(String name) throws ModuleLoadException {
        try {
            Class c = getClass().forName(name);
            Module m = (Module) c.newInstance();
            m.register(this);
            m.start();
        } catch (Exception e) {
            throw new ModuleLoadException(e);
        }
    }

    /**
     * Unload and unregister the specified module. Modules that are not
     * needed any more may be unloaded from the kernel to save resources.
     *
     * @param mod The module that is to be unloaded.
     *
     * @throws ModuleRegisterException If an register exception occurred.
     * @throws ModuleUnloadException If an exception occurred.
     */
    public void unloadModule(Module mod) throws ModuleRegisterException {
        unregister(mod);
    }

    /**
     * Unload and unregister the specified module. Modules that are not
     * needed any more may be unloaded from the kernel to save resources.
     *
     * @param name The name of the module that is to be unloaded.
     *
     * @throws ModuleUnloadException If an exception occurred.
     */
    public void unloadModule(String name) throws ModuleUnloadException {
        try {
            Module m = modules.get(name);
            unloadModule(m);
            m.getThread().join(100);
            m = null;
        } catch (Exception e) {
            throw new ModuleUnloadException(""mod="" + name, e);
        }
    }

    /**
     * Register the specified module with this kernel. A module is required
     * to register with the kernel in order to subscribe to messages and
     * in turn communicate with other modules.
     *
     * @param mod The module that is to be registered.
     * @throws ModuleRegisterException if the module has already registered.
     */
    public void register(Module m) throws ModuleRegisterException {
        Message msg = null;
        System.err.println(""KERNEL REGISTERED: "" + m);
        try {
            if (modules.containsKey(m.info().name)) {
                throw new ModuleRegisterException(m, ""A module with that name has already been registered: "" + ""name="" + m.info().name);
            }
            // Add the module to the collection of registered modules.
            modules.put(m.info().name, m);
            // Let the module know it has been registered.
            //sendMessage(m, new Message(""KERNEL"",""REGISTERED""));
            msg = MessageFactory.createMessage(""KERNEL"", m.getClass().getName(), ""REGISTERED"");
            // MessageFactory.getInstance().sendRegisterMessage(this, m);
            sendMessage(m, msg);
        } catch (ModuleRegisterException e) {
            throw e;
        } catch (Exception e) {
            throw new ModuleRegisterException(m, e);
        } finally {
            if (msg != null)
                msg.unref();
        }
    }

    /**
     * Unregister the specified module. An unused module should unregister
     * with the kernel so that all references to that module will be freed.
     *
     * @param mod The module that is to be unregistered.
     * @throws ModuleRegisterException if the module is not registered.
     */
    public void unregister(Module m) throws ModuleRegisterException {
        try {
            if (!modules.containsKey(m.info().name)) {
                throw new ModuleRegisterException(m, ""Not registered!"");
            }
            // maybe this should be synchronized
            unsubscribe(m);
            modules.remove(m.info().name);
            //MessageFactory.getInstance().sendUnregisterMessage(this, m);
            sendMessage(m, new Message(""KERNEL"", ""UNREGISTERED""));
        } catch (ModuleRegisterException e) {
            throw e;
        } catch (Exception e) {
            throw new ModuleRegisterException(m, e);
        }
    }

    /**
     * Adds module as a subscriber of all messages with the
     * specified topic.
     *
     * @param mod The module that is to subscribe to topic.
     * @param topic The topic that should be subscribed to.
     */
    public void subscribe(Module mod, String topics) throws ModuleSubscriptionException {
        try {
            String[] top = topics.split(""(,|\\s+)"");
            for (int i = 0; i < top.length; i++) {
                if (subscribers.containsKey(top[i])) {
                    subscribers.get(top[i]).add(mod);
                } else {
                    Vector<Module> nv = new Vector<Module>();
                    nv.add(mod);
                    subscribers.put(top[i], nv);
                }
            }
        } catch (Exception e) {
            throw new ModuleSubscriptionException(mod, ""topics="" + topics, e);
        }
    }

    /**
     * Unsubscribes the specified module from every topic it is
     * subscribing to. Modules will still receive messages from
     * the kernel though.
     *
     * @param mod The module that is to be unsubscribed.
     */
    public void unsubscribe(Module mod) {
        // fixme - this is really ugly, O(t+ts) may easily be O(t)!
        for (Vector v : subscribers.values()) {
            v.remove(mod);
        }
    }

    /**
     * Unsubscribes the specified module from the given topic. Modules may
     * call this method to instruct the kernel that they do not whish to
     * receive messages in the specified topic.
     *
     * @param mod The module that is to be unsubscribed from topic.
     * @param topic The topic from which we wish to unsubscribe.
     *
     * @throws ModuleSubscriptionException If either the topic or module are
     * null.
     */
    public void unsubscribe(Module mod, String topic) throws ModuleSubscriptionException {
        try {
            if (subscribers.containsKey(topic)) {
                Vector t = subscribers.get(topic);
                t.remove(mod);
                if (t.size() == 0) {
                    subscribers.remove(topic);
                }
            }
        } catch (Exception e) {
            throw new ModuleSubscriptionException(e);
        }
    }

    /**
     * Requests the specified query from the specified topic. Observe that
     * if there are more than one module answering a specific request, only
     * the first one will be returned.
     *
     * @deprecated Requests are currently not used by the Kernel.
     *
     * @param mod The module that should receive the request.
     * @param key A string containing the actual request.
     */
    public Object request(String mod, String key) throws MessageTimeoutException {
        throw new MessageTimeoutException(""Requests are not implemented"");
    }

    /**
     * Requests the specified query from the specified topic. Observe that
     * if there are more than one module answering a specific request, only
     * the first one will be returned.
     *
     * @deprecated Requests are currently not used by the Kernel.
     *
     * @param msg The message containing the request.
     *
     * @throws MessageTimeoutException
     * If the request times out before we receive any replies.
     */
    public Message request(Message msg) throws MessageTimeoutException {
        throw new MessageTimeoutException(""Sorry, requests are not implemented in Kernel"");
    }

    /**
     */
    public ModuleInfo info() {
        return modinfo;
    }

    /**
     * Delivers the specified message to the kernel.
     * @param msg The message to be delivered.
     * @throws MessageDeliveryException if message could not be delivered.
     */
    public void sendMessage(Message msg) throws MessageDeliveryException {
        try {
            sendMessage(modules.get(msg.recipient), msg);
        } catch (Exception e) {
            throw new MessageDeliveryException(e);
        }
    }

    /**
     * Delivers the specified message to the given module.
     *
     * @param mod the module that should receive the message.
     * @param msg the message that should be sent.
     * @throws MessageDeliveryException if message could not be delivered.
     */
    private void sendMessage(Module mod, Message msg) throws MessageDeliveryException {
        try {
            mod.receiveMessage(msg);
        } catch (Exception e) {
            throw new MessageDeliveryException(mod, msg, e);
        }
    }

    /**
     * Receives a message from another module. This function is public
     * and should be called from the other module.
     *
     * @param msg The message to receive.
     */
    public void receiveMessage(Message msg) throws MessageDeliveryException {
        try {
            msg.ref();
            messages.add(msg);
            //msg.setState(Message.SENT);
        } catch (Exception e) {
            msg.unref();
            throw new MessageDeliveryException(this, msg, e);
        }
    }

    /**
     * Handles what should done with messages sent to this module.
     *
     * @param msg The message to be processed.
     * @throws Exception if the processing failed for this message.
     */
    protected void processMessage(Message msg) throws Exception {
        String[] cmd = null;
        cmd = ((String) msg.body).split("" "");
        if (cmd.length == 0) {
            return;
        }
        if (cmd[0].equals(""LOAD"")) {
            loadModule(cmd[1]);
            return;
        }
        if (cmd[0].equals(""UNLOAD"")) {
            unloadModule(cmd[1]);
            return;
        }
        if (cmd[0].equals(""DUMP"")) {
            sendMessage(modules.get(msg.sender), msg.reply(modules.toString()));
            sendMessage(modules.get(msg.sender), msg.reply(subscribers.toString()));
            return;
        }
    }

    /**
     * Process messages from the message queue.
     *
     * @throws MessageProcessingException if processing failed for any
     * message in the message queue.
     */
    private void processMessages() throws MessageProcessingException {
        Message msg = null;
        Module dst = null;
        try {
            while (!messages.isEmpty()) {
                msg = messages.remove(0);
                /* intercept messages destined for the kernel */
                if (msg.header.equals(""KERNEL"")) {
                    processMessage(msg);
                }
                /* try sending message directly to recipient, if not null,
		   otherwise send to everyone that is subscribing to the
		   specified topic. */
                dst = modules.get(msg.getRecipient());
                if (dst != null) {
                    sendMessage(dst, msg);
                } else if (subscribers.containsKey(msg.getHeader())) {
                    sendMessageNotify(subscribers.get(msg.getHeader()), msg);
                }
                /* Notify modules subscribing on all Message classes. */
                if (subscribers.containsKey(""*"")) {
                    sendMessageNotify(subscribers.get(""*""), msg);
                }
                msg.setDelivered(true);
                msg.unref();
            }
        } catch (Exception e) {
            if (msg != null) {
                msg.unref();
            }
            throw new MessageProcessingException(msg, e);
        }
    }

    /**
     * Sends the specified message to the given collection of modules.
     * The modules are notified of the delivery (i.e. the thread is notified.)
     *
     * @param mods the modules that should receive the message.
     * @param msg the message that should be delivered.
     * @throws MessageDeliveryException if the message could not be delivered.
     */
    public void sendMessageNotify(Collection<Module> mods, Message msg) throws MessageDeliveryException {
        for (Module mod : mods) {
            sendMessage(mod, msg);
            synchronized (mod) {
                mod.notify();
            }
        }
    }

    /**
     * Returns the Kernel associated with this Module.
     * @return the Kernel associated with this Module.
     */
    public Kernel getKernel() {
        return null;
    }

    /**
     * Returns the thread associated with this module.
     * @return The thread associated with this module.
     */
    public Thread getThread() {
        return thread;
    }
}
","// Kernel_0Test.java
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Kernel}.
* It contains ten unit test cases for the {@link Kernel#request(String, String)} method.
*/
class Kernel_0Test {","// Kernel_0Test.java
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Kernel}.
* It contains ten unit test cases for the {@link Kernel#request(String, String)} method.
*/
class Kernel_0Test {
"
2ca55bc0-5fde-45e7-a8bc-9b47c6585392,/EvoSuiteBenchmark/27_gangup/src/main/java/module/Kernel_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8124 tokens (4124 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Kernel.java
/* $Id: Kernel.java,v 1.7 2004/05/01 23:20:45 bja Exp $ 
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 *
 */
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;

@cvs(file = ""$RCSfile: Kernel.java,v $"", revision = ""$Revision: 1.7 $"", date = ""$Date: 2004/05/01 23:20:45 $"", author = ""$Author: bja $"", tag = ""$Name:  $"", build = """")
@mod(name = ""Kernel"", topics = ""KERNEL"", cmds = ""DUMP LOAD UNLOAD LIST EXISTS"", desc = ""This class provides a message delivery system. It's primary task is "" + ""to manage loaded modules. It has methods for loading and unloading "" + ""modules, subscribing and unsubscribing modules to specified topics, "" + ""and for creating and destroying sessions."")
public class /**
 * This class provides a message delivery system. It's primary task is to
 * manage loaded modules. It has methods for loading and unloading modules,
 * subscribing and unsubscribing modules to specified topics, and for creating
 * and destroying sessions.
 */
Kernel implements Module {

    /**
     * Topic to subcribers lookup table.
     */
    private Hashtable<String, Vector<Module>> subscribers;

    /**
     * Module name lookup table.
     */
    private Hashtable<String, Module> modules;

    /**
     * Message queue.
     */
    private List<Message> messages;

    /**
     * The thread associated with this module.
     */
    private Thread thread;

    /**
     * Contains module specific information.
     */
    private ModuleInfo modinfo = new ModuleInfo(this);

    /**
     * Specifies whether the Kernel should stop running.
     */
    private boolean done = false;

    /**
     * Create a new instance of the Kernel module. There has to be at least
     * one kernel up and running in order to have messages processed.
     */
    public Kernel() {
        /* Create the lookup table of module subscriptions */
        subscribers = new Hashtable<String, Vector<Module>>();
        /* Create the table of registered modules */
        modules = new Hashtable<String, Module>();
        /* Initialize message queue */
        messages = Collections.synchronizedList(new LinkedList<Message>());
        /* fixme - for now! */
        start();
    }

    /**
     * Start executing the run method in a separate thread. This method
     * is invoked automatically be the Kernel when the module is loaded
     * and should not be invoked manually.
     */
    public void start() {
        thread = new Thread(this, modinfo.name);
        thread.start();
    }

    /**
     * This is the kernels main thread routine. Its sole purpose is to
     * regularly process the messagequeue.
     */
    public void run() {
        while (!done) {
            try {
                processMessages();
                thread.sleep(10);
            } catch (Exception e) {
                System.err.println(e);
            }
        }
    }

    /**
     * Load and register the specified module. This method provides
     * a mechanism for dynamically loading modules to the runtime.
     *
     * @param name The name of the module that is to be loaded.
     * @throws ModuleLoadException If an exception occurred.
     */
    public void loadModule(String name) throws ModuleLoadException {
        try {
            Class c = getClass().forName(name);
            Module m = (Module) c.newInstance();
            m.register(this);
            m.start();
        } catch (Exception e) {
            throw new ModuleLoadException(e);
        }
    }

    /**
     * Unload and unregister the specified module. Modules that are not
     * needed any more may be unloaded from the kernel to save resources.
     *
     * @param mod The module that is to be unloaded.
     *
     * @throws ModuleRegisterException If an register exception occurred.
     * @throws ModuleUnloadException If an exception occurred.
     */
    public void unloadModule(Module mod) throws ModuleRegisterException {
        unregister(mod);
    }

    /**
     * Unload and unregister the specified module. Modules that are not
     * needed any more may be unloaded from the kernel to save resources.
     *
     * @param name The name of the module that is to be unloaded.
     *
     * @throws ModuleUnloadException If an exception occurred.
     */
    public void unloadModule(String name) throws ModuleUnloadException {
        try {
            Module m = modules.get(name);
            unloadModule(m);
            m.getThread().join(100);
            m = null;
        } catch (Exception e) {
            throw new ModuleUnloadException(""mod="" + name, e);
        }
    }

    /**
     * Register the specified module with this kernel. A module is required
     * to register with the kernel in order to subscribe to messages and
     * in turn communicate with other modules.
     *
     * @param mod The module that is to be registered.
     * @throws ModuleRegisterException if the module has already registered.
     */
    public void register(Module m) throws ModuleRegisterException {
        Message msg = null;
        System.err.println(""KERNEL REGISTERED: "" + m);
        try {
            if (modules.containsKey(m.info().name)) {
                throw new ModuleRegisterException(m, ""A module with that name has already been registered: "" + ""name="" + m.info().name);
            }
            // Add the module to the collection of registered modules.
            modules.put(m.info().name, m);
            // Let the module know it has been registered.
            //sendMessage(m, new Message(""KERNEL"",""REGISTERED""));
            msg = MessageFactory.createMessage(""KERNEL"", m.getClass().getName(), ""REGISTERED"");
            // MessageFactory.getInstance().sendRegisterMessage(this, m);
            sendMessage(m, msg);
        } catch (ModuleRegisterException e) {
            throw e;
        } catch (Exception e) {
            throw new ModuleRegisterException(m, e);
        } finally {
            if (msg != null)
                msg.unref();
        }
    }

    /**
     * Unregister the specified module. An unused module should unregister
     * with the kernel so that all references to that module will be freed.
     *
     * @param mod The module that is to be unregistered.
     * @throws ModuleRegisterException if the module is not registered.
     */
    public void unregister(Module m) throws ModuleRegisterException {
        try {
            if (!modules.containsKey(m.info().name)) {
                throw new ModuleRegisterException(m, ""Not registered!"");
            }
            // maybe this should be synchronized
            unsubscribe(m);
            modules.remove(m.info().name);
            //MessageFactory.getInstance().sendUnregisterMessage(this, m);
            sendMessage(m, new Message(""KERNEL"", ""UNREGISTERED""));
        } catch (ModuleRegisterException e) {
            throw e;
        } catch (Exception e) {
            throw new ModuleRegisterException(m, e);
        }
    }

    /**
     * Adds module as a subscriber of all messages with the
     * specified topic.
     *
     * @param mod The module that is to subscribe to topic.
     * @param topic The topic that should be subscribed to.
     */
    public void subscribe(Module mod, String topics) throws ModuleSubscriptionException {
        try {
            String[] top = topics.split(""(,|\\s+)"");
            for (int i = 0; i < top.length; i++) {
                if (subscribers.containsKey(top[i])) {
                    subscribers.get(top[i]).add(mod);
                } else {
                    Vector<Module> nv = new Vector<Module>();
                    nv.add(mod);
                    subscribers.put(top[i], nv);
                }
            }
        } catch (Exception e) {
            throw new ModuleSubscriptionException(mod, ""topics="" + topics, e);
        }
    }

    /**
     * Unsubscribes the specified module from every topic it is
     * subscribing to. Modules will still receive messages from
     * the kernel though.
     *
     * @param mod The module that is to be unsubscribed.
     */
    public void unsubscribe(Module mod) {
        // fixme - this is really ugly, O(t+ts) may easily be O(t)!
        for (Vector v : subscribers.values()) {
            v.remove(mod);
        }
    }

    /**
     * Unsubscribes the specified module from the given topic. Modules may
     * call this method to instruct the kernel that they do not whish to
     * receive messages in the specified topic.
     *
     * @param mod The module that is to be unsubscribed from topic.
     * @param topic The topic from which we wish to unsubscribe.
     *
     * @throws ModuleSubscriptionException If either the topic or module are
     * null.
     */
    public void unsubscribe(Module mod, String topic) throws ModuleSubscriptionException {
        try {
            if (subscribers.containsKey(topic)) {
                Vector t = subscribers.get(topic);
                t.remove(mod);
                if (t.size() == 0) {
                    subscribers.remove(topic);
                }
            }
        } catch (Exception e) {
            throw new ModuleSubscriptionException(e);
        }
    }

    /**
     * Requests the specified query from the specified topic. Observe that
     * if there are more than one module answering a specific request, only
     * the first one will be returned.
     *
     * @deprecated Requests are currently not used by the Kernel.
     *
     * @param mod The module that should receive the request.
     * @param key A string containing the actual request.
     */
    public Object request(String mod, String key) throws MessageTimeoutException {
        throw new MessageTimeoutException(""Requests are not implemented"");
    }

    /**
     * Requests the specified query from the specified topic. Observe that
     * if there are more than one module answering a specific request, only
     * the first one will be returned.
     *
     * @deprecated Requests are currently not used by the Kernel.
     *
     * @param msg The message containing the request.
     *
     * @throws MessageTimeoutException
     * If the request times out before we receive any replies.
     */
    public Message request(Message msg) throws MessageTimeoutException {
        throw new MessageTimeoutException(""Sorry, requests are not implemented in Kernel"");
    }

    /**
     */
    public ModuleInfo info() {
        return modinfo;
    }

    /**
     * Delivers the specified message to the kernel.
     * @param msg The message to be delivered.
     * @throws MessageDeliveryException if message could not be delivered.
     */
    public void sendMessage(Message msg) throws MessageDeliveryException {
        try {
            sendMessage(modules.get(msg.recipient), msg);
        } catch (Exception e) {
            throw new MessageDeliveryException(e);
        }
    }

    /**
     * Delivers the specified message to the given module.
     *
     * @param mod the module that should receive the message.
     * @param msg the message that should be sent.
     * @throws MessageDeliveryException if message could not be delivered.
     */
    private void sendMessage(Module mod, Message msg) throws MessageDeliveryException {
        try {
            mod.receiveMessage(msg);
        } catch (Exception e) {
            throw new MessageDeliveryException(mod, msg, e);
        }
    }

    /**
     * Receives a message from another module. This function is public
     * and should be called from the other module.
     *
     * @param msg The message to receive.
     */
    public void receiveMessage(Message msg) throws MessageDeliveryException {
        try {
            msg.ref();
            messages.add(msg);
            //msg.setState(Message.SENT);
        } catch (Exception e) {
            msg.unref();
            throw new MessageDeliveryException(this, msg, e);
        }
    }

    /**
     * Handles what should done with messages sent to this module.
     *
     * @param msg The message to be processed.
     * @throws Exception if the processing failed for this message.
     */
    protected void processMessage(Message msg) throws Exception {
        String[] cmd = null;
        cmd = ((String) msg.body).split("" "");
        if (cmd.length == 0) {
            return;
        }
        if (cmd[0].equals(""LOAD"")) {
            loadModule(cmd[1]);
            return;
        }
        if (cmd[0].equals(""UNLOAD"")) {
            unloadModule(cmd[1]);
            return;
        }
        if (cmd[0].equals(""DUMP"")) {
            sendMessage(modules.get(msg.sender), msg.reply(modules.toString()));
            sendMessage(modules.get(msg.sender), msg.reply(subscribers.toString()));
            return;
        }
    }

    /**
     * Process messages from the message queue.
     *
     * @throws MessageProcessingException if processing failed for any
     * message in the message queue.
     */
    private void processMessages() throws MessageProcessingException {
        Message msg = null;
        Module dst = null;
        try {
            while (!messages.isEmpty()) {
                msg = messages.remove(0);
                /* intercept messages destined for the kernel */
                if (msg.header.equals(""KERNEL"")) {
                    processMessage(msg);
                }
                /* try sending message directly to recipient, if not null,
		   otherwise send to everyone that is subscribing to the
		   specified topic. */
                dst = modules.get(msg.getRecipient());
                if (dst != null) {
                    sendMessage(dst, msg);
                } else if (subscribers.containsKey(msg.getHeader())) {
                    sendMessageNotify(subscribers.get(msg.getHeader()), msg);
                }
                /* Notify modules subscribing on all Message classes. */
                if (subscribers.containsKey(""*"")) {
                    sendMessageNotify(subscribers.get(""*""), msg);
                }
                msg.setDelivered(true);
                msg.unref();
            }
        } catch (Exception e) {
            if (msg != null) {
                msg.unref();
            }
            throw new MessageProcessingException(msg, e);
        }
    }

    /**
     * Sends the specified message to the given collection of modules.
     * The modules are notified of the delivery (i.e. the thread is notified.)
     *
     * @param mods the modules that should receive the message.
     * @param msg the message that should be delivered.
     * @throws MessageDeliveryException if the message could not be delivered.
     */
    public void sendMessageNotify(Collection<Module> mods, Message msg) throws MessageDeliveryException {
        for (Module mod : mods) {
            sendMessage(mod, msg);
            synchronized (mod) {
                mod.notify();
            }
        }
    }

    /**
     * Returns the Kernel associated with this Module.
     * @return the Kernel associated with this Module.
     */
    public Kernel getKernel() {
        return null;
    }

    /**
     * Returns the thread associated with this module.
     * @return The thread associated with this module.
     */
    public Thread getThread() {
        return thread;
    }
}
","// Kernel_1Test.java
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Kernel}.
* It contains ten unit test cases for the {@link Kernel#request(Message)} method.
*/
class Kernel_1Test {","// Kernel_1Test.java
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Kernel}.
* It contains ten unit test cases for the {@link Kernel#request(Message)} method.
*/
class Kernel_1Test {
"
9cff9dcf-db22-4976-a2c7-f766a6788dd5,/EvoSuiteBenchmark/27_gangup/src/main/java/module/Kernel_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8123 tokens (4123 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// Kernel.java
/* $Id: Kernel.java,v 1.7 2004/05/01 23:20:45 bja Exp $ 
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.7 $
 *
 */
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;

@cvs(file = ""$RCSfile: Kernel.java,v $"", revision = ""$Revision: 1.7 $"", date = ""$Date: 2004/05/01 23:20:45 $"", author = ""$Author: bja $"", tag = ""$Name:  $"", build = """")
@mod(name = ""Kernel"", topics = ""KERNEL"", cmds = ""DUMP LOAD UNLOAD LIST EXISTS"", desc = ""This class provides a message delivery system. It's primary task is "" + ""to manage loaded modules. It has methods for loading and unloading "" + ""modules, subscribing and unsubscribing modules to specified topics, "" + ""and for creating and destroying sessions."")
public class /**
 * This class provides a message delivery system. It's primary task is to
 * manage loaded modules. It has methods for loading and unloading modules,
 * subscribing and unsubscribing modules to specified topics, and for creating
 * and destroying sessions.
 */
Kernel implements Module {

    /**
     * Topic to subcribers lookup table.
     */
    private Hashtable<String, Vector<Module>> subscribers;

    /**
     * Module name lookup table.
     */
    private Hashtable<String, Module> modules;

    /**
     * Message queue.
     */
    private List<Message> messages;

    /**
     * The thread associated with this module.
     */
    private Thread thread;

    /**
     * Contains module specific information.
     */
    private ModuleInfo modinfo = new ModuleInfo(this);

    /**
     * Specifies whether the Kernel should stop running.
     */
    private boolean done = false;

    /**
     * Create a new instance of the Kernel module. There has to be at least
     * one kernel up and running in order to have messages processed.
     */
    public Kernel() {
        /* Create the lookup table of module subscriptions */
        subscribers = new Hashtable<String, Vector<Module>>();
        /* Create the table of registered modules */
        modules = new Hashtable<String, Module>();
        /* Initialize message queue */
        messages = Collections.synchronizedList(new LinkedList<Message>());
        /* fixme - for now! */
        start();
    }

    /**
     * Start executing the run method in a separate thread. This method
     * is invoked automatically be the Kernel when the module is loaded
     * and should not be invoked manually.
     */
    public void start() {
        thread = new Thread(this, modinfo.name);
        thread.start();
    }

    /**
     * This is the kernels main thread routine. Its sole purpose is to
     * regularly process the messagequeue.
     */
    public void run() {
        while (!done) {
            try {
                processMessages();
                thread.sleep(10);
            } catch (Exception e) {
                System.err.println(e);
            }
        }
    }

    /**
     * Load and register the specified module. This method provides
     * a mechanism for dynamically loading modules to the runtime.
     *
     * @param name The name of the module that is to be loaded.
     * @throws ModuleLoadException If an exception occurred.
     */
    public void loadModule(String name) throws ModuleLoadException {
        try {
            Class c = getClass().forName(name);
            Module m = (Module) c.newInstance();
            m.register(this);
            m.start();
        } catch (Exception e) {
            throw new ModuleLoadException(e);
        }
    }

    /**
     * Unload and unregister the specified module. Modules that are not
     * needed any more may be unloaded from the kernel to save resources.
     *
     * @param mod The module that is to be unloaded.
     *
     * @throws ModuleRegisterException If an register exception occurred.
     * @throws ModuleUnloadException If an exception occurred.
     */
    public void unloadModule(Module mod) throws ModuleRegisterException {
        unregister(mod);
    }

    /**
     * Unload and unregister the specified module. Modules that are not
     * needed any more may be unloaded from the kernel to save resources.
     *
     * @param name The name of the module that is to be unloaded.
     *
     * @throws ModuleUnloadException If an exception occurred.
     */
    public void unloadModule(String name) throws ModuleUnloadException {
        try {
            Module m = modules.get(name);
            unloadModule(m);
            m.getThread().join(100);
            m = null;
        } catch (Exception e) {
            throw new ModuleUnloadException(""mod="" + name, e);
        }
    }

    /**
     * Register the specified module with this kernel. A module is required
     * to register with the kernel in order to subscribe to messages and
     * in turn communicate with other modules.
     *
     * @param mod The module that is to be registered.
     * @throws ModuleRegisterException if the module has already registered.
     */
    public void register(Module m) throws ModuleRegisterException {
        Message msg = null;
        System.err.println(""KERNEL REGISTERED: "" + m);
        try {
            if (modules.containsKey(m.info().name)) {
                throw new ModuleRegisterException(m, ""A module with that name has already been registered: "" + ""name="" + m.info().name);
            }
            // Add the module to the collection of registered modules.
            modules.put(m.info().name, m);
            // Let the module know it has been registered.
            //sendMessage(m, new Message(""KERNEL"",""REGISTERED""));
            msg = MessageFactory.createMessage(""KERNEL"", m.getClass().getName(), ""REGISTERED"");
            // MessageFactory.getInstance().sendRegisterMessage(this, m);
            sendMessage(m, msg);
        } catch (ModuleRegisterException e) {
            throw e;
        } catch (Exception e) {
            throw new ModuleRegisterException(m, e);
        } finally {
            if (msg != null)
                msg.unref();
        }
    }

    /**
     * Unregister the specified module. An unused module should unregister
     * with the kernel so that all references to that module will be freed.
     *
     * @param mod The module that is to be unregistered.
     * @throws ModuleRegisterException if the module is not registered.
     */
    public void unregister(Module m) throws ModuleRegisterException {
        try {
            if (!modules.containsKey(m.info().name)) {
                throw new ModuleRegisterException(m, ""Not registered!"");
            }
            // maybe this should be synchronized
            unsubscribe(m);
            modules.remove(m.info().name);
            //MessageFactory.getInstance().sendUnregisterMessage(this, m);
            sendMessage(m, new Message(""KERNEL"", ""UNREGISTERED""));
        } catch (ModuleRegisterException e) {
            throw e;
        } catch (Exception e) {
            throw new ModuleRegisterException(m, e);
        }
    }

    /**
     * Adds module as a subscriber of all messages with the
     * specified topic.
     *
     * @param mod The module that is to subscribe to topic.
     * @param topic The topic that should be subscribed to.
     */
    public void subscribe(Module mod, String topics) throws ModuleSubscriptionException {
        try {
            String[] top = topics.split(""(,|\\s+)"");
            for (int i = 0; i < top.length; i++) {
                if (subscribers.containsKey(top[i])) {
                    subscribers.get(top[i]).add(mod);
                } else {
                    Vector<Module> nv = new Vector<Module>();
                    nv.add(mod);
                    subscribers.put(top[i], nv);
                }
            }
        } catch (Exception e) {
            throw new ModuleSubscriptionException(mod, ""topics="" + topics, e);
        }
    }

    /**
     * Unsubscribes the specified module from every topic it is
     * subscribing to. Modules will still receive messages from
     * the kernel though.
     *
     * @param mod The module that is to be unsubscribed.
     */
    public void unsubscribe(Module mod) {
        // fixme - this is really ugly, O(t+ts) may easily be O(t)!
        for (Vector v : subscribers.values()) {
            v.remove(mod);
        }
    }

    /**
     * Unsubscribes the specified module from the given topic. Modules may
     * call this method to instruct the kernel that they do not whish to
     * receive messages in the specified topic.
     *
     * @param mod The module that is to be unsubscribed from topic.
     * @param topic The topic from which we wish to unsubscribe.
     *
     * @throws ModuleSubscriptionException If either the topic or module are
     * null.
     */
    public void unsubscribe(Module mod, String topic) throws ModuleSubscriptionException {
        try {
            if (subscribers.containsKey(topic)) {
                Vector t = subscribers.get(topic);
                t.remove(mod);
                if (t.size() == 0) {
                    subscribers.remove(topic);
                }
            }
        } catch (Exception e) {
            throw new ModuleSubscriptionException(e);
        }
    }

    /**
     * Requests the specified query from the specified topic. Observe that
     * if there are more than one module answering a specific request, only
     * the first one will be returned.
     *
     * @deprecated Requests are currently not used by the Kernel.
     *
     * @param mod The module that should receive the request.
     * @param key A string containing the actual request.
     */
    public Object request(String mod, String key) throws MessageTimeoutException {
        throw new MessageTimeoutException(""Requests are not implemented"");
    }

    /**
     * Requests the specified query from the specified topic. Observe that
     * if there are more than one module answering a specific request, only
     * the first one will be returned.
     *
     * @deprecated Requests are currently not used by the Kernel.
     *
     * @param msg The message containing the request.
     *
     * @throws MessageTimeoutException
     * If the request times out before we receive any replies.
     */
    public Message request(Message msg) throws MessageTimeoutException {
        throw new MessageTimeoutException(""Sorry, requests are not implemented in Kernel"");
    }

    /**
     */
    public ModuleInfo info() {
        return modinfo;
    }

    /**
     * Delivers the specified message to the kernel.
     * @param msg The message to be delivered.
     * @throws MessageDeliveryException if message could not be delivered.
     */
    public void sendMessage(Message msg) throws MessageDeliveryException {
        try {
            sendMessage(modules.get(msg.recipient), msg);
        } catch (Exception e) {
            throw new MessageDeliveryException(e);
        }
    }

    /**
     * Delivers the specified message to the given module.
     *
     * @param mod the module that should receive the message.
     * @param msg the message that should be sent.
     * @throws MessageDeliveryException if message could not be delivered.
     */
    private void sendMessage(Module mod, Message msg) throws MessageDeliveryException {
        try {
            mod.receiveMessage(msg);
        } catch (Exception e) {
            throw new MessageDeliveryException(mod, msg, e);
        }
    }

    /**
     * Receives a message from another module. This function is public
     * and should be called from the other module.
     *
     * @param msg The message to receive.
     */
    public void receiveMessage(Message msg) throws MessageDeliveryException {
        try {
            msg.ref();
            messages.add(msg);
            //msg.setState(Message.SENT);
        } catch (Exception e) {
            msg.unref();
            throw new MessageDeliveryException(this, msg, e);
        }
    }

    /**
     * Handles what should done with messages sent to this module.
     *
     * @param msg The message to be processed.
     * @throws Exception if the processing failed for this message.
     */
    protected void processMessage(Message msg) throws Exception {
        String[] cmd = null;
        cmd = ((String) msg.body).split("" "");
        if (cmd.length == 0) {
            return;
        }
        if (cmd[0].equals(""LOAD"")) {
            loadModule(cmd[1]);
            return;
        }
        if (cmd[0].equals(""UNLOAD"")) {
            unloadModule(cmd[1]);
            return;
        }
        if (cmd[0].equals(""DUMP"")) {
            sendMessage(modules.get(msg.sender), msg.reply(modules.toString()));
            sendMessage(modules.get(msg.sender), msg.reply(subscribers.toString()));
            return;
        }
    }

    /**
     * Process messages from the message queue.
     *
     * @throws MessageProcessingException if processing failed for any
     * message in the message queue.
     */
    private void processMessages() throws MessageProcessingException {
        Message msg = null;
        Module dst = null;
        try {
            while (!messages.isEmpty()) {
                msg = messages.remove(0);
                /* intercept messages destined for the kernel */
                if (msg.header.equals(""KERNEL"")) {
                    processMessage(msg);
                }
                /* try sending message directly to recipient, if not null,
		   otherwise send to everyone that is subscribing to the
		   specified topic. */
                dst = modules.get(msg.getRecipient());
                if (dst != null) {
                    sendMessage(dst, msg);
                } else if (subscribers.containsKey(msg.getHeader())) {
                    sendMessageNotify(subscribers.get(msg.getHeader()), msg);
                }
                /* Notify modules subscribing on all Message classes. */
                if (subscribers.containsKey(""*"")) {
                    sendMessageNotify(subscribers.get(""*""), msg);
                }
                msg.setDelivered(true);
                msg.unref();
            }
        } catch (Exception e) {
            if (msg != null) {
                msg.unref();
            }
            throw new MessageProcessingException(msg, e);
        }
    }

    /**
     * Sends the specified message to the given collection of modules.
     * The modules are notified of the delivery (i.e. the thread is notified.)
     *
     * @param mods the modules that should receive the message.
     * @param msg the message that should be delivered.
     * @throws MessageDeliveryException if the message could not be delivered.
     */
    public void sendMessageNotify(Collection<Module> mods, Message msg) throws MessageDeliveryException {
        for (Module mod : mods) {
            sendMessage(mod, msg);
            synchronized (mod) {
                mod.notify();
            }
        }
    }

    /**
     * Returns the Kernel associated with this Module.
     * @return the Kernel associated with this Module.
     */
    public Kernel getKernel() {
        return null;
    }

    /**
     * Returns the thread associated with this module.
     * @return The thread associated with this module.
     */
    public Thread getThread() {
        return thread;
    }
}
","// Kernel_2Test.java
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Kernel}.
* It contains ten unit test cases for the {@link Kernel#info()} method.
*/
class Kernel_2Test {","// Kernel_2Test.java
package module;

import java.util.Collection;
import java.util.Hashtable;
import java.util.Vector;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Collections;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Kernel}.
* It contains ten unit test cases for the {@link Kernel#info()} method.
*/
class Kernel_2Test {
"
7cc2fcb6-cb69-4b63-9789-6dc01b9c7dcf,/EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactory_0Test.java,-1,"ERROR - Request timed out: HTTPSConnectionPool(host='api.openai.com', port=443): Read timed out. (read timeout=600)","// MessageFactory.java
/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;

/**
 * This class provides methods for creating Messages of various kind.
 * Messages created by this factory are managed, that is instances are
 * reused after they have been used.
 */
public class MessageFactory extends AbstractFactory<Message> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static MessageFactory instance = null;

    /**
     * Creates a new instance of the MessageFactory class.
     */
    private MessageFactory() {
        super(new Message());
        this.instance = this;
    }

    /**
     * Returns a reference to new empty message. The message topic and
     * data is set to null. The recipient field is set to default ""*"".
     */
    public Message createMessage() {
        return createMessage(null, ""*"", null);
    }

    /**
     * Returns the MessageFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static MessageFactory getInstance() {
        return instance != null ? instance : new MessageFactory();
    }

    /**
     * Create a new Message instance with the specified topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, Object data) {
        return createMessage(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified topic,
     * recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recip The recipient of this message.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, String recip, Object data) {
        Message msg = getInstance().createObject();
        msg.set(topic, recip, data);
        return msg;
    }

    public static Message createUnloadMessage(String name) {
        return createMessage(""KERNEL"", ""UNLOAD "" + name);
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createWarningMessage(String localeKey, Object... args) {
        Message msg = getInstance().createObject();
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(""gangup"");
            msg.set(""WARNING"", ""*"", String.format(bundle.getString(localeKey), args));
        } catch (Exception e) {
            msg.set(""WARNING"", ""*"", ""Reading string from locale failed: key="" + localeKey + ""\n"" + ""This probably means that you have an old or otherwise\n"" + ""inaccurate locale file (maybe it's missing altogether)\n"" + ""or that the classpath does not contain the directory."");
        }
        return msg;
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createErrorMessage(String localeKey, Object... args) {
        Message msg = createWarningMessage(localeKey, args);
        msg.setHeader(""ERROR"");
        return msg;
    }

    /**
     * @param id
     * @param addr
     */
    public static Message createConnectionDroppedMessage(int id, String addr) {
        Message msg = getInstance().createObject();
        msg.set(""DROPPED"", ""*"", ""ID: "" + id + "" IP: "" + addr);
        return msg;
    }
}
","// MessageFactory_0Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage()} method.
*/
class MessageFactory_0Test {","// MessageFactory_0Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage()} method.
*/
class MessageFactory_0Test {
"
cmpl-6tuT5DdKPn3D7YLZT3CNHzNKoAOir,/EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactory_1Test.java,81.34354305267334,length,"// MessageFactory.java
/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;

/**
 * This class provides methods for creating Messages of various kind.
 * Messages created by this factory are managed, that is instances are
 * reused after they have been used.
 */
public class MessageFactory extends AbstractFactory<Message> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static MessageFactory instance = null;

    /**
     * Creates a new instance of the MessageFactory class.
     */
    private MessageFactory() {
        super(new Message());
        this.instance = this;
    }

    /**
     * Returns a reference to new empty message. The message topic and
     * data is set to null. The recipient field is set to default ""*"".
     */
    public Message createMessage() {
        return createMessage(null, ""*"", null);
    }

    /**
     * Returns the MessageFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static MessageFactory getInstance() {
        return instance != null ? instance : new MessageFactory();
    }

    /**
     * Create a new Message instance with the specified topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, Object data) {
        return createMessage(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified topic,
     * recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recip The recipient of this message.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, String recip, Object data) {
        Message msg = getInstance().createObject();
        msg.set(topic, recip, data);
        return msg;
    }

    public static Message createUnloadMessage(String name) {
        return createMessage(""KERNEL"", ""UNLOAD "" + name);
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createWarningMessage(String localeKey, Object... args) {
        Message msg = getInstance().createObject();
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(""gangup"");
            msg.set(""WARNING"", ""*"", String.format(bundle.getString(localeKey), args));
        } catch (Exception e) {
            msg.set(""WARNING"", ""*"", ""Reading string from locale failed: key="" + localeKey + ""\n"" + ""This probably means that you have an old or otherwise\n"" + ""inaccurate locale file (maybe it's missing altogether)\n"" + ""or that the classpath does not contain the directory."");
        }
        return msg;
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createErrorMessage(String localeKey, Object... args) {
        Message msg = createWarningMessage(localeKey, args);
        msg.setHeader(""ERROR"");
        return msg;
    }

    /**
     * @param id
     * @param addr
     */
    public static Message createConnectionDroppedMessage(int id, String addr) {
        Message msg = getInstance().createObject();
        msg.set(""DROPPED"", ""*"", ""ID: "" + id + "" IP: "" + addr);
        return msg;
    }
}
","// MessageFactory_1Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#getInstance()} method.
*/
class MessageFactory_1Test {","// MessageFactory_1Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#getInstance()} method.
*/
class MessageFactory_1Test {

	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_1() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_2() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_3() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_4() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_5() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_6() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_7() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_8() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* This test case tests if the method returns a reference to the MessageFactory instance.
	*/
	@Test
	void testGetInstance_9() {
		MessageFactory mf = MessageFactory.getInstance();
		assertNotNull(mf);
	}
	
}

// MessageFactory_2Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage()} method.
*/
class MessageFactory_2Test {
		
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_1() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_2() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_3() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_4() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_5() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_6() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_7() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_8() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* This test case tests if the method returns a reference to new empty message.
	*/
	@Test
	void testCreateMessage_9() {
		Message msg = MessageFactory.createMessage();
		assertNotNull(msg);
	}
	
}

// MessageFactory_3Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, Object)} method.
*/
class MessageFactory_3Test {
		
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_1() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_2() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_3() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_4() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_5() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_6() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_7() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_8() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic and data.
	*/
	@Test
	void testCreateMessage_9() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertNotNull(msg);
	}
	
}

// MessageFactory_4Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, String, Object)} method.
*/
class MessageFactory_4Test {
		
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_1() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_2() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_3() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_4() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_5() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_6() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_7() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* This test case tests if the method returns a reference to new Message instance with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage_8() {
		Message msg = MessageFactory.createMessage(""topic"", ""recip"", ""data"");
		assertNotNull(msg);
	}
	
	/**
	* Test case for the {@link"
cmpl-6tuUO5S3q5nyFuDKf4IqJJsRfhXSJ,/EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactory_2Test.java,76.62332725524902,length,"// MessageFactory.java
/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;

/**
 * This class provides methods for creating Messages of various kind.
 * Messages created by this factory are managed, that is instances are
 * reused after they have been used.
 */
public class MessageFactory extends AbstractFactory<Message> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static MessageFactory instance = null;

    /**
     * Creates a new instance of the MessageFactory class.
     */
    private MessageFactory() {
        super(new Message());
        this.instance = this;
    }

    /**
     * Returns a reference to new empty message. The message topic and
     * data is set to null. The recipient field is set to default ""*"".
     */
    public Message createMessage() {
        return createMessage(null, ""*"", null);
    }

    /**
     * Returns the MessageFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static MessageFactory getInstance() {
        return instance != null ? instance : new MessageFactory();
    }

    /**
     * Create a new Message instance with the specified topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, Object data) {
        return createMessage(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified topic,
     * recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recip The recipient of this message.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, String recip, Object data) {
        Message msg = getInstance().createObject();
        msg.set(topic, recip, data);
        return msg;
    }

    public static Message createUnloadMessage(String name) {
        return createMessage(""KERNEL"", ""UNLOAD "" + name);
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createWarningMessage(String localeKey, Object... args) {
        Message msg = getInstance().createObject();
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(""gangup"");
            msg.set(""WARNING"", ""*"", String.format(bundle.getString(localeKey), args));
        } catch (Exception e) {
            msg.set(""WARNING"", ""*"", ""Reading string from locale failed: key="" + localeKey + ""\n"" + ""This probably means that you have an old or otherwise\n"" + ""inaccurate locale file (maybe it's missing altogether)\n"" + ""or that the classpath does not contain the directory."");
        }
        return msg;
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createErrorMessage(String localeKey, Object... args) {
        Message msg = createWarningMessage(localeKey, args);
        msg.setHeader(""ERROR"");
        return msg;
    }

    /**
     * @param id
     * @param addr
     */
    public static Message createConnectionDroppedMessage(int id, String addr) {
        Message msg = getInstance().createObject();
        msg.set(""DROPPED"", ""*"", ""ID: "" + id + "" IP: "" + addr);
        return msg;
    }
}
","// MessageFactory_2Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, Object)} method.
*/
class MessageFactory_2Test {","// MessageFactory_2Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, Object)} method.
*/
class MessageFactory_2Test {

	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage2() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage3() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage4() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage5() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage6() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage7() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage8() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage9() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* It tests if the method returns a new message with the specified topic and data.
	*/
	@Test
	void testCreateMessage10() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
}

// MessageFactory_3Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, String, Object)} method.
*/
class MessageFactory_3Test {
		
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage2() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage3() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage4() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage5() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage6() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage7() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage8() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage9() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* It tests if the method returns a new message with the specified topic, recipient, and data.
	*/
	@Test
	void testCreateMessage10() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertEquals(""topic"", msg.getTopic());
		assertEquals(""recipient"", msg.getRecipient());
		assertEquals(""data"", msg.getData());
	}
}

// MessageFactory_4Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createUnloadMessage(String)} method.
*/
class MessageFactory_4Test {
		
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage2() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage3() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage4() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage5() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage6() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage7() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage8() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	* Test case for the {@link MessageFactory#createUnloadMessage(String)} method.
	* It tests if the method returns a new message with the specified name.
	*/
	@Test
	void testCreateUnloadMessage9() {
		Message msg = MessageFactory.createUnloadMessage(""name"");
		assertEquals(""KERNEL"", msg.getTopic());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD name"", msg.getData());
	}
	
	/**
	"
cmpl-6tuVcQZFSPdvUhuiHzL3m9FbTWvli,/EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactory_3Test.java,75.15614438056946,length,"// MessageFactory.java
/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;

/**
 * This class provides methods for creating Messages of various kind.
 * Messages created by this factory are managed, that is instances are
 * reused after they have been used.
 */
public class MessageFactory extends AbstractFactory<Message> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static MessageFactory instance = null;

    /**
     * Creates a new instance of the MessageFactory class.
     */
    private MessageFactory() {
        super(new Message());
        this.instance = this;
    }

    /**
     * Returns a reference to new empty message. The message topic and
     * data is set to null. The recipient field is set to default ""*"".
     */
    public Message createMessage() {
        return createMessage(null, ""*"", null);
    }

    /**
     * Returns the MessageFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static MessageFactory getInstance() {
        return instance != null ? instance : new MessageFactory();
    }

    /**
     * Create a new Message instance with the specified topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, Object data) {
        return createMessage(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified topic,
     * recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recip The recipient of this message.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, String recip, Object data) {
        Message msg = getInstance().createObject();
        msg.set(topic, recip, data);
        return msg;
    }

    public static Message createUnloadMessage(String name) {
        return createMessage(""KERNEL"", ""UNLOAD "" + name);
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createWarningMessage(String localeKey, Object... args) {
        Message msg = getInstance().createObject();
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(""gangup"");
            msg.set(""WARNING"", ""*"", String.format(bundle.getString(localeKey), args));
        } catch (Exception e) {
            msg.set(""WARNING"", ""*"", ""Reading string from locale failed: key="" + localeKey + ""\n"" + ""This probably means that you have an old or otherwise\n"" + ""inaccurate locale file (maybe it's missing altogether)\n"" + ""or that the classpath does not contain the directory."");
        }
        return msg;
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createErrorMessage(String localeKey, Object... args) {
        Message msg = createWarningMessage(localeKey, args);
        msg.setHeader(""ERROR"");
        return msg;
    }

    /**
     * @param id
     * @param addr
     */
    public static Message createConnectionDroppedMessage(int id, String addr) {
        Message msg = getInstance().createObject();
        msg.set(""DROPPED"", ""*"", ""ID: "" + id + "" IP: "" + addr);
        return msg;
    }
}
","// MessageFactory_3Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, String, Object)} method.
*/
class MessageFactory_3Test {","// MessageFactory_3Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, String, Object)} method.
*/
class MessageFactory_3Test {

	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_1() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_2() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_3() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_4() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_5() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_6() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_7() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_8() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_9() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_10() {
		Message msg = MessageFactory.createMessage(""topic"", ""recipient"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
}

// MessageFactory_2Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage(String, Object)} method.
*/
class MessageFactory_2Test {
		
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_1() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_2() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_3() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_4() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_5() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_6() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_7() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_8() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_9() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage(String, Object)} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_10() {
		Message msg = MessageFactory.createMessage(""topic"", ""data"");
		assertTrue(msg instanceof Message);
	}
	
}

// MessageFactory_1Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createMessage()} method.
*/
class MessageFactory_1Test {
		
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_1() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_2() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_3() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_4() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_5() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_6() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_7() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_8() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_9() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
	/**
	* Test case for the {@link MessageFactory#createMessage()} method.
	* The test case tests if the method returns a new instance of the {@link Message} class.
	*/
	@Test
	void testCreateMessage_10() {
		Message msg = MessageFactory.createMessage();
		assertTrue(msg instanceof Message);
	}
	
}

// MessageFactoryTest.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#getInstance()} method.
*/
class MessageFactoryTest {
		
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_1() {
		MessageFactory msg = MessageFactory.getInstance();
		assertTrue(msg instanceof MessageFactory);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_2() {
		MessageFactory msg = MessageFactory.getInstance();
		assertTrue(msg instanceof MessageFactory);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_3() {
		MessageFactory msg = MessageFactory.getInstance();
		assertTrue(msg instanceof MessageFactory);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_4() {
		MessageFactory msg = MessageFactory.getInstance();
		assertTrue(msg instanceof MessageFactory);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_5() {
		MessageFactory msg = MessageFactory.getInstance();
		assertTrue(msg instanceof MessageFactory);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_6() {
		MessageFactory msg = MessageFactory.getInstance();
		assertTrue(msg instanceof MessageFactory);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_7() {
		MessageFactory msg = MessageFactory.getInstance();
		assertTrue(msg instanceof MessageFactory);
	}
	
	/**
	* Test case for the {@link MessageFactory#getInstance()} method.
	* The test case tests if the method returns a new instance of the {@link MessageFactory} class.
	*/
	@Test
	void testGetInstance_8() {
		Message"
cmpl-6tuWqUYVH1hU9CBgE1pFBmtKIgk9i,/EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactory_5Test.java,85.94063115119934,length,"// MessageFactory.java
/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;

/**
 * This class provides methods for creating Messages of various kind.
 * Messages created by this factory are managed, that is instances are
 * reused after they have been used.
 */
public class MessageFactory extends AbstractFactory<Message> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static MessageFactory instance = null;

    /**
     * Creates a new instance of the MessageFactory class.
     */
    private MessageFactory() {
        super(new Message());
        this.instance = this;
    }

    /**
     * Returns a reference to new empty message. The message topic and
     * data is set to null. The recipient field is set to default ""*"".
     */
    public Message createMessage() {
        return createMessage(null, ""*"", null);
    }

    /**
     * Returns the MessageFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static MessageFactory getInstance() {
        return instance != null ? instance : new MessageFactory();
    }

    /**
     * Create a new Message instance with the specified topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, Object data) {
        return createMessage(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified topic,
     * recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recip The recipient of this message.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, String recip, Object data) {
        Message msg = getInstance().createObject();
        msg.set(topic, recip, data);
        return msg;
    }

    public static Message createUnloadMessage(String name) {
        return createMessage(""KERNEL"", ""UNLOAD "" + name);
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createWarningMessage(String localeKey, Object... args) {
        Message msg = getInstance().createObject();
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(""gangup"");
            msg.set(""WARNING"", ""*"", String.format(bundle.getString(localeKey), args));
        } catch (Exception e) {
            msg.set(""WARNING"", ""*"", ""Reading string from locale failed: key="" + localeKey + ""\n"" + ""This probably means that you have an old or otherwise\n"" + ""inaccurate locale file (maybe it's missing altogether)\n"" + ""or that the classpath does not contain the directory."");
        }
        return msg;
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createErrorMessage(String localeKey, Object... args) {
        Message msg = createWarningMessage(localeKey, args);
        msg.setHeader(""ERROR"");
        return msg;
    }

    /**
     * @param id
     * @param addr
     */
    public static Message createConnectionDroppedMessage(int id, String addr) {
        Message msg = getInstance().createObject();
        msg.set(""DROPPED"", ""*"", ""ID: "" + id + "" IP: "" + addr);
        return msg;
    }
}
","// MessageFactory_5Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createWarningMessage(String, Object[])} method.
*/
class MessageFactory_5Test {","// MessageFactory_5Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createWarningMessage(String, Object[])} method.
*/
class MessageFactory_5Test {

	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is null.
	*/
	@Test
	void testCreateWarningMessage_1() {
		Message msg = MessageFactory.createWarningMessage(null);
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=null\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is empty.
	*/
	@Test
	void testCreateWarningMessage_2() {
		Message msg = MessageFactory.createWarningMessage("""");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is not found.
	*/
	@Test
	void testCreateWarningMessage_3() {
		Message msg = MessageFactory.createWarningMessage(""test"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=test\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found.
	*/
	@Test
	void testCreateWarningMessage_4() {
		Message msg = MessageFactory.createWarningMessage(""test.warning"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test warning message."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not null.
	*/
	@Test
	void testCreateWarningMessage_5() {
		Message msg = MessageFactory.createWarningMessage(""test.warning.args"", ""test"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test warning message with arguments: test"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are null.
	*/
	@Test
	void testCreateWarningMessage_6() {
		Message msg = MessageFactory.createWarningMessage(""test.warning.args"", (Object[])null);
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test warning message with arguments: null"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are empty.
	*/
	@Test
	void testCreateWarningMessage_7() {
		Message msg = MessageFactory.createWarningMessage(""test.warning.args"", new Object[0]);
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test warning message with arguments: "", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not empty.
	*/
	@Test
	void testCreateWarningMessage_8() {
		Message msg = MessageFactory.createWarningMessage(""test.warning.args"", ""test"", ""test2"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test warning message with arguments: test test2"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not empty.
	*/
	@Test
	void testCreateWarningMessage_9() {
		Message msg = MessageFactory.createWarningMessage(""test.warning.args"", ""test"", ""test2"", ""test3"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test warning message with arguments: test test2 test3"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not empty.
	*/
	@Test
	void testCreateWarningMessage_10() {
		Message msg = MessageFactory.createWarningMessage(""test.warning.args"", ""test"", ""test2"", ""test3"", ""test4"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test warning message with arguments: test test2 test3 test4"", msg.getData());
	}
}

// MessageFactory_6Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createErrorMessage(String, Object[])} method.
*/
class MessageFactory_6Test {
		
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is null.
	*/
	@Test
	void testCreateErrorMessage_1() {
		Message msg = MessageFactory.createErrorMessage(null);
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=null\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is empty.
	*/
	@Test
	void testCreateErrorMessage_2() {
		Message msg = MessageFactory.createErrorMessage("""");
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is not found.
	*/
	@Test
	void testCreateErrorMessage_3() {
		Message msg = MessageFactory.createErrorMessage(""test"");
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=test\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found.
	*/
	@Test
	void testCreateErrorMessage_4() {
		Message msg = MessageFactory.createErrorMessage(""test.error"");
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test error message."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not null.
	*/
	@Test
	void testCreateErrorMessage_5() {
		Message msg = MessageFactory.createErrorMessage(""test.error.args"", ""test"");
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test error message with arguments: test"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are null.
	*/
	@Test
	void testCreateErrorMessage_6() {
		Message msg = MessageFactory.createErrorMessage(""test.error.args"", (Object[])null);
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test error message with arguments: null"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are empty.
	*/
	@Test
	void testCreateErrorMessage_7() {
		Message msg = MessageFactory.createErrorMessage(""test.error.args"", new Object[0]);
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test error message with arguments: "", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not empty.
	*/
	@Test
	void testCreateErrorMessage_8() {
		Message msg = MessageFactory.createErrorMessage(""test.error.args"", ""test"", ""test2"");
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test error message with arguments: test test2"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not empty.
	*/
	@Test
	void testCreateErrorMessage_9() {
		Message msg = MessageFactory.createErrorMessage(""test.error.args"", ""test"", ""test2"", ""test3"");
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test error message with arguments: test test2 test3"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createErrorMessage(String, Object[])} method.
	* This test case tests the functionality of the method when the locale key is found and the arguments are not empty.
	*/
	@Test
	void testCreateErrorMessage_10() {
		Message msg = MessageFactory.createErrorMessage(""test.error.args"", ""test"", ""test2"", ""test3"", ""test4"");
		assertEquals(""ERROR"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""This is a test error message with arguments: test test2 test3 test4"", msg.getData());
	}
}

// MessageFactory_7Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
*/
class MessageFactory_7Test {
		
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the functionality of the method when the id is negative.
	*/
	@Test
	void testCreateConnectionDroppedMessage_1() {
		Message msg = MessageFactory.createConnectionDroppedMessage(-1, ""test"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: -1 IP: test"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the functionality of the method when the id is zero.
	*/
	@Test
	void testCreateConnectionDroppedMessage_2() {
		Message msg = MessageFactory.createConnectionDroppedMessage(0, ""test"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 0 IP: test"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the functionality of the method when the id is positive.
	*/
	@Test
	void testCreateConnectionDroppedMessage_3() {
		Message msg = MessageFactory.createConnectionDroppedMessage(1, ""test"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 1 IP: test"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the functionality of the method when the id is positive and the address is null.
	*/
	@Test
	void testCreateConnectionDroppedMessage_4() {
		Message msg = MessageFactory.createConnectionDroppedMessage(1, null);
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 1 IP: null"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This"
cmpl-6tuYEE4OEz1jWdBNshsWkunrbbC5A,/EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactory_6Test.java,77.80531549453735,length,"// MessageFactory.java
/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;

/**
 * This class provides methods for creating Messages of various kind.
 * Messages created by this factory are managed, that is instances are
 * reused after they have been used.
 */
public class MessageFactory extends AbstractFactory<Message> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static MessageFactory instance = null;

    /**
     * Creates a new instance of the MessageFactory class.
     */
    private MessageFactory() {
        super(new Message());
        this.instance = this;
    }

    /**
     * Returns a reference to new empty message. The message topic and
     * data is set to null. The recipient field is set to default ""*"".
     */
    public Message createMessage() {
        return createMessage(null, ""*"", null);
    }

    /**
     * Returns the MessageFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static MessageFactory getInstance() {
        return instance != null ? instance : new MessageFactory();
    }

    /**
     * Create a new Message instance with the specified topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, Object data) {
        return createMessage(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified topic,
     * recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recip The recipient of this message.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, String recip, Object data) {
        Message msg = getInstance().createObject();
        msg.set(topic, recip, data);
        return msg;
    }

    public static Message createUnloadMessage(String name) {
        return createMessage(""KERNEL"", ""UNLOAD "" + name);
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createWarningMessage(String localeKey, Object... args) {
        Message msg = getInstance().createObject();
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(""gangup"");
            msg.set(""WARNING"", ""*"", String.format(bundle.getString(localeKey), args));
        } catch (Exception e) {
            msg.set(""WARNING"", ""*"", ""Reading string from locale failed: key="" + localeKey + ""\n"" + ""This probably means that you have an old or otherwise\n"" + ""inaccurate locale file (maybe it's missing altogether)\n"" + ""or that the classpath does not contain the directory."");
        }
        return msg;
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createErrorMessage(String localeKey, Object... args) {
        Message msg = createWarningMessage(localeKey, args);
        msg.setHeader(""ERROR"");
        return msg;
    }

    /**
     * @param id
     * @param addr
     */
    public static Message createConnectionDroppedMessage(int id, String addr) {
        Message msg = getInstance().createObject();
        msg.set(""DROPPED"", ""*"", ""ID: "" + id + "" IP: "" + addr);
        return msg;
    }
}
","// MessageFactory_6Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createErrorMessage(String, Object[])} method.
*/
class MessageFactory_6Test {","// MessageFactory_6Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createErrorMessage(String, Object[])} method.
*/
class MessageFactory_6Test {

	/**
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
	* Test case 1 for method createErrorMessage.
"
cmpl-6tuZT0NRF2re7ID9vwtidpsvwTerm,/EvoSuiteBenchmark/27_gangup/src/main/java/module/MessageFactory_7Test.java,159.1099557876587,length,"// MessageFactory.java
/* $Id: MessageFactory.java,v 1.2 2004/04/27 19:26:21 bja Exp $ */
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;

/**
 * This class provides methods for creating Messages of various kind.
 * Messages created by this factory are managed, that is instances are
 * reused after they have been used.
 */
public class MessageFactory extends AbstractFactory<Message> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static MessageFactory instance = null;

    /**
     * Creates a new instance of the MessageFactory class.
     */
    private MessageFactory() {
        super(new Message());
        this.instance = this;
    }

    /**
     * Returns a reference to new empty message. The message topic and
     * data is set to null. The recipient field is set to default ""*"".
     */
    public Message createMessage() {
        return createMessage(null, ""*"", null);
    }

    /**
     * Returns the MessageFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static MessageFactory getInstance() {
        return instance != null ? instance : new MessageFactory();
    }

    /**
     * Create a new Message instance with the specified topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, Object data) {
        return createMessage(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified topic,
     * recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recip The recipient of this message.
     * @param data The data associated with this message.
     */
    public static Message createMessage(String topic, String recip, Object data) {
        Message msg = getInstance().createObject();
        msg.set(topic, recip, data);
        return msg;
    }

    public static Message createUnloadMessage(String name) {
        return createMessage(""KERNEL"", ""UNLOAD "" + name);
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createWarningMessage(String localeKey, Object... args) {
        Message msg = getInstance().createObject();
        try {
            ResourceBundle bundle = ResourceBundle.getBundle(""gangup"");
            msg.set(""WARNING"", ""*"", String.format(bundle.getString(localeKey), args));
        } catch (Exception e) {
            msg.set(""WARNING"", ""*"", ""Reading string from locale failed: key="" + localeKey + ""\n"" + ""This probably means that you have an old or otherwise\n"" + ""inaccurate locale file (maybe it's missing altogether)\n"" + ""or that the classpath does not contain the directory."");
        }
        return msg;
    }

    /**
     * @param localeKey
     * @param args
     */
    public static Message createErrorMessage(String localeKey, Object... args) {
        Message msg = createWarningMessage(localeKey, args);
        msg.setHeader(""ERROR"");
        return msg;
    }

    /**
     * @param id
     * @param addr
     */
    public static Message createConnectionDroppedMessage(int id, String addr) {
        Message msg = getInstance().createObject();
        msg.set(""DROPPED"", ""*"", ""ID: "" + id + "" IP: "" + addr);
        return msg;
    }
}
","// MessageFactory_7Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
*/
class MessageFactory_7Test {","// MessageFactory_7Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
*/
class MessageFactory_7Test {

	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_1() {
		Message msg = MessageFactory.createConnectionDroppedMessage(1, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 1 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_2() {
		Message msg = MessageFactory.createConnectionDroppedMessage(2, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 2 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_3() {
		Message msg = MessageFactory.createConnectionDroppedMessage(3, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 3 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_4() {
		Message msg = MessageFactory.createConnectionDroppedMessage(4, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 4 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_5() {
		Message msg = MessageFactory.createConnectionDroppedMessage(5, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 5 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_6() {
		Message msg = MessageFactory.createConnectionDroppedMessage(6, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 6 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_7() {
		Message msg = MessageFactory.createConnectionDroppedMessage(7, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 7 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_8() {
		Message msg = MessageFactory.createConnectionDroppedMessage(8, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 8 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_9() {
		Message msg = MessageFactory.createConnectionDroppedMessage(9, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 9 IP: 127.0.0.1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createConnectionDroppedMessage(int, String)} method.
	* This test case tests the method with a valid id and a valid address.
	*/
	@Test
	void testCreateConnectionDroppedMessage_10() {
		Message msg = MessageFactory.createConnectionDroppedMessage(10, ""127.0.0.1"");
		assertEquals(""DROPPED"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""ID: 10 IP: 127.0.0.1"", msg.getData());
	}
}

// MessageFactory_8Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createUnloadMessage(String)} method.
*/
class MessageFactory_8Test {
		
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_1() {
		Message msg = MessageFactory.createUnloadMessage(""module1"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module1"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_2() {
		Message msg = MessageFactory.createUnloadMessage(""module2"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module2"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_3() {
		Message msg = MessageFactory.createUnloadMessage(""module3"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module3"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_4() {
		Message msg = MessageFactory.createUnloadMessage(""module4"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module4"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_5() {
		Message msg = MessageFactory.createUnloadMessage(""module5"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module5"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_6() {
		Message msg = MessageFactory.createUnloadMessage(""module6"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module6"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_7() {
		Message msg = MessageFactory.createUnloadMessage(""module7"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module7"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_8() {
		Message msg = MessageFactory.createUnloadMessage(""module8"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module8"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_9() {
		Message msg = MessageFactory.createUnloadMessage(""module9"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module9"", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createUnloadMessage(String)} method.
	* This test case tests the method with a valid name.
	*/
	@Test
	void testCreateUnloadMessage_10() {
		Message msg = MessageFactory.createUnloadMessage(""module10"");
		assertEquals(""KERNEL"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""UNLOAD module10"", msg.getData());
	}
}

// MessageFactory_9Test.java
package module;

import util.AbstractFactory;
import module.Message;
import java.util.ResourceBundle;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link MessageFactory}.
* It contains ten unit test cases for the {@link MessageFactory#createWarningMessage(String, Object...)} method.
*/
class MessageFactory_9Test {
		
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object...)} method.
	* This test case tests the method with a valid locale key and a valid argument.
	*/
	@Test
	void testCreateWarningMessage_1() {
		Message msg = MessageFactory.createWarningMessage(""key1"", ""arg1"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=key1\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object...)} method.
	* This test case tests the method with a valid locale key and a valid argument.
	*/
	@Test
	void testCreateWarningMessage_2() {
		Message msg = MessageFactory.createWarningMessage(""key2"", ""arg2"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=key2\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object...)} method.
	* This test case tests the method with a valid locale key and a valid argument.
	*/
	@Test
	void testCreateWarningMessage_3() {
		Message msg = MessageFactory.createWarningMessage(""key3"", ""arg3"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=key3\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object...)} method.
	* This test case tests the method with a valid locale key and a valid argument.
	*/
	@Test
	void testCreateWarningMessage_4() {
		Message msg = MessageFactory.createWarningMessage(""key4"", ""arg4"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=key4\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object...)} method.
	* This test case tests the method with a valid locale key and a valid argument.
	*/
	@Test
	void testCreateWarningMessage_5() {
		Message msg = MessageFactory.createWarningMessage(""key5"", ""arg5"");
		assertEquals(""WARNING"", msg.getHeader());
		assertEquals(""*"", msg.getRecipient());
		assertEquals(""Reading string from locale failed: key=key5\nThis probably means that you have an old or otherwise\ninaccurate locale file (maybe it's missing altogether)\nor that the classpath does not contain the directory."", msg.getData());
	}
	
	/**
	* Test case for {@link MessageFactory#createWarningMessage(String, Object...)} method.
	* This test case tests the method with a valid locale key and a valid argument.
	*/
	@Test
	void testCreateWarningMessage_6() {
		Message msg = MessageFactory.createWarningMessage(""key6"","
cea2ced2-baa1-42a4-b708-502ae85471c6,/EvoSuiteBenchmark/27_gangup/src/main/java/module/Message_0Test.java,-1,"ERROR - Request timed out: HTTPSConnectionPool(host='api.openai.com', port=443): Read timed out. (read timeout=600)","// Message.java
/* $Id: Message.java,v 1.6 2004/04/27 19:26:21 bja Exp $ 
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.6 $
 *
 */
package module;

import util.ManagedObject;

/**
 * The Message class provides the common data link between modules. It's
 * sole purpose is to move data from one module to another.
 */
public class Message extends ManagedObject {

    /**
     * Enumeration of possible message states
     */
    public static final int UNDEFINED = 0;

    public static final int CREATED = 1;

    public static final int RECEIVED = 2;

    public static final int DELIVERED = 4;

    /**
     * Default time to live in milliseconds.
     */
    public static final int TIME_TO_LIVE = 3000;

    /**
     * The number of instantiated messages.
     */
    private static long messages;

    /**
     * Integer that uniqely identifies this message.
     */
    long messageID;

    /**
     * Integer that uniqely identifies this session.
     */
    long sessionID;

    /**
     * The header or class of this message.
     */
    String header;

    /**
     * The name of the module this message orignitated from.
     */
    String sender;

    /**
     * The name of the module this message is destined for.
     */
    String recipient;

    /**
     * The content or data of this message.
     */
    Object body;

    /**
     * The time when this message was created.
     */
    long timestamp;

    /**
     * The maximum time to live in milliseconds.
     */
    long timetolive;

    /**
     * The current state of this message.
     */
    int state;

    /**
     * Create a new Message instance without topic and data.
     */
    public Message() {
        //this(null, ""*"", null);
    }

    /**
     * Create a new Message instance with the specified
     * topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public Message(String topic, Object data) {
        this(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified
     * topic, recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recipient The recipient of this message.
     * @param data The data associated with this message.
     */
    public Message(String topic, String recipient, Object data) {
        timestamp = System.currentTimeMillis();
        timetolive = TIME_TO_LIVE;
        state = CREATED;
        this.header = topic;
        this.recipient = recipient;
        setBody(data);
        ;
        synchronized (this) {
            messageID = messages++;
        }
        sessionID = messageID;
        sender = null;
    }

    /**
     * Set the content of this message to the specified values.
     *
     * @param topic
     * @param recipient
     * @param data
     */
    public void set(String topic, String recipient, Object data) {
        timestamp = System.currentTimeMillis();
        timetolive = TIME_TO_LIVE;
        state = CREATED;
        header = topic;
        setBody(data);
        ;
        this.recipient = recipient;
        synchronized (this) {
            messageID = messages++;
        }
        sessionID = messageID;
        sender = null;
    }

    public long getID() {
        return messageID;
    }

    public long getSID() {
        return sessionID;
    }

    public long getTTL() {
        return timetolive;
    }

    public long getTimeStamp() {
        return timestamp;
    }

    public int getState() {
        return state;
    }

    /**
     * Sets the topic attribute of this message to the specified value.
     * @param name the name of the topic to send this message to.
     */
    public void setHeader(String topic) {
        header = topic;
    }

    /**
     * Returns The header of this message.
     * @return The header of this message.
     */
    public String getHeader() {
        return header == null ? """" : header;
    }

    /**
     * Sets the body attribute of this message to the specified value.
     * @param data the data associated with this message.
     */
    public void setBody(Object data) {
        if (data instanceof ManagedObject) {
            ((ManagedObject) data).ref();
        }
        body = data;
    }

    /**
     * Returns The body of this message.
     * @return The body of this message.
     */
    public Object getBody() {
        return body == null ? """" : body;
    }

    /**
     * Sets the sender attribute of this message to the specified value.
     * @param name the name of the module that sent this message.
     */
    public void setSender(String name) {
        sender = name;
    }

    /**
     * Returns the name of the module this message originated from.
     * @return The name of the module this message originated from.
     */
    public String getSender() {
        return sender;
    }

    /**
     * Returns the name of the module this message is destined for.
     * @return The name of the module this message is destined for.
     */
    public String getRecipient() {
        return recipient;
    }

    /**
     * Sets the recipient attribute of this message to the specified value.
     * @param name the name of the module that this message is destined for.
     */
    public void setRecipient(String name) {
        recipient = name;
    }

    /**
     * Sets the delivery state of this Message to the specified boolean.
     * @param b The new delivery state of thie Message.
     */
    public void setDelivered(boolean b) {
        if (b) {
            state |= DELIVERED;
        } else {
            state &= ~DELIVERED;
        }
    }

    /**
     * Creates a new reply to this Message. Replies share the session key
     * with the original Message.
     *
     * @param data The body of the returned Message.
     */
    public Message reply(Object data) {
        Message m = new Message(header, sender, data);
        m.sessionID = sessionID;
        return m;
    }

    /**
     * @return true if this Message has been delivered by the message
     *         service, otherwise return false.
     */
    public boolean delivered() {
        return (state & DELIVERED) != 0;
    }

    /**
     * @return true if this Message has been received by the message
     *         service, otherwise return false.
     */
    public boolean received() {
        return (state & RECEIVED) != 0;
    }

    /**
     * This method is invoked when the reference count for this object
     * is set to zero, meaning no objects (modules) are referencing it,
     * thus it's safe to change the content.
     */
    protected synchronized void consume() {
        if (body instanceof ManagedObject) {
            ((ManagedObject) body).unref();
            //ManagedObject mo = (ManagedObject) body;
            //if (mo.getIsManaged()) {
            //	mo.unref();
            //}
        }
        super.consume();
    }

    public Message(util.ObjectManager m) {
        super(m);
    }

    public Message clone() {
        return new Message(manager);
    }

    /**
     */
    private Module sourceModule = null;

    public void send() throws MessageDeliveryException {
        if (sourceModule == null) {
            throw new MessageDeliveryException(sourceModule, this, ""no source module"");
        }
        sourceModule.sendMessage(this);
    }

    /**
     * @param source the module from which to send this message.
     */
    public void send(Module source) throws MessageDeliveryException {
        source.sendMessage(this);
    }

    /**
     * @param source the module from which to send this message.
     */
    public void sendFrom(Module source) throws MessageDeliveryException {
        source.sendMessage(this);
    }

    /**
     * @param destinatino the module to which to send this message.
     */
    public void sendTo(Module destination) throws MessageDeliveryException {
        destination.receiveMessage(this);
    }

    /**
     * Return a string representation of this Message.
     * @return a string representation of this object.
     */
    public String toString() {
        return ""Message[id="" + messageID + "",session="" + sessionID + "",head="" + header + "",recip="" + recipient + "",sender="" + sender + "",state="" + state + "",ttl="" + timetolive + "",time="" + timestamp + "",body="" + body + ""]"";
    }
}
","// Message_0Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#reply(Object)} method.
*/
class Message_0Test {","// Message_0Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#reply(Object)} method.
*/
class Message_0Test {
"
cmpl-6tumhte0OPgvSUw49VYP9h5oCvy5i,/EvoSuiteBenchmark/27_gangup/src/main/java/module/Message_1Test.java,87.42551517486572,length,"// Message.java
/* $Id: Message.java,v 1.6 2004/04/27 19:26:21 bja Exp $ 
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.6 $
 *
 */
package module;

import util.ManagedObject;

/**
 * The Message class provides the common data link between modules. It's
 * sole purpose is to move data from one module to another.
 */
public class Message extends ManagedObject {

    /**
     * Enumeration of possible message states
     */
    public static final int UNDEFINED = 0;

    public static final int CREATED = 1;

    public static final int RECEIVED = 2;

    public static final int DELIVERED = 4;

    /**
     * Default time to live in milliseconds.
     */
    public static final int TIME_TO_LIVE = 3000;

    /**
     * The number of instantiated messages.
     */
    private static long messages;

    /**
     * Integer that uniqely identifies this message.
     */
    long messageID;

    /**
     * Integer that uniqely identifies this session.
     */
    long sessionID;

    /**
     * The header or class of this message.
     */
    String header;

    /**
     * The name of the module this message orignitated from.
     */
    String sender;

    /**
     * The name of the module this message is destined for.
     */
    String recipient;

    /**
     * The content or data of this message.
     */
    Object body;

    /**
     * The time when this message was created.
     */
    long timestamp;

    /**
     * The maximum time to live in milliseconds.
     */
    long timetolive;

    /**
     * The current state of this message.
     */
    int state;

    /**
     * Create a new Message instance without topic and data.
     */
    public Message() {
        //this(null, ""*"", null);
    }

    /**
     * Create a new Message instance with the specified
     * topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public Message(String topic, Object data) {
        this(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified
     * topic, recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recipient The recipient of this message.
     * @param data The data associated with this message.
     */
    public Message(String topic, String recipient, Object data) {
        timestamp = System.currentTimeMillis();
        timetolive = TIME_TO_LIVE;
        state = CREATED;
        this.header = topic;
        this.recipient = recipient;
        setBody(data);
        ;
        synchronized (this) {
            messageID = messages++;
        }
        sessionID = messageID;
        sender = null;
    }

    /**
     * Set the content of this message to the specified values.
     *
     * @param topic
     * @param recipient
     * @param data
     */
    public void set(String topic, String recipient, Object data) {
        timestamp = System.currentTimeMillis();
        timetolive = TIME_TO_LIVE;
        state = CREATED;
        header = topic;
        setBody(data);
        ;
        this.recipient = recipient;
        synchronized (this) {
            messageID = messages++;
        }
        sessionID = messageID;
        sender = null;
    }

    public long getID() {
        return messageID;
    }

    public long getSID() {
        return sessionID;
    }

    public long getTTL() {
        return timetolive;
    }

    public long getTimeStamp() {
        return timestamp;
    }

    public int getState() {
        return state;
    }

    /**
     * Sets the topic attribute of this message to the specified value.
     * @param name the name of the topic to send this message to.
     */
    public void setHeader(String topic) {
        header = topic;
    }

    /**
     * Returns The header of this message.
     * @return The header of this message.
     */
    public String getHeader() {
        return header == null ? """" : header;
    }

    /**
     * Sets the body attribute of this message to the specified value.
     * @param data the data associated with this message.
     */
    public void setBody(Object data) {
        if (data instanceof ManagedObject) {
            ((ManagedObject) data).ref();
        }
        body = data;
    }

    /**
     * Returns The body of this message.
     * @return The body of this message.
     */
    public Object getBody() {
        return body == null ? """" : body;
    }

    /**
     * Sets the sender attribute of this message to the specified value.
     * @param name the name of the module that sent this message.
     */
    public void setSender(String name) {
        sender = name;
    }

    /**
     * Returns the name of the module this message originated from.
     * @return The name of the module this message originated from.
     */
    public String getSender() {
        return sender;
    }

    /**
     * Returns the name of the module this message is destined for.
     * @return The name of the module this message is destined for.
     */
    public String getRecipient() {
        return recipient;
    }

    /**
     * Sets the recipient attribute of this message to the specified value.
     * @param name the name of the module that this message is destined for.
     */
    public void setRecipient(String name) {
        recipient = name;
    }

    /**
     * Sets the delivery state of this Message to the specified boolean.
     * @param b The new delivery state of thie Message.
     */
    public void setDelivered(boolean b) {
        if (b) {
            state |= DELIVERED;
        } else {
            state &= ~DELIVERED;
        }
    }

    /**
     * Creates a new reply to this Message. Replies share the session key
     * with the original Message.
     *
     * @param data The body of the returned Message.
     */
    public Message reply(Object data) {
        Message m = new Message(header, sender, data);
        m.sessionID = sessionID;
        return m;
    }

    /**
     * @return true if this Message has been delivered by the message
     *         service, otherwise return false.
     */
    public boolean delivered() {
        return (state & DELIVERED) != 0;
    }

    /**
     * @return true if this Message has been received by the message
     *         service, otherwise return false.
     */
    public boolean received() {
        return (state & RECEIVED) != 0;
    }

    /**
     * This method is invoked when the reference count for this object
     * is set to zero, meaning no objects (modules) are referencing it,
     * thus it's safe to change the content.
     */
    protected synchronized void consume() {
        if (body instanceof ManagedObject) {
            ((ManagedObject) body).unref();
            //ManagedObject mo = (ManagedObject) body;
            //if (mo.getIsManaged()) {
            //	mo.unref();
            //}
        }
        super.consume();
    }

    public Message(util.ObjectManager m) {
        super(m);
    }

    public Message clone() {
        return new Message(manager);
    }

    /**
     */
    private Module sourceModule = null;

    public void send() throws MessageDeliveryException {
        if (sourceModule == null) {
            throw new MessageDeliveryException(sourceModule, this, ""no source module"");
        }
        sourceModule.sendMessage(this);
    }

    /**
     * @param source the module from which to send this message.
     */
    public void send(Module source) throws MessageDeliveryException {
        source.sendMessage(this);
    }

    /**
     * @param source the module from which to send this message.
     */
    public void sendFrom(Module source) throws MessageDeliveryException {
        source.sendMessage(this);
    }

    /**
     * @param destinatino the module to which to send this message.
     */
    public void sendTo(Module destination) throws MessageDeliveryException {
        destination.receiveMessage(this);
    }

    /**
     * Return a string representation of this Message.
     * @return a string representation of this object.
     */
    public String toString() {
        return ""Message[id="" + messageID + "",session="" + sessionID + "",head="" + header + "",recip="" + recipient + "",sender="" + sender + "",state="" + state + "",ttl="" + timetolive + "",time="" + timestamp + "",body="" + body + ""]"";
    }
}
","// Message_1Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#delivered()} method.
*/
class Message_1Test {","// Message_1Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#delivered()} method.
*/
class Message_1Test {

	/**
	* Test case 1 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 0.
	* The expected result is false.
	*/
	@Test
	void testDelivered_1() {
		Message message = new Message();
		message.state = 0;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 2 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 1.
	* The expected result is false.
	*/
	@Test
	void testDelivered_2() {
		Message message = new Message();
		message.state = 1;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 3 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 2.
	* The expected result is false.
	*/
	@Test
	void testDelivered_3() {
		Message message = new Message();
		message.state = 2;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 4 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 3.
	* The expected result is false.
	*/
	@Test
	void testDelivered_4() {
		Message message = new Message();
		message.state = 3;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 5 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 4.
	* The expected result is true.
	*/
	@Test
	void testDelivered_5() {
		Message message = new Message();
		message.state = 4;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 6 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 5.
	* The expected result is true.
	*/
	@Test
	void testDelivered_6() {
		Message message = new Message();
		message.state = 5;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 7 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 6.
	* The expected result is true.
	*/
	@Test
	void testDelivered_7() {
		Message message = new Message();
		message.state = 6;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 8 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 7.
	* The expected result is true.
	*/
	@Test
	void testDelivered_8() {
		Message message = new Message();
		message.state = 7;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 9 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 8.
	* The expected result is false.
	*/
	@Test
	void testDelivered_9() {
		Message message = new Message();
		message.state = 8;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 10 for {@link Message#delivered()}.
	* This test case tests the delivered method with the state set to 9.
	* The expected result is false.
	*/
	@Test
	void testDelivered_10() {
		Message message = new Message();
		message.state = 9;
		assertFalse(message.delivered());
	}
}

// Message_2Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#received()} method.
*/
class Message_2Test {
		
	/**
	* Test case 1 for {@link Message#received()}.
	* This test case tests the received method with the state set to 0.
	* The expected result is false.
	*/
	@Test
	void testReceived_1() {
		Message message = new Message();
		message.state = 0;
		assertFalse(message.received());
	}
	
	/**
	* Test case 2 for {@link Message#received()}.
	* This test case tests the received method with the state set to 1.
	* The expected result is false.
	*/
	@Test
	void testReceived_2() {
		Message message = new Message();
		message.state = 1;
		assertFalse(message.received());
	}
	
	/**
	* Test case 3 for {@link Message#received()}.
	* This test case tests the received method with the state set to 2.
	* The expected result is true.
	*/
	@Test
	void testReceived_3() {
		Message message = new Message();
		message.state = 2;
		assertTrue(message.received());
	}
	
	/**
	* Test case 4 for {@link Message#received()}.
	* This test case tests the received method with the state set to 3.
	* The expected result is true.
	*/
	@Test
	void testReceived_4() {
		Message message = new Message();
		message.state = 3;
		assertTrue(message.received());
	}
	
	/**
	* Test case 5 for {@link Message#received()}.
	* This test case tests the received method with the state set to 4.
	* The expected result is true.
	*/
	@Test
	void testReceived_5() {
		Message message = new Message();
		message.state = 4;
		assertTrue(message.received());
	}
	
	/**
	* Test case 6 for {@link Message#received()}.
	* This test case tests the received method with the state set to 5.
	* The expected result is true.
	*/
	@Test
	void testReceived_6() {
		Message message = new Message();
		message.state = 5;
		assertTrue(message.received());
	}
	
	/**
	* Test case 7 for {@link Message#received()}.
	* This test case tests the received method with the state set to 6.
	* The expected result is true.
	*/
	@Test
	void testReceived_7() {
		Message message = new Message();
		message.state = 6;
		assertTrue(message.received());
	}
	
	/**
	* Test case 8 for {@link Message#received()}.
	* This test case tests the received method with the state set to 7.
	* The expected result is true.
	*/
	@Test
	void testReceived_8() {
		Message message = new Message();
		message.state = 7;
		assertTrue(message.received());
	}
	
	/**
	* Test case 9 for {@link Message#received()}.
	* This test case tests the received method with the state set to 8.
	* The expected result is false.
	*/
	@Test
	void testReceived_9() {
		Message message = new Message();
		message.state = 8;
		assertFalse(message.received());
	}
	
	/**
	* Test case 10 for {@link Message#received()}.
	* This test case tests the received method with the state set to 9.
	* The expected result is false.
	*/
	@Test
	void testReceived_10() {
		Message message = new Message();
		message.state = 9;
		assertFalse(message.received());
	}
}

// Message_3Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#setDelivered(boolean)} method.
*/
class Message_3Test {
		
	/**
	* Test case 1 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 0 and the boolean set to true.
	* The expected result is 4.
	*/
	@Test
	void testSetDelivered_1() {
		Message message = new Message();
		message.state = 0;
		message.setDelivered(true);
		assertEquals(4, message.state);
	}
	
	/**
	* Test case 2 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 1 and the boolean set to true.
	* The expected result is 5.
	*/
	@Test
	void testSetDelivered_2() {
		Message message = new Message();
		message.state = 1;
		message.setDelivered(true);
		assertEquals(5, message.state);
	}
	
	/**
	* Test case 3 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 2 and the boolean set to true.
	* The expected result is 6.
	*/
	@Test
	void testSetDelivered_3() {
		Message message = new Message();
		message.state = 2;
		message.setDelivered(true);
		assertEquals(6, message.state);
	}
	
	/**
	* Test case 4 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 3 and the boolean set to true.
	* The expected result is 7.
	*/
	@Test
	void testSetDelivered_4() {
		Message message = new Message();
		message.state = 3;
		message.setDelivered(true);
		assertEquals(7, message.state);
	}
	
	/**
	* Test case 5 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 4 and the boolean set to true.
	* The expected result is 4.
	*/
	@Test
	void testSetDelivered_5() {
		Message message = new Message();
		message.state = 4;
		message.setDelivered(true);
		assertEquals(4, message.state);
	}
	
	/**
	* Test case 6 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 5 and the boolean set to true.
	* The expected result is 5.
	*/
	@Test
	void testSetDelivered_6() {
		Message message = new Message();
		message.state = 5;
		message.setDelivered(true);
		assertEquals(5, message.state);
	}
	
	/**
	* Test case 7 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 6 and the boolean set to true.
	* The expected result is 6.
	*/
	@Test
	void testSetDelivered_7() {
		Message message = new Message();
		message.state = 6;
		message.setDelivered(true);
		assertEquals(6, message.state);
	}
	
	/**
	* Test case 8 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 7 and the boolean set to true.
	* The expected result is 7.
	*/
	@Test
	void testSetDelivered_8() {
		Message message = new Message();
		message.state = 7;
		message.setDelivered(true);
		assertEquals(7, message.state);
	}
	
	/**
	* Test case 9 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 8 and the boolean set to true.
	* The expected result is 8.
	*/
	@Test
	void testSetDelivered_9() {
		Message message = new Message();
		message.state = 8;
		message.setDelivered(true);
		assertEquals(8, message.state);
	}
	
	/**
	* Test case 10 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 9 and the boolean set to true.
	* The expected result is 9.
	*/
	@Test
	void testSetDelivered_10() {
		Message message = new Message();
		message.state = 9;
		message.setDelivered(true);
		assertEquals(9, message.state);
	}
}

// Message_4Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#setDelivered(boolean)} method.
*/
class Message_4Test {
		
	/**
	* Test case 1 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 0 and the boolean set to false.
	* The expected result is 0.
	*/
	@Test
	void testSetDelivered_1() {
		Message message = new Message();
		message.state = 0;
		message.setDelivered(false);
		assertEquals(0, message.state);
	}
	
	/**
	* Test case 2 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 1 and the boolean set to false.
	* The expected result is 1.
	*/
	@Test
	void testSetDelivered_2() {
		Message message = new Message();
		message.state = 1;
		message.setDelivered(false);
		assertEquals(1, message.state);
	}
	
	/**
	* Test case 3 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 2 and the boolean set to false.
	* The expected result is 2.
	*/
	@Test
	void testSetDelivered_3() {
		Message message = new Message();
		message.state = 2;
		message.setDelivered(false);
		assertEquals(2, message.state);
	}
	
	/**
	* Test case 4 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 3 and the boolean set to false.
	* The expected result is 3.
	*/
	@Test
	void testSetDelivered_4() {
		Message message = new Message();
		message.state = 3;
		message.setDelivered(false);
		assertEquals(3, message.state);
	}
	
	/**
	* Test case 5 for {@link Message#setDelivered(boolean)}.
	* This test case tests the setDelivered method with the state set to 4 and the boolean set to false.
	* The expected result is 0.
	*/
	@Test
	void testSetDelivered_5() {
		Message message = new Message();
		"
cmpl-6tuo6jfwPHZ2Lid4HV7I5XaDVo3Ok,/EvoSuiteBenchmark/27_gangup/src/main/java/module/Message_2Test.java,93.08917808532715,length,"// Message.java
/* $Id: Message.java,v 1.6 2004/04/27 19:26:21 bja Exp $ 
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.6 $
 *
 */
package module;

import util.ManagedObject;

/**
 * The Message class provides the common data link between modules. It's
 * sole purpose is to move data from one module to another.
 */
public class Message extends ManagedObject {

    /**
     * Enumeration of possible message states
     */
    public static final int UNDEFINED = 0;

    public static final int CREATED = 1;

    public static final int RECEIVED = 2;

    public static final int DELIVERED = 4;

    /**
     * Default time to live in milliseconds.
     */
    public static final int TIME_TO_LIVE = 3000;

    /**
     * The number of instantiated messages.
     */
    private static long messages;

    /**
     * Integer that uniqely identifies this message.
     */
    long messageID;

    /**
     * Integer that uniqely identifies this session.
     */
    long sessionID;

    /**
     * The header or class of this message.
     */
    String header;

    /**
     * The name of the module this message orignitated from.
     */
    String sender;

    /**
     * The name of the module this message is destined for.
     */
    String recipient;

    /**
     * The content or data of this message.
     */
    Object body;

    /**
     * The time when this message was created.
     */
    long timestamp;

    /**
     * The maximum time to live in milliseconds.
     */
    long timetolive;

    /**
     * The current state of this message.
     */
    int state;

    /**
     * Create a new Message instance without topic and data.
     */
    public Message() {
        //this(null, ""*"", null);
    }

    /**
     * Create a new Message instance with the specified
     * topic and data.
     *
     * @param topic The topic this messages is published to.
     * @param data The data associated with this message.
     */
    public Message(String topic, Object data) {
        this(topic, ""*"", data);
    }

    /**
     * Create a new Message instance with the specified
     * topic, recipient, and data.
     *
     * @param topic The topic this messages is published to.
     * @param recipient The recipient of this message.
     * @param data The data associated with this message.
     */
    public Message(String topic, String recipient, Object data) {
        timestamp = System.currentTimeMillis();
        timetolive = TIME_TO_LIVE;
        state = CREATED;
        this.header = topic;
        this.recipient = recipient;
        setBody(data);
        ;
        synchronized (this) {
            messageID = messages++;
        }
        sessionID = messageID;
        sender = null;
    }

    /**
     * Set the content of this message to the specified values.
     *
     * @param topic
     * @param recipient
     * @param data
     */
    public void set(String topic, String recipient, Object data) {
        timestamp = System.currentTimeMillis();
        timetolive = TIME_TO_LIVE;
        state = CREATED;
        header = topic;
        setBody(data);
        ;
        this.recipient = recipient;
        synchronized (this) {
            messageID = messages++;
        }
        sessionID = messageID;
        sender = null;
    }

    public long getID() {
        return messageID;
    }

    public long getSID() {
        return sessionID;
    }

    public long getTTL() {
        return timetolive;
    }

    public long getTimeStamp() {
        return timestamp;
    }

    public int getState() {
        return state;
    }

    /**
     * Sets the topic attribute of this message to the specified value.
     * @param name the name of the topic to send this message to.
     */
    public void setHeader(String topic) {
        header = topic;
    }

    /**
     * Returns The header of this message.
     * @return The header of this message.
     */
    public String getHeader() {
        return header == null ? """" : header;
    }

    /**
     * Sets the body attribute of this message to the specified value.
     * @param data the data associated with this message.
     */
    public void setBody(Object data) {
        if (data instanceof ManagedObject) {
            ((ManagedObject) data).ref();
        }
        body = data;
    }

    /**
     * Returns The body of this message.
     * @return The body of this message.
     */
    public Object getBody() {
        return body == null ? """" : body;
    }

    /**
     * Sets the sender attribute of this message to the specified value.
     * @param name the name of the module that sent this message.
     */
    public void setSender(String name) {
        sender = name;
    }

    /**
     * Returns the name of the module this message originated from.
     * @return The name of the module this message originated from.
     */
    public String getSender() {
        return sender;
    }

    /**
     * Returns the name of the module this message is destined for.
     * @return The name of the module this message is destined for.
     */
    public String getRecipient() {
        return recipient;
    }

    /**
     * Sets the recipient attribute of this message to the specified value.
     * @param name the name of the module that this message is destined for.
     */
    public void setRecipient(String name) {
        recipient = name;
    }

    /**
     * Sets the delivery state of this Message to the specified boolean.
     * @param b The new delivery state of thie Message.
     */
    public void setDelivered(boolean b) {
        if (b) {
            state |= DELIVERED;
        } else {
            state &= ~DELIVERED;
        }
    }

    /**
     * Creates a new reply to this Message. Replies share the session key
     * with the original Message.
     *
     * @param data The body of the returned Message.
     */
    public Message reply(Object data) {
        Message m = new Message(header, sender, data);
        m.sessionID = sessionID;
        return m;
    }

    /**
     * @return true if this Message has been delivered by the message
     *         service, otherwise return false.
     */
    public boolean delivered() {
        return (state & DELIVERED) != 0;
    }

    /**
     * @return true if this Message has been received by the message
     *         service, otherwise return false.
     */
    public boolean received() {
        return (state & RECEIVED) != 0;
    }

    /**
     * This method is invoked when the reference count for this object
     * is set to zero, meaning no objects (modules) are referencing it,
     * thus it's safe to change the content.
     */
    protected synchronized void consume() {
        if (body instanceof ManagedObject) {
            ((ManagedObject) body).unref();
            //ManagedObject mo = (ManagedObject) body;
            //if (mo.getIsManaged()) {
            //	mo.unref();
            //}
        }
        super.consume();
    }

    public Message(util.ObjectManager m) {
        super(m);
    }

    public Message clone() {
        return new Message(manager);
    }

    /**
     */
    private Module sourceModule = null;

    public void send() throws MessageDeliveryException {
        if (sourceModule == null) {
            throw new MessageDeliveryException(sourceModule, this, ""no source module"");
        }
        sourceModule.sendMessage(this);
    }

    /**
     * @param source the module from which to send this message.
     */
    public void send(Module source) throws MessageDeliveryException {
        source.sendMessage(this);
    }

    /**
     * @param source the module from which to send this message.
     */
    public void sendFrom(Module source) throws MessageDeliveryException {
        source.sendMessage(this);
    }

    /**
     * @param destinatino the module to which to send this message.
     */
    public void sendTo(Module destination) throws MessageDeliveryException {
        destination.receiveMessage(this);
    }

    /**
     * Return a string representation of this Message.
     * @return a string representation of this object.
     */
    public String toString() {
        return ""Message[id="" + messageID + "",session="" + sessionID + "",head="" + header + "",recip="" + recipient + "",sender="" + sender + "",state="" + state + "",ttl="" + timetolive + "",time="" + timestamp + "",body="" + body + ""]"";
    }
}
","// Message_2Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#received()} method.
*/
class Message_2Test {","// Message_2Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#received()} method.
*/
class Message_2Test {

	/**
	* Test case 1 for {@link Message#received()}.
	* This test case tests the method with a message that has been received.
	*/
	@Test
	void testReceived_1() {
		Message message = new Message();
		message.state = Message.RECEIVED;
		assertTrue(message.received());
	}
	
	/**
	* Test case 2 for {@link Message#received()}.
	* This test case tests the method with a message that has not been received.
	*/
	@Test
	void testReceived_2() {
		Message message = new Message();
		message.state = Message.CREATED;
		assertFalse(message.received());
	}
	
	/**
	* Test case 3 for {@link Message#received()}.
	* This test case tests the method with a message that has been received and delivered.
	*/
	@Test
	void testReceived_3() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.DELIVERED;
		assertTrue(message.received());
	}
	
	/**
	* Test case 4 for {@link Message#received()}.
	* This test case tests the method with a message that has been delivered.
	*/
	@Test
	void testReceived_4() {
		Message message = new Message();
		message.state = Message.DELIVERED;
		assertFalse(message.received());
	}
	
	/**
	* Test case 5 for {@link Message#received()}.
	* This test case tests the method with a message that has been received and delivered and has an undefined state.
	*/
	@Test
	void testReceived_5() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.DELIVERED | Message.UNDEFINED;
		assertTrue(message.received());
	}
	
	/**
	* Test case 6 for {@link Message#received()}.
	* This test case tests the method with a message that has been delivered and has an undefined state.
	*/
	@Test
	void testReceived_6() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.UNDEFINED;
		assertFalse(message.received());
	}
	
	/**
	* Test case 7 for {@link Message#received()}.
	* This test case tests the method with a message that has been received and has an undefined state.
	*/
	@Test
	void testReceived_7() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.UNDEFINED;
		assertTrue(message.received());
	}
	
	/**
	* Test case 8 for {@link Message#received()}.
	* This test case tests the method with a message that has an undefined state.
	*/
	@Test
	void testReceived_8() {
		Message message = new Message();
		message.state = Message.UNDEFINED;
		assertFalse(message.received());
	}
	
	/**
	* Test case 9 for {@link Message#received()}.
	* This test case tests the method with a message that has been received and delivered and has an undefined state.
	*/
	@Test
	void testReceived_9() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.DELIVERED | Message.UNDEFINED;
		assertTrue(message.received());
	}
	
	/**
	* Test case 10 for {@link Message#received()}.
	* This test case tests the method with a message that has been delivered and has an undefined state.
	*/
	@Test
	void testReceived_10() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.UNDEFINED;
		assertFalse(message.received());
	}
}

// Message_3Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#delivered()} method.
*/
class Message_3Test {
		
	/**
	* Test case 1 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been delivered.
	*/
	@Test
	void testDelivered_1() {
		Message message = new Message();
		message.state = Message.DELIVERED;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 2 for {@link Message#delivered()}.
	* This test case tests the method with a message that has not been delivered.
	*/
	@Test
	void testDelivered_2() {
		Message message = new Message();
		message.state = Message.CREATED;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 3 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been delivered and received.
	*/
	@Test
	void testDelivered_3() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 4 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been received.
	*/
	@Test
	void testDelivered_4() {
		Message message = new Message();
		message.state = Message.RECEIVED;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 5 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been delivered and received and has an undefined state.
	*/
	@Test
	void testDelivered_5() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED | Message.UNDEFINED;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 6 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been received and has an undefined state.
	*/
	@Test
	void testDelivered_6() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.UNDEFINED;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 7 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been delivered and has an undefined state.
	*/
	@Test
	void testDelivered_7() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.UNDEFINED;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 8 for {@link Message#delivered()}.
	* This test case tests the method with a message that has an undefined state.
	*/
	@Test
	void testDelivered_8() {
		Message message = new Message();
		message.state = Message.UNDEFINED;
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 9 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been delivered and received and has an undefined state.
	*/
	@Test
	void testDelivered_9() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED | Message.UNDEFINED;
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 10 for {@link Message#delivered()}.
	* This test case tests the method with a message that has been received and has an undefined state.
	*/
	@Test
	void testDelivered_10() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.UNDEFINED;
		assertFalse(message.delivered());
	}
}

// Message_4Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#setDelivered(boolean)} method.
*/
class Message_4Test {
		
	/**
	* Test case 1 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been delivered.
	*/
	@Test
	void testSetDelivered_1() {
		Message message = new Message();
		message.state = Message.DELIVERED;
		message.setDelivered(true);
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 2 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has not been delivered.
	*/
	@Test
	void testSetDelivered_2() {
		Message message = new Message();
		message.state = Message.CREATED;
		message.setDelivered(false);
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 3 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been delivered and received.
	*/
	@Test
	void testSetDelivered_3() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED;
		message.setDelivered(true);
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 4 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been received.
	*/
	@Test
	void testSetDelivered_4() {
		Message message = new Message();
		message.state = Message.RECEIVED;
		message.setDelivered(false);
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 5 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been delivered and received and has an undefined state.
	*/
	@Test
	void testSetDelivered_5() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED | Message.UNDEFINED;
		message.setDelivered(true);
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 6 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been received and has an undefined state.
	*/
	@Test
	void testSetDelivered_6() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.UNDEFINED;
		message.setDelivered(false);
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 7 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been delivered and has an undefined state.
	*/
	@Test
	void testSetDelivered_7() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.UNDEFINED;
		message.setDelivered(true);
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 8 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has an undefined state.
	*/
	@Test
	void testSetDelivered_8() {
		Message message = new Message();
		message.state = Message.UNDEFINED;
		message.setDelivered(false);
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 9 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been delivered and received and has an undefined state.
	*/
	@Test
	void testSetDelivered_9() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED | Message.UNDEFINED;
		message.setDelivered(true);
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 10 for {@link Message#setDelivered(boolean)}.
	* This test case tests the method with a message that has been received and has an undefined state.
	*/
	@Test
	void testSetDelivered_10() {
		Message message = new Message();
		message.state = Message.RECEIVED | Message.UNDEFINED;
		message.setDelivered(false);
		assertFalse(message.delivered());
	}
}

// Message_5Test.java
package module;

import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Message}.
* It contains ten unit test cases for the {@link Message#reply(Object)} method.
*/
class Message_5Test {
		
	/**
	* Test case 1 for {@link Message#reply(Object)}.
	* This test case tests the method with a message that has been delivered.
	*/
	@Test
	void testReply_1() {
		Message message = new Message();
		message.state = Message.DELIVERED;
		message.reply(null);
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 2 for {@link Message#reply(Object)}.
	* This test case tests the method with a message that has not been delivered.
	*/
	@Test
	void testReply_2() {
		Message message = new Message();
		message.state = Message.CREATED;
		message.reply(null);
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 3 for {@link Message#reply(Object)}.
	* This test case tests the method with a message that has been delivered and received.
	*/
	@Test
	void testReply_3() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED;
		message.reply(null);
		assertTrue(message.delivered());
	}
	
	/**
	* Test case 4 for {@link Message#reply(Object)}.
	* This test case tests the method with a message that has been received.
	*/
	@Test
	void testReply_4() {
		Message message = new Message();
		message.state = Message.RECEIVED;
		message.reply(null);
		assertFalse(message.delivered());
	}
	
	/**
	* Test case 5 for {@link Message#reply(Object)}.
	* This test case tests the method with a message that has been delivered and received and has an undefined state.
	*/
	@Test
	void testReply_5() {
		Message message = new Message();
		message.state = Message.DELIVERED | Message.RECEIVED | Message.UNDEFINED;
		message.reply(null);
		assertTrue(message.delivered());
	}
	
	"
cmpl-6tupbmxoirrX6toM2kNNgeilxJPTw,/EvoSuiteBenchmark/27_gangup/src/main/java/module/ModuleInfo.java,17.924615621566772,stop,"// ModuleInfo.java
/* $Id: ModuleInfo.java,v 1.4 2004/04/27 19:26:21 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.4 $
 *
 */
package module;

import java.lang.annotation.*;
import java.util.regex.*;
import java.lang.reflect.*;
import java.util.*;

/**
 * Contains module specific information. The information contained
 * within the ModuleInfo is mainly used for debugging.
 */
public class ModuleInfo {

    String file;

    String revision;

    String date;

    String author;

    String tag;

    String name;

    String desc;

    String cmds;

    String topics;

    /**
     * Hashtable containing all annotations.
     */
    private Hashtable<String, String> hash = new Hashtable<String, String>();

    /**
     * Regular expression that splits annotations into key and value,
     * It cannot handle commas and right parens inside values, see BUGS!
     */
    private static Pattern p = Pattern.compile(""(\\p{Alpha}+)=(?:[$]\\p{Alpha}+[:]\\s*)?"" + ""(([\\p{Graph}&&[^=,$)]]|\\p{Blank})*)[$]?"");

    /**
     * Creates a new instance of the ModuleInfo class.
     */
    public ModuleInfo() {
    }

    /**
     * Creates a new instance of the ModuleInfo class.
     * @param mod The module which to build info for.
     */
    public ModuleInfo(Module mod) {
        this(mod.getClass().getAnnotations());
    }

    /**
     * Creates a new instance of the ModuleInfo class using the specified
     * annotation array.
     *
     * @param av Array of Annotation objects to build info from.
     */
    public ModuleInfo(Annotation[] av) {
        /* Get annotations and put them into hashtable. */
        for (Annotation a : av) {
            Matcher m = p.matcher(a.toString());
            while (m.find()) {
                hash.put(m.group(1), m.group(2));
            }
        }
        /* Fill in instance variables with values contained in hash. */
        for (Field f : getClass().getDeclaredFields()) {
            try {
                String val = get(f.getName());
                if (val != null) {
                    f.set(this, val);
                }
            } catch (Exception e) {
                e.printStackTrace(System.err);
            }
        }
    }

    /**
     * Returns the value of the specified annotation field.
     *
     * @param key the annotation field to get.
     * @return the value of the specified annotation field.
     */
    public String get(String key) {
        return hash.get(key);
    }

    /**
     * Sets the value of the specified attribute to the given value.
     *
     * @param key the annotation field to get.
     * @param val the value to set.
     */
    public void set(String key, String val) {
        try {
            hash.put(key, val);
            Field f = getClass().getDeclaredField(key);
            f.set(this, val);
        } catch (NoSuchFieldException e) {
            // not a problem really.
            //e.printStackTrace(System.err);
        } catch (IllegalArgumentException e) {
            // neither is this.
            //e.printStackTrace(System.err);
        } catch (IllegalAccessException e) {
            // do not use security manager.
            //e.printStackTrace(System.err);
        }
    }

    public void update() {
        hash.put(""name"", name);
    }

    public String toString() {
        return hash.toString();
    }
}
","// ModuleInfoTest.java
package module;

import java.lang.annotation.*;
import java.util.regex.*;
import java.lang.reflect.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModuleInfo}.
* It contains ten unit test cases for the {@link ModuleInfo#get(String)} method.
*/
class ModuleInfoTest {","// ModuleInfoTest.java
package module;

import java.lang.annotation.*;
import java.util.regex.*;
import java.lang.reflect.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ModuleInfo}.
* It contains ten unit test cases for the {@link ModuleInfo#get(String)} method.
*/
class ModuleInfoTest {

		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet2() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet3() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet4() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet5() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet6() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet7() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet8() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet9() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
		
		/**
		* Test case for the {@link ModuleInfo#get(String)} method.
		* It tests if the method returns the correct value for the specified key.
		*/
		@Test
		void testGet10() {
				ModuleInfo mi = new ModuleInfo();
				mi.set(""name"", ""test"");
				assertEquals(""test"", mi.get(""name""));
		}
}"
8aaf531f-7218-42f9-bc90-e96e70e14c4d,/EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionFactory_0Test.java,-1,"ERROR - Error communicating with OpenAI: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))","// ActionFactory.java
/* $Id: ActionFactory.java,v 1.2 2004/04/27 19:26:22 bja Exp $ */
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;

public class ActionFactory extends AbstractFactory<Action> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static ActionFactory instance = null;

    /**
     * Creates a new instance of the ActionFactory class.
     */
    private ActionFactory() {
        super(new Action());
    }

    /**
     * Creates a new default Action with the specified arguments.
     *
     * @param type The type of Action to create.
     * @param actor The actorID associated with this Action.
     * @param target The targetID associated with this Action.
     * @return a new Action instance with the specified arguments.
     */
    public Action createAction(int type, int actor, int target) {
        Action action = createObject();
        action.set(type, actor, target, (byte) 0, (byte) 0, (byte) 0);
        System.err.println(""ActionFactory.createAction(): size = "" + getStockCount());
        return action;
    }

    /**
     * Creates a new move Action with the specified arguments.
     *
     * @param actor The actorID associated with this Action.
     * @param x the x coordinate of the destination point.
     * @param y the y coordinate of the destination point.
     * @param z the z coordinate of the destination point.
     * @return a new move Action with the specified arguments.
     */
    public Action createMoveAction(int actor, byte x, byte y, byte z) {
        Action action = createObject();
        action.set(Action.ACTION_MOVE, actor, -1, x, y, z);
        System.err.println(""ActionFactory.createAction(): size = "" + getStockCount());
        return action;
    }

    /**
     * Returns the ActionFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static ActionFactory getInstance() {
        return instance != null ? instance : new ActionFactory();
    }
}
","// ActionFactory_0Test.java
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ActionFactory}.
* It contains ten unit test cases for the {@link ActionFactory#createAction(int, int, int)} method.
*/
class ActionFactory_0Test {","// ActionFactory_0Test.java
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ActionFactory}.
* It contains ten unit test cases for the {@link ActionFactory#createAction(int, int, int)} method.
*/
class ActionFactory_0Test {
"
5b3186ec-36c9-4d52-a18d-5d0d870f8cfe,/EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionFactory_1Test.java,-1,"ERROR - Request timed out: HTTPSConnectionPool(host='api.openai.com', port=443): Read timed out. (read timeout=600)","// ActionFactory.java
/* $Id: ActionFactory.java,v 1.2 2004/04/27 19:26:22 bja Exp $ */
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;

public class ActionFactory extends AbstractFactory<Action> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static ActionFactory instance = null;

    /**
     * Creates a new instance of the ActionFactory class.
     */
    private ActionFactory() {
        super(new Action());
    }

    /**
     * Creates a new default Action with the specified arguments.
     *
     * @param type The type of Action to create.
     * @param actor The actorID associated with this Action.
     * @param target The targetID associated with this Action.
     * @return a new Action instance with the specified arguments.
     */
    public Action createAction(int type, int actor, int target) {
        Action action = createObject();
        action.set(type, actor, target, (byte) 0, (byte) 0, (byte) 0);
        System.err.println(""ActionFactory.createAction(): size = "" + getStockCount());
        return action;
    }

    /**
     * Creates a new move Action with the specified arguments.
     *
     * @param actor The actorID associated with this Action.
     * @param x the x coordinate of the destination point.
     * @param y the y coordinate of the destination point.
     * @param z the z coordinate of the destination point.
     * @return a new move Action with the specified arguments.
     */
    public Action createMoveAction(int actor, byte x, byte y, byte z) {
        Action action = createObject();
        action.set(Action.ACTION_MOVE, actor, -1, x, y, z);
        System.err.println(""ActionFactory.createAction(): size = "" + getStockCount());
        return action;
    }

    /**
     * Returns the ActionFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static ActionFactory getInstance() {
        return instance != null ? instance : new ActionFactory();
    }
}
","// ActionFactory_1Test.java
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ActionFactory}.
* It contains ten unit test cases for the {@link ActionFactory#createMoveAction(int, byte, byte, byte)} method.
*/
class ActionFactory_1Test {","// ActionFactory_1Test.java
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ActionFactory}.
* It contains ten unit test cases for the {@link ActionFactory#createMoveAction(int, byte, byte, byte)} method.
*/
class ActionFactory_1Test {
"
5002bcbe-5895-4d8e-b299-0554e02957f2,/EvoSuiteBenchmark/27_gangup/src/main/java/state/ActionFactory_2Test.java,-1,"ERROR - Request timed out: HTTPSConnectionPool(host='api.openai.com', port=443): Read timed out. (read timeout=600)","// ActionFactory.java
/* $Id: ActionFactory.java,v 1.2 2004/04/27 19:26:22 bja Exp $ */
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;

public class ActionFactory extends AbstractFactory<Action> {

    /**
     * The reference to the MessageFactory instance.
     */
    protected static ActionFactory instance = null;

    /**
     * Creates a new instance of the ActionFactory class.
     */
    private ActionFactory() {
        super(new Action());
    }

    /**
     * Creates a new default Action with the specified arguments.
     *
     * @param type The type of Action to create.
     * @param actor The actorID associated with this Action.
     * @param target The targetID associated with this Action.
     * @return a new Action instance with the specified arguments.
     */
    public Action createAction(int type, int actor, int target) {
        Action action = createObject();
        action.set(type, actor, target, (byte) 0, (byte) 0, (byte) 0);
        System.err.println(""ActionFactory.createAction(): size = "" + getStockCount());
        return action;
    }

    /**
     * Creates a new move Action with the specified arguments.
     *
     * @param actor The actorID associated with this Action.
     * @param x the x coordinate of the destination point.
     * @param y the y coordinate of the destination point.
     * @param z the z coordinate of the destination point.
     * @return a new move Action with the specified arguments.
     */
    public Action createMoveAction(int actor, byte x, byte y, byte z) {
        Action action = createObject();
        action.set(Action.ACTION_MOVE, actor, -1, x, y, z);
        System.err.println(""ActionFactory.createAction(): size = "" + getStockCount());
        return action;
    }

    /**
     * Returns the ActionFactory instance, currently the instance
     * returned is that of the last created MessageFactory.
     */
    public static ActionFactory getInstance() {
        return instance != null ? instance : new ActionFactory();
    }
}
","// ActionFactory_2Test.java
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ActionFactory}.
* It contains ten unit test cases for the {@link ActionFactory#getInstance()} method.
*/
class ActionFactory_2Test {","// ActionFactory_2Test.java
package state;

import util.AbstractFactory;
import util.ObjectManager;
import util.ManagedObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ActionFactory}.
* It contains ten unit test cases for the {@link ActionFactory#getInstance()} method.
*/
class ActionFactory_2Test {
"
cmpl-6tvGwrfdCJwoJ8kZAS9s613850bly,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Action_0Test.java,89.5740716457367,length,"// Action.java
/* $Id: Action.java,v 1.4 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.4 $
 *
 */
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;

/**
 * Interface for all objects that are packable, i.e. objects that are
 * to be sent over the network.
 */
public class Action extends ManagedObject implements Packable {

    public final static int ACTION_JOIN = 0;

    public final static int ACTION_PART = 1;

    public final static int ACTION_ATTACK = 2;

    public final static int ACTION_JOIN_APPLY = 3;

    public final static int ACTION_JOIN_INVITE = 4;

    public final static int ACTION_JOIN_ALLOW = 5;

    public final static int ACTION_JOIN_AGREE = 6;

    public final static int ACTION_MOVE = 7;

    public final static int ACTION_KICK = 8;

    /**
     * Number used by the network module to identify
     * a piece of data as being an Action.
     */
    private static final int PACK_TYPE = Packable.ACTION;

    /**
     * The actor (i.e. the Player that invkoked the action).
     */
    private int actor;

    /**
     * The target (i.e. the Player the action is invoked on).
     */
    private int target;

    /**
     * The type of action this is.
     */
    private int action;

    /**
     * The destination associated with a ACTION_MOVE.
     */
    private byte destX, destY, destZ;

    /**
     * Utility classes, not part of the Action.
     */
    private TaintedByteArrayOutputStream byteOutputStream;

    private TaintedByteArrayInputStream byteInputStream;

    private DataOutputStream outputStream;

    private DataInputStream inputStream;

    /**
     * The manager associated with this Action, if any.
     */
    private ObjectManager manager = null;

    /**
     * Create a new instance of the Action class. Fields are set to
     * default values. The action, actor, and target are set to -1.
     */
    public Action() {
        this(-1, -1, -1);
    }

    /**
     * @param action
     * @param actor
     * @param target
     */
    public Action(int action, int actor, int target) {
        this.actor = actor;
        this.action = action;
        this.target = target;
        byteOutputStream = new TaintedByteArrayOutputStream();
        outputStream = new DataOutputStream(byteOutputStream);
        byteInputStream = new TaintedByteArrayInputStream();
        inputStream = new DataInputStream(byteInputStream);
    }

    /**
     */
    public Action(int action, int actor, byte x, byte y, byte z) {
        this(action, actor, -1);
        this.destX = x;
        this.destY = y;
        this.destZ = z;
    }

    /**
     */
    public void set(int action, int actor, int target, byte x, byte y, byte z) {
        this.actor = actor;
        this.action = action;
        this.target = target;
        this.destX = x;
        this.destY = y;
        this.destZ = z;
    }

    /**
     * Sets the actor of this Action object.
     */
    public void setActor(int actor) {
        this.actor = actor;
    }

    /**
     * Returns the action of the Action object.
     *
     * @return The action byte.
     */
    public int getAction() {
        return action;
    }

    /**
     * Returns the actor trying to perform this Action.
     *
     * @return The actor byte.
     */
    public int getActor() {
        return actor;
    }

    /**
     * Returns the target of the action.
     *
     * @return The target byte.
     */
    public int getTarget() {
        return target;
    }

    /**
     * Returns the type of Packable this is. This number is used by the
     * network module to identify a piece of data coming from the network
     * as being an Action.
     *
     * @return the type of Packable this is.
     */
    public int type() {
        return PACK_TYPE;
    }

    /**
     * Packs this Action into the specified stream.
     * @param out the stream to write this player to.
     * @throws PackingException if the packing failed.
     */
    public void pack(DataOutputStream out) throws PackingException {
        try {
            //out.writeByte(PACK_TYPE);
            out.writeByte(actor);
            out.writeByte(target);
            out.writeByte(action);
            /* Pack the waypoints associated with this action if any. */
            /* fixme - this should really be subclassed, but the Action design 
	       has not been finalized, so until then we do it here, *sigh*. */
            if (action == ACTION_MOVE) {
                out.writeByte(destX);
                out.writeByte(destY);
                out.writeByte(destZ);
                //out.writeByte(this.numOfWaypoints);
                //out.writeFloat(wp[0]);
                //out.writeFloat(wp[1]);
                //out.writeFloat(wp[2]);
                // waypoints are stored as offsets
                //for (byte[] wp : waypoints) {
                //}
            }
        } catch (Exception e) {
            throw new PackingException(e);
        }
    }

    /**
     * Unpack and set action data from the specified stream.
     * @param in the stream to read data from.
     * @throws PackingException if the unpacking failed.
     */
    public void unpack(DataInputStream in) throws PackingException {
        try {
            /*
	    byte packType = in.readByte();

	    if (PACK_TYPE != packType) {
		throw new PackingException(
		    String.format(
			""Action.unpack(): *** ERROR *** "" +
			""Data is not of correct packable type: "" +
			""got %d should be %d"", packType, PACK_TYPE));
	    }
	    */
            actor = in.readByte();
            target = in.readByte();
            action = in.readByte();
            if (action == ACTION_MOVE) {
                destX = in.readByte();
                destY = in.readByte();
                destZ = in.readByte();
            }
        } catch (Exception e) {
            //if (e instanceof PackingException) throw (PackingException) e;
            throw new PackingException(e);
        }
    }

    /**
     * Returns a byte array representation of this Action.
     *
     * @return The resulting byte array.
     */
    public byte[] pack() /* throws PackingException */
    {
        try {
            byteOutputStream.reset();
            pack(outputStream);
            return byteOutputStream.toByteArray();
        } catch (PackingException e) {
            System.err.println(e.getMessage());
        }
        return null;
    }

    /**
     * Unpacks an array previously created with pack() and puts in
     * this object.
     *
     * @deprecated
     * @param b the byte array to be unpacked.
     */
    public void unpack(byte[] b) /* throws PackingException */
    {
        try {
            byteInputStream.setByteArray(b);
            unpack(inputStream);
        } catch (PackingException e) {
            // caught here since letting it propagate would break
            // things in other modules.
            System.err.println(""Action.unpack(): *** ERROR *** [IO] "" + ""unpack failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
    }

    public Action clone() {
        Action a = new Action();
        a.setManager(manager);
        return a;
    }

    public String toString() {
        return String.format(""Action[type=%d,action=%s,actor=%s,target=%s,"" + ""destX=%d,destY=%d,destZ=%d]"", PACK_TYPE, action, actor, target, destX, destY, destZ);
    }
}
","// Action_0Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#type()} method.
*/
class Action_0Test {","// Action_0Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#type()} method.
*/
class Action_0Test {

	/**
	* Test case 1 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_1() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 2 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_2() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 3 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_3() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 4 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_4() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 5 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_5() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 6 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_6() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 7 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_7() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 8 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_8() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 9 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_9() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
	
	/**
	* Test case 10 for method type.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testType_10() throws UnsupportedEncodingException {
		Action a = new Action();
		int result = a.type();
		assertEquals(0, result);
	}
}

// Action_1Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#pack(DataOutputStream)} method.
*/
class Action_1Test {
		
	/**
	* Test case 1 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_1() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 2 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_2() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 3 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_3() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 4 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_4() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 5 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_5() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 6 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_6() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 7 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_7() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 8 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_8() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 9 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_9() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
	
	/**
	* Test case 10 for method pack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testPack_10() throws UnsupportedEncodingException {
		Action a = new Action();
		DataOutputStream out = new DataOutputStream(new TaintedByteArrayOutputStream());
		a.pack(out);
	}
}

// Action_2Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#unpack(DataInputStream)} method.
*/
class Action_2Test {
		
	/**
	* Test case 1 for method unpack.
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testUnpack_1() throws UnsupportedEncodingException {
		Action a = new Action();
		DataInputStream in = new DataInputStream(new ByteArrayInputStream(new byte[] {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0"
cmpl-6tvIO9S5OdoQXpa78O2WsZ6inQzmx,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Action_1Test.java,94.7887647151947,length,"// Action.java
/* $Id: Action.java,v 1.4 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.4 $
 *
 */
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;

/**
 * Interface for all objects that are packable, i.e. objects that are
 * to be sent over the network.
 */
public class Action extends ManagedObject implements Packable {

    public final static int ACTION_JOIN = 0;

    public final static int ACTION_PART = 1;

    public final static int ACTION_ATTACK = 2;

    public final static int ACTION_JOIN_APPLY = 3;

    public final static int ACTION_JOIN_INVITE = 4;

    public final static int ACTION_JOIN_ALLOW = 5;

    public final static int ACTION_JOIN_AGREE = 6;

    public final static int ACTION_MOVE = 7;

    public final static int ACTION_KICK = 8;

    /**
     * Number used by the network module to identify
     * a piece of data as being an Action.
     */
    private static final int PACK_TYPE = Packable.ACTION;

    /**
     * The actor (i.e. the Player that invkoked the action).
     */
    private int actor;

    /**
     * The target (i.e. the Player the action is invoked on).
     */
    private int target;

    /**
     * The type of action this is.
     */
    private int action;

    /**
     * The destination associated with a ACTION_MOVE.
     */
    private byte destX, destY, destZ;

    /**
     * Utility classes, not part of the Action.
     */
    private TaintedByteArrayOutputStream byteOutputStream;

    private TaintedByteArrayInputStream byteInputStream;

    private DataOutputStream outputStream;

    private DataInputStream inputStream;

    /**
     * The manager associated with this Action, if any.
     */
    private ObjectManager manager = null;

    /**
     * Create a new instance of the Action class. Fields are set to
     * default values. The action, actor, and target are set to -1.
     */
    public Action() {
        this(-1, -1, -1);
    }

    /**
     * @param action
     * @param actor
     * @param target
     */
    public Action(int action, int actor, int target) {
        this.actor = actor;
        this.action = action;
        this.target = target;
        byteOutputStream = new TaintedByteArrayOutputStream();
        outputStream = new DataOutputStream(byteOutputStream);
        byteInputStream = new TaintedByteArrayInputStream();
        inputStream = new DataInputStream(byteInputStream);
    }

    /**
     */
    public Action(int action, int actor, byte x, byte y, byte z) {
        this(action, actor, -1);
        this.destX = x;
        this.destY = y;
        this.destZ = z;
    }

    /**
     */
    public void set(int action, int actor, int target, byte x, byte y, byte z) {
        this.actor = actor;
        this.action = action;
        this.target = target;
        this.destX = x;
        this.destY = y;
        this.destZ = z;
    }

    /**
     * Sets the actor of this Action object.
     */
    public void setActor(int actor) {
        this.actor = actor;
    }

    /**
     * Returns the action of the Action object.
     *
     * @return The action byte.
     */
    public int getAction() {
        return action;
    }

    /**
     * Returns the actor trying to perform this Action.
     *
     * @return The actor byte.
     */
    public int getActor() {
        return actor;
    }

    /**
     * Returns the target of the action.
     *
     * @return The target byte.
     */
    public int getTarget() {
        return target;
    }

    /**
     * Returns the type of Packable this is. This number is used by the
     * network module to identify a piece of data coming from the network
     * as being an Action.
     *
     * @return the type of Packable this is.
     */
    public int type() {
        return PACK_TYPE;
    }

    /**
     * Packs this Action into the specified stream.
     * @param out the stream to write this player to.
     * @throws PackingException if the packing failed.
     */
    public void pack(DataOutputStream out) throws PackingException {
        try {
            //out.writeByte(PACK_TYPE);
            out.writeByte(actor);
            out.writeByte(target);
            out.writeByte(action);
            /* Pack the waypoints associated with this action if any. */
            /* fixme - this should really be subclassed, but the Action design 
	       has not been finalized, so until then we do it here, *sigh*. */
            if (action == ACTION_MOVE) {
                out.writeByte(destX);
                out.writeByte(destY);
                out.writeByte(destZ);
                //out.writeByte(this.numOfWaypoints);
                //out.writeFloat(wp[0]);
                //out.writeFloat(wp[1]);
                //out.writeFloat(wp[2]);
                // waypoints are stored as offsets
                //for (byte[] wp : waypoints) {
                //}
            }
        } catch (Exception e) {
            throw new PackingException(e);
        }
    }

    /**
     * Unpack and set action data from the specified stream.
     * @param in the stream to read data from.
     * @throws PackingException if the unpacking failed.
     */
    public void unpack(DataInputStream in) throws PackingException {
        try {
            /*
	    byte packType = in.readByte();

	    if (PACK_TYPE != packType) {
		throw new PackingException(
		    String.format(
			""Action.unpack(): *** ERROR *** "" +
			""Data is not of correct packable type: "" +
			""got %d should be %d"", packType, PACK_TYPE));
	    }
	    */
            actor = in.readByte();
            target = in.readByte();
            action = in.readByte();
            if (action == ACTION_MOVE) {
                destX = in.readByte();
                destY = in.readByte();
                destZ = in.readByte();
            }
        } catch (Exception e) {
            //if (e instanceof PackingException) throw (PackingException) e;
            throw new PackingException(e);
        }
    }

    /**
     * Returns a byte array representation of this Action.
     *
     * @return The resulting byte array.
     */
    public byte[] pack() /* throws PackingException */
    {
        try {
            byteOutputStream.reset();
            pack(outputStream);
            return byteOutputStream.toByteArray();
        } catch (PackingException e) {
            System.err.println(e.getMessage());
        }
        return null;
    }

    /**
     * Unpacks an array previously created with pack() and puts in
     * this object.
     *
     * @deprecated
     * @param b the byte array to be unpacked.
     */
    public void unpack(byte[] b) /* throws PackingException */
    {
        try {
            byteInputStream.setByteArray(b);
            unpack(inputStream);
        } catch (PackingException e) {
            // caught here since letting it propagate would break
            // things in other modules.
            System.err.println(""Action.unpack(): *** ERROR *** [IO] "" + ""unpack failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
    }

    public Action clone() {
        Action a = new Action();
        a.setManager(manager);
        return a;
    }

    public String toString() {
        return String.format(""Action[type=%d,action=%s,actor=%s,target=%s,"" + ""destX=%d,destY=%d,destZ=%d]"", PACK_TYPE, action, actor, target, destX, destY, destZ);
    }
}
","// Action_1Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#pack()} method.
*/
class Action_1Test {","// Action_1Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#pack()} method.
*/
class Action_1Test {

	/**
	* Test case 1 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_1() {
		Action a = new Action();
		a.set(Action.ACTION_JOIN, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 0);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 2 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_2() {
		Action a = new Action();
		a.set(Action.ACTION_PART, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 1);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 3 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_3() {
		Action a = new Action();
		a.set(Action.ACTION_ATTACK, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 2);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 4 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_4() {
		Action a = new Action();
		a.set(Action.ACTION_JOIN_APPLY, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 3);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 5 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_5() {
		Action a = new Action();
		a.set(Action.ACTION_JOIN_INVITE, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 4);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 6 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_6() {
		Action a = new Action();
		a.set(Action.ACTION_JOIN_ALLOW, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 5);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 7 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_7() {
		Action a = new Action();
		a.set(Action.ACTION_JOIN_AGREE, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 6);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 8 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_8() {
		Action a = new Action();
		a.set(Action.ACTION_MOVE, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 7);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 9 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_9() {
		Action a = new Action();
		a.set(Action.ACTION_KICK, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 8);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
	
	/**
	* Test case 10 for {@link Action#pack()}.
	* It tests the normal case.
	*/
	@Test
	void testPack_10() {
		Action a = new Action();
		a.set(Action.ACTION_KICK, 1, 2, (byte)3, (byte)4, (byte)5);
		byte[] b = a.pack();
		assertEquals(b[0], 1);
		assertEquals(b[1], 2);
		assertEquals(b[2], 8);
		assertEquals(b[3], 3);
		assertEquals(b[4], 4);
		assertEquals(b[5], 5);
	}
}

// Action_2Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#unpack(byte[])} method.
*/
class Action_2Test {
		
	/**
	* Test case 1 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_1() {
		Action a = new Action();
		byte[] b = {1, 2, 0, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 0);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 2 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_2() {
		Action a = new Action();
		byte[] b = {1, 2, 1, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 1);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 3 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_3() {
		Action a = new Action();
		byte[] b = {1, 2, 2, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 2);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 4 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_4() {
		Action a = new Action();
		byte[] b = {1, 2, 3, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 3);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 5 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_5() {
		Action a = new Action();
		byte[] b = {1, 2, 4, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 4);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 6 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_6() {
		Action a = new Action();
		byte[] b = {1, 2, 5, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 5);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 7 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_7() {
		Action a = new Action();
		byte[] b = {1, 2, 6, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 6);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 8 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_8() {
		Action a = new Action();
		byte[] b = {1, 2, 7, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 7);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 9 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_9() {
		Action a = new Action();
		byte[] b = {1, 2, 8, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 8);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
	
	/**
	* Test case 10 for {@link Action#unpack(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_10() {
		Action a = new Action();
		byte[] b = {1, 2, 8, 3, 4, 5};
		a.unpack(b);
		assertEquals(a.getActor(), 1);
		assertEquals(a.getTarget(), 2);
		assertEquals(a.getAction(), 8);
		assertEquals(a.destX, 3);
		assertEquals(a.destY, 4);
		assertEquals(a.destZ, 5);
	}
}

// Action_3Test.java
package state;

import java.io.UnsupportedEncodingException;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.ByteArrayInputStream;
import util.TaintedByteArrayOutputStream;
import util.TaintedByteArrayInputStream;
import util.ManagedObject;
import util.ObjectManager;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Action}.
* It contains ten unit test cases for the {@link Action#unpack(DataInputStream)} method.
*/
class Action_3Test {
		
	/**
	* Test case 1 for {@link Action#unpack(DataInputStream)}.
	* It tests the normal case.
	*/
	@Test
	void testUnpack_1() {
		Action a = new Action();
		byte[] b = {1, 2, 0, 3, 4, 5};
		TaintedByteArrayInputStream"
cmpl-6tvJuH1HngLa1JdYoJ9gPDI7eWAGP,/EvoSuiteBenchmark/27_gangup/src/main/java/state/GameEvent_1Test.java,81.2459671497345,length,"// GameEvent.java
/* $Id: GameEvent.java,v 1.6 2004/04/30 23:35:12 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.6 $
 *
 */
package state;

import java.io.UnsupportedEncodingException;

/**
 * Class for game events to be sent to the clients.
 *
 * Possible events include:
 *
 * GameEvent.FIGHT
 * <i>actor</i>'s group defeated <i>target</i>'s group in a fight.
 * GameEvent.JOIN
 * <i>actor</i> joined <i>target</i>'s group.
 * GameEvent.APPLY
 * <i>actor</i> wants to join <i>target</i>'s group.
 * GameEvent.INVITE
 * <i>actor</i> invites <i>target</i> to join.
 * GameEvent.WARMUP
 * The warmup time has started. <i>actor</i> and <i>target</i> are undefined.
 * GameEvent.START
 * The game is now started. <i>actor</i> and <i>target</i> are undefined.
 * GameEvent.END
 * The game has now ended. <i>actor</i> and <i>target</i> are undefined.
 * GameEvent.DROP
 * <i>actor</i> was dropped from the game.
 */
public class GameEvent implements Packable {

    /**
     * Actor
     */
    private int actor;

    /**
     * Target of the action. @see GameEvent
     */
    private int target;

    /**
     * Event type! Can be of values:
     * FIGHT, JOIN, APPLY, INVITE, START, END, DROP, PART.
     */
    private int eventtype;

    /**
     * Relative time to gamestart.
     */
    private long time;

    public final int type = Packable.GAME_EVENT;

    public final static int FIGHT = 0;

    public final static int JOIN = 1;

    public final static int APPLY = 2;

    public final static int INVITE = 3;

    public final static int START = 4;

    public final static int END = 5;

    public final static int DROP = 6;

    public final static int PART = 7;

    public final static int MOVE = 8;

    public final static int KICK = 9;

    public final static int WARMUP = 10;

    /**
     * Creates a new GameEvent.
     */
    public GameEvent(int actor, int target, int eventtype) {
        this.actor = actor;
        this.target = target;
        this.eventtype = eventtype;
    }

    /**
     * Creates a new GameEvent.
     */
    public GameEvent(int actor, int target, int eventtype, int time) {
        this(actor, target, eventtype);
        this.time = time;
    }

    /**
     * Creates a new empty GameEvent. Empty events cannot be sent over
     * the network, and will throw a NullPointerException if done.
     */
    public GameEvent() {
        this(-1, -1, -1);
    }

    /**
     * Creates a new empty GameEvent. Empty events cannot be sent over
     * the network, and will throw a NullPointerException if done.
     */
    public GameEvent(long time) {
        this(-1, -1, -1);
        this.time = time;
    }

    public int getActor() {
        return actor;
    }

    public int getTarget() {
        return target;
    }

    public int getEventType() {
        return eventtype;
    }

    public long getTime() {
        return time;
    }

    public void setTime(long l) {
        time = l;
    }

    /**
     * Sets the actor, target, and eventType of this Action to the
     * specified values;
     *
     * @param actor the Actor performing this action.
     * @param target the Target receiving this action.
     * @param etype the type of action.
     */
    public void setAction(int actor, int target, int etype) {
        this.actor = actor;
        this.target = target;
        this.eventtype = etype;
    }

    public int type() {
        return Packable.GAME_EVENT;
    }

    /**
     * Converts a GameEvent into a byte array representation.
     *
     * @param msg The message to be converted.
     * @return The resulting byte array.
     */
    public byte[] pack() {
        byte[] data = new byte[3];
        data[0] = (byte) actor;
        data[1] = (byte) target;
        data[2] = (byte) eventtype;
        return data;
    }

    /**
     * Converts a byte array back into a GameEvent.
     *
     * @param data The byte array to be converted.
     * @return The resultning message.
     */
    public void unpack(byte[] data) {
        this.actor = (int) data[0];
        this.target = (int) data[1];
        this.eventtype = (int) data[2];
    }

    public String toString() {
        return ""GameEvent["" + eventtype + "","" + actor + "","" + target + ""]"";
    }
}
","// GameEvent_1Test.java
package state;

import java.io.UnsupportedEncodingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameEvent}.
* It contains ten unit test cases for the {@link GameEvent#pack()} method.
*/
class GameEvent_1Test {","// GameEvent_1Test.java
package state;

import java.io.UnsupportedEncodingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameEvent}.
* It contains ten unit test cases for the {@link GameEvent#pack()} method.
*/
class GameEvent_1Test {

	/**
	* Test case 1.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase1() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(0, 0, 0);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(0, data[0]);
		assertEquals(0, data[1]);
		assertEquals(0, data[2]);
	}
	
	/**
	* Test case 2.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase2() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(1, 1, 1);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(1, data[0]);
		assertEquals(1, data[1]);
		assertEquals(1, data[2]);
	}
	
	/**
	* Test case 3.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase3() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(2, 2, 2);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(2, data[0]);
		assertEquals(2, data[1]);
		assertEquals(2, data[2]);
	}
	
	/**
	* Test case 4.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase4() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(3, 3, 3);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(3, data[0]);
		assertEquals(3, data[1]);
		assertEquals(3, data[2]);
	}
	
	/**
	* Test case 5.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase5() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(4, 4, 4);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(4, data[0]);
		assertEquals(4, data[1]);
		assertEquals(4, data[2]);
	}
	
	/**
	* Test case 6.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase6() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(5, 5, 5);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(5, data[0]);
		assertEquals(5, data[1]);
		assertEquals(5, data[2]);
	}
	
	/**
	* Test case 7.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase7() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(6, 6, 6);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(6, data[0]);
		assertEquals(6, data[1]);
		assertEquals(6, data[2]);
	}
	
	/**
	* Test case 8.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase8() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(7, 7, 7);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(7, data[0]);
		assertEquals(7, data[1]);
		assertEquals(7, data[2]);
	}
	
	/**
	* Test case 9.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase9() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(8, 8, 8);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(8, data[0]);
		assertEquals(8, data[1]);
		assertEquals(8, data[2]);
	}
	
	/**
	* Test case 10.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase10() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent(9, 9, 9);
		byte[] data = gameEvent.pack();
		assertEquals(3, data.length);
		assertEquals(9, data[0]);
		assertEquals(9, data[1]);
		assertEquals(9, data[2]);
	}
}

// GameEvent_2Test.java
package state;

import java.io.UnsupportedEncodingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameEvent}.
* It contains ten unit test cases for the {@link GameEvent#unpack(byte[])} method.
*/
class GameEvent_2Test {
		
	/**
	* Test case 1.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase1() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 0;
		data[1] = 0;
		data[2] = 0;
		gameEvent.unpack(data);
		assertEquals(0, gameEvent.getActor());
		assertEquals(0, gameEvent.getTarget());
		assertEquals(0, gameEvent.getEventType());
	}
	
	/**
	* Test case 2.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase2() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 1;
		data[1] = 1;
		data[2] = 1;
		gameEvent.unpack(data);
		assertEquals(1, gameEvent.getActor());
		assertEquals(1, gameEvent.getTarget());
		assertEquals(1, gameEvent.getEventType());
	}
	
	/**
	* Test case 3.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase3() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 2;
		data[1] = 2;
		data[2] = 2;
		gameEvent.unpack(data);
		assertEquals(2, gameEvent.getActor());
		assertEquals(2, gameEvent.getTarget());
		assertEquals(2, gameEvent.getEventType());
	}
	
	/**
	* Test case 4.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase4() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 3;
		data[1] = 3;
		data[2] = 3;
		gameEvent.unpack(data);
		assertEquals(3, gameEvent.getActor());
		assertEquals(3, gameEvent.getTarget());
		assertEquals(3, gameEvent.getEventType());
	}
	
	/**
	* Test case 5.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase5() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 4;
		data[1] = 4;
		data[2] = 4;
		gameEvent.unpack(data);
		assertEquals(4, gameEvent.getActor());
		assertEquals(4, gameEvent.getTarget());
		assertEquals(4, gameEvent.getEventType());
	}
	
	/**
	* Test case 6.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase6() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 5;
		data[1] = 5;
		data[2] = 5;
		gameEvent.unpack(data);
		assertEquals(5, gameEvent.getActor());
		assertEquals(5, gameEvent.getTarget());
		assertEquals(5, gameEvent.getEventType());
	}
	
	/**
	* Test case 7.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase7() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 6;
		data[1] = 6;
		data[2] = 6;
		gameEvent.unpack(data);
		assertEquals(6, gameEvent.getActor());
		assertEquals(6, gameEvent.getTarget());
		assertEquals(6, gameEvent.getEventType());
	}
	
	/**
	* Test case 8.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase8() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 7;
		data[1] = 7;
		data[2] = 7;
		gameEvent.unpack(data);
		assertEquals(7, gameEvent.getActor());
		assertEquals(7, gameEvent.getTarget());
		assertEquals(7, gameEvent.getEventType());
	}
	
	/**
	* Test case 9.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase9() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 8;
		data[1] = 8;
		data[2] = 8;
		gameEvent.unpack(data);
		assertEquals(8, gameEvent.getActor());
		assertEquals(8, gameEvent.getTarget());
		assertEquals(8, gameEvent.getEventType());
	}
	
	/**
	* Test case 10.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase10() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		byte[] data = new byte[3];
		data[0] = 9;
		data[1] = 9;
		data[2] = 9;
		gameEvent.unpack(data);
		assertEquals(9, gameEvent.getActor());
		assertEquals(9, gameEvent.getTarget());
		assertEquals(9, gameEvent.getEventType());
	}
}

// GameEvent_3Test.java
package state;

import java.io.UnsupportedEncodingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameEvent}.
* It contains ten unit test cases for the {@link GameEvent#setAction(int, int, int)} method.
*/
class GameEvent_3Test {
		
	/**
	* Test case 1.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase1() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		gameEvent.setAction(0, 0, 0);
		assertEquals(0, gameEvent.getActor());
		assertEquals(0, gameEvent.getTarget());
		assertEquals(0, gameEvent.getEventType());
	}
	
	/**
	* Test case 2.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase2() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		gameEvent.setAction(1, 1, 1);
		assertEquals(1, gameEvent.getActor());
		assertEquals(1, gameEvent.getTarget());
		assertEquals(1, gameEvent.getEventType());
	}
	
	/**
	* Test case 3.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase3() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		gameEvent.setAction(2, 2, 2);
		assertEquals(2, gameEvent.getActor());
		assertEquals(2, gameEvent.getTarget());
		assertEquals(2, gameEvent.getEventType());
	}
	
	/**
	* Test case 4.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase4() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		gameEvent.setAction(3, 3, 3);
		assertEquals(3, gameEvent.getActor());
		assertEquals(3, gameEvent.getTarget());
		assertEquals(3, gameEvent.getEventType());
	}
	
	/**
	* Test case 5.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase5() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		gameEvent.setAction(4, 4, 4);
		assertEquals(4, gameEvent.getActor());
		assertEquals(4, gameEvent.getTarget());
		assertEquals(4, gameEvent.getEventType());
	}
	
	/**
	* Test case 6.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase6() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		gameEvent.setAction(5, 5, 5);
		assertEquals(5, gameEvent.getActor());
		assertEquals(5, gameEvent.getTarget());
		assertEquals(5, gameEvent.getEventType());
	}
	
	/**
	* Test case 7.
	*
	* @throws UnsupportedEncodingException
	*/
	@Test
	void testCase7() throws UnsupportedEncodingException {
		GameEvent gameEvent = new GameEvent();
		gameEvent.setAction(6, 6, 6);
		assertEquals(6, gameEvent.getActor());
		assertEquals(6, gameEvent.getTarget());
		assertEquals"
efa01546-5e36-4bcc-bdeb-34b1f81ac269,/EvoSuiteBenchmark/27_gangup/src/main/java/state/GameState_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8677 tokens (4677 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GameState.java
/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.30 $
 *
 */
package state;

import java.util.*;
import java.io.*;

/**
 * The state of the game. Includes the gang tree, all players stats
 * and more. Implements Observable for whenever a change in the state
 * is detected.
 */
public class GameState extends Observable implements Packable {

    /**
     * Maximum number of players.
     */
    public static final int MAX_PLAYER_LIMIT = 128;

    /**
     * Number to verify against when unpacking.
     */
    private static final short MAGIC_NO = 0x3BBA;

    /**
     * List of known players.
     */
    private Player[] players;

    /**
     * Total number of known players.
     */
    private int numOfPlayers;

    /**
     * Number of dead players
     */
    private int numDead;

    /**
     * Save when a game is started.
     */
    private long gamestart;

    /**
     * Current state of the game
     */
    private int gamestate;

    /**
     * Waiting for players to join
     */
    public static final int STATE_WAITING = 1;

    /**
     * Warmup time. No attacks possible.
     */
    public static final int STATE_WARMUP = 2;

    /**
     * A game is in progress.
     */
    public static final int STATE_PLAYING = 3;

    /**
     * Game has ended.
     */
    public static final int STATE_ENDED = 4;

    /**
     * The current player for this client. null for the server.
     */
    private Player me;

    /**
     * Minimum time to wait before making next move
     */
    private long mintimemove;

    /**
     * Number of rounds to play
     */
    private int totalRounds;

    /**
     * Current round number
     */
    private int currentRound;

    /**
     * Keep track of when last move of a user was done
     */
    private Hashtable<Integer, Long> lastmove;

    /**
     * Creates a new instance of the GameState class.
     */
    public GameState() {
        this(15000);
    }

    /**
     * Creates a new instance of the GameState class.
     * @param mintimemove How long a user must wait between attack moves.
     */
    public GameState(long mintimemove) {
        players = new Player[MAX_PLAYER_LIMIT];
        numOfPlayers = 0;
        numDead = 0;
        gamestart = 0;
        gamestate = STATE_WAITING;
        currentRound = 1;
        totalRounds = 1;
        this.mintimemove = mintimemove;
        lastmove = new Hashtable<Integer, Long>();
    }

    public void reset(boolean newGame) {
        numDead = 0;
        for (int i = 0; i < players.length; i++) {
            if (players[i] == null)
                continue;
            if (!players[i].isConnected()) {
                if (newGame) {
                    players[i] = null;
                    numOfPlayers--;
                } else {
                    players[i].reset(newGame);
                    setDead(players[i]);
                }
            } else {
                players[i].reset(newGame);
            }
        }
        if (newGame)
            currentRound = 1;
        lastmove = new Hashtable<Integer, Long>();
    }

    public void setTotalRounds(int totalRounds) {
        this.totalRounds = totalRounds;
    }

    public int getTotalRounds() {
        return totalRounds;
    }

    public void setCurrentRound(int currentRound) {
        this.currentRound = currentRound;
    }

    public int getCurrentRound() {
        return currentRound;
    }

    /**
     * Returns the state of the game. Ie, warmup, running, waiting for users.
     * Use the predefined values defined as STATE_* in this class.
     */
    public int getGameState() {
        return gamestate;
    }

    /**
     * Sets the state of the game. Ie, warmup, running, waiting for users.
     * Use the predefined values defined as STATE_* in this class.
     */
    public void setGameState(int gamestate) {
        this.gamestate = gamestate;
        System.err.println(""Notifying observers...:"" + this.gamestate);
        setChanged();
        notifyObservers(new Integer(gamestate));
    }

    /**
     * Check if enough time has passed since last move.
     */
    public boolean isMoveTimeOK(Player player) {
        if (lastmove.containsKey(player.getId())) {
            long time = lastmove.get(new Integer(player.getId()));
            if (time + mintimemove > System.currentTimeMillis())
                return false;
        }
        return true;
    }

    /**
     * Update the time when player last made an attack move.
     */
    public void updateLastMove(Player player) {
        lastmove.put(player.getId(), System.currentTimeMillis());
    }

    /**
     * Adds the specified player to the list of known players.
     *
     * @param p The player that is to be added.
     */
    public void addPlayer(Player p) {
        try {
            if (players[p.getId()] != null) {
                /* throw new GameStateException(""PlayerID exists!""); */
                System.err.println(""GameState.addPlayer(): PlayerID exists!"");
                return;
            }
            players[p.getId()] = p;
            numOfPlayers++;
            updateLastMove(p);
            setChanged();
            notifyObservers();
        } catch (IndexOutOfBoundsException e) {
            System.err.println(""GameState.addPlayer(): "" + ""PlayerID '"" + p.id + ""' out of the allowed "" + ""range 0 - "" + MAX_PLAYER_LIMIT);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Removes the specified player from the list of known players.
     *
     * @param p The player that is to be removed.
     */
    public void removePlayer(Player p) {
        try {
            if (players[p.getId()] == null) {
                /* throw new GameStateException(""PlayerID doesn't exist!""); */
                System.err.println(""GameState.removePlayer(): "" + ""PlayerID doesn't exist!"");
            }
            if (!p.isBoss()) {
                part(p.boss, p);
            }
            while (p.head != null) {
                part(p, p.head);
            }
            if (gamestate == STATE_WAITING) {
                players[p.getId()] = null;
                numOfPlayers--;
            } else {
                setDead(p);
                p.setConnected(false);
            }
            setChanged();
            notifyObservers(p);
        } catch (IndexOutOfBoundsException e) {
            System.err.println(""GameState.removePlayer(): "" + ""PlayerID '"" + p.getId() + ""' out of the allowed "" + ""range 0 - "" + MAX_PLAYER_LIMIT);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Adds a party to another party's underling list. This
     * automatically merges the two parties' gangs.
     *
     * @param parent The Party whose gang the child joined.
     * @param child The Party which joined the parent's gang.
     */
    public void join(Party parent, Party child) {
        try {
            parent.add(child);
            setChanged();
            notifyObservers(child);
        } catch (NullPointerException e) {
            System.err.println(""GameState.join(): parent="" + parent + "" "" + ""child="" + child);
            e.printStackTrace(System.err);
        }
    }

    /**
     * Removes a party from another party's underling list. The
     * parties that were previously member of the parting party's gang
     * before the join will also part with it, provided they are still
     * in the party's underling list.
     *
     * @param parent The Party whose gang the child parts from.
     * @param child The Party which parted the parent's gang.
     */
    public void part(Party parent, Party child) {
        try {
            parent.remove(child);
            setChanged();
            notifyObservers(child);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Returns the player at int id. If player id is out of bounds for
     * the player array, or if no player exists with given id, null is
     * returned. This is consequent with pidFor(Player p) which
     * returns -1 when passed a null value.
     *
     * @param id The id of the player that is to be found.
     * @return The Player with the right id. -1 if no player could be
     * found.
     */
    public Player player(int id) {
        if (id < 0 || id >= MAX_PLAYER_LIMIT)
            return null;
        return players[id];
    }

    public Player[] players() {
        return players;
    }

    public void setMe(Player p) {
        me = p;
    }

    public Player getMe() {
        return me;
    }

    public int getNumOfPlayers() {
        return numOfPlayers;
    }

    public void reload() {
        setChanged();
        notifyObservers(this);
    }

    /**
     * Sets a player's state to dead and increases the dead players
     * counter.
     *
     * @param p The dead Player.
     * @param deathtime The time of death of the player.
     */
    public void setDead(Player p, long deathtime) {
        if (p != null && !p.isDead()) {
            numDead++;
            p.setDead(deathtime);
            setChanged();
            notifyObservers(p);
        }
    }

    public void setDead(Player p) {
        setDead(p, System.currentTimeMillis());
    }

    /**
     * Updates a player's world coordinates in the specified
     * direction.
     *
     * @param p The player.
     * @param direction The direction. As specified by the
     * ANSI-DIRECTIONAL-STANDARD 8-55-155.
     * @deprecated does nothing in gl gui
     */
    public void move(Player p, int direction) {
        /*
	float dirx = 0;
	float diry = 0;
	
	if ((direction & 0x1) != 0) {
	    diry -= Player.MOVE_DISTANCE;
	}
	if ((direction & 0x2) != 0) {
	    dirx -= Player.MOVE_DISTANCE;
	}
	if ((direction & 0x4) != 0) {
	    diry += Player.MOVE_DISTANCE;
	}
	if ((direction & 0x8) != 0) {
	    dirx += Player.MOVE_DISTANCE;
	}
	
	p.setX(p.getX() + dirx);
	p.setY(p.getY() + diry);
	System.err.println(""New player pos:"" + p.getX() + "","" + p.getY() + "" "" + dirx + "" "" + diry);
	setChanged();
	notifyObservers(p);
	*/
    }

    /**
     * Returns number of dead players.
     *
     * @return the number of dead players.
     */
    public int getNumDead() {
        return numDead;
    }

    /**
     * Returns when the game was started.
     *
     * @return The system time when game was started. -1 when game is
     * not yet started.
     */
    public long getGamestart() {
        return gamestart;
    }

    public void setGamestart(long l) {
        gamestart = l;
    }

    /**
     * Packs the entire GameState structure into a byte array.
     * @return array of bytes representing the packed object.
     */
    public byte[] pack() {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        DataOutputStream out = new DataOutputStream(buf);
        Player p = null;
        try {
            int numplayers = numOfPlayers;
            for (int i = 0; i < players.length; i++) {
                if (players[i] != null && !players[i].isConnected())
                    numplayers--;
            }
            out.writeShort(MAGIC_NO);
            out.writeByte(gamestate);
            out.writeByte(numplayers);
            for (int i = 0, k = -1; i < numOfPlayers; i++) {
                // fixme - fix this!
                // exceptions are caught
                while (players[++k] == null) ;
                p = players[k];
                if (!p.isConnected())
                    continue;
                p.pack(out);
                out.writeByte(pidOf(p.boss));
                out.writeByte(pidOf(p.next));
                out.writeByte(pidOf(p.prev));
                out.writeByte(pidOf(p.head));
            }
        } catch (IOException e) {
            System.err.println(""GameState.pack(): *** WARNING *** [IO] "" + ""failed to pack data: "" + e.getMessage());
            return null;
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println(""GameState.pack(): *** ERROR *** [IDX] "" + ""failed to pack data: "" + e.getMessage());
            return null;
        }
        return buf.toByteArray();
    }

    /**
     * Unpacks the current state from the given array.
     * @param b the byte array from which to read.
     */
    public void unpack(byte[] b) {
        try {
            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));
            /* read and verify magic number */
            if (in.readShort() != MAGIC_NO) {
                /* throw new PackableException(); */
                System.err.println(""GameState.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return;
            }
            gamestate = in.readByte();
            // number of players.
            int n = in.readByte();
            /* fixme - data should be read to a temporary place and then
	       verified, after which it should be commited. */
            Player p = null;
            for (int i = 0; i < n; i++) {
                in.mark(3);
                // magic number is checked in Player.unpack().
                in.readShort();
                p = playerAt(in.readByte());
                in.reset();
                if (p.unpack(in)) {
                    p.boss = playerAt(in.readByte());
                    p.next = playerAt(in.readByte());
                    p.prev = playerAt(in.readByte());
                    p.head = playerAt(in.readByte());
                } else {
                    System.err.println(""GameState.unpack(): *** ERROR *** "" + ""data is incomplete! current state "" + ""is inconsistent!"");
                }
            }
        } catch (EOFException e) {
            System.err.println(""GameState.unpack(): *** ERROR *** [EOF] "" + ""data is incomplete! current state is "" + ""inconsistent: "" + e.getMessage());
        } catch (IOException e) {
            System.err.println(""GameState.unpack(): *** ERROR *** [IO] "" + ""unpack data failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
    }

    public int type() {
        return Packable.GAME_STATE;
    }

    /**
     * Returns the player whith the specified id. If a player doesn't exist
     * with that id doesn't exist, a new player is created and returned. If
     * id is outside the allowed range, null is returned.
     *
     * @return the player with the specified id, or null if id is
     *         outside allowed range.
     */
    private Player playerAt(int id) {
        Player p = null;
        try {
            p = players[id];
            if (p == null) {
                p = new Player(id);
                addPlayer(p);
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            //System.err.println(""GameState.playerAt(): "" +
            //		       ""Invalid Player ID specified: "" + id);
        }
        return p;
    }

    /**
     * Returns the id of the specified player.
     *
     * @param p The player for which id is returned.
     * @return The
     */
    private int pidOf(Party p) {
        if (p == null)
            return -1;
        return p.getId();
    }

    /**
     * Returns a string representation of GameState. This includes a
     * full view of the tree.
     */
    public String toString() {
        StringBuffer str = new StringBuffer(""GameState["");
        boolean first = true;
        for (int i = 0, t = -1; i < numOfPlayers; i++) {
            while (++t < players.length && players[t] == null) ;
            if (t >= players.length) {
                return ""ERR,"" + numOfPlayers + ""]"";
            }
            if (first) {
                str.append(players[t]);
                first = false;
            } else {
                str.append("" , "" + players[t]);
            }
        }
        return str + ""]"";
    }
}
","// GameState_0Test.java
package state;

import java.util.*;
import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameState}.
* It contains ten unit test cases for the {@link GameState#isMoveTimeOK(Player)} method.
*/
class GameState_0Test {","// GameState_0Test.java
package state;

import java.util.*;
import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameState}.
* It contains ten unit test cases for the {@link GameState#isMoveTimeOK(Player)} method.
*/
class GameState_0Test {
"
f8e12923-0b75-4c9e-be8e-5df1d66f3520,/EvoSuiteBenchmark/27_gangup/src/main/java/state/GameState_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8674 tokens (4674 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GameState.java
/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.30 $
 *
 */
package state;

import java.util.*;
import java.io.*;

/**
 * The state of the game. Includes the gang tree, all players stats
 * and more. Implements Observable for whenever a change in the state
 * is detected.
 */
public class GameState extends Observable implements Packable {

    /**
     * Maximum number of players.
     */
    public static final int MAX_PLAYER_LIMIT = 128;

    /**
     * Number to verify against when unpacking.
     */
    private static final short MAGIC_NO = 0x3BBA;

    /**
     * List of known players.
     */
    private Player[] players;

    /**
     * Total number of known players.
     */
    private int numOfPlayers;

    /**
     * Number of dead players
     */
    private int numDead;

    /**
     * Save when a game is started.
     */
    private long gamestart;

    /**
     * Current state of the game
     */
    private int gamestate;

    /**
     * Waiting for players to join
     */
    public static final int STATE_WAITING = 1;

    /**
     * Warmup time. No attacks possible.
     */
    public static final int STATE_WARMUP = 2;

    /**
     * A game is in progress.
     */
    public static final int STATE_PLAYING = 3;

    /**
     * Game has ended.
     */
    public static final int STATE_ENDED = 4;

    /**
     * The current player for this client. null for the server.
     */
    private Player me;

    /**
     * Minimum time to wait before making next move
     */
    private long mintimemove;

    /**
     * Number of rounds to play
     */
    private int totalRounds;

    /**
     * Current round number
     */
    private int currentRound;

    /**
     * Keep track of when last move of a user was done
     */
    private Hashtable<Integer, Long> lastmove;

    /**
     * Creates a new instance of the GameState class.
     */
    public GameState() {
        this(15000);
    }

    /**
     * Creates a new instance of the GameState class.
     * @param mintimemove How long a user must wait between attack moves.
     */
    public GameState(long mintimemove) {
        players = new Player[MAX_PLAYER_LIMIT];
        numOfPlayers = 0;
        numDead = 0;
        gamestart = 0;
        gamestate = STATE_WAITING;
        currentRound = 1;
        totalRounds = 1;
        this.mintimemove = mintimemove;
        lastmove = new Hashtable<Integer, Long>();
    }

    public void reset(boolean newGame) {
        numDead = 0;
        for (int i = 0; i < players.length; i++) {
            if (players[i] == null)
                continue;
            if (!players[i].isConnected()) {
                if (newGame) {
                    players[i] = null;
                    numOfPlayers--;
                } else {
                    players[i].reset(newGame);
                    setDead(players[i]);
                }
            } else {
                players[i].reset(newGame);
            }
        }
        if (newGame)
            currentRound = 1;
        lastmove = new Hashtable<Integer, Long>();
    }

    public void setTotalRounds(int totalRounds) {
        this.totalRounds = totalRounds;
    }

    public int getTotalRounds() {
        return totalRounds;
    }

    public void setCurrentRound(int currentRound) {
        this.currentRound = currentRound;
    }

    public int getCurrentRound() {
        return currentRound;
    }

    /**
     * Returns the state of the game. Ie, warmup, running, waiting for users.
     * Use the predefined values defined as STATE_* in this class.
     */
    public int getGameState() {
        return gamestate;
    }

    /**
     * Sets the state of the game. Ie, warmup, running, waiting for users.
     * Use the predefined values defined as STATE_* in this class.
     */
    public void setGameState(int gamestate) {
        this.gamestate = gamestate;
        System.err.println(""Notifying observers...:"" + this.gamestate);
        setChanged();
        notifyObservers(new Integer(gamestate));
    }

    /**
     * Check if enough time has passed since last move.
     */
    public boolean isMoveTimeOK(Player player) {
        if (lastmove.containsKey(player.getId())) {
            long time = lastmove.get(new Integer(player.getId()));
            if (time + mintimemove > System.currentTimeMillis())
                return false;
        }
        return true;
    }

    /**
     * Update the time when player last made an attack move.
     */
    public void updateLastMove(Player player) {
        lastmove.put(player.getId(), System.currentTimeMillis());
    }

    /**
     * Adds the specified player to the list of known players.
     *
     * @param p The player that is to be added.
     */
    public void addPlayer(Player p) {
        try {
            if (players[p.getId()] != null) {
                /* throw new GameStateException(""PlayerID exists!""); */
                System.err.println(""GameState.addPlayer(): PlayerID exists!"");
                return;
            }
            players[p.getId()] = p;
            numOfPlayers++;
            updateLastMove(p);
            setChanged();
            notifyObservers();
        } catch (IndexOutOfBoundsException e) {
            System.err.println(""GameState.addPlayer(): "" + ""PlayerID '"" + p.id + ""' out of the allowed "" + ""range 0 - "" + MAX_PLAYER_LIMIT);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Removes the specified player from the list of known players.
     *
     * @param p The player that is to be removed.
     */
    public void removePlayer(Player p) {
        try {
            if (players[p.getId()] == null) {
                /* throw new GameStateException(""PlayerID doesn't exist!""); */
                System.err.println(""GameState.removePlayer(): "" + ""PlayerID doesn't exist!"");
            }
            if (!p.isBoss()) {
                part(p.boss, p);
            }
            while (p.head != null) {
                part(p, p.head);
            }
            if (gamestate == STATE_WAITING) {
                players[p.getId()] = null;
                numOfPlayers--;
            } else {
                setDead(p);
                p.setConnected(false);
            }
            setChanged();
            notifyObservers(p);
        } catch (IndexOutOfBoundsException e) {
            System.err.println(""GameState.removePlayer(): "" + ""PlayerID '"" + p.getId() + ""' out of the allowed "" + ""range 0 - "" + MAX_PLAYER_LIMIT);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Adds a party to another party's underling list. This
     * automatically merges the two parties' gangs.
     *
     * @param parent The Party whose gang the child joined.
     * @param child The Party which joined the parent's gang.
     */
    public void join(Party parent, Party child) {
        try {
            parent.add(child);
            setChanged();
            notifyObservers(child);
        } catch (NullPointerException e) {
            System.err.println(""GameState.join(): parent="" + parent + "" "" + ""child="" + child);
            e.printStackTrace(System.err);
        }
    }

    /**
     * Removes a party from another party's underling list. The
     * parties that were previously member of the parting party's gang
     * before the join will also part with it, provided they are still
     * in the party's underling list.
     *
     * @param parent The Party whose gang the child parts from.
     * @param child The Party which parted the parent's gang.
     */
    public void part(Party parent, Party child) {
        try {
            parent.remove(child);
            setChanged();
            notifyObservers(child);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Returns the player at int id. If player id is out of bounds for
     * the player array, or if no player exists with given id, null is
     * returned. This is consequent with pidFor(Player p) which
     * returns -1 when passed a null value.
     *
     * @param id The id of the player that is to be found.
     * @return The Player with the right id. -1 if no player could be
     * found.
     */
    public Player player(int id) {
        if (id < 0 || id >= MAX_PLAYER_LIMIT)
            return null;
        return players[id];
    }

    public Player[] players() {
        return players;
    }

    public void setMe(Player p) {
        me = p;
    }

    public Player getMe() {
        return me;
    }

    public int getNumOfPlayers() {
        return numOfPlayers;
    }

    public void reload() {
        setChanged();
        notifyObservers(this);
    }

    /**
     * Sets a player's state to dead and increases the dead players
     * counter.
     *
     * @param p The dead Player.
     * @param deathtime The time of death of the player.
     */
    public void setDead(Player p, long deathtime) {
        if (p != null && !p.isDead()) {
            numDead++;
            p.setDead(deathtime);
            setChanged();
            notifyObservers(p);
        }
    }

    public void setDead(Player p) {
        setDead(p, System.currentTimeMillis());
    }

    /**
     * Updates a player's world coordinates in the specified
     * direction.
     *
     * @param p The player.
     * @param direction The direction. As specified by the
     * ANSI-DIRECTIONAL-STANDARD 8-55-155.
     * @deprecated does nothing in gl gui
     */
    public void move(Player p, int direction) {
        /*
	float dirx = 0;
	float diry = 0;
	
	if ((direction & 0x1) != 0) {
	    diry -= Player.MOVE_DISTANCE;
	}
	if ((direction & 0x2) != 0) {
	    dirx -= Player.MOVE_DISTANCE;
	}
	if ((direction & 0x4) != 0) {
	    diry += Player.MOVE_DISTANCE;
	}
	if ((direction & 0x8) != 0) {
	    dirx += Player.MOVE_DISTANCE;
	}
	
	p.setX(p.getX() + dirx);
	p.setY(p.getY() + diry);
	System.err.println(""New player pos:"" + p.getX() + "","" + p.getY() + "" "" + dirx + "" "" + diry);
	setChanged();
	notifyObservers(p);
	*/
    }

    /**
     * Returns number of dead players.
     *
     * @return the number of dead players.
     */
    public int getNumDead() {
        return numDead;
    }

    /**
     * Returns when the game was started.
     *
     * @return The system time when game was started. -1 when game is
     * not yet started.
     */
    public long getGamestart() {
        return gamestart;
    }

    public void setGamestart(long l) {
        gamestart = l;
    }

    /**
     * Packs the entire GameState structure into a byte array.
     * @return array of bytes representing the packed object.
     */
    public byte[] pack() {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        DataOutputStream out = new DataOutputStream(buf);
        Player p = null;
        try {
            int numplayers = numOfPlayers;
            for (int i = 0; i < players.length; i++) {
                if (players[i] != null && !players[i].isConnected())
                    numplayers--;
            }
            out.writeShort(MAGIC_NO);
            out.writeByte(gamestate);
            out.writeByte(numplayers);
            for (int i = 0, k = -1; i < numOfPlayers; i++) {
                // fixme - fix this!
                // exceptions are caught
                while (players[++k] == null) ;
                p = players[k];
                if (!p.isConnected())
                    continue;
                p.pack(out);
                out.writeByte(pidOf(p.boss));
                out.writeByte(pidOf(p.next));
                out.writeByte(pidOf(p.prev));
                out.writeByte(pidOf(p.head));
            }
        } catch (IOException e) {
            System.err.println(""GameState.pack(): *** WARNING *** [IO] "" + ""failed to pack data: "" + e.getMessage());
            return null;
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println(""GameState.pack(): *** ERROR *** [IDX] "" + ""failed to pack data: "" + e.getMessage());
            return null;
        }
        return buf.toByteArray();
    }

    /**
     * Unpacks the current state from the given array.
     * @param b the byte array from which to read.
     */
    public void unpack(byte[] b) {
        try {
            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));
            /* read and verify magic number */
            if (in.readShort() != MAGIC_NO) {
                /* throw new PackableException(); */
                System.err.println(""GameState.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return;
            }
            gamestate = in.readByte();
            // number of players.
            int n = in.readByte();
            /* fixme - data should be read to a temporary place and then
	       verified, after which it should be commited. */
            Player p = null;
            for (int i = 0; i < n; i++) {
                in.mark(3);
                // magic number is checked in Player.unpack().
                in.readShort();
                p = playerAt(in.readByte());
                in.reset();
                if (p.unpack(in)) {
                    p.boss = playerAt(in.readByte());
                    p.next = playerAt(in.readByte());
                    p.prev = playerAt(in.readByte());
                    p.head = playerAt(in.readByte());
                } else {
                    System.err.println(""GameState.unpack(): *** ERROR *** "" + ""data is incomplete! current state "" + ""is inconsistent!"");
                }
            }
        } catch (EOFException e) {
            System.err.println(""GameState.unpack(): *** ERROR *** [EOF] "" + ""data is incomplete! current state is "" + ""inconsistent: "" + e.getMessage());
        } catch (IOException e) {
            System.err.println(""GameState.unpack(): *** ERROR *** [IO] "" + ""unpack data failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
    }

    public int type() {
        return Packable.GAME_STATE;
    }

    /**
     * Returns the player whith the specified id. If a player doesn't exist
     * with that id doesn't exist, a new player is created and returned. If
     * id is outside the allowed range, null is returned.
     *
     * @return the player with the specified id, or null if id is
     *         outside allowed range.
     */
    private Player playerAt(int id) {
        Player p = null;
        try {
            p = players[id];
            if (p == null) {
                p = new Player(id);
                addPlayer(p);
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            //System.err.println(""GameState.playerAt(): "" +
            //		       ""Invalid Player ID specified: "" + id);
        }
        return p;
    }

    /**
     * Returns the id of the specified player.
     *
     * @param p The player for which id is returned.
     * @return The
     */
    private int pidOf(Party p) {
        if (p == null)
            return -1;
        return p.getId();
    }

    /**
     * Returns a string representation of GameState. This includes a
     * full view of the tree.
     */
    public String toString() {
        StringBuffer str = new StringBuffer(""GameState["");
        boolean first = true;
        for (int i = 0, t = -1; i < numOfPlayers; i++) {
            while (++t < players.length && players[t] == null) ;
            if (t >= players.length) {
                return ""ERR,"" + numOfPlayers + ""]"";
            }
            if (first) {
                str.append(players[t]);
                first = false;
            } else {
                str.append("" , "" + players[t]);
            }
        }
        return str + ""]"";
    }
}
","// GameState_1Test.java
package state;

import java.util.*;
import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameState}.
* It contains ten unit test cases for the {@link GameState#player(int)} method.
*/
class GameState_1Test {","// GameState_1Test.java
package state;

import java.util.*;
import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameState}.
* It contains ten unit test cases for the {@link GameState#player(int)} method.
*/
class GameState_1Test {
"
cd58d756-910d-4d08-8670-4d0cd51de1da,/EvoSuiteBenchmark/27_gangup/src/main/java/state/GameState_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8673 tokens (4673 in your prompt; 4000 for the completion). Please reduce your prompt; or completion length.","// GameState.java
/* $Id: GameState.java,v 1.30 2004/05/05 23:45:19 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.30 $
 *
 */
package state;

import java.util.*;
import java.io.*;

/**
 * The state of the game. Includes the gang tree, all players stats
 * and more. Implements Observable for whenever a change in the state
 * is detected.
 */
public class GameState extends Observable implements Packable {

    /**
     * Maximum number of players.
     */
    public static final int MAX_PLAYER_LIMIT = 128;

    /**
     * Number to verify against when unpacking.
     */
    private static final short MAGIC_NO = 0x3BBA;

    /**
     * List of known players.
     */
    private Player[] players;

    /**
     * Total number of known players.
     */
    private int numOfPlayers;

    /**
     * Number of dead players
     */
    private int numDead;

    /**
     * Save when a game is started.
     */
    private long gamestart;

    /**
     * Current state of the game
     */
    private int gamestate;

    /**
     * Waiting for players to join
     */
    public static final int STATE_WAITING = 1;

    /**
     * Warmup time. No attacks possible.
     */
    public static final int STATE_WARMUP = 2;

    /**
     * A game is in progress.
     */
    public static final int STATE_PLAYING = 3;

    /**
     * Game has ended.
     */
    public static final int STATE_ENDED = 4;

    /**
     * The current player for this client. null for the server.
     */
    private Player me;

    /**
     * Minimum time to wait before making next move
     */
    private long mintimemove;

    /**
     * Number of rounds to play
     */
    private int totalRounds;

    /**
     * Current round number
     */
    private int currentRound;

    /**
     * Keep track of when last move of a user was done
     */
    private Hashtable<Integer, Long> lastmove;

    /**
     * Creates a new instance of the GameState class.
     */
    public GameState() {
        this(15000);
    }

    /**
     * Creates a new instance of the GameState class.
     * @param mintimemove How long a user must wait between attack moves.
     */
    public GameState(long mintimemove) {
        players = new Player[MAX_PLAYER_LIMIT];
        numOfPlayers = 0;
        numDead = 0;
        gamestart = 0;
        gamestate = STATE_WAITING;
        currentRound = 1;
        totalRounds = 1;
        this.mintimemove = mintimemove;
        lastmove = new Hashtable<Integer, Long>();
    }

    public void reset(boolean newGame) {
        numDead = 0;
        for (int i = 0; i < players.length; i++) {
            if (players[i] == null)
                continue;
            if (!players[i].isConnected()) {
                if (newGame) {
                    players[i] = null;
                    numOfPlayers--;
                } else {
                    players[i].reset(newGame);
                    setDead(players[i]);
                }
            } else {
                players[i].reset(newGame);
            }
        }
        if (newGame)
            currentRound = 1;
        lastmove = new Hashtable<Integer, Long>();
    }

    public void setTotalRounds(int totalRounds) {
        this.totalRounds = totalRounds;
    }

    public int getTotalRounds() {
        return totalRounds;
    }

    public void setCurrentRound(int currentRound) {
        this.currentRound = currentRound;
    }

    public int getCurrentRound() {
        return currentRound;
    }

    /**
     * Returns the state of the game. Ie, warmup, running, waiting for users.
     * Use the predefined values defined as STATE_* in this class.
     */
    public int getGameState() {
        return gamestate;
    }

    /**
     * Sets the state of the game. Ie, warmup, running, waiting for users.
     * Use the predefined values defined as STATE_* in this class.
     */
    public void setGameState(int gamestate) {
        this.gamestate = gamestate;
        System.err.println(""Notifying observers...:"" + this.gamestate);
        setChanged();
        notifyObservers(new Integer(gamestate));
    }

    /**
     * Check if enough time has passed since last move.
     */
    public boolean isMoveTimeOK(Player player) {
        if (lastmove.containsKey(player.getId())) {
            long time = lastmove.get(new Integer(player.getId()));
            if (time + mintimemove > System.currentTimeMillis())
                return false;
        }
        return true;
    }

    /**
     * Update the time when player last made an attack move.
     */
    public void updateLastMove(Player player) {
        lastmove.put(player.getId(), System.currentTimeMillis());
    }

    /**
     * Adds the specified player to the list of known players.
     *
     * @param p The player that is to be added.
     */
    public void addPlayer(Player p) {
        try {
            if (players[p.getId()] != null) {
                /* throw new GameStateException(""PlayerID exists!""); */
                System.err.println(""GameState.addPlayer(): PlayerID exists!"");
                return;
            }
            players[p.getId()] = p;
            numOfPlayers++;
            updateLastMove(p);
            setChanged();
            notifyObservers();
        } catch (IndexOutOfBoundsException e) {
            System.err.println(""GameState.addPlayer(): "" + ""PlayerID '"" + p.id + ""' out of the allowed "" + ""range 0 - "" + MAX_PLAYER_LIMIT);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Removes the specified player from the list of known players.
     *
     * @param p The player that is to be removed.
     */
    public void removePlayer(Player p) {
        try {
            if (players[p.getId()] == null) {
                /* throw new GameStateException(""PlayerID doesn't exist!""); */
                System.err.println(""GameState.removePlayer(): "" + ""PlayerID doesn't exist!"");
            }
            if (!p.isBoss()) {
                part(p.boss, p);
            }
            while (p.head != null) {
                part(p, p.head);
            }
            if (gamestate == STATE_WAITING) {
                players[p.getId()] = null;
                numOfPlayers--;
            } else {
                setDead(p);
                p.setConnected(false);
            }
            setChanged();
            notifyObservers(p);
        } catch (IndexOutOfBoundsException e) {
            System.err.println(""GameState.removePlayer(): "" + ""PlayerID '"" + p.getId() + ""' out of the allowed "" + ""range 0 - "" + MAX_PLAYER_LIMIT);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Adds a party to another party's underling list. This
     * automatically merges the two parties' gangs.
     *
     * @param parent The Party whose gang the child joined.
     * @param child The Party which joined the parent's gang.
     */
    public void join(Party parent, Party child) {
        try {
            parent.add(child);
            setChanged();
            notifyObservers(child);
        } catch (NullPointerException e) {
            System.err.println(""GameState.join(): parent="" + parent + "" "" + ""child="" + child);
            e.printStackTrace(System.err);
        }
    }

    /**
     * Removes a party from another party's underling list. The
     * parties that were previously member of the parting party's gang
     * before the join will also part with it, provided they are still
     * in the party's underling list.
     *
     * @param parent The Party whose gang the child parts from.
     * @param child The Party which parted the parent's gang.
     */
    public void part(Party parent, Party child) {
        try {
            parent.remove(child);
            setChanged();
            notifyObservers(child);
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Returns the player at int id. If player id is out of bounds for
     * the player array, or if no player exists with given id, null is
     * returned. This is consequent with pidFor(Player p) which
     * returns -1 when passed a null value.
     *
     * @param id The id of the player that is to be found.
     * @return The Player with the right id. -1 if no player could be
     * found.
     */
    public Player player(int id) {
        if (id < 0 || id >= MAX_PLAYER_LIMIT)
            return null;
        return players[id];
    }

    public Player[] players() {
        return players;
    }

    public void setMe(Player p) {
        me = p;
    }

    public Player getMe() {
        return me;
    }

    public int getNumOfPlayers() {
        return numOfPlayers;
    }

    public void reload() {
        setChanged();
        notifyObservers(this);
    }

    /**
     * Sets a player's state to dead and increases the dead players
     * counter.
     *
     * @param p The dead Player.
     * @param deathtime The time of death of the player.
     */
    public void setDead(Player p, long deathtime) {
        if (p != null && !p.isDead()) {
            numDead++;
            p.setDead(deathtime);
            setChanged();
            notifyObservers(p);
        }
    }

    public void setDead(Player p) {
        setDead(p, System.currentTimeMillis());
    }

    /**
     * Updates a player's world coordinates in the specified
     * direction.
     *
     * @param p The player.
     * @param direction The direction. As specified by the
     * ANSI-DIRECTIONAL-STANDARD 8-55-155.
     * @deprecated does nothing in gl gui
     */
    public void move(Player p, int direction) {
        /*
	float dirx = 0;
	float diry = 0;
	
	if ((direction & 0x1) != 0) {
	    diry -= Player.MOVE_DISTANCE;
	}
	if ((direction & 0x2) != 0) {
	    dirx -= Player.MOVE_DISTANCE;
	}
	if ((direction & 0x4) != 0) {
	    diry += Player.MOVE_DISTANCE;
	}
	if ((direction & 0x8) != 0) {
	    dirx += Player.MOVE_DISTANCE;
	}
	
	p.setX(p.getX() + dirx);
	p.setY(p.getY() + diry);
	System.err.println(""New player pos:"" + p.getX() + "","" + p.getY() + "" "" + dirx + "" "" + diry);
	setChanged();
	notifyObservers(p);
	*/
    }

    /**
     * Returns number of dead players.
     *
     * @return the number of dead players.
     */
    public int getNumDead() {
        return numDead;
    }

    /**
     * Returns when the game was started.
     *
     * @return The system time when game was started. -1 when game is
     * not yet started.
     */
    public long getGamestart() {
        return gamestart;
    }

    public void setGamestart(long l) {
        gamestart = l;
    }

    /**
     * Packs the entire GameState structure into a byte array.
     * @return array of bytes representing the packed object.
     */
    public byte[] pack() {
        ByteArrayOutputStream buf = new ByteArrayOutputStream();
        DataOutputStream out = new DataOutputStream(buf);
        Player p = null;
        try {
            int numplayers = numOfPlayers;
            for (int i = 0; i < players.length; i++) {
                if (players[i] != null && !players[i].isConnected())
                    numplayers--;
            }
            out.writeShort(MAGIC_NO);
            out.writeByte(gamestate);
            out.writeByte(numplayers);
            for (int i = 0, k = -1; i < numOfPlayers; i++) {
                // fixme - fix this!
                // exceptions are caught
                while (players[++k] == null) ;
                p = players[k];
                if (!p.isConnected())
                    continue;
                p.pack(out);
                out.writeByte(pidOf(p.boss));
                out.writeByte(pidOf(p.next));
                out.writeByte(pidOf(p.prev));
                out.writeByte(pidOf(p.head));
            }
        } catch (IOException e) {
            System.err.println(""GameState.pack(): *** WARNING *** [IO] "" + ""failed to pack data: "" + e.getMessage());
            return null;
        } catch (ArrayIndexOutOfBoundsException e) {
            System.err.println(""GameState.pack(): *** ERROR *** [IDX] "" + ""failed to pack data: "" + e.getMessage());
            return null;
        }
        return buf.toByteArray();
    }

    /**
     * Unpacks the current state from the given array.
     * @param b the byte array from which to read.
     */
    public void unpack(byte[] b) {
        try {
            DataInputStream in = new DataInputStream(new ByteArrayInputStream(b));
            /* read and verify magic number */
            if (in.readShort() != MAGIC_NO) {
                /* throw new PackableException(); */
                System.err.println(""GameState.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return;
            }
            gamestate = in.readByte();
            // number of players.
            int n = in.readByte();
            /* fixme - data should be read to a temporary place and then
	       verified, after which it should be commited. */
            Player p = null;
            for (int i = 0; i < n; i++) {
                in.mark(3);
                // magic number is checked in Player.unpack().
                in.readShort();
                p = playerAt(in.readByte());
                in.reset();
                if (p.unpack(in)) {
                    p.boss = playerAt(in.readByte());
                    p.next = playerAt(in.readByte());
                    p.prev = playerAt(in.readByte());
                    p.head = playerAt(in.readByte());
                } else {
                    System.err.println(""GameState.unpack(): *** ERROR *** "" + ""data is incomplete! current state "" + ""is inconsistent!"");
                }
            }
        } catch (EOFException e) {
            System.err.println(""GameState.unpack(): *** ERROR *** [EOF] "" + ""data is incomplete! current state is "" + ""inconsistent: "" + e.getMessage());
        } catch (IOException e) {
            System.err.println(""GameState.unpack(): *** ERROR *** [IO] "" + ""unpack data failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
    }

    public int type() {
        return Packable.GAME_STATE;
    }

    /**
     * Returns the player whith the specified id. If a player doesn't exist
     * with that id doesn't exist, a new player is created and returned. If
     * id is outside the allowed range, null is returned.
     *
     * @return the player with the specified id, or null if id is
     *         outside allowed range.
     */
    private Player playerAt(int id) {
        Player p = null;
        try {
            p = players[id];
            if (p == null) {
                p = new Player(id);
                addPlayer(p);
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            //System.err.println(""GameState.playerAt(): "" +
            //		       ""Invalid Player ID specified: "" + id);
        }
        return p;
    }

    /**
     * Returns the id of the specified player.
     *
     * @param p The player for which id is returned.
     * @return The
     */
    private int pidOf(Party p) {
        if (p == null)
            return -1;
        return p.getId();
    }

    /**
     * Returns a string representation of GameState. This includes a
     * full view of the tree.
     */
    public String toString() {
        StringBuffer str = new StringBuffer(""GameState["");
        boolean first = true;
        for (int i = 0, t = -1; i < numOfPlayers; i++) {
            while (++t < players.length && players[t] == null) ;
            if (t >= players.length) {
                return ""ERR,"" + numOfPlayers + ""]"";
            }
            if (first) {
                str.append(players[t]);
                first = false;
            } else {
                str.append("" , "" + players[t]);
            }
        }
        return str + ""]"";
    }
}
","// GameState_3Test.java
package state;

import java.util.*;
import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameState}.
* It contains ten unit test cases for the {@link GameState#pack()} method.
*/
class GameState_3Test {","// GameState_3Test.java
package state;

import java.util.*;
import java.io.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link GameState}.
* It contains ten unit test cases for the {@link GameState#pack()} method.
*/
class GameState_3Test {
"
cmpl-6tvO8jShqYEX5K9JciDsP4EOZxoR3,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Party.java,38.48352384567261,stop,"// Party.java
/* $Id: Party.java,v 1.2 2004/03/31 21:12:03 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.2 $
 *
 */
package state;

import java.io.*;
import java.util.*;

/**
 * A party in the tree view. Generally, all parties used will be of
 * class Player (which extends Party).
 */
public class Party {

    /**
     * The party id
     */
    int id;

    /**
     * The supergroup.
     */
    public Party boss;

    /**
     * The first subgroup.
     */
    public Party head;

    /**
     * The next group at the same level.
     */
    public Party next;

    /**
     * The previous group at the same level.
     */
    public Party prev;

    /**
     * Creates a new instance of the Party class. All fields are set
     * to null, except id which is set to -1.
     */
    public Party() {
        this(-1);
    }

    public Party(int id) {
        this.id = id;
        this.boss = null;
        this.head = null;
        this.next = null;
        this.prev = null;
    }

    /**
     * Used to determine whether this player is the current boss of
     * his gang.
     *
     * @return <i>true</i> if this player currently has no
     * boss. Otherwise <i>false</i>.
     */
    public boolean isBoss() {
        return boss == null;
    }

    /**
     * Returns the boss of current gang.
     */
    public Party gangBoss() {
        if (isBoss()) {
            return this;
        } else {
            return boss.gangBoss();
        }
    }

    /**
     * Add a group as a subgroup to this group. Does not check whether
     * a join is allowed or not.
     *
     * @param p The party to be added.
     */
    public void add(Party p) {
        try {
            p.boss = this;
            p.next = head;
            p.prev = null;
            if (head != null) {
                head.prev = p;
            }
            head = p;
        } catch (NullPointerException e) {
            e.printStackTrace(System.err);
        }
    }

    /**
     * Remove a group as a subgroup to this group. Does not check
     * whether given group is a subgroup.
     *
     * @param p The party to be removed.
     */
    public void remove(Party p) {
        if (p != null) {
            if (p.prev != null) {
                p.prev.next = p.next;
            } else {
                head = p.next;
            }
            if (p.next != null) {
                p.next.prev = p.prev;
            }
            p.next = null;
            p.prev = null;
            p.boss = null;
        }
    }

    /**
     * Returns a LinkedList representation of the current subparty. A
     * subparty includes the current Party plus all its childrens
     * subparties.
     */
    public LinkedList<Party> getSubparty() {
        LinkedList<Party> plist = new LinkedList<Party>();
        Party tmp;
        plist.add(this);
        for (tmp = head; tmp != null; tmp = tmp.next) {
            plist.addAll(tmp.getSubparty());
        }
        return plist;
    }

    public int getId() {
        return id;
    }

    public String toString() {
        return """";
    }
}
","// PartyTest.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Party}.
* It contains ten unit test cases for the {@link Party#gangBoss()} method.
*/
class PartyTest {","// PartyTest.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Party}.
* It contains ten unit test cases for the {@link Party#gangBoss()} method.
*/
class PartyTest {

		/**
		* Test case 1 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is the boss.
		*/
		@Test
		void testGangBoss1() {
				Party p = new Party(1);
				assertEquals(p, p.gangBoss());
		}
		
		/**
		* Test case 2 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss2() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				p.add(p2);
				assertEquals(p, p2.gangBoss());
		}
		
		/**
		* Test case 3 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss3() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				p.add(p2);
				p2.add(p3);
				assertEquals(p, p3.gangBoss());
		}
		
		/**
		* Test case 4 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss4() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				Party p4 = new Party(4);
				p.add(p2);
				p2.add(p3);
				p3.add(p4);
				assertEquals(p, p4.gangBoss());
		}
		
		/**
		* Test case 5 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss5() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				Party p4 = new Party(4);
				Party p5 = new Party(5);
				p.add(p2);
				p2.add(p3);
				p3.add(p4);
				p4.add(p5);
				assertEquals(p, p5.gangBoss());
		}
		
		/**
		* Test case 6 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss6() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				Party p4 = new Party(4);
				Party p5 = new Party(5);
				Party p6 = new Party(6);
				p.add(p2);
				p2.add(p3);
				p3.add(p4);
				p4.add(p5);
				p5.add(p6);
				assertEquals(p, p6.gangBoss());
		}
		
		/**
		* Test case 7 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss7() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				Party p4 = new Party(4);
				Party p5 = new Party(5);
				Party p6 = new Party(6);
				Party p7 = new Party(7);
				p.add(p2);
				p2.add(p3);
				p3.add(p4);
				p4.add(p5);
				p5.add(p6);
				p6.add(p7);
				assertEquals(p, p7.gangBoss());
		}
		
		/**
		* Test case 8 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss8() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				Party p4 = new Party(4);
				Party p5 = new Party(5);
				Party p6 = new Party(6);
				Party p7 = new Party(7);
				Party p8 = new Party(8);
				p.add(p2);
				p2.add(p3);
				p3.add(p4);
				p4.add(p5);
				p5.add(p6);
				p6.add(p7);
				p7.add(p8);
				assertEquals(p, p8.gangBoss());
		}
		
		/**
		* Test case 9 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss9() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				Party p4 = new Party(4);
				Party p5 = new Party(5);
				Party p6 = new Party(6);
				Party p7 = new Party(7);
				Party p8 = new Party(8);
				Party p9 = new Party(9);
				p.add(p2);
				p2.add(p3);
				p3.add(p4);
				p4.add(p5);
				p5.add(p6);
				p6.add(p7);
				p7.add(p8);
				p8.add(p9);
				assertEquals(p, p9.gangBoss());
		}
		
		/**
		* Test case 10 for {@link Party#gangBoss()}.
		* This test case tests the gangBoss method when the party is not the boss.
		*/
		@Test
		void testGangBoss10() {
				Party p = new Party(1);
				Party p2 = new Party(2);
				Party p3 = new Party(3);
				Party p4 = new Party(4);
				Party p5 = new Party(5);
				Party p6 = new Party(6);
				Party p7 = new Party(7);
				Party p8 = new Party(8);
				Party p9 = new Party(9);
				Party p10 = new Party(10);
				p.add(p2);
				p2.add(p3);
				p3.add(p4);
				p4.add(p5);
				p5.add(p6);
				p6.add(p7);
				p7.add(p8);
				p8.add(p9);
				p9.add(p10);
				assertEquals(p, p10.gangBoss());
		}
}"
cmpl-6tvPBtufjUydbsbqRrHSQKXez0lzZ,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Player_0Test.java,91.6305935382843,length,"// Player.java
/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.20 $
 *
 */
package state;

import java.io.*;
import java.util.*;

/**
 * Represents a player in the game world.
 */
public class Player extends Party implements Packable {

    /**
     * The tolerance to decide whether a player has reached its
     *        destination. If x or y distance to target is less than
     *        TOLERANCE, no move in that direction is triggered.
     */
    public static final float TOLERANCE = 0.2f;

    /**
     * The distance to move in one step.
     */
    public static final float MOVE_DISTANCE = 0.1f;

    /**
     * Number to verify against when unpacking.
     */
    public static final short MAGIC_NO = 0x1337;

    /* Strength of this player */
    private int strength;

    /* Picture of this player */
    private int pictureid;

    /* True if this player is alive */
    private boolean alive;

    /* The time when this user died. */
    private long deathtime;

    /* World coordinates of this player. */
    private float x = 10.0f, y = 0.0f, z;

    /**
     * List to keep track of allowed joins
     */
    private Hashtable<Integer, JoinInfo> joinlist;

    /**
     * Size of player class when packed (not including length of name)
     */
    private int packsize = 10;

    /**
     * Reference to the packed data.
     */
    private byte[] data;

    /**
     * True if referenced data is _not_ up to date.
     */
    private boolean dirty;

    /**
     * Name of the player.
     */
    private String name;

    /**
     * False if this player has dropped from the game.
     */
    private boolean connected;

    /**
     * The IP of the player.
     */
    private String ip;

    /**
     * Amount of money the user has earned.
     */
    private float money;

    /**
     * Class used to keep track of when a user was invited or applied
     * to join a group.
     */
    private class JoinInfo {

        long time;

        boolean invite;

        JoinInfo(boolean invited) {
            time = System.currentTimeMillis();
            invite = invited;
        }
    }

    /**
     * Creates a new empty instance of the Player class without an
     * id. Note that a call to GameState.player(pidFor(new Player()))
     * will return null.
     */
    public Player() {
        this(-1);
    }

    /**
     * Creates a new player with the given id.
     * @param id the associated id of this player.
     */
    public Player(int id) {
        super(id);
        this.strength = 1;
        this.pictureid = 0;
        this.alive = true;
        this.dirty = true;
        this.name = ""Player"" + id;
        this.deathtime = 0;
        this.connected = true;
        this.ip = ""0.0.0.0"";
        this.joinlist = new Hashtable<Integer, JoinInfo>();
    }

    public void reset(boolean newGame) {
        this.joinlist = new Hashtable<Integer, JoinInfo>();
        this.alive = true;
        this.dirty = true;
        this.deathtime = 0;
        this.boss = null;
        this.head = null;
        this.next = null;
        this.prev = null;
        if (newGame) {
            money = 0;
        }
    }

    /**
     */
    public Player(int id, String name, int pictureid) {
        this(id);
        this.name = name;
        this.pictureid = pictureid;
        System.err.println(id + "" "" + name + "" "" + pictureid);
    }

    /**
     */
    public Player(int id, String ip, String name, int pictureid) {
        this(id, name, pictureid);
        this.ip = ip;
    }

    public Player(int id, String ip, String name, int pid, int strength) {
        this(id, ip, name, pid);
        this.strength = strength;
    }

    public boolean isConnected() {
        return connected;
    }

    public void setConnected(boolean conned) {
        connected = conned;
    }

    /**
     * Returns the current strength of the gang this player is part of.
     * @return the total strength of this players gang.
     */
    public int gangStrength() {
        int str = 0;
        LinkedList<Party> gang = gangBoss().getSubparty();
        for (Party p : gang) {
            str += ((Player) p).strength;
        }
        return str;
    }

    public void setDead(long deathtime, boolean alive) {
        this.deathtime = deathtime;
        this.alive = alive;
    }

    public void setDead() {
        setDead(System.currentTimeMillis());
    }

    public void setDead(long deathtime) {
        setDead(deathtime, false);
    }

    public boolean isDead() {
        return !alive;
    }

    public long getTimeOfDeath() {
        return deathtime;
    }

    public int getStrength() {
        return strength;
    }

    /**
     * Sets the amount of money this player has earned
     */
    public void setMoney(float money) {
        this.money = money;
    }

    /**
     * Returns amount of money this player has earned
     */
    public float getMoney() {
        return money;
    }

    /**
     * Returns player IP.
     */
    public String getIP() {
        return ip;
    }

    /**
     * Returns player name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns player picture id.
     */
    public int getPictureId() {
        return pictureid;
    }

    /**
     * Returns player x coordinate.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns player y coordinate.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns player z coordinate.
     */
    public float getZ() {
        return z;
    }

    /**
     * Sets player y coordinate.
     */
    public void setY(float f) {
        y = f;
    }

    /**
     * Sets player x coordinate.
     */
    public void setX(float f) {
        x = f;
    }

    /**
     * Sets player z coordinate.
     */
    public void setZ(float f) {
        z = f;
    }

    /**
     * Checks if player <i>joiner</i> is allowed to join the current player.
     * If <i>invited</i> is set it will be checked if <i>joiner</i> was
     * invited, otherwise it'll be checked if <i>joiner</i> applied.
     */
    public boolean isJoinOK(Player joiner, boolean invited) {
        if (joinlist.containsKey(joiner.getId())) {
            JoinInfo jinfo = joinlist.get(joiner.getId());
            // change 15000 to either a constant defined at top of
            // file or a variable read from config
            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)
                return true;
        }
        return false;
    }

    public void setJoinOK(Player joiner, boolean invited) {
        JoinInfo jinfo = new JoinInfo(invited);
        joinlist.put(joiner.id, jinfo);
    }

    /**
     * Packs this player into the specified stream.
     * @param out the stream to write this player to.
     */
    public void pack(DataOutputStream out) throws IOException {
        out.writeShort(MAGIC_NO);
        out.writeByte(id);
        out.writeShort(strength);
        out.writeShort(pictureid);
        out.writeFloat(x);
        out.writeFloat(y);
        out.writeFloat(z);
        out.writeUTF(name);
    }

    /**
     * Unpack and set player data from the specified stream.
     * @param in the stream to read data from.
     * @return true if data was successfully unpacked.
     */
    public boolean unpack(DataInputStream in) {
        Player tmp = null;
        try {
            /* Verify that stream really contains player data. */
            if (in.readShort() != MAGIC_NO) {
                System.err.println(""Player.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return false;
            }
            /* Try unpacking the data to a temporary variable before
	       commiting the changes. */
            tmp = new Player();
            tmp.id = in.readByte();
            tmp.strength = in.readShort();
            tmp.pictureid = in.readShort();
            tmp.x = in.readFloat();
            tmp.y = in.readFloat();
            tmp.z = in.readFloat();
            tmp.name = in.readUTF();
        } catch (EOFException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [EOF] "" + ""data was incomplete: "" + e.getMessage());
            return false;
        } catch (IOException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [IO] "" + ""failed to unpack data: "" + e.getMessage());
            return false;
        }
        /* Apply the unpacked data. */
        id = tmp.id;
        name = tmp.name;
        strength = tmp.strength;
        pictureid = tmp.pictureid;
        x = tmp.x;
        y = tmp.y;
        z = tmp.z;
        return true;
    }

    /**
     * Returns an unambigious byte-array representation of this
     * object.
     *
     * @deprecated
     * @return The resulting byte array.
     */
    public byte[] pack() {
        try {
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            DataOutputStream out = new DataOutputStream(buf);
            pack(out);
            out.close();
            return buf.toByteArray();
        } catch (IOException e) {
            System.err.println(""Player.pack(): *** ERROR *** [IO] "" + ""pack failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
        return null;
    }

    /**
     * Unpacks an array previously created with pack() and puts in
     * this object.
     *
     * @deprecated
     * @param b the byte array to be unpacked.
     */
    public void unpack(byte[] b) {
        unpack(new DataInputStream(new ByteArrayInputStream(b)));
    }

    /**
     * Returns the type of the packable.
     * @return The resulting byte array.
     */
    public int type() {
        return Packable.PLAYER;
    }

    public String toString() {
        return name;
    }
}
","// Player_0Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#gangStrength()} method.
*/
class Player_0Test {","// Player_0Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#gangStrength()} method.
*/
class Player_0Test {

		/**
		* Test case 1 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is not in a gang.
		*/
		@Test
		void testGangStrength_1() {
				Player p = new Player();
				assertEquals(0, p.gangStrength());
		}
		
		/**
		* Test case 2 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with one member.
		*/
		@Test
		void testGangStrength_2() {
				Player p = new Player();
				Player p2 = new Player();
				p.join(p2);
				assertEquals(1, p.gangStrength());
		}
		
		/**
		* Test case 3 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with two members.
		*/
		@Test
		void testGangStrength_3() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				p.join(p2);
				p.join(p3);
				assertEquals(2, p.gangStrength());
		}
		
		/**
		* Test case 4 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with three members.
		*/
		@Test
		void testGangStrength_4() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				assertEquals(3, p.gangStrength());
		}
		
		/**
		* Test case 5 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with four members.
		*/
		@Test
		void testGangStrength_5() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				assertEquals(4, p.gangStrength());
		}
		
		/**
		* Test case 6 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with five members.
		*/
		@Test
		void testGangStrength_6() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				assertEquals(5, p.gangStrength());
		}
		
		/**
		* Test case 7 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with six members.
		*/
		@Test
		void testGangStrength_7() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				Player p7 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				p.join(p7);
				assertEquals(6, p.gangStrength());
		}
		
		/**
		* Test case 8 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with seven members.
		*/
		@Test
		void testGangStrength_8() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				Player p7 = new Player();
				Player p8 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				p.join(p7);
				p.join(p8);
				assertEquals(7, p.gangStrength());
		}
		
		/**
		* Test case 9 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with eight members.
		*/
		@Test
		void testGangStrength_9() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				Player p7 = new Player();
				Player p8 = new Player();
				Player p9 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				p.join(p7);
				p.join(p8);
				p.join(p9);
				assertEquals(8, p.gangStrength());
		}
		
		/**
		* Test case 10 for {@link Player#gangStrength()}.
		* This test case tests the gangStrength method when the player is in a gang with nine members.
		*/
		@Test
		void testGangStrength_10() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				Player p7 = new Player();
				Player p8 = new Player();
				Player p9 = new Player();
				Player p10 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				p.join(p7);
				p.join(p8);
				p.join(p9);
				p.join(p10);
				assertEquals(9, p.gangStrength());
		}
}

// Player_1Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#isJoinOK(Player, boolean)} method.
*/
class Player_1Test {
		
		/**
		* Test case 1 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is not in a gang.
		*/
		@Test
		void testIsJoinOK_1() {
				Player p = new Player();
				Player p2 = new Player();
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 2 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with one member.
		*/
		@Test
		void testIsJoinOK_2() {
				Player p = new Player();
				Player p2 = new Player();
				p.join(p2);
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 3 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with two members.
		*/
		@Test
		void testIsJoinOK_3() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				p.join(p2);
				p.join(p3);
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 4 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with three members.
		*/
		@Test
		void testIsJoinOK_4() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 5 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with four members.
		*/
		@Test
		void testIsJoinOK_5() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 6 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with five members.
		*/
		@Test
		void testIsJoinOK_6() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 7 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with six members.
		*/
		@Test
		void testIsJoinOK_7() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				Player p7 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				p.join(p7);
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 8 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with seven members.
		*/
		@Test
		void testIsJoinOK_8() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				Player p7 = new Player();
				Player p8 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				p.join(p7);
				p.join(p8);
				assertFalse(p.isJoinOK(p2, true));
		}
		
		/**
		* Test case 9 for {@link Player#isJoinOK(Player, boolean)}.
		* This test case tests the isJoinOK method when the player is in a gang with eight members.
		*/
		@Test
		void testIsJoinOK_9() {
				Player p = new Player();
				Player p2 = new Player();
				Player p3 = new Player();
				Player p4 = new Player();
				Player p5 = new Player();
				Player p6 = new Player();
				Player p7 = new Player();
				Player p8 = new Player();
				Player p9 = new Player();
				p.join(p2);
				p.join(p3);
				p.join(p4);
				p.join(p5);
				p.join(p6);
				p.join(p7);
				p.join(p8);
				p.join(p9);
		"
cmpl-6tvQft8Zbd6HQ84pVbpLTkmAZjADe,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Player_1Test.java,96.28447794914246,length,"// Player.java
/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.20 $
 *
 */
package state;

import java.io.*;
import java.util.*;

/**
 * Represents a player in the game world.
 */
public class Player extends Party implements Packable {

    /**
     * The tolerance to decide whether a player has reached its
     *        destination. If x or y distance to target is less than
     *        TOLERANCE, no move in that direction is triggered.
     */
    public static final float TOLERANCE = 0.2f;

    /**
     * The distance to move in one step.
     */
    public static final float MOVE_DISTANCE = 0.1f;

    /**
     * Number to verify against when unpacking.
     */
    public static final short MAGIC_NO = 0x1337;

    /* Strength of this player */
    private int strength;

    /* Picture of this player */
    private int pictureid;

    /* True if this player is alive */
    private boolean alive;

    /* The time when this user died. */
    private long deathtime;

    /* World coordinates of this player. */
    private float x = 10.0f, y = 0.0f, z;

    /**
     * List to keep track of allowed joins
     */
    private Hashtable<Integer, JoinInfo> joinlist;

    /**
     * Size of player class when packed (not including length of name)
     */
    private int packsize = 10;

    /**
     * Reference to the packed data.
     */
    private byte[] data;

    /**
     * True if referenced data is _not_ up to date.
     */
    private boolean dirty;

    /**
     * Name of the player.
     */
    private String name;

    /**
     * False if this player has dropped from the game.
     */
    private boolean connected;

    /**
     * The IP of the player.
     */
    private String ip;

    /**
     * Amount of money the user has earned.
     */
    private float money;

    /**
     * Class used to keep track of when a user was invited or applied
     * to join a group.
     */
    private class JoinInfo {

        long time;

        boolean invite;

        JoinInfo(boolean invited) {
            time = System.currentTimeMillis();
            invite = invited;
        }
    }

    /**
     * Creates a new empty instance of the Player class without an
     * id. Note that a call to GameState.player(pidFor(new Player()))
     * will return null.
     */
    public Player() {
        this(-1);
    }

    /**
     * Creates a new player with the given id.
     * @param id the associated id of this player.
     */
    public Player(int id) {
        super(id);
        this.strength = 1;
        this.pictureid = 0;
        this.alive = true;
        this.dirty = true;
        this.name = ""Player"" + id;
        this.deathtime = 0;
        this.connected = true;
        this.ip = ""0.0.0.0"";
        this.joinlist = new Hashtable<Integer, JoinInfo>();
    }

    public void reset(boolean newGame) {
        this.joinlist = new Hashtable<Integer, JoinInfo>();
        this.alive = true;
        this.dirty = true;
        this.deathtime = 0;
        this.boss = null;
        this.head = null;
        this.next = null;
        this.prev = null;
        if (newGame) {
            money = 0;
        }
    }

    /**
     */
    public Player(int id, String name, int pictureid) {
        this(id);
        this.name = name;
        this.pictureid = pictureid;
        System.err.println(id + "" "" + name + "" "" + pictureid);
    }

    /**
     */
    public Player(int id, String ip, String name, int pictureid) {
        this(id, name, pictureid);
        this.ip = ip;
    }

    public Player(int id, String ip, String name, int pid, int strength) {
        this(id, ip, name, pid);
        this.strength = strength;
    }

    public boolean isConnected() {
        return connected;
    }

    public void setConnected(boolean conned) {
        connected = conned;
    }

    /**
     * Returns the current strength of the gang this player is part of.
     * @return the total strength of this players gang.
     */
    public int gangStrength() {
        int str = 0;
        LinkedList<Party> gang = gangBoss().getSubparty();
        for (Party p : gang) {
            str += ((Player) p).strength;
        }
        return str;
    }

    public void setDead(long deathtime, boolean alive) {
        this.deathtime = deathtime;
        this.alive = alive;
    }

    public void setDead() {
        setDead(System.currentTimeMillis());
    }

    public void setDead(long deathtime) {
        setDead(deathtime, false);
    }

    public boolean isDead() {
        return !alive;
    }

    public long getTimeOfDeath() {
        return deathtime;
    }

    public int getStrength() {
        return strength;
    }

    /**
     * Sets the amount of money this player has earned
     */
    public void setMoney(float money) {
        this.money = money;
    }

    /**
     * Returns amount of money this player has earned
     */
    public float getMoney() {
        return money;
    }

    /**
     * Returns player IP.
     */
    public String getIP() {
        return ip;
    }

    /**
     * Returns player name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns player picture id.
     */
    public int getPictureId() {
        return pictureid;
    }

    /**
     * Returns player x coordinate.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns player y coordinate.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns player z coordinate.
     */
    public float getZ() {
        return z;
    }

    /**
     * Sets player y coordinate.
     */
    public void setY(float f) {
        y = f;
    }

    /**
     * Sets player x coordinate.
     */
    public void setX(float f) {
        x = f;
    }

    /**
     * Sets player z coordinate.
     */
    public void setZ(float f) {
        z = f;
    }

    /**
     * Checks if player <i>joiner</i> is allowed to join the current player.
     * If <i>invited</i> is set it will be checked if <i>joiner</i> was
     * invited, otherwise it'll be checked if <i>joiner</i> applied.
     */
    public boolean isJoinOK(Player joiner, boolean invited) {
        if (joinlist.containsKey(joiner.getId())) {
            JoinInfo jinfo = joinlist.get(joiner.getId());
            // change 15000 to either a constant defined at top of
            // file or a variable read from config
            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)
                return true;
        }
        return false;
    }

    public void setJoinOK(Player joiner, boolean invited) {
        JoinInfo jinfo = new JoinInfo(invited);
        joinlist.put(joiner.id, jinfo);
    }

    /**
     * Packs this player into the specified stream.
     * @param out the stream to write this player to.
     */
    public void pack(DataOutputStream out) throws IOException {
        out.writeShort(MAGIC_NO);
        out.writeByte(id);
        out.writeShort(strength);
        out.writeShort(pictureid);
        out.writeFloat(x);
        out.writeFloat(y);
        out.writeFloat(z);
        out.writeUTF(name);
    }

    /**
     * Unpack and set player data from the specified stream.
     * @param in the stream to read data from.
     * @return true if data was successfully unpacked.
     */
    public boolean unpack(DataInputStream in) {
        Player tmp = null;
        try {
            /* Verify that stream really contains player data. */
            if (in.readShort() != MAGIC_NO) {
                System.err.println(""Player.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return false;
            }
            /* Try unpacking the data to a temporary variable before
	       commiting the changes. */
            tmp = new Player();
            tmp.id = in.readByte();
            tmp.strength = in.readShort();
            tmp.pictureid = in.readShort();
            tmp.x = in.readFloat();
            tmp.y = in.readFloat();
            tmp.z = in.readFloat();
            tmp.name = in.readUTF();
        } catch (EOFException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [EOF] "" + ""data was incomplete: "" + e.getMessage());
            return false;
        } catch (IOException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [IO] "" + ""failed to unpack data: "" + e.getMessage());
            return false;
        }
        /* Apply the unpacked data. */
        id = tmp.id;
        name = tmp.name;
        strength = tmp.strength;
        pictureid = tmp.pictureid;
        x = tmp.x;
        y = tmp.y;
        z = tmp.z;
        return true;
    }

    /**
     * Returns an unambigious byte-array representation of this
     * object.
     *
     * @deprecated
     * @return The resulting byte array.
     */
    public byte[] pack() {
        try {
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            DataOutputStream out = new DataOutputStream(buf);
            pack(out);
            out.close();
            return buf.toByteArray();
        } catch (IOException e) {
            System.err.println(""Player.pack(): *** ERROR *** [IO] "" + ""pack failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
        return null;
    }

    /**
     * Unpacks an array previously created with pack() and puts in
     * this object.
     *
     * @deprecated
     * @param b the byte array to be unpacked.
     */
    public void unpack(byte[] b) {
        unpack(new DataInputStream(new ByteArrayInputStream(b)));
    }

    /**
     * Returns the type of the packable.
     * @return The resulting byte array.
     */
    public int type() {
        return Packable.PLAYER;
    }

    public String toString() {
        return name;
    }
}
","// Player_1Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#isJoinOK(Player, boolean)} method.
*/
class Player_1Test {","// Player_1Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#isJoinOK(Player, boolean)} method.
*/
class Player_1Test {

		/**
		* Test case 1 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is not in the joinlist.
		*/
		@Test
		void testIsJoinOK_1() {
				Player player = new Player();
				Player joiner = new Player();
				assertFalse(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 2 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is in the joinlist but the time has expired.
		*/
		@Test
		void testIsJoinOK_2() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 3 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is in the joinlist but the time has not expired.
		*/
		@Test
		void testIsJoinOK_3() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				assertFalse(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 4 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is in the joinlist but the time has expired.
		*/
		@Test
		void testIsJoinOK_4() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 5 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is in the joinlist but the time has not expired.
		*/
		@Test
		void testIsJoinOK_5() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				assertFalse(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 6 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is in the joinlist but the time has expired.
		*/
		@Test
		void testIsJoinOK_6() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 7 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is in the joinlist but the time has not expired.
		*/
		@Test
		void testIsJoinOK_7() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				assertFalse(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 8 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns false when the player is in the joinlist but the time has expired.
		*/
		@Test
		void testIsJoinOK_8() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 9 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns true when the player is in the joinlist and the time has not expired.
		*/
		@Test
		void testIsJoinOK_9() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				assertTrue(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 10 for {@link Player#isJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method returns true when the player is in the joinlist and the time has not expired.
		*/
		@Test
		void testIsJoinOK_10() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				assertTrue(player.isJoinOK(joiner, false));
		}
}

// Player_2Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#setJoinOK(Player, boolean)} method.
*/
class Player_2Test {
		
		/**
		* Test case 1 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_1() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				assertTrue(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 2 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_2() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				assertTrue(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 3 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_3() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				assertFalse(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 4 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_4() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				assertFalse(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 5 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_5() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 6 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_6() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 7 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_7() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, false));
		}
		
		/**
		* Test case 8 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_8() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				try {
						Thread.sleep(15000);
				} catch (InterruptedException e) {
						e.printStackTrace();
				}
				assertFalse(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 9 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_9() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, true);
				assertTrue(player.isJoinOK(joiner, true));
		}
		
		/**
		* Test case 10 for {@link Player#setJoinOK(Player, boolean)}.
		* <p>
		* This test case checks if the method adds the player to the joinlist.
		*/
		@Test
		void testSetJoinOK_10() {
				Player player = new Player();
				Player joiner = new Player();
				player.setJoinOK(joiner, false);
				assertTrue(player.isJoinOK(joiner, false));
		}
}

// Player_3Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#setDead(long)} method.
*/
class Player_3Test {
		
		/**
		* Test case 1 for {@link Player#setDead(long)}.
		* <p>
		* This test case checks if the method sets the deathtime to the current time.
		*/
		@Test
		void testSetDead_1() {
				Player player = new Player();
				player.setDead();
				assertEquals(System.currentTimeMillis(), player.getTimeOfDeath());
		}
		
		/**
		* Test case 2 for {@link Player#setDead(long)}.
		* <p>
		* This test case checks if the method sets the deathtime to the current time.
		*/
		@Test
		void testSetDead_2() {
				Player player = new Player();
				player.setDead(System.currentTimeMillis());
				assertEquals(System.currentTimeMillis(), player.getTimeOfDeath());
		}
		
		/**
		* Test case 3 for {@link Player#setDead(long)}.
		* <p>
		* This test case checks if the method sets the deathtime to the current time.
		*/
		@Test
		void testSetDead_3() {
				Player player = new Player();
				player.setDead(System.currentTimeMillis() + 100);
				assertEquals(System.currentTimeMillis() + 100, player.getTimeOfDeath());
		}
		
		/**
		* Test case 4 for {@link Player#setDead(long)}.
		* <p>
		* This test case checks if the method sets the deathtime to the current time.
		*/
		@Test
		void testSetDead_4() {
				Player player = new Player();
				player.setDead(System.currentTimeMillis() - 100);
				assertEquals(System.currentTimeMillis() - 100, player.getTimeOfDeath());
		}
		
		"
cmpl-6tvSDY0mHZcirmd3LRGOTKtp8UGlF,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Player_2Test.java,97.08538842201233,length,"// Player.java
/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.20 $
 *
 */
package state;

import java.io.*;
import java.util.*;

/**
 * Represents a player in the game world.
 */
public class Player extends Party implements Packable {

    /**
     * The tolerance to decide whether a player has reached its
     *        destination. If x or y distance to target is less than
     *        TOLERANCE, no move in that direction is triggered.
     */
    public static final float TOLERANCE = 0.2f;

    /**
     * The distance to move in one step.
     */
    public static final float MOVE_DISTANCE = 0.1f;

    /**
     * Number to verify against when unpacking.
     */
    public static final short MAGIC_NO = 0x1337;

    /* Strength of this player */
    private int strength;

    /* Picture of this player */
    private int pictureid;

    /* True if this player is alive */
    private boolean alive;

    /* The time when this user died. */
    private long deathtime;

    /* World coordinates of this player. */
    private float x = 10.0f, y = 0.0f, z;

    /**
     * List to keep track of allowed joins
     */
    private Hashtable<Integer, JoinInfo> joinlist;

    /**
     * Size of player class when packed (not including length of name)
     */
    private int packsize = 10;

    /**
     * Reference to the packed data.
     */
    private byte[] data;

    /**
     * True if referenced data is _not_ up to date.
     */
    private boolean dirty;

    /**
     * Name of the player.
     */
    private String name;

    /**
     * False if this player has dropped from the game.
     */
    private boolean connected;

    /**
     * The IP of the player.
     */
    private String ip;

    /**
     * Amount of money the user has earned.
     */
    private float money;

    /**
     * Class used to keep track of when a user was invited or applied
     * to join a group.
     */
    private class JoinInfo {

        long time;

        boolean invite;

        JoinInfo(boolean invited) {
            time = System.currentTimeMillis();
            invite = invited;
        }
    }

    /**
     * Creates a new empty instance of the Player class without an
     * id. Note that a call to GameState.player(pidFor(new Player()))
     * will return null.
     */
    public Player() {
        this(-1);
    }

    /**
     * Creates a new player with the given id.
     * @param id the associated id of this player.
     */
    public Player(int id) {
        super(id);
        this.strength = 1;
        this.pictureid = 0;
        this.alive = true;
        this.dirty = true;
        this.name = ""Player"" + id;
        this.deathtime = 0;
        this.connected = true;
        this.ip = ""0.0.0.0"";
        this.joinlist = new Hashtable<Integer, JoinInfo>();
    }

    public void reset(boolean newGame) {
        this.joinlist = new Hashtable<Integer, JoinInfo>();
        this.alive = true;
        this.dirty = true;
        this.deathtime = 0;
        this.boss = null;
        this.head = null;
        this.next = null;
        this.prev = null;
        if (newGame) {
            money = 0;
        }
    }

    /**
     */
    public Player(int id, String name, int pictureid) {
        this(id);
        this.name = name;
        this.pictureid = pictureid;
        System.err.println(id + "" "" + name + "" "" + pictureid);
    }

    /**
     */
    public Player(int id, String ip, String name, int pictureid) {
        this(id, name, pictureid);
        this.ip = ip;
    }

    public Player(int id, String ip, String name, int pid, int strength) {
        this(id, ip, name, pid);
        this.strength = strength;
    }

    public boolean isConnected() {
        return connected;
    }

    public void setConnected(boolean conned) {
        connected = conned;
    }

    /**
     * Returns the current strength of the gang this player is part of.
     * @return the total strength of this players gang.
     */
    public int gangStrength() {
        int str = 0;
        LinkedList<Party> gang = gangBoss().getSubparty();
        for (Party p : gang) {
            str += ((Player) p).strength;
        }
        return str;
    }

    public void setDead(long deathtime, boolean alive) {
        this.deathtime = deathtime;
        this.alive = alive;
    }

    public void setDead() {
        setDead(System.currentTimeMillis());
    }

    public void setDead(long deathtime) {
        setDead(deathtime, false);
    }

    public boolean isDead() {
        return !alive;
    }

    public long getTimeOfDeath() {
        return deathtime;
    }

    public int getStrength() {
        return strength;
    }

    /**
     * Sets the amount of money this player has earned
     */
    public void setMoney(float money) {
        this.money = money;
    }

    /**
     * Returns amount of money this player has earned
     */
    public float getMoney() {
        return money;
    }

    /**
     * Returns player IP.
     */
    public String getIP() {
        return ip;
    }

    /**
     * Returns player name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns player picture id.
     */
    public int getPictureId() {
        return pictureid;
    }

    /**
     * Returns player x coordinate.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns player y coordinate.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns player z coordinate.
     */
    public float getZ() {
        return z;
    }

    /**
     * Sets player y coordinate.
     */
    public void setY(float f) {
        y = f;
    }

    /**
     * Sets player x coordinate.
     */
    public void setX(float f) {
        x = f;
    }

    /**
     * Sets player z coordinate.
     */
    public void setZ(float f) {
        z = f;
    }

    /**
     * Checks if player <i>joiner</i> is allowed to join the current player.
     * If <i>invited</i> is set it will be checked if <i>joiner</i> was
     * invited, otherwise it'll be checked if <i>joiner</i> applied.
     */
    public boolean isJoinOK(Player joiner, boolean invited) {
        if (joinlist.containsKey(joiner.getId())) {
            JoinInfo jinfo = joinlist.get(joiner.getId());
            // change 15000 to either a constant defined at top of
            // file or a variable read from config
            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)
                return true;
        }
        return false;
    }

    public void setJoinOK(Player joiner, boolean invited) {
        JoinInfo jinfo = new JoinInfo(invited);
        joinlist.put(joiner.id, jinfo);
    }

    /**
     * Packs this player into the specified stream.
     * @param out the stream to write this player to.
     */
    public void pack(DataOutputStream out) throws IOException {
        out.writeShort(MAGIC_NO);
        out.writeByte(id);
        out.writeShort(strength);
        out.writeShort(pictureid);
        out.writeFloat(x);
        out.writeFloat(y);
        out.writeFloat(z);
        out.writeUTF(name);
    }

    /**
     * Unpack and set player data from the specified stream.
     * @param in the stream to read data from.
     * @return true if data was successfully unpacked.
     */
    public boolean unpack(DataInputStream in) {
        Player tmp = null;
        try {
            /* Verify that stream really contains player data. */
            if (in.readShort() != MAGIC_NO) {
                System.err.println(""Player.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return false;
            }
            /* Try unpacking the data to a temporary variable before
	       commiting the changes. */
            tmp = new Player();
            tmp.id = in.readByte();
            tmp.strength = in.readShort();
            tmp.pictureid = in.readShort();
            tmp.x = in.readFloat();
            tmp.y = in.readFloat();
            tmp.z = in.readFloat();
            tmp.name = in.readUTF();
        } catch (EOFException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [EOF] "" + ""data was incomplete: "" + e.getMessage());
            return false;
        } catch (IOException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [IO] "" + ""failed to unpack data: "" + e.getMessage());
            return false;
        }
        /* Apply the unpacked data. */
        id = tmp.id;
        name = tmp.name;
        strength = tmp.strength;
        pictureid = tmp.pictureid;
        x = tmp.x;
        y = tmp.y;
        z = tmp.z;
        return true;
    }

    /**
     * Returns an unambigious byte-array representation of this
     * object.
     *
     * @deprecated
     * @return The resulting byte array.
     */
    public byte[] pack() {
        try {
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            DataOutputStream out = new DataOutputStream(buf);
            pack(out);
            out.close();
            return buf.toByteArray();
        } catch (IOException e) {
            System.err.println(""Player.pack(): *** ERROR *** [IO] "" + ""pack failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
        return null;
    }

    /**
     * Unpacks an array previously created with pack() and puts in
     * this object.
     *
     * @deprecated
     * @param b the byte array to be unpacked.
     */
    public void unpack(byte[] b) {
        unpack(new DataInputStream(new ByteArrayInputStream(b)));
    }

    /**
     * Returns the type of the packable.
     * @return The resulting byte array.
     */
    public int type() {
        return Packable.PLAYER;
    }

    public String toString() {
        return name;
    }
}
","// Player_2Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#unpack(DataInputStream)} method.
*/
class Player_2Test {","// Player_2Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#unpack(DataInputStream)} method.
*/
class Player_2Test {

		/**
		* Test case 1 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a null input stream.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_1() {
				Player player = new Player();
				assertFalse(player.unpack(null));
		}
		
		/**
		* Test case 2 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid magic number.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_2() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1338);
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 3 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid id.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_3() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0xFF);
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 4 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid strength.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_4() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0x01);
						out.writeShort(0xFFFF);
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 5 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid picture id.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_5() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0x01);
						out.writeShort(0x0001);
						out.writeShort(0xFFFF);
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 6 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid x coordinate.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_6() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0x01);
						out.writeShort(0x0001);
						out.writeShort(0x0001);
						out.writeFloat(Float.NaN);
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 7 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid y coordinate.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_7() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0x01);
						out.writeShort(0x0001);
						out.writeShort(0x0001);
						out.writeFloat(0.0f);
						out.writeFloat(Float.NaN);
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 8 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid z coordinate.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_8() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0x01);
						out.writeShort(0x0001);
						out.writeShort(0x0001);
						out.writeFloat(0.0f);
						out.writeFloat(0.0f);
						out.writeFloat(Float.NaN);
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 9 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid name.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_9() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0x01);
						out.writeShort(0x0001);
						out.writeShort(0x0001);
						out.writeFloat(0.0f);
						out.writeFloat(0.0f);
						out.writeFloat(0.0f);
						out.writeUTF("""");
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
		/**
		* Test case 10 for {@link Player#unpack(DataInputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an incomplete name.
		* <p>
		* Expected result: The method should return false.
		*/
		@Test
		void testUnpack_10() {
				Player player = new Player();
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						DataOutputStream out = new DataOutputStream(buf);
						out.writeShort(0x1337);
						out.writeByte(0x01);
						out.writeShort(0x0001);
						out.writeShort(0x0001);
						out.writeFloat(0.0f);
						out.writeFloat(0.0f);
						out.writeFloat(0.0f);
						out.writeUTF(""Player"");
						out.close();
						assertFalse(player.unpack(new DataInputStream(new ByteArrayInputStream(buf.toByteArray()))));
				} catch (IOException e) {
						fail(""Unexpected IOException: "" + e.getMessage());
				}
		}
		
}

// Player_3Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#pack(DataOutputStream)} method.
*/
class Player_3Test {
		
		/**
		* Test case 1 for {@link Player#pack(DataOutputStream)}.
		* <p>
		* This test case checks if the method can handle a null output stream.
		* <p>
		* Expected result: The method should throw an IOException.
		*/
		@Test
		void testPack_1() {
				Player player = new Player();
				try {
						player.pack(null);
						fail(""Expected IOException"");
				} catch (IOException e) {
				}
		}
		
		/**
		* Test case 2 for {@link Player#pack(DataOutputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid id.
		* <p>
		* Expected result: The method should throw an IOException.
		*/
		@Test
		void testPack_2() {
				Player player = new Player();
				player.id = 0xFF;
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						player.pack(new DataOutputStream(buf));
						fail(""Expected IOException"");
				} catch (IOException e) {
				}
		}
		
		/**
		* Test case 3 for {@link Player#pack(DataOutputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid strength.
		* <p>
		* Expected result: The method should throw an IOException.
		*/
		@Test
		void testPack_3() {
				Player player = new Player();
				player.strength = 0xFFFF;
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						player.pack(new DataOutputStream(buf));
						fail(""Expected IOException"");
				} catch (IOException e) {
				}
		}
		
		/**
		* Test case 4 for {@link Player#pack(DataOutputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid picture id.
		* <p>
		* Expected result: The method should throw an IOException.
		*/
		@Test
		void testPack_4() {
				Player player = new Player();
				player.pictureid = 0xFFFF;
				try {
						ByteArrayOutputStream buf = new ByteArrayOutputStream();
						player.pack(new DataOutputStream(buf));
						fail(""Expected IOException"");
				} catch (IOException e) {
				}
		}
		
		/**
		* Test case 5 for {@link Player#pack(DataOutputStream)}.
		* <p>
		* This test case checks if the method can handle a stream with an invalid x coordinate.
		* <p>
		* Expected result: The method should throw an IOException.
		*/
		@Test
		void testPack_5() {
				Player player = new Player();"
cmpl-6tvTmxlVPiTmgKD1A4FQ3VUoJ8UkG,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Player_3Test.java,96.58067011833191,length,"// Player.java
/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.20 $
 *
 */
package state;

import java.io.*;
import java.util.*;

/**
 * Represents a player in the game world.
 */
public class Player extends Party implements Packable {

    /**
     * The tolerance to decide whether a player has reached its
     *        destination. If x or y distance to target is less than
     *        TOLERANCE, no move in that direction is triggered.
     */
    public static final float TOLERANCE = 0.2f;

    /**
     * The distance to move in one step.
     */
    public static final float MOVE_DISTANCE = 0.1f;

    /**
     * Number to verify against when unpacking.
     */
    public static final short MAGIC_NO = 0x1337;

    /* Strength of this player */
    private int strength;

    /* Picture of this player */
    private int pictureid;

    /* True if this player is alive */
    private boolean alive;

    /* The time when this user died. */
    private long deathtime;

    /* World coordinates of this player. */
    private float x = 10.0f, y = 0.0f, z;

    /**
     * List to keep track of allowed joins
     */
    private Hashtable<Integer, JoinInfo> joinlist;

    /**
     * Size of player class when packed (not including length of name)
     */
    private int packsize = 10;

    /**
     * Reference to the packed data.
     */
    private byte[] data;

    /**
     * True if referenced data is _not_ up to date.
     */
    private boolean dirty;

    /**
     * Name of the player.
     */
    private String name;

    /**
     * False if this player has dropped from the game.
     */
    private boolean connected;

    /**
     * The IP of the player.
     */
    private String ip;

    /**
     * Amount of money the user has earned.
     */
    private float money;

    /**
     * Class used to keep track of when a user was invited or applied
     * to join a group.
     */
    private class JoinInfo {

        long time;

        boolean invite;

        JoinInfo(boolean invited) {
            time = System.currentTimeMillis();
            invite = invited;
        }
    }

    /**
     * Creates a new empty instance of the Player class without an
     * id. Note that a call to GameState.player(pidFor(new Player()))
     * will return null.
     */
    public Player() {
        this(-1);
    }

    /**
     * Creates a new player with the given id.
     * @param id the associated id of this player.
     */
    public Player(int id) {
        super(id);
        this.strength = 1;
        this.pictureid = 0;
        this.alive = true;
        this.dirty = true;
        this.name = ""Player"" + id;
        this.deathtime = 0;
        this.connected = true;
        this.ip = ""0.0.0.0"";
        this.joinlist = new Hashtable<Integer, JoinInfo>();
    }

    public void reset(boolean newGame) {
        this.joinlist = new Hashtable<Integer, JoinInfo>();
        this.alive = true;
        this.dirty = true;
        this.deathtime = 0;
        this.boss = null;
        this.head = null;
        this.next = null;
        this.prev = null;
        if (newGame) {
            money = 0;
        }
    }

    /**
     */
    public Player(int id, String name, int pictureid) {
        this(id);
        this.name = name;
        this.pictureid = pictureid;
        System.err.println(id + "" "" + name + "" "" + pictureid);
    }

    /**
     */
    public Player(int id, String ip, String name, int pictureid) {
        this(id, name, pictureid);
        this.ip = ip;
    }

    public Player(int id, String ip, String name, int pid, int strength) {
        this(id, ip, name, pid);
        this.strength = strength;
    }

    public boolean isConnected() {
        return connected;
    }

    public void setConnected(boolean conned) {
        connected = conned;
    }

    /**
     * Returns the current strength of the gang this player is part of.
     * @return the total strength of this players gang.
     */
    public int gangStrength() {
        int str = 0;
        LinkedList<Party> gang = gangBoss().getSubparty();
        for (Party p : gang) {
            str += ((Player) p).strength;
        }
        return str;
    }

    public void setDead(long deathtime, boolean alive) {
        this.deathtime = deathtime;
        this.alive = alive;
    }

    public void setDead() {
        setDead(System.currentTimeMillis());
    }

    public void setDead(long deathtime) {
        setDead(deathtime, false);
    }

    public boolean isDead() {
        return !alive;
    }

    public long getTimeOfDeath() {
        return deathtime;
    }

    public int getStrength() {
        return strength;
    }

    /**
     * Sets the amount of money this player has earned
     */
    public void setMoney(float money) {
        this.money = money;
    }

    /**
     * Returns amount of money this player has earned
     */
    public float getMoney() {
        return money;
    }

    /**
     * Returns player IP.
     */
    public String getIP() {
        return ip;
    }

    /**
     * Returns player name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns player picture id.
     */
    public int getPictureId() {
        return pictureid;
    }

    /**
     * Returns player x coordinate.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns player y coordinate.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns player z coordinate.
     */
    public float getZ() {
        return z;
    }

    /**
     * Sets player y coordinate.
     */
    public void setY(float f) {
        y = f;
    }

    /**
     * Sets player x coordinate.
     */
    public void setX(float f) {
        x = f;
    }

    /**
     * Sets player z coordinate.
     */
    public void setZ(float f) {
        z = f;
    }

    /**
     * Checks if player <i>joiner</i> is allowed to join the current player.
     * If <i>invited</i> is set it will be checked if <i>joiner</i> was
     * invited, otherwise it'll be checked if <i>joiner</i> applied.
     */
    public boolean isJoinOK(Player joiner, boolean invited) {
        if (joinlist.containsKey(joiner.getId())) {
            JoinInfo jinfo = joinlist.get(joiner.getId());
            // change 15000 to either a constant defined at top of
            // file or a variable read from config
            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)
                return true;
        }
        return false;
    }

    public void setJoinOK(Player joiner, boolean invited) {
        JoinInfo jinfo = new JoinInfo(invited);
        joinlist.put(joiner.id, jinfo);
    }

    /**
     * Packs this player into the specified stream.
     * @param out the stream to write this player to.
     */
    public void pack(DataOutputStream out) throws IOException {
        out.writeShort(MAGIC_NO);
        out.writeByte(id);
        out.writeShort(strength);
        out.writeShort(pictureid);
        out.writeFloat(x);
        out.writeFloat(y);
        out.writeFloat(z);
        out.writeUTF(name);
    }

    /**
     * Unpack and set player data from the specified stream.
     * @param in the stream to read data from.
     * @return true if data was successfully unpacked.
     */
    public boolean unpack(DataInputStream in) {
        Player tmp = null;
        try {
            /* Verify that stream really contains player data. */
            if (in.readShort() != MAGIC_NO) {
                System.err.println(""Player.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return false;
            }
            /* Try unpacking the data to a temporary variable before
	       commiting the changes. */
            tmp = new Player();
            tmp.id = in.readByte();
            tmp.strength = in.readShort();
            tmp.pictureid = in.readShort();
            tmp.x = in.readFloat();
            tmp.y = in.readFloat();
            tmp.z = in.readFloat();
            tmp.name = in.readUTF();
        } catch (EOFException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [EOF] "" + ""data was incomplete: "" + e.getMessage());
            return false;
        } catch (IOException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [IO] "" + ""failed to unpack data: "" + e.getMessage());
            return false;
        }
        /* Apply the unpacked data. */
        id = tmp.id;
        name = tmp.name;
        strength = tmp.strength;
        pictureid = tmp.pictureid;
        x = tmp.x;
        y = tmp.y;
        z = tmp.z;
        return true;
    }

    /**
     * Returns an unambigious byte-array representation of this
     * object.
     *
     * @deprecated
     * @return The resulting byte array.
     */
    public byte[] pack() {
        try {
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            DataOutputStream out = new DataOutputStream(buf);
            pack(out);
            out.close();
            return buf.toByteArray();
        } catch (IOException e) {
            System.err.println(""Player.pack(): *** ERROR *** [IO] "" + ""pack failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
        return null;
    }

    /**
     * Unpacks an array previously created with pack() and puts in
     * this object.
     *
     * @deprecated
     * @param b the byte array to be unpacked.
     */
    public void unpack(byte[] b) {
        unpack(new DataInputStream(new ByteArrayInputStream(b)));
    }

    /**
     * Returns the type of the packable.
     * @return The resulting byte array.
     */
    public int type() {
        return Packable.PLAYER;
    }

    public String toString() {
        return name;
    }
}
","// Player_3Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#pack()} method.
*/
class Player_3Test {","// Player_3Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#pack()} method.
*/
class Player_3Test {

		/**
		* Test case 1 for {@link Player#pack()}.
		* It tests the normal case.
		*/
		@Test
		void testPack_1() {
				Player player = new Player(1, ""127.0.0.1"", ""Player1"", 1, 1);
				byte[] expected = {0x1b, 0x37, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x"
cmpl-6tvVLQx7VVHGXPdHHlFkhnT2yirK4,/EvoSuiteBenchmark/27_gangup/src/main/java/state/Player_4Test.java,90.68668985366821,length,"// Player.java
/* $Id: Player.java,v 1.20 2004/05/05 23:45:20 njursten Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Rasmus Ahlberg <ahlbgerg@kth.se>
 * @version: $Revision: 1.20 $
 *
 */
package state;

import java.io.*;
import java.util.*;

/**
 * Represents a player in the game world.
 */
public class Player extends Party implements Packable {

    /**
     * The tolerance to decide whether a player has reached its
     *        destination. If x or y distance to target is less than
     *        TOLERANCE, no move in that direction is triggered.
     */
    public static final float TOLERANCE = 0.2f;

    /**
     * The distance to move in one step.
     */
    public static final float MOVE_DISTANCE = 0.1f;

    /**
     * Number to verify against when unpacking.
     */
    public static final short MAGIC_NO = 0x1337;

    /* Strength of this player */
    private int strength;

    /* Picture of this player */
    private int pictureid;

    /* True if this player is alive */
    private boolean alive;

    /* The time when this user died. */
    private long deathtime;

    /* World coordinates of this player. */
    private float x = 10.0f, y = 0.0f, z;

    /**
     * List to keep track of allowed joins
     */
    private Hashtable<Integer, JoinInfo> joinlist;

    /**
     * Size of player class when packed (not including length of name)
     */
    private int packsize = 10;

    /**
     * Reference to the packed data.
     */
    private byte[] data;

    /**
     * True if referenced data is _not_ up to date.
     */
    private boolean dirty;

    /**
     * Name of the player.
     */
    private String name;

    /**
     * False if this player has dropped from the game.
     */
    private boolean connected;

    /**
     * The IP of the player.
     */
    private String ip;

    /**
     * Amount of money the user has earned.
     */
    private float money;

    /**
     * Class used to keep track of when a user was invited or applied
     * to join a group.
     */
    private class JoinInfo {

        long time;

        boolean invite;

        JoinInfo(boolean invited) {
            time = System.currentTimeMillis();
            invite = invited;
        }
    }

    /**
     * Creates a new empty instance of the Player class without an
     * id. Note that a call to GameState.player(pidFor(new Player()))
     * will return null.
     */
    public Player() {
        this(-1);
    }

    /**
     * Creates a new player with the given id.
     * @param id the associated id of this player.
     */
    public Player(int id) {
        super(id);
        this.strength = 1;
        this.pictureid = 0;
        this.alive = true;
        this.dirty = true;
        this.name = ""Player"" + id;
        this.deathtime = 0;
        this.connected = true;
        this.ip = ""0.0.0.0"";
        this.joinlist = new Hashtable<Integer, JoinInfo>();
    }

    public void reset(boolean newGame) {
        this.joinlist = new Hashtable<Integer, JoinInfo>();
        this.alive = true;
        this.dirty = true;
        this.deathtime = 0;
        this.boss = null;
        this.head = null;
        this.next = null;
        this.prev = null;
        if (newGame) {
            money = 0;
        }
    }

    /**
     */
    public Player(int id, String name, int pictureid) {
        this(id);
        this.name = name;
        this.pictureid = pictureid;
        System.err.println(id + "" "" + name + "" "" + pictureid);
    }

    /**
     */
    public Player(int id, String ip, String name, int pictureid) {
        this(id, name, pictureid);
        this.ip = ip;
    }

    public Player(int id, String ip, String name, int pid, int strength) {
        this(id, ip, name, pid);
        this.strength = strength;
    }

    public boolean isConnected() {
        return connected;
    }

    public void setConnected(boolean conned) {
        connected = conned;
    }

    /**
     * Returns the current strength of the gang this player is part of.
     * @return the total strength of this players gang.
     */
    public int gangStrength() {
        int str = 0;
        LinkedList<Party> gang = gangBoss().getSubparty();
        for (Party p : gang) {
            str += ((Player) p).strength;
        }
        return str;
    }

    public void setDead(long deathtime, boolean alive) {
        this.deathtime = deathtime;
        this.alive = alive;
    }

    public void setDead() {
        setDead(System.currentTimeMillis());
    }

    public void setDead(long deathtime) {
        setDead(deathtime, false);
    }

    public boolean isDead() {
        return !alive;
    }

    public long getTimeOfDeath() {
        return deathtime;
    }

    public int getStrength() {
        return strength;
    }

    /**
     * Sets the amount of money this player has earned
     */
    public void setMoney(float money) {
        this.money = money;
    }

    /**
     * Returns amount of money this player has earned
     */
    public float getMoney() {
        return money;
    }

    /**
     * Returns player IP.
     */
    public String getIP() {
        return ip;
    }

    /**
     * Returns player name.
     */
    public String getName() {
        return name;
    }

    /**
     * Returns player picture id.
     */
    public int getPictureId() {
        return pictureid;
    }

    /**
     * Returns player x coordinate.
     */
    public float getX() {
        return x;
    }

    /**
     * Returns player y coordinate.
     */
    public float getY() {
        return y;
    }

    /**
     * Returns player z coordinate.
     */
    public float getZ() {
        return z;
    }

    /**
     * Sets player y coordinate.
     */
    public void setY(float f) {
        y = f;
    }

    /**
     * Sets player x coordinate.
     */
    public void setX(float f) {
        x = f;
    }

    /**
     * Sets player z coordinate.
     */
    public void setZ(float f) {
        z = f;
    }

    /**
     * Checks if player <i>joiner</i> is allowed to join the current player.
     * If <i>invited</i> is set it will be checked if <i>joiner</i> was
     * invited, otherwise it'll be checked if <i>joiner</i> applied.
     */
    public boolean isJoinOK(Player joiner, boolean invited) {
        if (joinlist.containsKey(joiner.getId())) {
            JoinInfo jinfo = joinlist.get(joiner.getId());
            // change 15000 to either a constant defined at top of
            // file or a variable read from config
            if (jinfo.time + 15000 > System.currentTimeMillis() && jinfo.invite == invited)
                return true;
        }
        return false;
    }

    public void setJoinOK(Player joiner, boolean invited) {
        JoinInfo jinfo = new JoinInfo(invited);
        joinlist.put(joiner.id, jinfo);
    }

    /**
     * Packs this player into the specified stream.
     * @param out the stream to write this player to.
     */
    public void pack(DataOutputStream out) throws IOException {
        out.writeShort(MAGIC_NO);
        out.writeByte(id);
        out.writeShort(strength);
        out.writeShort(pictureid);
        out.writeFloat(x);
        out.writeFloat(y);
        out.writeFloat(z);
        out.writeUTF(name);
    }

    /**
     * Unpack and set player data from the specified stream.
     * @param in the stream to read data from.
     * @return true if data was successfully unpacked.
     */
    public boolean unpack(DataInputStream in) {
        Player tmp = null;
        try {
            /* Verify that stream really contains player data. */
            if (in.readShort() != MAGIC_NO) {
                System.err.println(""Player.unpack(): *** WARNING *** "" + ""data is not of proper type!"");
                return false;
            }
            /* Try unpacking the data to a temporary variable before
	       commiting the changes. */
            tmp = new Player();
            tmp.id = in.readByte();
            tmp.strength = in.readShort();
            tmp.pictureid = in.readShort();
            tmp.x = in.readFloat();
            tmp.y = in.readFloat();
            tmp.z = in.readFloat();
            tmp.name = in.readUTF();
        } catch (EOFException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [EOF] "" + ""data was incomplete: "" + e.getMessage());
            return false;
        } catch (IOException e) {
            System.err.println(""Player.unpack(): *** WARNING *** [IO] "" + ""failed to unpack data: "" + e.getMessage());
            return false;
        }
        /* Apply the unpacked data. */
        id = tmp.id;
        name = tmp.name;
        strength = tmp.strength;
        pictureid = tmp.pictureid;
        x = tmp.x;
        y = tmp.y;
        z = tmp.z;
        return true;
    }

    /**
     * Returns an unambigious byte-array representation of this
     * object.
     *
     * @deprecated
     * @return The resulting byte array.
     */
    public byte[] pack() {
        try {
            ByteArrayOutputStream buf = new ByteArrayOutputStream();
            DataOutputStream out = new DataOutputStream(buf);
            pack(out);
            out.close();
            return buf.toByteArray();
        } catch (IOException e) {
            System.err.println(""Player.pack(): *** ERROR *** [IO] "" + ""pack failed! current state is "" + ""inconsistent: "" + e.getMessage());
        }
        return null;
    }

    /**
     * Unpacks an array previously created with pack() and puts in
     * this object.
     *
     * @deprecated
     * @param b the byte array to be unpacked.
     */
    public void unpack(byte[] b) {
        unpack(new DataInputStream(new ByteArrayInputStream(b)));
    }

    /**
     * Returns the type of the packable.
     * @return The resulting byte array.
     */
    public int type() {
        return Packable.PLAYER;
    }

    public String toString() {
        return name;
    }
}
","// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {","// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {

		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package state;

import java.io.*;
import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Player}.
* It contains ten unit test cases for the {@link Player#type()} method.
*/
class Player_4Test {
		
		/**
		* Test case for {@link Player#type()}.
		*/
		@Test
		void test_type() {
				Player p = new Player();
				assertEquals(p.type(), Packable.PLAYER);
		}
}

// Player_4Test.java
package"
cmpl-6tvWovEYagB2AuWOHfEzqh5sGROcA,/EvoSuiteBenchmark/27_gangup/src/main/java/state/TextMessage_1Test.java,95.57922887802124,length,"// TextMessage.java
/* $Id: TextMessage.java,v 1.3 2004/04/30 23:35:13 emill Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Emil Lundstrï¿½m <emill@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package state;

import java.io.UnsupportedEncodingException;

/**
 * Class for TextMessages, i.e. messages used for the chat.
 */
public class TextMessage implements Packable {

    private int actor;

    private int target;

    private int messagetype;

    private String text;

    private long time;

    public final static int GENERAL = 0;

    public final static int GROUP = 1;

    public final static int PRIVATE = 2;

    public final int type = Packable.TEXT_MESSAGE;

    /**
     * Creates a new TextMessage.
     */
    public TextMessage(int actor, int target, int messagetype, String text) {
        this.actor = actor;
        this.target = target;
        this.messagetype = messagetype;
        this.text = text;
    }

    /**
     * Creates a new empty TextMessage. Empty messages cannot be sent
     * over the network, and will throw a NullPointerException if
     * done.
     */
    public TextMessage() {
        this(-1, -1, -1, null);
    }

    /**
     * Sets the actor of this Action object.
     */
    public void setActor(int actor) {
        this.actor = actor;
    }

    public int getActor() {
        return actor;
    }

    public int getTarget() {
        return target;
    }

    public int getMessageType() {
        return messagetype;
    }

    public String getText() {
        return text;
    }

    public long getTime() {
        return time;
    }

    public void setTime(long l) {
        time = l;
    }

    public int type() {
        return Packable.TEXT_MESSAGE;
    }

    /**
     * Converts a TextMessage into a byte array representation.
     *
     * @param msg The message to be converted.
     * @return The resulting byte array.
     */
    public byte[] pack() {
        //TextMessage msg = (TextMessage) p;
        byte[] data = null;
        try {
            byte[] t2 = text.getBytes(""UTF-8"");
            data = new byte[t2.length + 3];
            System.arraycopy(t2, 0, data, 3, t2.length);
            data[0] = (byte) actor;
            data[1] = (byte) target;
            data[2] = (byte) messagetype;
        } catch (UnsupportedEncodingException e) {
            /* All javavms are required to implement UTF-8 */
        }
        return data;
    }

    /**
     * Converts a byte array back into a TextMessage.
     *
     * @param data The byte array to be converted.
     * @return The resultning message.
     */
    public void unpack(byte[] data) {
        try {
            this.actor = (int) data[0];
            this.target = (int) data[1];
            this.messagetype = (int) data[2];
            byte[] textbytes = new byte[data.length - 3];
            System.arraycopy(data, 3, textbytes, 0, data.length - 3);
            this.text = new String(textbytes, ""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            /* All javavms are required to implement UTF-8 */
        }
    }

    public String toString() {
        return ""TextMessage["" + actor + "","" + target + "","" + messagetype + "","" + text + ""]"";
    }
}
","// TextMessage_1Test.java
package state;

import java.io.UnsupportedEncodingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextMessage}.
* It contains ten unit test cases for the {@link TextMessage#pack()} method.
*/
class TextMessage_1Test {","// TextMessage_1Test.java
package state;

import java.io.UnsupportedEncodingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextMessage}.
* It contains ten unit test cases for the {@link TextMessage#pack()} method.
*/
class TextMessage_1Test {

	/**
	* Test case 1 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_1() {
		TextMessage msg = new TextMessage(1, 2, 3, ""abc"");
		byte[] expected = {1, 2, 3, 'a', 'b', 'c'};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_2() {
		TextMessage msg = new TextMessage(1, 2, 3, ""abcdefghijklmnopqrstuvwxyz"");
		byte[] expected = {1, 2, 3, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_3() {
		TextMessage msg = new TextMessage(1, 2, 3, ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"");
		byte[] expected = {1, 2, 3, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_4() {
		TextMessage msg = new TextMessage(1, 2, 3, ""0123456789"");
		byte[] expected = {1, 2, 3, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_5() {
		TextMessage msg = new TextMessage(1, 2, 3, ""!\""#Â¤%&/()=?`*'_:;,.-"");
		byte[] expected = {1, 2, 3, '!', '""', '#', 'Â¤', '%', '&', '/', '(', ')', '=', '?', '`', '*', '\'', '_', ':', ';', ',', '.', '-'};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_6() {
		TextMessage msg = new TextMessage(1, 2, 3, "" "");
		byte[] expected = {1, 2, 3, ' '};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_7() {
		TextMessage msg = new TextMessage(1, 2, 3, ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\""#Â¤%&/()=?`*'_:;,.- "");
		byte[] expected = {1, 2, 3, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '""', '#', 'Â¤', '%', '&', '/', '(', ')', '=', '?', '`', '*', '\'', '_', ':', ';', ',', '.', '-', ' '};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_8() {
		TextMessage msg = new TextMessage(1, 2, 3, ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\""#Â¤%&/()=?`*'_:;,.- "");
		byte[] expected = {1, 2, 3, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '""', '#', 'Â¤', '%', '&', '/', '(', ')', '=', '?', '`', '*', '\'', '_', ':', ';', ',', '.', '-', ' '};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_9() {
		TextMessage msg = new TextMessage(1, 2, 3, ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\""#Â¤%&/()=?`*'_:;,.- "");
		byte[] expected = {1, 2, 3, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '""', '#', 'Â¤', '%', '&', '/', '(', ')', '=', '?', '`', '*', '\'', '_', ':', ';', ',', '.', '-', ' '};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link TextMessage#pack()}.
	* This test case tests the {@link TextMessage#pack()} method with a message containing only ASCII characters.
	* The expected result is a byte array containing the same characters as the message.
	*/
	@Test
	void testPack_10() {
		TextMessage msg = new TextMessage(1, 2, 3, ""abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!\""#Â¤%&/()=?`*'_:;,.- "");
		byte[] expected = {1, 2, 3, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '!', '""', '#', 'Â¤', '%', '&', '/', '(', ')', '=', '?', '`', '*', '\'', '_', ':', ';', ',', '.', '-', ' '};
		byte[] actual = msg.pack();
		assertArrayEquals(expected, actual);
	}
	
}

// TextMessage_2Test.java
package state;

import java.io.UnsupportedEncodingException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TextMessage}.
* It contains ten unit test cases for the {@link TextMessage#unpack(byte[])} method.
*/
class TextMessage_2Test {
		
	/**
	* Test case 1 for {@link TextMessage#unpack(byte[])}.
	* This test case tests the {@link TextMessage#unpack(byte[])} method with a byte array containing only ASCII characters.
	* The expected result is a message containing the same characters as the byte array.
	*/
	@Test
	void testUnpack_1() {
		TextMessage msg = new TextMessage();
		byte[] data = {1, 2, 3, 'a', 'b', 'c'};
		msg.unpack(data);
		String expected = ""abc"";
		String actual = msg.getText();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link TextMessage#unpack(byte[])}.
	* This test case tests the {@link TextMessage#unpack(byte[])} method with a byte array containing only ASCII characters.
	* The expected result is a message containing the same characters as the byte array.
	*/
	@Test
	void testUnpack_2() {
		TextMessage msg = new TextMessage();
		byte[] data = {1, 2, 3, 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
		msg.unpack(data);
		String expected = ""abcdefghijklmnopqrstuvwxyz"";
		String actual = msg.getText();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link TextMessage#unpack(byte[])}.
	* This test case tests the {@link TextMessage#unpack(byte[])} method with a byte array containing only ASCII characters.
	* The expected result is a message containing the same characters as the byte array.
	*/
	@Test
	void testUnpack_3() {
		TextMessage msg = new TextMessage();
		byte[] data = {1, 2, 3, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
		msg.unpack(data);
		String expected = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
		String actual = msg.getText();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link TextMessage#unpack(byte[])}.
	* This test case tests the {@link TextMessage#unpack(byte[])} method with a byte array containing only ASCII characters.
	* The expected result is a message containing the same characters as the byte array.
	*/
	@Test
	void testUnpack_4() {
		TextMessage msg = new TextMessage();
		byte[] data = {1, 2, 3, '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
		msg.unpack(data);
		String expected = ""0123456789"";
		String actual = msg.getText();
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link TextMessage#unpack(byte[])}.
	* This test case tests the {@link TextMessage#unpack(byte[])} method with a byte array containing only ASCII characters.
	* The expected result is a message containing the same characters as the byte array.
	*/
	@Test
	void testUnpack_5() {
		TextMessage msg = new Text"
cmpl-6tvYL0QpuplqUia6KQUYzWrfsMOzx,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_10Test.java,86.16677355766296,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_10Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packfv(float[], int, int)} method.
*/
class Packer_10Test {","// Packer_10Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packfv(float[], int, int)} method.
*/
class Packer_10Test {

		/**
		* Test case 1 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv1() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 0, 10);
				assertEquals(40, b.length);
				assertEquals(0x3f, b[0]);
				assertEquals(0x80, b[1]);
				assertEquals(0x00, b[2]);
				assertEquals(0x00, b[3]);
				assertEquals(0x40, b[4]);
				assertEquals(0x00, b[5]);
				assertEquals(0x00, b[6]);
				assertEquals(0x00, b[7]);
				assertEquals(0x40, b[8]);
				assertEquals(0x40, b[9]);
				assertEquals(0x00, b[10]);
				assertEquals(0x00, b[11]);
				assertEquals(0x40, b[12]);
				assertEquals(0x60, b[13]);
				assertEquals(0x00, b[14]);
				assertEquals(0x00, b[15]);
				assertEquals(0x40, b[16]);
				assertEquals(0x80, b[17]);
				assertEquals(0x00, b[18]);
				assertEquals(0x00, b[19]);
				assertEquals(0x40, b[20]);
				assertEquals(0xa0, b[21]);
				assertEquals(0x00, b[22]);
				assertEquals(0x00, b[23]);
				assertEquals(0x40, b[24]);
				assertEquals(0xc0, b[25]);
				assertEquals(0x00, b[26]);
				assertEquals(0x00, b[27]);
				assertEquals(0x40, b[28]);
				assertEquals(0xe0, b[29]);
				assertEquals(0x00, b[30]);
				assertEquals(0x00, b[31]);
				assertEquals(0x41, b[32]);
				assertEquals(0x00, b[33]);
				assertEquals(0x00, b[34]);
				assertEquals(0x00, b[35]);
				assertEquals(0x41, b[36]);
				assertEquals(0x20, b[37]);
				assertEquals(0x00, b[38]);
				assertEquals(0x00, b[39]);
		}
		
		/**
		* Test case 2 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv2() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 0, 5);
				assertEquals(20, b.length);
				assertEquals(0x3f, b[0]);
				assertEquals(0x80, b[1]);
				assertEquals(0x00, b[2]);
				assertEquals(0x00, b[3]);
				assertEquals(0x40, b[4]);
				assertEquals(0x00, b[5]);
				assertEquals(0x00, b[6]);
				assertEquals(0x00, b[7]);
				assertEquals(0x40, b[8]);
				assertEquals(0x40, b[9]);
				assertEquals(0x00, b[10]);
				assertEquals(0x00, b[11]);
				assertEquals(0x40, b[12]);
				assertEquals(0x60, b[13]);
				assertEquals(0x00, b[14]);
				assertEquals(0x00, b[15]);
				assertEquals(0x40, b[16]);
				assertEquals(0x80, b[17]);
				assertEquals(0x00, b[18]);
				assertEquals(0x00, b[19]);
		}
		
		/**
		* Test case 3 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv3() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 5, 5);
				assertEquals(20, b.length);
				assertEquals(0x40, b[0]);
				assertEquals(0xa0, b[1]);
				assertEquals(0x00, b[2]);
				assertEquals(0x00, b[3]);
				assertEquals(0x40, b[4]);
				assertEquals(0xc0, b[5]);
				assertEquals(0x00, b[6]);
				assertEquals(0x00, b[7]);
				assertEquals(0x40, b[8]);
				assertEquals(0xe0, b[9]);
				assertEquals(0x00, b[10]);
				assertEquals(0x00, b[11]);
				assertEquals(0x41, b[12]);
				assertEquals(0x00, b[13]);
				assertEquals(0x00, b[14]);
				assertEquals(0x00, b[15]);
				assertEquals(0x41, b[16]);
				assertEquals(0x20, b[17]);
				assertEquals(0x00, b[18]);
				assertEquals(0x00, b[19]);
		}
		
		/**
		* Test case 4 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv4() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 0, 0);
				assertEquals(0, b.length);
		}
		
		/**
		* Test case 5 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv5() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 5, 0);
				assertEquals(0, b.length);
		}
		
		/**
		* Test case 6 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv6() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 0, 5);
				assertEquals(20, b.length);
				assertEquals(0x3f, b[0]);
				assertEquals(0x80, b[1]);
				assertEquals(0x00, b[2]);
				assertEquals(0x00, b[3]);
				assertEquals(0x40, b[4]);
				assertEquals(0x00, b[5]);
				assertEquals(0x00, b[6]);
				assertEquals(0x00, b[7]);
				assertEquals(0x40, b[8]);
				assertEquals(0x40, b[9]);
				assertEquals(0x00, b[10]);
				assertEquals(0x00, b[11]);
				assertEquals(0x40, b[12]);
				assertEquals(0x60, b[13]);
				assertEquals(0x00, b[14]);
				assertEquals(0x00, b[15]);
				assertEquals(0x40, b[16]);
				assertEquals(0x80, b[17]);
				assertEquals(0x00, b[18]);
				assertEquals(0x00, b[19]);
		}
		
		/**
		* Test case 7 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv7() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 5, 5);
				assertEquals(20, b.length);
				assertEquals(0x40, b[0]);
				assertEquals(0xa0, b[1]);
				assertEquals(0x00, b[2]);
				assertEquals(0x00, b[3]);
				assertEquals(0x40, b[4]);
				assertEquals(0xc0, b[5]);
				assertEquals(0x00, b[6]);
				assertEquals(0x00, b[7]);
				assertEquals(0x40, b[8]);
				assertEquals(0xe0, b[9]);
				assertEquals(0x00, b[10]);
				assertEquals(0x00, b[11]);
				assertEquals(0x41, b[12]);
				assertEquals(0x00, b[13]);
				assertEquals(0x00, b[14]);
				assertEquals(0x00, b[15]);
				assertEquals(0x41, b[16]);
				assertEquals(0x20, b[17]);
				assertEquals(0x00, b[18]);
				assertEquals(0x00, b[19]);
		}
		
		/**
		* Test case 8 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv8() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 0, 0);
				assertEquals(0, b.length);
		}
		
		/**
		* Test case 9 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv9() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 5, 0);
				assertEquals(0, b.length);
		}
		
		/**
		* Test case 10 for {@link Packer#packfv(float[], int, int)}.
		*/
		@Test
		void testPackfv10() {
				float[] fv = {1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f, 10.0f};
				byte[] b = Packer.packfv(fv, 0, 5);
				assertEquals(20, b.length);
				assertEquals(0x3f, b[0]);
				assertEquals(0x80, b[1]);
				assertEquals(0x00, b[2]);
				assertEquals(0x00, b[3]);
				assertEquals(0x40, b[4]);
				assertEquals(0x00, b[5]);
				assertEquals(0x00, b[6]);
				assertEquals(0x00, b[7]);
				assertEquals(0x40, b[8]);
				assertEquals(0x40, b[9]);
				assertEquals(0x00, b[10]);
				assertEquals(0x00, b[11]);
				assertEquals(0x40, b[12]);
				assertEquals(0x60, b[13]);
				assertEquals(0x00, b[14]);
				assertEquals(0x00, b[15]);
				assertEquals(0x40, b[16]);
				assertEquals(0x80, b[17]);
				assertEquals(0x00, b[18]);
				assertEquals(0x00, b[19]);
		}
}

// Packer_11Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@"
cmpl-6tvZj62cQgoPVi0zUHzQkQKPUflH5,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_11Test.java,92.03053760528564,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_11Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackf(byte[])} method.
*/
class Packer_11Test {","// Packer_11Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackf(byte[])} method.
*/
class Packer_11Test {

	/**
	* Test case 1 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_1() {
		byte[] b = {0x00, 0x00, 0x00, 0x00};
		float f = Packer.unpackf(b);
		assertEquals(0.0f, f);
	}
	
	/**
	* Test case 2 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_2() {
		byte[] b = {(byte) 0x80, 0x00, 0x00, 0x00};
		float f = Packer.unpackf(b);
		assertEquals(-0.0f, f);
	}
	
	/**
	* Test case 3 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_3() {
		byte[] b = {(byte) 0x7f, (byte) 0x80, 0x00, 0x00};
		float f = Packer.unpackf(b);
		assertEquals(Float.POSITIVE_INFINITY, f);
	}
	
	/**
	* Test case 4 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_4() {
		byte[] b = {(byte) 0xff, (byte) 0x80, 0x00, 0x00};
		float f = Packer.unpackf(b);
		assertEquals(Float.NEGATIVE_INFINITY, f);
	}
	
	/**
	* Test case 5 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_5() {
		byte[] b = {(byte) 0xff, (byte) 0x7f, (byte) 0xff, (byte) 0xff};
		float f = Packer.unpackf(b);
		assertEquals(Float.NaN, f);
	}
	
	/**
	* Test case 6 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_6() {
		byte[] b = {(byte) 0x7f, (byte) 0x7f, (byte) 0xff, (byte) 0xff};
		float f = Packer.unpackf(b);
		assertEquals(Float.NaN, f);
	}
	
	/**
	* Test case 7 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_7() {
		byte[] b = {(byte) 0x7f, (byte) 0x7f, (byte) 0xff, (byte) 0xfe};
		float f = Packer.unpackf(b);
		assertEquals(Float.NaN, f);
	}
	
	/**
	* Test case 8 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_8() {
		byte[] b = {(byte) 0x7f, (byte) 0x7f, (byte) 0xff, (byte) 0xfd};
		float f = Packer.unpackf(b);
		assertEquals(Float.NaN, f);
	}
	
	/**
	* Test case 9 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_9() {
		byte[] b = {(byte) 0x7f, (byte) 0x7f, (byte) 0xff, (byte) 0xfc};
		float f = Packer.unpackf(b);
		assertEquals(Float.NaN, f);
	}
	
	/**
	* Test case 10 for {@link Packer#unpackf(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackf_10() {
		byte[] b = {(byte) 0x7f, (byte) 0x7f, (byte) 0xff, (byte) 0xfb};
		float f = Packer.unpackf(b);
		assertEquals(Float.NaN, f);
	}
	
}

// Packer_12Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackd(byte[])} method.
*/
class Packer_12Test {
		
	/**
	* Test case 1 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_1() {
		byte[] b = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
		double d = Packer.unpackd(b);
		assertEquals(0.0, d);
	}
	
	/**
	* Test case 2 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_2() {
		byte[] b = {(byte) 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
		double d = Packer.unpackd(b);
		assertEquals(-0.0, d);
	}
	
	/**
	* Test case 3 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_3() {
		byte[] b = {(byte) 0x7f, (byte) 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
		double d = Packer.unpackd(b);
		assertEquals(Double.POSITIVE_INFINITY, d);
	}
	
	/**
	* Test case 4 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_4() {
		byte[] b = {(byte) 0xff, (byte) 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
		double d = Packer.unpackd(b);
		assertEquals(Double.NEGATIVE_INFINITY, d);
	}
	
	/**
	* Test case 5 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_5() {
		byte[] b = {(byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff};
		double d = Packer.unpackd(b);
		assertEquals(Double.NaN, d);
	}
	
	/**
	* Test case 6 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_6() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff};
		double d = Packer.unpackd(b);
		assertEquals(Double.NaN, d);
	}
	
	/**
	* Test case 7 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_7() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfe};
		double d = Packer.unpackd(b);
		assertEquals(Double.NaN, d);
	}
	
	/**
	* Test case 8 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_8() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfd};
		double d = Packer.unpackd(b);
		assertEquals(Double.NaN, d);
	}
	
	/**
	* Test case 9 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_9() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfc};
		double d = Packer.unpackd(b);
		assertEquals(Double.NaN, d);
	}
	
	/**
	* Test case 10 for {@link Packer#unpackd(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpackd_10() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xfb};
		double d = Packer.unpackd(b);
		assertEquals(Double.NaN, d);
	}
	
}

// Packer_13Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacki(byte[])} method.
*/
class Packer_13Test {
		
	/**
	* Test case 1 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_1() {
		byte[] b = {0x00, 0x00, 0x00, 0x00};
		int i = Packer.unpacki(b);
		assertEquals(0, i);
	}
	
	/**
	* Test case 2 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_2() {
		byte[] b = {(byte) 0x80, 0x00, 0x00, 0x00};
		int i = Packer.unpacki(b);
		assertEquals(-2147483648, i);
	}
	
	/**
	* Test case 3 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_3() {
		byte[] b = {(byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff};
		int i = Packer.unpacki(b);
		assertEquals(-1, i);
	}
	
	/**
	* Test case 4 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_4() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xff};
		int i = Packer.unpacki(b);
		assertEquals(2147483647, i);
	}
	
	/**
	* Test case 5 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_5() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xfe};
		int i = Packer.unpacki(b);
		assertEquals(2147483646, i);
	}
	
	/**
	* Test case 6 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_6() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xfd};
		int i = Packer.unpacki(b);
		assertEquals(2147483645, i);
	}
	
	/**
	* Test case 7 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_7() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xfc};
		int i = Packer.unpacki(b);
		assertEquals(2147483644, i);
	}
	
	/**
	* Test case 8 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_8() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xfb};
		int i = Packer.unpacki(b);
		assertEquals(2147483643, i);
	}
	
	/**
	* Test case 9 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_9() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xfa};
		int i = Packer.unpacki(b);
		assertEquals(2147483642, i);
	}
	
	/**
	* Test case 10 for {@link Packer#unpacki(byte[])}.
	* It tests the normal case.
	*/
	@Test
	void testUnpacki_10() {
		byte[] b = {(byte) 0x7f, (byte) 0xff, (byte) 0xff, (byte) 0xf9};
		int i = Packer.unpacki(b);
		assertEquals(2147483641, i);
	}
	
}

// Packer_14Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Ass"
cmpl-6tvbDe2Hyvz60e3e2oz8TTqVeVgDI,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_12Test.java,93.49720311164856,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_12Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packi(int)} method.
*/
class Packer_12Test {","// Packer_12Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packi(int)} method.
*/
class Packer_12Test {

		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 0.
		*/
		@Test
		void testPacki_0() {
				byte[] expected = {0, 0, 0, 0};
				byte[] actual = Packer.packi(0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 1.
		*/
		@Test
		void testPacki_1() {
				byte[] expected = {0, 0, 0, 1};
				byte[] actual = Packer.packi(1);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 2.
		*/
		@Test
		void testPacki_2() {
				byte[] expected = {0, 0, 0, 2};
				byte[] actual = Packer.packi(2);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 3.
		*/
		@Test
		void testPacki_3() {
				byte[] expected = {0, 0, 0, 3};
				byte[] actual = Packer.packi(3);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 4.
		*/
		@Test
		void testPacki_4() {
				byte[] expected = {0, 0, 0, 4};
				byte[] actual = Packer.packi(4);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 5.
		*/
		@Test
		void testPacki_5() {
				byte[] expected = {0, 0, 0, 5};
				byte[] actual = Packer.packi(5);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 6.
		*/
		@Test
		void testPacki_6() {
				byte[] expected = {0, 0, 0, 6};
				byte[] actual = Packer.packi(6);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 7.
		*/
		@Test
		void testPacki_7() {
				byte[] expected = {0, 0, 0, 7};
				byte[] actual = Packer.packi(7);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 8.
		*/
		@Test
		void testPacki_8() {
				byte[] expected = {0, 0, 0, 8};
				byte[] actual = Packer.packi(8);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 9.
		*/
		@Test
		void testPacki_9() {
				byte[] expected = {0, 0, 0, 9};
				byte[] actual = Packer.packi(9);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 10.
		*/
		@Test
		void testPacki_10() {
				byte[] expected = {0, 0, 0, 10};
				byte[] actual = Packer.packi(10);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 11.
		*/
		@Test
		void testPacki_11() {
				byte[] expected = {0, 0, 0, 11};
				byte[] actual = Packer.packi(11);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 12.
		*/
		@Test
		void testPacki_12() {
				byte[] expected = {0, 0, 0, 12};
				byte[] actual = Packer.packi(12);
				assertArrayEquals(expected, actual);
		}
		
}

// Packer_13Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packi(int)} method.
*/
class Packer_13Test {
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 0.
		*/
		@Test
		void testPacki_0() {
				byte[] expected = {0, 0, 0, 0};
				byte[] actual = Packer.packi(0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 1.
		*/
		@Test
		void testPacki_1() {
				byte[] expected = {0, 0, 0, 1};
				byte[] actual = Packer.packi(1);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 2.
		*/
		@Test
		void testPacki_2() {
				byte[] expected = {0, 0, 0, 2};
				byte[] actual = Packer.packi(2);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 3.
		*/
		@Test
		void testPacki_3() {
				byte[] expected = {0, 0, 0, 3};
				byte[] actual = Packer.packi(3);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 4.
		*/
		@Test
		void testPacki_4() {
				byte[] expected = {0, 0, 0, 4};
				byte[] actual = Packer.packi(4);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 5.
		*/
		@Test
		void testPacki_5() {
				byte[] expected = {0, 0, 0, 5};
				byte[] actual = Packer.packi(5);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 6.
		*/
		@Test
		void testPacki_6() {
				byte[] expected = {0, 0, 0, 6};
				byte[] actual = Packer.packi(6);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 7.
		*/
		@Test
		void testPacki_7() {
				byte[] expected = {0, 0, 0, 7};
				byte[] actual = Packer.packi(7);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 8.
		*/
		@Test
		void testPacki_8() {
				byte[] expected = {0, 0, 0, 8};
				byte[] actual = Packer.packi(8);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 9.
		*/
		@Test
		void testPacki_9() {
				byte[] expected = {0, 0, 0, 9};
				byte[] actual = Packer.packi(9);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 10.
		*/
		@Test
		void testPacki_10() {
				byte[] expected = {0, 0, 0, 10};
				byte[] actual = Packer.packi(10);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 11.
		*/
		@Test
		void testPacki_11() {
				byte[] expected = {0, 0, 0, 11};
				byte[] actual = Packer.packi(11);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 12.
		*/
		@Test
		void testPacki_12() {
				byte[] expected = {0, 0, 0, 12};
				byte[] actual = Packer.packi(12);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 13.
		*/
		@Test
		void testPacki_13() {
				byte[] expected = {0, 0, 0, 13};
				byte[] actual = Packer.packi(13);
				assertArrayEquals(expected, actual);
		}
		
}

// Packer_14Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packi(int)} method.
*/
class Packer_14Test {
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 0.
		*/
		@Test
		void testPacki_0() {
				byte[] expected = {0, 0, 0, 0};
				byte[] actual = Packer.packi(0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 1.
		*/
		@Test
		void testPacki_1() {
				byte[] expected = {0, 0, 0, 1};
				byte[] actual = Packer.packi(1);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 2.
		*/
		@Test
		void testPacki_2() {
				byte[] expected = {0, 0, 0, 2};
				byte[] actual = Packer.packi(2);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 3.
		*/
		@Test
		void testPacki_3() {
				byte[] expected = {0, 0, 0, 3};
				byte[] actual = Packer.packi(3);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packi(int)}.
		* It tests if the method returns the correct byte array for the integer value 4.
		*/
		@Test
		void testPacki_4() {
				byte[] expected = {0, 0, 0, 4};
				byte[] actual = Packer.packi(4);
				assertArrayEquals(expected, actual);
"
cmpl-6tvcjvejokh1Iinc7RxdOaD8n5inL,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_13Test.java,101.4613025188446,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_13Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacki(byte[])} method.
*/
class Packer_13Test {","// Packer_13Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacki(byte[])} method.
*/
class Packer_13Test {

	/**
	* Test case 1 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_1() {
		byte[] b = {0, 0, 0, 0};
		int expected = 0;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_2() {
		byte[] b = {-1, -1, -1, -1};
		int expected = -1;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_3() {
		byte[] b = {-1, -1, -1, 0};
		int expected = 16777215;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_4() {
		byte[] b = {-1, -1, 0, 0};
		int expected = 65535;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_5() {
		byte[] b = {-1, 0, 0, 0};
		int expected = 255;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_6() {
		byte[] b = {0, 0, 0, -1};
		int expected = -16777216;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_7() {
		byte[] b = {0, 0, -1, -1};
		int expected = -256;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_8() {
		byte[] b = {0, -1, -1, -1};
		int expected = -1;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_9() {
		byte[] b = {-1, -1, -1, -1};
		int expected = -1;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link Packer#unpacki(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpacki_10() {
		byte[] b = {-1, -1, -1, -1};
		int expected = -1;
		int actual = Packer.unpacki(b);
		assertEquals(expected, actual);
	}
}

// Packer_14Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackl(byte[])} method.
*/
class Packer_14Test {
		
	/**
	* Test case 1 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_1() {
		byte[] b = {0, 0, 0, 0, 0, 0, 0, 0};
		long expected = 0;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_2() {
		byte[] b = {-1, -1, -1, -1, -1, -1, -1, -1};
		long expected = -1;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_3() {
		byte[] b = {-1, -1, -1, -1, -1, -1, -1, 0};
		long expected = 72057594037927935L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_4() {
		byte[] b = {-1, -1, -1, -1, -1, -1, 0, 0};
		long expected = 281474976710655L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_5() {
		byte[] b = {-1, -1, -1, -1, -1, 0, 0, 0};
		long expected = 1099511627775L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_6() {
		byte[] b = {-1, -1, -1, -1, 0, 0, 0, 0};
		long expected = 4294967295L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_7() {
		byte[] b = {-1, -1, -1, 0, 0, 0, 0, 0};
		long expected = 16777215L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_8() {
		byte[] b = {-1, -1, 0, 0, 0, 0, 0, 0};
		long expected = 65535L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_9() {
		byte[] b = {-1, 0, 0, 0, 0, 0, 0, 0};
		long expected = 255L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link Packer#unpackl(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackl_10() {
		byte[] b = {0, 0, 0, 0, 0, 0, 0, -1};
		long expected = -72057594037927936L;
		long actual = Packer.unpackl(b);
		assertEquals(expected, actual);
	}
}

// Packer_15Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackf(byte[])} method.
*/
class Packer_15Test {
		
	/**
	* Test case 1 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_1() {
		byte[] b = {0, 0, 0, 0};
		float expected = 0.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 2 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_2() {
		byte[] b = {-1, -1, -1, -1};
		float expected = -1.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 3 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_3() {
		byte[] b = {-1, -1, -1, 0};
		float expected = 16777215.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 4 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_4() {
		byte[] b = {-1, -1, 0, 0};
		float expected = 65535.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 5 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_5() {
		byte[] b = {-1, 0, 0, 0};
		float expected = 255.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 6 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_6() {
		byte[] b = {0, 0, 0, -1};
		float expected = -16777216.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 7 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_7() {
		byte[] b = {0, 0, -1, -1};
		float expected = -256.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 8 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_8() {
		byte[] b = {0, -1, -1, -1};
		float expected = -1.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 9 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_9() {
		byte[] b = {-1, -1, -1, -1};
		float expected = -1.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
	
	/**
	* Test case 10 for {@link Packer#unpackf(byte[])}.
	* It tests the method with a byte array of length 4.
	*/
	@Test
	void testUnpackf_10() {
		byte[] b = {-1, -1, -1, -1};
		float expected = -1.0f;
		float actual = Packer.unpackf(b);
		assertEquals(expected, actual);
	}
}

// Packer_16Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackd(byte[])} method.
*/
class Packer_16Test {
		
	/**
	* Test case 1 for {@link Packer#unpackd(byte[])}.
	* It tests the method with a byte array of length 8.
	*/
	@Test
	void testUnpackd_1() {
		byte[] b = {0, 0, 0, 0, 0, 0, 0, 0};"
cmpl-6tveMUVQJ8Ig32o1wSoFu8YBK8A9M,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_14Test.java,96.55660843849182,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_14Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packl(long)} method.
*/
class Packer_14Test {","// Packer_14Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packl(long)} method.
*/
class Packer_14Test {

		/**
		* Test case 1 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_1() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 1};
				byte[] actual = Packer.packl(1);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_2() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -1};
				byte[] actual = Packer.packl(-1);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_3() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 0};
				byte[] actual = Packer.packl(0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_4() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -128};
				byte[] actual = Packer.packl(-128);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_5() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 127};
				byte[] actual = Packer.packl(127);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_6() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -2};
				byte[] actual = Packer.packl(-2);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_7() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 2};
				byte[] actual = Packer.packl(2);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_8() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -3};
				byte[] actual = Packer.packl(-3);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_9() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 3};
				byte[] actual = Packer.packl(3);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link Packer#packl(long)}.
		* It tests the normal case.
		*/
		@Test
		void testPackl_10() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -4};
				byte[] actual = Packer.packl(-4);
				assertArrayEquals(expected, actual);
		}
}

// Packer_15Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packd(double)} method.
*/
class Packer_15Test {
		
		/**
		* Test case 1 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_1() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 0};
				byte[] actual = Packer.packd(0.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_2() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -1};
				byte[] actual = Packer.packd(-1.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_3() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 1};
				byte[] actual = Packer.packd(1.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_4() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -2};
				byte[] actual = Packer.packd(-2.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_5() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 2};
				byte[] actual = Packer.packd(2.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_6() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -3};
				byte[] actual = Packer.packd(-3.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_7() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 3};
				byte[] actual = Packer.packd(3.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_8() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -4};
				byte[] actual = Packer.packd(-4.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_9() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, 4};
				byte[] actual = Packer.packd(4.0);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link Packer#packd(double)}.
		* It tests the normal case.
		*/
		@Test
		void testPackd_10() {
				byte[] expected = {0, 0, 0, 0, 0, 0, 0, -5};
				byte[] actual = Packer.packd(-5.0);
				assertArrayEquals(expected, actual);
		}
}

// Packer_16Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packf(float)} method.
*/
class Packer_16Test {
		
		/**
		* Test case 1 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_1() {
				byte[] expected = {0, 0, 0, 0};
				byte[] actual = Packer.packf(0.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_2() {
				byte[] expected = {0, 0, 0, -1};
				byte[] actual = Packer.packf(-1.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_3() {
				byte[] expected = {0, 0, 0, 1};
				byte[] actual = Packer.packf(1.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_4() {
				byte[] expected = {0, 0, 0, -2};
				byte[] actual = Packer.packf(-2.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_5() {
				byte[] expected = {0, 0, 0, 2};
				byte[] actual = Packer.packf(2.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_6() {
				byte[] expected = {0, 0, 0, -3};
				byte[] actual = Packer.packf(-3.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_7() {
				byte[] expected = {0, 0, 0, 3};
				byte[] actual = Packer.packf(3.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_8() {
				byte[] expected = {0, 0, 0, -4};
				byte[] actual = Packer.packf(-4.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_9() {
				byte[] expected = {0, 0, 0, 4};
				byte[] actual = Packer.packf(4.0f);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link Packer#packf(float)}.
		* It tests the normal case.
		*/
		@Test
		void testPackf_10() {
				byte[] expected = {0, 0, 0, -5};
				byte[] actual = Packer.packf(-5.0f);
				assertArrayEquals(expected, actual);
		}
}

// Packer_17Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packi(int)} method.
*/
class Packer_17Test {
		
		/**
		* Test case 1 for {@link Packer#packi(int)}.
		* It tests the normal case.
		*/
		@Test
		void testPacki_1() {
				byte[] expected = {0, 0, 0, 1};
				byte[] actual = Packer.packi(1);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link Packer#packi(int)}.
		* It tests the normal case.
		*/
		@Test
		void testPacki_2() {
				byte[] expected = {0, 0, 0, -1};
			"
cmpl-6tvfv1Pw6YQTMbn2Ds19J2WCFw3YW,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_15Test.java,105.65368890762329,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_15Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackl(byte[])} method.
*/
class Packer_15Test {","// Packer_15Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackl(byte[])} method.
*/
class Packer_15Test {

		/**
		* Test case 1 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_1() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, 0};
				long expected = 0;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_2() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, -1};
				long expected = -1;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_3() {
				byte[] b = {-1, -1, -1, -1, 0, 0, 0, 0};
				long expected = -4294967296L;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_4() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, 127};
				long expected = 9223372036854775807L;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_5() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, -128};
				long expected = -9223372036854775808L;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_6() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, -1};
				long expected = -1;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_7() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, 0};
				long expected = -256;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_8() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, 1};
				long expected = -255;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_9() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, 2};
				long expected = -254;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link Packer#unpackl(byte[])}.
		* It tests the method with a byte array of length 8.
		*/
		@Test
		void testUnpackl_10() {
				byte[] b = {-1, -1, -1, -1, -1, -1, -1, 3};
				long expected = -253;
				long actual = Packer.unpackl(b);
				assertEquals(expected, actual);
		}
}

// Packer_16Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpack16(byte[])} method.
*/
class Packer_16Test {
		
		/**
		* Test case 1 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_1() {
				byte[] b = {0, 0};
				short expected = 0;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_2() {
				byte[] b = {-1, -1};
				short expected = -1;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_3() {
				byte[] b = {-1, 0};
				short expected = -256;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_4() {
				byte[] b = {-1, 1};
				short expected = -255;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_5() {
				byte[] b = {-1, 2};
				short expected = -254;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_6() {
				byte[] b = {-1, 3};
				short expected = -253;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_7() {
				byte[] b = {-1, 4};
				short expected = -252;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_8() {
				byte[] b = {-1, 5};
				short expected = -251;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_9() {
				byte[] b = {-1, 6};
				short expected = -250;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link Packer#unpack16(byte[])}.
		* It tests the method with a byte array of length 2.
		*/
		@Test
		void testUnpack16_10() {
				byte[] b = {-1, 7};
				short expected = -249;
				short actual = Packer.unpack16(b);
				assertEquals(expected, actual);
		}
}

// Packer_17Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpack32(byte[])} method.
*/
class Packer_17Test {
		
		/**
		* Test case 1 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_1() {
				byte[] b = {0, 0, 0, 0};
				int expected = 0;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_2() {
				byte[] b = {-1, -1, -1, -1};
				int expected = -1;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_3() {
				byte[] b = {-1, -1, -1, 0};
				int expected = -65536;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_4() {
				byte[] b = {-1, -1, -1, 1};
				int expected = -65535;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_5() {
				byte[] b = {-1, -1, -1, 2};
				int expected = -65534;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_6() {
				byte[] b = {-1, -1, -1, 3};
				int expected = -65533;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_7() {
				byte[] b = {-1, -1, -1, 4};
				int expected = -65532;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link Packer#unpack32(byte[])}.
		* It tests the method with a byte array of length 4.
		*/
		@Test
		void testUnpack32_8() {
				byte[] b = {-1, -1, -1, 5};
				int expected = -65531;
				int actual = Packer.unpack32(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link Packer#unpack32(byte[])}.
		* It"
cmpl-6tvhdtesRkrDOCd6zFcYYSAkRZBiZ,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_16Test.java,97.3626856803894,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_16Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packd(double)} method.
*/
class Packer_16Test {","// Packer_16Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packd(double)} method.
*/
class Packer_16Test {

		/**
		* Test case 1 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_1() {
				double d = 1.0;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(63, b[7]);
		}
		
		/**
		* Test case 2 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_2() {
				double d = -1.0;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-64, b[7]);
		}
		
		/**
		* Test case 3 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_3() {
				double d = 1.5;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(64, b[7]);
		}
		
		/**
		* Test case 4 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_4() {
				double d = -1.5;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-65, b[7]);
		}
		
		/**
		* Test case 5 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_5() {
				double d = 1.25;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(63, b[7]);
		}
		
		/**
		* Test case 6 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_6() {
				double d = -1.25;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-64, b[7]);
		}
		
		/**
		* Test case 7 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_7() {
				double d = 1.75;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(64, b[7]);
		}
		
		/**
		* Test case 8 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_8() {
				double d = -1.75;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-65, b[7]);
		}
		
		/**
		* Test case 9 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_9() {
				double d = 1.125;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(63, b[7]);
		}
		
		/**
		* Test case 10 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_10() {
				double d = -1.125;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-64, b[7]);
		}
}

// Packer_32Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packd(double)} method.
*/
class Packer_32Test {
		
		/**
		* Test case 1 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_1() {
				double d = 1.0;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(63, b[7]);
		}
		
		/**
		* Test case 2 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_2() {
				double d = -1.0;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-64, b[7]);
		}
		
		/**
		* Test case 3 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_3() {
				double d = 1.5;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(64, b[7]);
		}
		
		/**
		* Test case 4 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_4() {
				double d = -1.5;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-65, b[7]);
		}
		
		/**
		* Test case 5 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_5() {
				double d = 1.25;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(63, b[7]);
		}
		
		/**
		* Test case 6 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_6() {
				double d = -1.25;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-64, b[7]);
		}
		
		/**
		* Test case 7 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
		@Test
		void testPackd_7() {
				double d = 1.75;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(64, b[7]);
		}
		
		/**
		* Test case 8 for {@link Packer#packd(double)}.
		* It tests the method with a negative double value.
		*/
		@Test
		void testPackd_8() {
				double d = -1.75;
				byte[] b = Packer.packd(d);
				assertEquals(0, b[0]);
				assertEquals(0, b[1]);
				assertEquals(0, b[2]);
				assertEquals(0, b[3]);
				assertEquals(0, b[4]);
				assertEquals(0, b[5]);
				assertEquals(0, b[6]);
				assertEquals(-65, b[7]);
		}
		
		/**
		* Test case 9 for {@link Packer#packd(double)}.
		* It tests the method with a positive double value.
		*/
"
cmpl-6tvjCazClj4wtjIJqObk2rYfXNsOx,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_17Test.java,103.88626551628113,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_17Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackd(byte[])} method.
*/
class Packer_17Test {","// Packer_17Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackd(byte[])} method.
*/
class Packer_17Test {

		/**
		* Test case 1 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of 0.0.
		*/
		@Test
		void testUnpackd_1() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, 0};
				double d = Packer.unpackd(b);
				assertEquals(0.0, d);
		}
		
		/**
		* Test case 2 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of 1.0.
		*/
		@Test
		void testUnpackd_2() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, 64};
				double d = Packer.unpackd(b);
				assertEquals(1.0, d);
		}
		
		/**
		* Test case 3 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of -1.0.
		*/
		@Test
		void testUnpackd_3() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, -64};
				double d = Packer.unpackd(b);
				assertEquals(-1.0, d);
		}
		
		/**
		* Test case 4 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of 0.5.
		*/
		@Test
		void testUnpackd_4() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, 63};
				double d = Packer.unpackd(b);
				assertEquals(0.5, d);
		}
		
		/**
		* Test case 5 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of -0.5.
		*/
		@Test
		void testUnpackd_5() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, -65};
				double d = Packer.unpackd(b);
				assertEquals(-0.5, d);
		}
		
		/**
		* Test case 6 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of 0.25.
		*/
		@Test
		void testUnpackd_6() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, 62};
				double d = Packer.unpackd(b);
				assertEquals(0.25, d);
		}
		
		/**
		* Test case 7 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of -0.25.
		*/
		@Test
		void testUnpackd_7() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, -66};
				double d = Packer.unpackd(b);
				assertEquals(-0.25, d);
		}
		
		/**
		* Test case 8 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of 0.75.
		*/
		@Test
		void testUnpackd_8() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, 64};
				double d = Packer.unpackd(b);
				assertEquals(0.75, d);
		}
		
		/**
		* Test case 9 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of -0.75.
		*/
		@Test
		void testUnpackd_9() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, -64};
				double d = Packer.unpackd(b);
				assertEquals(-0.75, d);
		}
		
		/**
		* Test case 10 for {@link Packer#unpackd(byte[])}.
		* It tests the method with a double value of 0.125.
		*/
		@Test
		void testUnpackd_10() {
				byte[] b = {0, 0, 0, 0, 0, 0, 0, 61};
				double d = Packer.unpackd(b);
				assertEquals(0.125, d);
		}
}

// Packer_18Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpackf(byte[])} method.
*/
class Packer_18Test {
		
		/**
		* Test case 1 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of 0.0.
		*/
		@Test
		void testUnpackf_1() {
				byte[] b = {0, 0, 0, 0};
				float f = Packer.unpackf(b);
				assertEquals(0.0, f);
		}
		
		/**
		* Test case 2 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of 1.0.
		*/
		@Test
		void testUnpackf_2() {
				byte[] b = {0, 0, 0, 64};
				float f = Packer.unpackf(b);
				assertEquals(1.0, f);
		}
		
		/**
		* Test case 3 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of -1.0.
		*/
		@Test
		void testUnpackf_3() {
				byte[] b = {0, 0, 0, -64};
				float f = Packer.unpackf(b);
				assertEquals(-1.0, f);
		}
		
		/**
		* Test case 4 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of 0.5.
		*/
		@Test
		void testUnpackf_4() {
				byte[] b = {0, 0, 0, 63};
				float f = Packer.unpackf(b);
				assertEquals(0.5, f);
		}
		
		/**
		* Test case 5 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of -0.5.
		*/
		@Test
		void testUnpackf_5() {
				byte[] b = {0, 0, 0, -65};
				float f = Packer.unpackf(b);
				assertEquals(-0.5, f);
		}
		
		/**
		* Test case 6 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of 0.25.
		*/
		@Test
		void testUnpackf_6() {
				byte[] b = {0, 0, 0, 62};
				float f = Packer.unpackf(b);
				assertEquals(0.25, f);
		}
		
		/**
		* Test case 7 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of -0.25.
		*/
		@Test
		void testUnpackf_7() {
				byte[] b = {0, 0, 0, -66};
				float f = Packer.unpackf(b);
				assertEquals(-0.25, f);
		}
		
		/**
		* Test case 8 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of 0.75.
		*/
		@Test
		void testUnpackf_8() {
				byte[] b = {0, 0, 0, 64};
				float f = Packer.unpackf(b);
				assertEquals(0.75, f);
		}
		
		/**
		* Test case 9 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of -0.75.
		*/
		@Test
		void testUnpackf_9() {
				byte[] b = {0, 0, 0, -64};
				float f = Packer.unpackf(b);
				assertEquals(-0.75, f);
		}
		
		/**
		* Test case 10 for {@link Packer#unpackf(byte[])}.
		* It tests the method with a float value of 0.125.
		*/
		@Test
		void testUnpackf_10() {
				byte[] b = {0, 0, 0, 61};
				float f = Packer.unpackf(b);
				assertEquals(0.125, f);
		}
}

// Packer_19Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacki(byte[])} method.
*/
class Packer_19Test {
		
		/**
		* Test case 1 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of 0.
		*/
		@Test
		void testUnpacki_1() {
				byte[] b = {0, 0, 0, 0};
				int i = Packer.unpacki(b);
				assertEquals(0, i);
		}
		
		/**
		* Test case 2 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of 1.
		*/
		@Test
		void testUnpacki_2() {
				byte[] b = {0, 0, 0, 1};
				int i = Packer.unpacki(b);
				assertEquals(1, i);
		}
		
		/**
		* Test case 3 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of -1.
		*/
		@Test
		void testUnpacki_3() {
				byte[] b = {-1, -1, -1, -1};
				int i = Packer.unpacki(b);
				assertEquals(-1, i);
		}
		
		/**
		* Test case 4 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of 2147483647.
		*/
		@Test
		void testUnpacki_4() {
				byte[] b = {127, -1, -1, -1};
				int i = Packer.unpacki(b);
				assertEquals(2147483647, i);
		}
		
		/**
		* Test case 5 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of -2147483648.
		*/
		@Test
		void testUnpacki_5() {
				byte[] b = {-128, 0, 0, 0};
				int i = Packer.unpacki(b);
				assertEquals(-2147483648, i);
		}
		
		/**
		* Test case 6 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of 2147483646.
		*/
		@Test
		void testUnpacki_6() {
				byte[] b = {126, -1, -1, -1};
				int i = Packer.unpacki(b);
				assertEquals(2147483646, i);
		}
		
		/**
		* Test case 7 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of -2147483647.
		*/
		@Test
		void testUnpacki_7() {
				byte[] b = {-127, 0, 0, 0};
				int i = Packer.unpacki(b);
				assertEquals(-2147483647, i);
		}
		
		/**
		* Test case 8 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of 1073741823.
		*/
		@Test
		void testUnpacki_8() {
				byte[] b = {63, -1, -1, -1};
				int i = Packer.unpacki(b);
				assertEquals(1073741823, i);
		}
		
		/**
		* Test case 9 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of -1073741824.
		*/
		@Test
		void testUnpacki_9() {
				byte[] b = {-64, 0, 0, 0};
				int i = Packer.unpacki(b);
				assertEquals(-1073741824, i);
		}
		
		/**
		* Test case 10 for {@link Packer#unpacki(byte[])}.
		* It tests the method with an integer value of 1073741822.
		*/
		@Test
		void testUnpacki_10() {
				byte[] b = {62, -1, -1, -1};
				int i = Packer.unpacki(b);
				assertEquals(1073741822, i);
		}
}

// Packer_20Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assert"
cmpl-6tvksnaL4aGmxus5VSLfbvbFhrQIV,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_18Test.java,103.35799837112427,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_18Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacks(byte[], int, int)} method.
*/
class Packer_18Test {","// Packer_18Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacks(byte[], int, int)} method.
*/
class Packer_18Test {

		/**
		* Test case 1 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the normal case.
		*/
		@Test
		void testUnpacks1() {
				byte[] b = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,"
cmpl-6tvmXh2OzGsQZI8dsCJpdDN5LKMa1,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_19Test.java,104.60269165039062,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_19Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packs(String)} method.
*/
class Packer_19Test {","// Packer_19Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packs(String)} method.
*/
class Packer_19Test {

		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""abc"".
		*/
		@Test
		void testPacks_1() {
				byte[] expected = {97, 98, 99};
				byte[] actual = Packer.packs(""abc"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""abcdefghijklmnopqrstuvwxyz"".
		*/
		@Test
		void testPacks_2() {
				byte[] expected = {97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122};
				byte[] actual = Packer.packs(""abcdefghijklmnopqrstuvwxyz"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"".
		*/
		@Test
		void testPacks_3() {
				byte[] expected = {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90};
				byte[] actual = Packer.packs(""ABCDEFGHIJKLMNOPQRSTUVWXYZ"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""0123456789"".
		*/
		@Test
		void testPacks_4() {
				byte[] expected = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57};
				byte[] actual = Packer.packs(""0123456789"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""!\""#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"".
		*/
		@Test
		void testPacks_5() {
				byte[] expected = {33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 58, 59, 60, 61, 62, 63, 64, 91, 92, 93, 94, 95, 96, 123, 124, 125, 126};
				byte[] actual = Packer.packs(""!\""#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""ÃÃÃÃ¥Ã¤Ã¶"".
		*/
		@Test
		void testPacks_6() {
				byte[] expected = {-30, -126, -84, -30, -126, -96, -30, -126, -80, -30, -126, -94, -30, -126, -92};
				byte[] actual = Packer.packs(""ÃÃÃÃ¥Ã¤Ã¶"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""ÃÃÃÃ¦Ã¸Ã¾"".
		*/
		@Test
		void testPacks_7() {
				byte[] expected = {-30, -126, -78, -30, -126, -72, -30, -126, -66, -30, -126, -70, -30, -126, -68};
				byte[] actual = Packer.packs(""ÃÃÃÃ¦Ã¸Ã¾"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""ÃÃ°"".
		*/
		@Test
		void testPacks_8() {
				byte[] expected = {-30, -126, -64, -30, -126, -62};
				byte[] actual = Packer.packs(""ÃÃ°"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""ÃÃ±"".
		*/
		@Test
		void testPacks_9() {
				byte[] expected = {-30, -126, -60, -30, -126, -58};
				byte[] actual = Packer.packs(""ÃÃ±"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#packs(String)} method.
		* It tests if the method returns the correct byte array for the string ""ÃÃ½"".
		*/
		@Test
		void testPacks_10() {
				byte[] expected = {-30, -126, -54, -30, -126, -50};
				byte[] actual = Packer.packs(""ÃÃ½"");
				assertArrayEquals(expected, actual);
		}
}

// Packer_20Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacks(byte[])} method.
*/
class Packer_20Test {
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {97, 98, 99}.
		*/
		@Test
		void testUnpacks_1() {
				byte[] b = {97, 98, 99};
				String expected = ""abc"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122}.
		*/
		@Test
		void testUnpacks_2() {
				byte[] b = {97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122};
				String expected = ""abcdefghijklmnopqrstuvwxyz"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90}.
		*/
		@Test
		void testUnpacks_3() {
				byte[] b = {65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90};
				String expected = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {48, 49, 50, 51, 52, 53, 54, 55, 56, 57}.
		*/
		@Test
		void testUnpacks_4() {
				byte[] b = {48, 49, 50, 51, 52, 53, 54, 55, 56, 57};
				String expected = ""0123456789"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 58, 59, 60, 61, 62, 63, 64, 91, 92, 93, 94, 95, 96, 123, 124, 125, 126}.
		*/
		@Test
		void testUnpacks_5() {
				byte[] b = {33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 58, 59, 60, 61, 62, 63, 64, 91, 92, 93, 94, 95, 96, 123, 124, 125, 126};
				String expected = ""!\""#$%&'()*+,-./:;<=>?@[\\]^_`{|}~"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {-30, -126, -84, -30, -126, -96, -30, -126, -80, -30, -126, -94, -30, -126, -92}.
		*/
		@Test
		void testUnpacks_6() {
				byte[] b = {-30, -126, -84, -30, -126, -96, -30, -126, -80, -30, -126, -94, -30, -126, -92};
				String expected = ""ÃÃÃÃ¥Ã¤Ã¶"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {-30, -126, -78, -30, -126, -72, -30, -126, -66, -30, -126, -70, -30, -126, -68}.
		*/
		@Test
		void testUnpacks_7() {
				byte[] b = {-30, -126, -78, -30, -126, -72, -30, -126, -66, -30, -126, -70, -30, -126, -68};
				String expected = ""ÃÃÃÃ¦Ã¸Ã¾"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {-30, -126, -64, -30, -126, -62}.
		*/
		@Test
		void testUnpacks_8() {
				byte[] b = {-30, -126, -64, -30, -126, -62};
				String expected = ""ÃÃ°"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {-30, -126, -60, -30, -126, -58}.
		*/
		@Test
		void testUnpacks_9() {
				byte[] b = {-30, -126, -60, -30, -126, -58};
				String expected = ""ÃÃ±"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[])} method.
		* It tests if the method returns the correct string for the byte array {-30, -126, -54, -30, -126, -50}.
		*/
		@Test
		void testUnpacks_10() {
				byte[] b = {-30, -126, -54, -30, -126, -50};
				String expected = ""ÃÃ½"";
				String actual = Packer.unpacks(b);
				assertEquals(expected, actual);
		}
}

// Packer_21Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacks(byte[], int, int)} method.
*/
class Packer_21Test {
		
		/**
		* Test case for {@link Packer#unpacks(byte[], int, int)} method.
		* It tests if the method returns the correct string for the byte array {97, 98, 99} and the offset 0 and length 3.
		*/
		@Test
		void testUnpacks_1() {
				byte[] b = {97, 98, 99};
				String expected = ""abc"";
				String actual = Packer.unpacks(b, 0, 3);
				assertEquals(expected, actual);
		}
		
		/**
		* Test case for {@link Packer#unpacks(byte[], int, int)} method.
		* It tests if the method returns the correct string for the byte array {97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116"
cmpl-6tvoEuVEUBz4ih41dgaMMjF9T5OKq,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_20Test.java,104.55356931686401,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_20Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacks(byte[])} method.
*/
class Packer_20Test {","// Packer_20Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacks(byte[])} method.
*/
class Packer_20Test {

		/**
		* Test case 1 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a null byte array.
		*/
		@Test
		void testUnpacks1() {
				byte[] b = null;
				assertThrows(NullPointerException.class, () -> {
						Packer.unpacks(b);
				});
		}
		
		/**
		* Test case 2 for {@link Packer#unpacks(byte[])}.
		* It tests the method with an empty byte array.
		*/
		@Test
		void testUnpacks2() {
				byte[] b = new byte[0];
				assertEquals("""", Packer.unpacks(b));
		}
		
		/**
		* Test case 3 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks3() {
				byte[] b = new byte[1];
				b[0] = (byte) 0x00;
				assertEquals(""\u0000"", Packer.unpacks(b));
		}
		
		/**
		* Test case 4 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks4() {
				byte[] b = new byte[1];
				b[0] = (byte) 0x7F;
				assertEquals(""\u007F"", Packer.unpacks(b));
		}
		
		/**
		* Test case 5 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks5() {
				byte[] b = new byte[1];
				b[0] = (byte) 0x80;
				assertEquals(""\u0080"", Packer.unpacks(b));
		}
		
		/**
		* Test case 6 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks6() {
				byte[] b = new byte[1];
				b[0] = (byte) 0xFF;
				assertEquals(""\u00FF"", Packer.unpacks(b));
		}
		
		/**
		* Test case 7 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing two bytes.
		*/
		@Test
		void testUnpacks7() {
				byte[] b = new byte[2];
				b[0] = (byte) 0xC2;
				b[1] = (byte) 0x80;
				assertEquals(""\u0080"", Packer.unpacks(b));
		}
		
		/**
		* Test case 8 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing two bytes.
		*/
		@Test
		void testUnpacks8() {
				byte[] b = new byte[2];
				b[0] = (byte) 0xDF;
				b[1] = (byte) 0xBF;
				assertEquals(""\u07FF"", Packer.unpacks(b));
		}
		
		/**
		* Test case 9 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing three bytes.
		*/
		@Test
		void testUnpacks9() {
				byte[] b = new byte[3];
				b[0] = (byte) 0xE0;
				b[1] = (byte) 0xA0;
				b[2] = (byte) 0x80;
				assertEquals(""\u0800"", Packer.unpacks(b));
		}
		
		/**
		* Test case 10 for {@link Packer#unpacks(byte[])}.
		* It tests the method with a byte array containing three bytes.
		*/
		@Test
		void testUnpacks10() {
				byte[] b = new byte[3];
				b[0] = (byte) 0xEF;
				b[1] = (byte) 0xBF;
				b[2] = (byte) 0xBF;
				assertEquals(""\uFFFF"", Packer.unpacks(b));
		}
}

// Packer_21Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#unpacks(byte[], int, int)} method.
*/
class Packer_21Test {
		
		/**
		* Test case 1 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a null byte array.
		*/
		@Test
		void testUnpacks1() {
				byte[] b = null;
				assertThrows(NullPointerException.class, () -> {
						Packer.unpacks(b, 0, 0);
				});
		}
		
		/**
		* Test case 2 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with an empty byte array.
		*/
		@Test
		void testUnpacks2() {
				byte[] b = new byte[0];
				assertEquals("""", Packer.unpacks(b, 0, 0));
		}
		
		/**
		* Test case 3 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks3() {
				byte[] b = new byte[1];
				b[0] = (byte) 0x00;
				assertEquals(""\u0000"", Packer.unpacks(b, 0, 1));
		}
		
		/**
		* Test case 4 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks4() {
				byte[] b = new byte[1];
				b[0] = (byte) 0x7F;
				assertEquals(""\u007F"", Packer.unpacks(b, 0, 1));
		}
		
		/**
		* Test case 5 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks5() {
				byte[] b = new byte[1];
				b[0] = (byte) 0x80;
				assertEquals(""\u0080"", Packer.unpacks(b, 0, 1));
		}
		
		/**
		* Test case 6 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing a single byte.
		*/
		@Test
		void testUnpacks6() {
				byte[] b = new byte[1];
				b[0] = (byte) 0xFF;
				assertEquals(""\u00FF"", Packer.unpacks(b, 0, 1));
		}
		
		/**
		* Test case 7 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing two bytes.
		*/
		@Test
		void testUnpacks7() {
				byte[] b = new byte[2];
				b[0] = (byte) 0xC2;
				b[1] = (byte) 0x80;
				assertEquals(""\u0080"", Packer.unpacks(b, 0, 2));
		}
		
		/**
		* Test case 8 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing two bytes.
		*/
		@Test
		void testUnpacks8() {
				byte[] b = new byte[2];
				b[0] = (byte) 0xDF;
				b[1] = (byte) 0xBF;
				assertEquals(""\u07FF"", Packer.unpacks(b, 0, 2));
		}
		
		/**
		* Test case 9 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing three bytes.
		*/
		@Test
		void testUnpacks9() {
				byte[] b = new byte[3];
				b[0] = (byte) 0xE0;
				b[1] = (byte) 0xA0;
				b[2] = (byte) 0x80;
				assertEquals(""\u0800"", Packer.unpacks(b, 0, 3));
		}
		
		/**
		* Test case 10 for {@link Packer#unpacks(byte[], int, int)}.
		* It tests the method with a byte array containing three bytes.
		*/
		@Test
		void testUnpacks10() {
				byte[] b = new byte[3];
				b[0] = (byte) 0xEF;
				b[1] = (byte) 0xBF;
				b[2] = (byte) 0xBF;
				assertEquals(""\uFFFF"", Packer.unpacks(b, 0, 3));
		}
}

// Packer_22Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packs(String)} method.
*/
class Packer_22Test {
		
		/**
		* Test case 1 for {@link Packer#packs(String)}.
		* It tests the method with a null string.
		*/
		@Test
		void testPacks1() {
				String s = null;
				assertThrows(NullPointerException.class, () -> {
						Packer.packs(s);
				});
		}
		
		/**
		* Test case 2 for {@link Packer#packs(String)}.
		* It tests the method with an empty string.
		*/
		@Test
		void testPacks2() {
				String s = """";
				byte[] b = Packer.packs(s);
				assertEquals(0, b.length);
		}
		
		/**
		* Test case 3 for {@link Packer#packs(String)}.
		* It tests the method with a string containing a single character.
		*/
		@Test
		void testPacks3() {
				String s = ""\u0000"";
				byte[] b = Packer.packs(s);
				assertEquals(1, b.length);
				assertEquals((byte) 0x00, b[0]);
		}
		
		/**
		* Test case 4 for {@link Packer#packs(String)}.
		* It tests the method with a string containing a single character.
		*/
		@Test
		void testPacks4() {
				String s = ""\u007F"";
				byte[] b = Packer.packs(s);
				assertEquals(1, b.length);
				assertEquals((byte) 0x7F, b[0]);
		}
		
		/**
		* Test case 5 for {@link Packer#packs(String)}.
		* It tests the method with a string containing a single character.
		*/
		@Test
		void testPacks5() {
				String s = ""\u0080"";
				byte[] b = Packer.packs(s);
				assertEquals(2, b.length);
				assertEquals((byte) 0xC2, b[0]);
				assertEquals((byte) 0x80, b[1]);
		}
		
		/**
		* Test case 6 for {@link Packer#packs(String)}.
		* It tests the method with a string containing a single character.
		*/
		@Test
		void testPacks6() {
				String s = ""\u07FF"";
				byte[] b = Packer.packs(s);
				assertEquals(2, b.length);
				assertEquals((byte) 0xDF, b[0]);
				assertEquals((byte) 0xBF, b[1]);
		}
		
		/**
		* Test case 7 for {@link Packer#packs(String)}.
		* It tests the method with a string containing a single character.
		*/
		@Test
		void testPacks7() {
				String s = ""\u0800"";
				byte[] b = Packer.packs(s);
				assertEquals(3, b.length);
				assertEquals((byte) 0xE0, b[0]);
				assertEquals((byte) 0xA0, b[1]);
				assertEquals((byte) 0x80, b[2]);
		}
		
		/**
		* Test case 8 for {@link Packer#packs(String)}.
		* It tests the method with a string containing a single character.
		*/
		@Test
		void testPacks8() {
				String s = ""\uFFFF"";
				byte[] b = Packer.packs(s);
				assertEquals(3, b.length);
				assertEquals((byte) 0xEF, b[0]);
				assertEquals((byte) 0xBF, b[1]);
				assertEquals((byte) 0xBF, b[2]);
		}
		
		/**
		* Test case 9 for {@link Packer#packs(String)}.
		* It tests the method with a string containing a single character.
		*/
		@Test
		void testPacks9() {
				String"
cmpl-6tvpuC48CW43dJ8UvJALh2buWmxpP,/EvoSuiteBenchmark/27_gangup/src/main/java/util/Packer_9Test.java,101.94720458984375,length,"// Packer.java
/* $Id: Packer.java,v 1.3 2004/04/27 19:26:22 bja Exp $
 *
 * This software is hereby placed in the public domain. You are free to do
 * whatever you want with this software. It is distributed in hope that
 * someone will find it useful but without any warranties. 
 * 
 * @author: Joel Andersson <bja@kth.se>
 * @version: $Revision: 1.3 $
 *
 */
package util;

/**
 * This class provides a set of functions for converting data types from
 * their normal representation to byte arrays.
 */
public class Packer {

    /**
     * Packs n shorts of the short array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack16v(short[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 2) {
            pack16(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n shorts of the byte array b into the specified short array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack16v(byte[] b, int s, short[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 2) {
            v[d + i] = unpack16(b, s);
        }
    }

    public static void pack16(short x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static short unpack16(byte[] b, int offset) {
        short y = 0;
        y |= ((short) b[offset++] & 0xff) << 8;
        y |= ((short) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack16(short x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 8) & 0xff);
        b[1] = (byte) ((x) & 0xff);
        return b;
    }

    public static short unpack16(byte[] b) {
        short y = 0;
        y |= ((short) b[0] & 0xff) << 8;
        y |= ((short) b[1] & 0xff);
        return y;
    }

    /**
     * Packs n integers of the integer array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack32v(int[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 4) {
            pack32(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n integers of the byte array b into the specified integer
     * array v, starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack32v(byte[] b, int s, int[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 4) {
            v[d + i] = unpack32(b, s);
        }
    }

    public static void pack32(int x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static int unpack32(byte[] b, int offset) {
        int y = 0;
        y |= ((int) b[offset++] & 0xff) << 24;
        y |= ((int) b[offset++] & 0xff) << 16;
        y |= ((int) b[offset++] & 0xff) << 8;
        y |= ((int) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack32(int x) {
        byte[] b = new byte[4];
        b[0] = (byte) ((x >> 24) & 0xff);
        b[1] = (byte) ((x >> 16) & 0xff);
        b[2] = (byte) ((x >> 8) & 0xff);
        b[3] = (byte) ((x) & 0xff);
        return b;
    }

    public static int unpack32(byte[] b) {
        int y = 0;
        y |= ((int) (b[0]) & 0xff) << 24;
        y |= ((int) (b[1]) & 0xff) << 16;
        y |= ((int) (b[2]) & 0xff) << 8;
        y |= ((int) (b[3]) & 0xff);
        return y;
    }

    /**
     * Packs n longs in the long array v into the specified byte array b,
     * starting at position s and putting result starting at d.
     *
     * @param v source array.
     * @param s source offset.
     * @param d destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void pack64v(long[] v, int s, byte[] b, int d, int n) {
        for (int i = 0; i < n; i++, d += 8) {
            pack64(v[s + i], b, d);
        }
    }

    /**
     * Unpacks n longs of the byte array b into the specified long array v,
     * starting at position s and putting result starting at d.
     *
     * @param b source array.
     * @param s source offset.
     * @param v destination array.
     * @param d destination offset.
     * @param n number of values to convert.
     */
    public static void unpack64v(byte[] b, int s, long[] v, int d, int n) {
        for (int i = 0; i < n; i++, s += 8) {
            v[d + i] = unpack64(b, s);
        }
    }

    public static void pack64(long x, byte[] b, int offset) {
        b[offset++] = (byte) ((x >> 56) & 0xff);
        b[offset++] = (byte) ((x >> 48) & 0xff);
        b[offset++] = (byte) ((x >> 40) & 0xff);
        b[offset++] = (byte) ((x >> 32) & 0xff);
        b[offset++] = (byte) ((x >> 24) & 0xff);
        b[offset++] = (byte) ((x >> 16) & 0xff);
        b[offset++] = (byte) ((x >> 8) & 0xff);
        b[offset++] = (byte) ((x) & 0xff);
    }

    public static long unpack64(byte[] b, int offset) {
        long y = 0;
        y |= ((long) b[offset++] & 0xff) << 56;
        y |= ((long) b[offset++] & 0xff) << 48;
        y |= ((long) b[offset++] & 0xff) << 40;
        y |= ((long) b[offset++] & 0xff) << 32;
        y |= ((long) b[offset++] & 0xff) << 24;
        y |= ((long) b[offset++] & 0xff) << 16;
        y |= ((long) b[offset++] & 0xff) << 8;
        y |= ((long) b[offset++] & 0xff);
        return y;
    }

    public static byte[] pack64(long x) {
        byte[] b = new byte[8];
        b[0] = (byte) ((x >> 56) & 0xff);
        b[1] = (byte) ((x >> 48) & 0xff);
        b[2] = (byte) ((x >> 40) & 0xff);
        b[3] = (byte) ((x >> 32) & 0xff);
        b[4] = (byte) ((x >> 24) & 0xff);
        b[5] = (byte) ((x >> 16) & 0xff);
        b[6] = (byte) ((x >> 8) & 0xff);
        b[7] = (byte) ((x) & 0xff);
        return b;
    }

    public static long unpack64(byte[] b) {
        long y = 0;
        y |= ((long) b[0] & 0xff) << 56;
        y |= ((long) b[1] & 0xff) << 48;
        y |= ((long) b[2] & 0xff) << 40;
        y |= ((long) b[3] & 0xff) << 32;
        y |= ((long) b[4] & 0xff) << 24;
        y |= ((long) b[5] & 0xff) << 16;
        y |= ((long) b[6] & 0xff) << 8;
        y |= ((long) b[7] & 0xff);
        return y;
    }

    /**
     * Converts the specified float to four bytes.
     * @param f the float array that is to be packed as a bytes.
     */
    public static byte[] packf(float f) {
        return pack32(Float.floatToIntBits(f));
    }

    /**
     * Converts the specified float array to an array of bytes.
     * @param fv the float array that is to be packed as a byte array.
     * @param start the offset in fv from which to start packing.
     * @param count the number of floats to pack.
     */
    public static byte[] packfv(float[] fv, int start, int count) {
        byte[] buf = new byte[count << 4];
        count += start;
        for (int i = start, j = 0; i < count; i++, j += 4) {
            pack32(Float.floatToIntBits(fv[i]), buf, j);
        }
        return buf;
    }

    /**
     * Converts the specified byte vector to an float.
     * @param b the byte data that is to be unpacked as a float.
     */
    public static float unpackf(byte[] b) {
        return Float.intBitsToFloat(unpack32(b));
    }

    /**
     * Converts the specified integer to a byte vector.
     * @param i the integer that is to be packed.
     */
    public static byte[] packi(int i) {
        return pack32(i);
    }

    /**
     * Converts the specified byte vector to an integer.
     * @param b the byte data that is to be unpacked as an integer.
     */
    public static int unpacki(byte[] b) {
        return unpack32(b);
    }

    /**
     * Converts the specified long to a byte vector.
     * @param l the long that is to be packed.
     */
    public static byte[] packl(long l) {
        return pack64(l);
    }

    /**
     * Converts the specified byte vector to a long.
     * @param b the byte data that is to be unpacked as a long.
     */
    public static long unpackl(byte[] b) {
        return unpack64(b);
    }

    /**
     * Converts the specified double to a byte vector.
     * @param d the double that is to be packed.
     */
    public static byte[] packd(double d) {
        return pack64(Double.doubleToRawLongBits(d));
    }

    /**
     * Converts the specified byte vector to an double.
     * @param b the byte data that is to be unpacked as an double.
     */
    public static double unpackd(byte[] b) {
        return Double.longBitsToDouble(unpack64(b));
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     * @param b the byte vector to put result in.
     * @param offset the offset at which to put result.
     */
    public static void packs(String s, byte[] b, int offset) {
        byte[] p = packs(s);
        System.arraycopy(p, 0, b, offset, p.length);
    }

    /**
     * Converts the specified byte vector to a string.
     * @param b the byte vector containing the packed string.
     * @param offset the offset at which to start unpacking.
     * @param length the number of bytes to convert.
     */
    public static String unpacks(byte[] b, int offset, int length) {
        try {
            return new String(b, offset, length, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified string to a byte vector.
     * @param s the string that is to be packed.
     */
    public static byte[] packs(String s) {
        try {
            return s.getBytes(""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }

    /**
     * Converts the specified byte vector to a String.
     * @param data the byte data that is to be unpacked as a String.
     */
    public static String unpacks(byte[] b) {
        try {
            return new String(b, ""UTF-8"");
        } catch (java.io.UnsupportedEncodingException e) {
            /* all jvm:s support UTF-8 */
        }
        return null;
    }
}
","// Packer_9Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packf(float)} method.
*/
class Packer_9Test {","// Packer_9Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packf(float)} method.
*/
class Packer_9Test {

	/**
	* Test case 1 for {@link Packer#packf(float)}.
	* It tests the method with a float value of 0.
	*/
	@Test
	void testPackf_1() {
		float f = 0;
		byte[] b = Packer.packf(f);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
	}
	
	/**
	* Test case 2 for {@link Packer#packf(float)}.
	* It tests the method with a float value of 1.
	*/
	@Test
	void testPackf_2() {
		float f = 1;
		byte[] b = Packer.packf(f);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(63, b[3]);
	}
	
	/**
	* Test case 3 for {@link Packer#packf(float)}.
	* It tests the method with a float value of -1.
	*/
	@Test
	void testPackf_3() {
		float f = -1;
		byte[] b = Packer.packf(f);
		assertEquals(-1, b[0]);
		assertEquals(-1, b[1]);
		assertEquals(-1, b[2]);
		assertEquals(63, b[3]);
	}
	
	/**
	* Test case 4 for {@link Packer#packf(float)}.
	* It tests the method with a float value of 0.5.
	*/
	@Test
	void testPackf_4() {
		float f = 0.5f;
		byte[] b = Packer.packf(f);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(62, b[3]);
	}
	
	/**
	* Test case 5 for {@link Packer#packf(float)}.
	* It tests the method with a float value of -0.5.
	*/
	@Test
	void testPackf_5() {
		float f = -0.5f;
		byte[] b = Packer.packf(f);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(191, b[3]);
	}
	
	/**
	* Test case 6 for {@link Packer#packf(float)}.
	* It tests the method with a float value of Float.MAX_VALUE.
	*/
	@Test
	void testPackf_6() {
		float f = Float.MAX_VALUE;
		byte[] b = Packer.packf(f);
		assertEquals(127, b[0]);
		assertEquals(127, b[1]);
		assertEquals(255, b[2]);
		assertEquals(127, b[3]);
	}
	
	/**
	* Test case 7 for {@link Packer#packf(float)}.
	* It tests the method with a float value of Float.MIN_VALUE.
	*/
	@Test
	void testPackf_7() {
		float f = Float.MIN_VALUE;
		byte[] b = Packer.packf(f);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(1, b[3]);
	}
	
	/**
	* Test case 8 for {@link Packer#packf(float)}.
	* It tests the method with a float value of Float.NaN.
	*/
	@Test
	void testPackf_8() {
		float f = Float.NaN;
		byte[] b = Packer.packf(f);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(128, b[2]);
		assertEquals(127, b[3]);
	}
	
	/**
	* Test case 9 for {@link Packer#packf(float)}.
	* It tests the method with a float value of Float.POSITIVE_INFINITY.
	*/
	@Test
	void testPackf_9() {
		float f = Float.POSITIVE_INFINITY;
		byte[] b = Packer.packf(f);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(128, b[2]);
		assertEquals(127, b[3]);
	}
	
	/**
	* Test case 10 for {@link Packer#packf(float)}.
	* It tests the method with a float value of Float.NEGATIVE_INFINITY.
	*/
	@Test
	void testPackf_10() {
		float f = Float.NEGATIVE_INFINITY;
		byte[] b = Packer.packf(f);
		assertEquals(-1, b[0]);
		assertEquals(-1, b[1]);
		assertEquals(-1, b[2]);
		assertEquals(127, b[3]);
	}
}

// Packer_10Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packd(double)} method.
*/
class Packer_10Test {
		
	/**
	* Test case 1 for {@link Packer#packd(double)}.
	* It tests the method with a double value of 0.
	*/
	@Test
	void testPackd_1() {
		double d = 0;
		byte[] b = Packer.packd(d);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
		assertEquals(0, b[4]);
		assertEquals(0, b[5]);
		assertEquals(0, b[6]);
		assertEquals(0, b[7]);
	}
	
	/**
	* Test case 2 for {@link Packer#packd(double)}.
	* It tests the method with a double value of 1.
	*/
	@Test
	void testPackd_2() {
		double d = 1;
		byte[] b = Packer.packd(d);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
		assertEquals(0, b[4]);
		assertEquals(0, b[5]);
		assertEquals(0, b[6]);
		assertEquals(63, b[7]);
	}
	
	/**
	* Test case 3 for {@link Packer#packd(double)}.
	* It tests the method with a double value of -1.
	*/
	@Test
	void testPackd_3() {
		double d = -1;
		byte[] b = Packer.packd(d);
		assertEquals(-1, b[0]);
		assertEquals(-1, b[1]);
		assertEquals(-1, b[2]);
		assertEquals(-1, b[3]);
		assertEquals(-1, b[4]);
		assertEquals(-1, b[5]);
		assertEquals(-1, b[6]);
		assertEquals(63, b[7]);
	}
	
	/**
	* Test case 4 for {@link Packer#packd(double)}.
	* It tests the method with a double value of 0.5.
	*/
	@Test
	void testPackd_4() {
		double d = 0.5;
		byte[] b = Packer.packd(d);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
		assertEquals(0, b[4]);
		assertEquals(0, b[5]);
		assertEquals(0, b[6]);
		assertEquals(62, b[7]);
	}
	
	/**
	* Test case 5 for {@link Packer#packd(double)}.
	* It tests the method with a double value of -0.5.
	*/
	@Test
	void testPackd_5() {
		double d = -0.5;
		byte[] b = Packer.packd(d);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
		assertEquals(0, b[4]);
		assertEquals(0, b[5]);
		assertEquals(0, b[6]);
		assertEquals(191, b[7]);
	}
	
	/**
	* Test case 6 for {@link Packer#packd(double)}.
	* It tests the method with a double value of Double.MAX_VALUE.
	*/
	@Test
	void testPackd_6() {
		double d = Double.MAX_VALUE;
		byte[] b = Packer.packd(d);
		assertEquals(127, b[0]);
		assertEquals(127, b[1]);
		assertEquals(-1, b[2]);
		assertEquals(-1, b[3]);
		assertEquals(-1, b[4]);
		assertEquals(-1, b[5]);
		assertEquals(-1, b[6]);
		assertEquals(127, b[7]);
	}
	
	/**
	* Test case 7 for {@link Packer#packd(double)}.
	* It tests the method with a double value of Double.MIN_VALUE.
	*/
	@Test
	void testPackd_7() {
		double d = Double.MIN_VALUE;
		byte[] b = Packer.packd(d);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
		assertEquals(0, b[4]);
		assertEquals(0, b[5]);
		assertEquals(0, b[6]);
		assertEquals(1, b[7]);
	}
	
	/**
	* Test case 8 for {@link Packer#packd(double)}.
	* It tests the method with a double value of Double.NaN.
	*/
	@Test
	void testPackd_8() {
		double d = Double.NaN;
		byte[] b = Packer.packd(d);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
		assertEquals(0, b[4]);
		assertEquals(0, b[5]);
		assertEquals(128, b[6]);
		assertEquals(127, b[7]);
	}
	
	/**
	* Test case 9 for {@link Packer#packd(double)}.
	* It tests the method with a double value of Double.POSITIVE_INFINITY.
	*/
	@Test
	void testPackd_9() {
		double d = Double.POSITIVE_INFINITY;
		byte[] b = Packer.packd(d);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
		assertEquals(0, b[4]);
		assertEquals(0, b[5]);
		assertEquals(128, b[6]);
		assertEquals(127, b[7]);
	}
	
	/**
	* Test case 10 for {@link Packer#packd(double)}.
	* It tests the method with a double value of Double.NEGATIVE_INFINITY.
	*/
	@Test
	void testPackd_10() {
		double d = Double.NEGATIVE_INFINITY;
		byte[] b = Packer.packd(d);
		assertEquals(-1, b[0]);
		assertEquals(-1, b[1]);
		assertEquals(-1, b[2]);
		assertEquals(-1, b[3]);
		assertEquals(-1, b[4]);
		assertEquals(-1, b[5]);
		assertEquals(-1, b[6]);
		assertEquals(127, b[7]);
	}
}

// Packer_11Test.java
package util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Packer}.
* It contains ten unit test cases for the {@link Packer#packi(int)} method.
*/
class Packer_11Test {
		
	/**
	* Test case 1 for {@link Packer#packi(int)}.
	* It tests the method with an integer value of 0.
	*/
	@Test
	void testPacki_1() {
		int i = 0;
		byte[] b = Packer.packi(i);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(0, b[3]);
	}
	
	/**
	* Test case 2 for {@link Packer#packi(int)}.
	* It tests the method with an integer value of 1.
	*/
	@Test
	void testPacki_2() {
		int i = 1;
		byte[] b = Packer.packi(i);
		assertEquals(0, b[0]);
		assertEquals(0, b[1]);
		assertEquals(0, b[2]);
		assertEquals(1, b[3]);
	}
	
	/**
	* Test case 3 for {@link Packer#packi(int)}.
	* It tests the method with an integer value of -1.
	*/
	@Test
	void testPacki_3() {
		int i = -1;
		byte[] b = Packer.packi(i);
		assertEquals(-1, b[0]);
		assertEquals(-1, b[1]);
		assertEquals(-1, b[2]);
		assertEquals(255, b[3]);
	}
	
	/**
	* Test case 4 for {@link Packer#packi(int)}.
	* It tests the method with an integer value of Integer.MAX_VALUE.
	*/
	@Test
	void testPacki_4() {
		int i = Integer.MAX_VALUE;
		byte[] b = Packer.packi(i);
		assertEquals("
