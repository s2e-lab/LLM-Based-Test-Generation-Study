ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6uBR4wMjvPScJ64na6AcniPJkCXJr,/EvoSuiteBenchmark/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_0Test.java,43.0900776386261,length,"// JavaSource.java
/*
 * $Id: JavaSource.java,v 1.5 2004/05/14 23:56:11 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/tools/JavaSource.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    private String packageName = null;

    private String classJavadocs = null;

    private String className = null;

    private String superClass = null;

    private String interfaceName = null;

    private List memberVariables = new ArrayList();

    private boolean hasSuperClass = false;

    private boolean isInterface = false;

    /**
     * Returns the package name for the class.
     * @return the package name for the class.
     */
    public String getPackageName() {
        return packageName;
    }

    /**
     * Allows setting the package name for the class.
     * @param packageName the package name to set.
     */
    public void setPackageName(String packageName) {
        this.packageName = packageName;
    }

    /**
     * Returns the class javadocs for this class.
     * @return the class javadocs for this class.
     */
    public String getClassJavadocs() {
        if (classJavadocs == null)
            return """";
        else
            return classJavadocs;
    }

    /**
     * Allows setting the class javadocs for this class.
     * @param classJavadocs the class level javadocs to set.
     */
    public void setClassJavadocs(String classJavadocs) {
        this.classJavadocs = classJavadocs;
    }

    /**
     * Returns the class name.
     * @return the class name.
     */
    public String getClassName() {
        return className;
    }

    /**
     * Sets the class name.
     * @param className the class name.
     */
    public void setClassName(String className) {
        this.className = className;
    }

    /**
     * Gets the superclass name for this class.
     * @return the superclass for this class.
     */
    public String getSuperClass() {
        return superClass;
    }

    /**
     * Sets the superclass name if applicable.
     * @param superClass the super class name to set.
     */
    public void setSuperClass(String superClass) {
        this.superClass = superClass;
    }

    /**
     * Gets the fully qualified interface for this class if specified,
     * @return the interface name for this class.
     */
    public String getInterface() {
        return interfaceName;
    }

    /**
     * Sets the fully qualified interface name for this class.
     * @param interfaceName the fully qualified interface name for this class.
     */
    public void setInterface(String interfaceName) {
        this.interfaceName = interfaceName;
    }

    /**
     * Returns a list of member variable objects in this class.
     * @return a list of member variable objects in this class.
     */
    public List getMemberVariables() {
        return memberVariables;
    }

    /**
     * Returns the number of member variables for this class.
     * @return the number of member variables.
     */
    public int getNumberOfMemberVariables() {
        return memberVariables.size();
    }

    /**
     * Adds a new member variable object for the class. Deduces a variable
     * name from the class name.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarClass, boolean isArray) {
        String mVarName = mVarClass.substring(mVarClass.lastIndexOf('.') + 1);
        addMemberVariable(mVarName, mVarClass, isArray);
    }

    /**
     * Adds a new member variable for the class.
     * @param mVarName the name of the member variable.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarName, String mVarClass, boolean isArray) {
        MemberVariable mv = new MemberVariable(mVarName, mVarClass, isArray);
        if (!memberVariables.contains(mv)) {
            memberVariables.add(mv);
        }
    }

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface() {
        return (this.getInterface() != null);
    }

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass() {
        return (this.getSuperClass() != null);
    }
}
","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {","// JavaSource_0Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasInterface()} method.
*/
class JavaSource_0Test {

	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with a null interface.
	*/
	@Test
	void testHasInterface_0() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(null);
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with an empty interface.
	*/
	@Test
	void testHasInterface_1() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface("""");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with a non-empty interface.
	*/
	@Test
	void testHasInterface_2() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""java.lang.Runnable"");
		assertTrue(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with a null interface.
	*/
	@Test
	void testHasInterface_3() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(null);
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with an empty interface.
	*/
	@Test
	void testHasInterface_4() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface("""");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with a non-empty interface.
	*/
	@Test
	void testHasInterface_5() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""java.lang.Runnable"");
		assertTrue(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with a null interface.
	*/
	@Test
	void testHasInterface_6() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(null);
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with an empty interface.
	*/
	@Test
	void testHasInterface_7() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface("""");
		assertFalse(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with a non-empty interface.
	*/
	@Test
	void testHasInterface_8() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(""java.lang.Runnable"");
		assertTrue(javaSource.hasInterface());
	}
	
	/**
	* Test case for {@link JavaSource#hasInterface()}.
	* This test case tests the method with a null interface.
	*/
	@Test
	void testHasInterface_9() {
		JavaSource javaSource = new JavaSource();
		javaSource.setInterface(null);
		assertFalse(javaSource.hasInterface());
	}
	
}

// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {
		
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with a null superclass.
	*/
	@Test
	void testHasSuperClass_0() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(null);
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with an empty superclass.
	*/
	@Test
	void testHasSuperClass_1() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass("""");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with a non-empty superclass.
	*/
	@Test
	void testHasSuperClass_2() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with a null superclass.
	*/
	@Test
	void testHasSuperClass_3() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(null);
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with an empty superclass.
	*/
	@Test
	void testHasSuperClass_4() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass("""");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with a non-empty superclass.
	*/
	@Test
	void testHasSuperClass_5() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with a null superclass.
	*/
	@Test
	void testHasSuperClass_6() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(null);
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with an empty superclass.
	*/
	@Test
	void testHasSuperClass_7() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass("""");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with a non-empty superclass.
	*/
	@Test
	void testHasSuperClass_8() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for {@link JavaSource#hasSuperClass()}.
	* This test case tests the method with a null superclass.
	*/
	@Test
	void testHasSuperClass_9() {
		JavaSource javaSource = new JavaSource();
	"
cmpl-6uBS7vOxG3tt7XnM815baKSUmFVNo,/EvoSuiteBenchmark/84_ifx-framework/src/main/java/org/sourceforge/ifx/tools/JavaSource_1Test.java,19.12738871574402,,"// JavaSource.java
/*
 * $Id: JavaSource.java,v 1.5 2004/05/14 23:56:11 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/tools/JavaSource.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;

/**
 * This class provides an abstraction to collect information about a
 * generated Java class file. Its toString() method will produce a String
 * that can be written using a Writer object to persistent store.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.5 $
 */
public class JavaSource {

    private String packageName = null;

    private String classJavadocs = null;

    private String className = null;

    private String superClass = null;

    private String interfaceName = null;

    private List memberVariables = new ArrayList();

    private boolean hasSuperClass = false;

    private boolean isInterface = false;

    /**
     * Returns the package name for the class.
     * @return the package name for the class.
     */
    public String getPackageName() {
        return packageName;
    }

    /**
     * Allows setting the package name for the class.
     * @param packageName the package name to set.
     */
    public void setPackageName(String packageName) {
        this.packageName = packageName;
    }

    /**
     * Returns the class javadocs for this class.
     * @return the class javadocs for this class.
     */
    public String getClassJavadocs() {
        if (classJavadocs == null)
            return """";
        else
            return classJavadocs;
    }

    /**
     * Allows setting the class javadocs for this class.
     * @param classJavadocs the class level javadocs to set.
     */
    public void setClassJavadocs(String classJavadocs) {
        this.classJavadocs = classJavadocs;
    }

    /**
     * Returns the class name.
     * @return the class name.
     */
    public String getClassName() {
        return className;
    }

    /**
     * Sets the class name.
     * @param className the class name.
     */
    public void setClassName(String className) {
        this.className = className;
    }

    /**
     * Gets the superclass name for this class.
     * @return the superclass for this class.
     */
    public String getSuperClass() {
        return superClass;
    }

    /**
     * Sets the superclass name if applicable.
     * @param superClass the super class name to set.
     */
    public void setSuperClass(String superClass) {
        this.superClass = superClass;
    }

    /**
     * Gets the fully qualified interface for this class if specified,
     * @return the interface name for this class.
     */
    public String getInterface() {
        return interfaceName;
    }

    /**
     * Sets the fully qualified interface name for this class.
     * @param interfaceName the fully qualified interface name for this class.
     */
    public void setInterface(String interfaceName) {
        this.interfaceName = interfaceName;
    }

    /**
     * Returns a list of member variable objects in this class.
     * @return a list of member variable objects in this class.
     */
    public List getMemberVariables() {
        return memberVariables;
    }

    /**
     * Returns the number of member variables for this class.
     * @return the number of member variables.
     */
    public int getNumberOfMemberVariables() {
        return memberVariables.size();
    }

    /**
     * Adds a new member variable object for the class. Deduces a variable
     * name from the class name.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarClass, boolean isArray) {
        String mVarName = mVarClass.substring(mVarClass.lastIndexOf('.') + 1);
        addMemberVariable(mVarName, mVarClass, isArray);
    }

    /**
     * Adds a new member variable for the class.
     * @param mVarName the name of the member variable.
     * @param mVarClass the class name for the member variable.
     * @param isArray if the member variable type is an array.
     */
    public void addMemberVariable(String mVarName, String mVarClass, boolean isArray) {
        MemberVariable mv = new MemberVariable(mVarName, mVarClass, isArray);
        if (!memberVariables.contains(mv)) {
            memberVariables.add(mv);
        }
    }

    /**
     * Convenience methods since velocity does not understand the conditional
     * ""== null"". Returns true if this class implements an interface.
     * @return true if this class implements an interface else false.
     */
    public boolean hasInterface() {
        return (this.getInterface() != null);
    }

    /**
     * Convenience method since velocity does not understand the conditional
     * ""== null"". Returns true if this class inherits from a superclass.
     * @return true if this class has a superclass, else false.
     */
    public boolean hasSuperClass() {
        return (this.getSuperClass() != null);
    }
}
","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {","// JavaSource_1Test.java
package org.sourceforge.ifx.tools;

import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.StringTokenizer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JavaSource}.
* It contains ten unit test cases for the {@link JavaSource#hasSuperClass()} method.
*/
class JavaSource_1Test {

	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a null superclass.
	*/
	@Test
	void testHasSuperClass_1() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(null);
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with an empty superclass.
	*/
	@Test
	void testHasSuperClass_2() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass("""");
		assertFalse(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_3() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_4() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_5() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_6() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_7() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_8() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_9() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
	/**
	* Test case for the {@link JavaSource#hasSuperClass()} method.
	* This test case tests the method with a superclass.
	*/
	@Test
	void testHasSuperClass_10() {
		JavaSource javaSource = new JavaSource();
		javaSource.setSuperClass(""java.lang.Object"");
		assertTrue(javaSource.hasSuperClass());
	}
	
}"
cmpl-6uBTAD8u8GZnL5fcpTRzey1ZxpkG3,/EvoSuiteBenchmark/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDecoder.java,46.810636043548584,length,"// IFXDecoder.java
/*
 * $Id: IFXDecoder.java,v 1.3 2004/03/05 02:17:24 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/utils/IFXDecoder.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;

/**
 * Decodes an IFX XML String to its equivalent Framework bean.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.3 $
 */
public class IFXDecoder {

    private ResourceBundle bundle;

    /**
     * Creates an IFXDecoder object.
     */
    public IFXDecoder() {
        try {
            bundle = ResourceBundle.getBundle(""org.sourceforge.ifx.framework.elementmap"");
        } catch (MissingResourceException e) {
            e.printStackTrace();
            // :NOTE: should never happen
        }
    }

    /**
     * Decodes the element into its equivalent IFX XML representation.
     * @param element the Element to decode.
     * @return an IFXObject.
     * @exception IFXException wrapper for underlying exception.
     */
    public IFXObject decode(Element element) throws IFXException {
        try {
            String id = element.getAttributeValue(""Id"");
            String beanClassName = getBeanClassName(element);
            IFXObject obj = (IFXObject) Class.forName(beanClassName).newInstance();
            List children = element.getChildren();
            if (children.size() == 0) {
                String text = element.getText();
                if (text != null && text.trim().length() > 0) {
                    if (!(obj instanceof IBaseType)) {
                        throw new IFXException(""Leaf node not an instance of IBaseType: "" + obj.getClass().getName());
                    } else {
                        ((IBaseType) obj).setString(text);
                        return obj;
                    }
                } else {
                    // return the empty object
                    return obj;
                }
            } else {
                Iterator childIter = children.iterator();
                while (childIter.hasNext()) {
                    Element childElement = (Element) childIter.next();
                    IFXObject childObj = decode(childElement);
                    // run corresponding accessor method to see if the
                    // result is an array
                    Method accessorMethod = getAccessor(obj, childElement);
                    Object retValObj = accessorMethod.invoke(obj, null);
                    boolean isArray = accessorMethod.getReturnType().isArray();
                    // then get the mutator method and invoke it
                    Method mutatorMethod = getMutator(obj, childElement);
                    if (isArray) {
                        // if result is an array, build a new array with
                        // size = returned array size + 1, and stuff this
                        // object at the end of the array
                        IFXObject[] childObjs = null;
                        if (retValObj != null) {
                            int oldLen = Array.getLength(retValObj);
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { oldLen + 1 });
                            IFXObject[] retValObjs = (IFXObject[]) retValObj;
                            System.arraycopy(retValObj, 0, childObjs, 0, oldLen);
                            childObjs[oldLen] = childObj;
                        } else {
                            childObjs = (IFXObject[]) Array.newInstance(childObj.getClass(), new int[] { 1 });
                            childObjs[0] = childObj;
                        }
                        mutatorMethod.invoke(obj, new Object[] { childObjs });
                    } else {
                        mutatorMethod.invoke(obj, new Object[] { childObj });
                    }
                }
                // if Id attribute is specified, populate it
                if (id != null) {
                    Method mutatorMethod = getMutator(obj, ""Id"");
                    IFXString idObj = new IFXString();
                    idObj.setString(id);
                    mutatorMethod.invoke(obj, new Object[] { idObj });
                }
                return obj;
            }
        } catch (Exception e) {
            throw new IFXException(""Error decoding "" + element.getName(), e);
        }
    }

    /**
     * Returns a single setXXX Method object corresponding to the IFXObject
     * and childElement.
     * @param obj the IFXObject.
     * @param childElement the element corresponding to the mutator method.
     * @return a setXXX method object.
     * @exception IFXException if there was a problem getting the mutators.
     */
    private Method getMutator(IFXObject obj, Element childElement) throws IFXException {
        String childElementName = childElement.getName();
        return getMutator(obj, childElementName);
    }

    /**
     * Returns a single setXXX Method object corresponding to the IFXObject
     * and childElement name.
     * @param obj the IFXObject.
     * @param childElementName the element name for the mutator method.
     * @return a setXXX method object.
     * @exception IFXException if there was a problem getting the mutators.
     */
    private Method getMutator(IFXObject obj, String elementName) throws IFXException {
        try {
            // handle element names like USA.MilitaryRank or EU.Cur
            if (elementName.indexOf('.') > -1) {
                elementName = elementName.replace('.', '_');
            }
            String setterName = ""set"" + elementName;
            Class cl = obj.getClass();
            Method[] methods = cl.getMethods();
            boolean foundMethod = false;
            for (int i = 0; i < methods.length; i++) {
                if (methods[i].getName().equals(setterName)) {
                    foundMethod = true;
                    return methods[i];
                } else {
                    continue;
                }
            }
            // if we are here, then we did not get the method
            if (!foundMethod) {
                throw new IFXException(""Could not find method: "" + obj.getClass().getName() + ""#set"" + elementName);
            }
        } catch (Exception e) {
            throw new IFXException(""Exception getting Mutator Method: "" + obj.getClass().getName() + ""#set"" + elementName, e);
        }
        return null;
    }

    /**
     * Returns the accessor method associated with the given element name.
     * @param obj an IFXObject.
     * @param element the element object.
     * @return a getXXX Method object associated with the element.
     * @exception IFXException wraps the original exception thrown.
     */
    private Method getAccessor(IFXObject obj, Element element) throws IFXException {
        try {
            String elementName = element.getName();
            // handle element names like USA.MilitaryRank or EU.Cur
            if (elementName.indexOf('.') > -1) {
                elementName = elementName.replace('.', '_');
            }
            String getterName = ""get"" + elementName;
            Class cl = obj.getClass();
            Method[] allMethods = cl.getMethods();
            Method accessorMethod = null;
            for (int i = 0; i < allMethods.length; i++) {
                if (allMethods[i].getName().equals(getterName)) {
                    accessorMethod = allMethods[i];
                    break;
                }
            }
            return accessorMethod;
        } catch (Exception e) {
            throw new IFXException(""Exception getting Accessor"", e);
        }
    }

    /**
     * Returns the element name from a bean name.
     * @param element the Element representing the bean.
     * @return the element name.
     * @exception IFXException if bean class name could not be found.
     */
    private String getBeanClassName(Element element) throws IFXException {
        String beanClassName = bundle.getString(element.getName());
        if (beanClassName == null) {
            throw new IFXException(""No bean class found for: "" + element.getName());
        }
        return beanClassName;
    }
}
","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains ten unit test cases for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {","// IFXDecoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Method;
import java.util.List;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IFXString;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDecoder}.
* It contains ten unit test cases for the {@link IFXDecoder#decode(Element)} method.
*/
class IFXDecoderTest {

	/**
	* Test case for {@link IFXDecoder#decode(Element)} method.
	* It tests the decoding of an element with no children.
	*/
	@Test
	void testDecodeElementWithNoChildren() throws Exception {
		Element element = new Element(""IFX"");
		IFXDecoder decoder = new IFXDecoder();
		IFXObject ifxObject = decoder.decode(element);
		assertEquals(""org.sourceforge.ifx.framework.IFX"", ifxObject.getClass().getName());
	}
	
	/**
	* Test case for {@link IFXDecoder#decode(Element)} method.
	* It tests the decoding of an element with one child.
	*/
	@Test
	void testDecodeElementWithOneChild() throws Exception {
		Element element = new Element(""IFX"");
		Element childElement = new Element(""SignonRq"");
		element.addContent(childElement);
		IFXDecoder decoder = new IFXDecoder();
		IFXObject ifxObject = decoder.decode(element);
		assertEquals(""org.sourceforge.ifx.framework.IFX"", ifxObject.getClass().getName());
		Method accessorMethod = getAccessor(ifxObject, childElement);
		Object retValObj = accessorMethod.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.SignonRq"", retValObj.getClass().getName());
	}
	
	/**
	* Test case for {@link IFXDecoder#decode(Element)} method.
	* It tests the decoding of an element with two children.
	*/
	@Test
	void testDecodeElementWithTwoChildren() throws Exception {
		Element element = new Element(""IFX"");
		Element childElement1 = new Element(""SignonRq"");
		Element childElement2 = new Element(""SignonRs"");
		element.addContent(childElement1);
		element.addContent(childElement2);
		IFXDecoder decoder = new IFXDecoder();
		IFXObject ifxObject = decoder.decode(element);
		assertEquals(""org.sourceforge.ifx.framework.IFX"", ifxObject.getClass().getName());
		Method accessorMethod1 = getAccessor(ifxObject, childElement1);
		Object retValObj1 = accessorMethod1.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.SignonRq"", retValObj1.getClass().getName());
		Method accessorMethod2 = getAccessor(ifxObject, childElement2);
		Object retValObj2 = accessorMethod2.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.SignonRs"", retValObj2.getClass().getName());
	}
	
	/**
	* Test case for {@link IFXDecoder#decode(Element)} method.
	* It tests the decoding of an element with three children.
	*/
	@Test
	void testDecodeElementWithThreeChildren() throws Exception {
		Element element = new Element(""IFX"");
		Element childElement1 = new Element(""SignonRq"");
		Element childElement2 = new Element(""SignonRs"");
		Element childElement3 = new Element(""BankingRq"");
		element.addContent(childElement1);
		element.addContent(childElement2);
		element.addContent(childElement3);
		IFXDecoder decoder = new IFXDecoder();
		IFXObject ifxObject = decoder.decode(element);
		assertEquals(""org.sourceforge.ifx.framework.IFX"", ifxObject.getClass().getName());
		Method accessorMethod1 = getAccessor(ifxObject, childElement1);
		Object retValObj1 = accessorMethod1.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.SignonRq"", retValObj1.getClass().getName());
		Method accessorMethod2 = getAccessor(ifxObject, childElement2);
		Object retValObj2 = accessorMethod2.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.SignonRs"", retValObj2.getClass().getName());
		Method accessorMethod3 = getAccessor(ifxObject, childElement3);
		Object retValObj3 = accessorMethod3.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.BankingRq"", retValObj3.getClass().getName());
	}
	
	/**
	* Test case for {@link IFXDecoder#decode(Element)} method.
	* It tests the decoding of an element with four children.
	*/
	@Test
	void testDecodeElementWithFourChildren() throws Exception {
		Element element = new Element(""IFX"");
		Element childElement1 = new Element(""SignonRq"");
		Element childElement2 = new Element(""SignonRs"");
		Element childElement3 = new Element(""BankingRq"");
		Element childElement4 = new Element(""BankingRs"");
		element.addContent(childElement1);
		element.addContent(childElement2);
		element.addContent(childElement3);
		element.addContent(childElement4);
		IFXDecoder decoder = new IFXDecoder();
		IFXObject ifxObject = decoder.decode(element);
		assertEquals(""org.sourceforge.ifx.framework.IFX"", ifxObject.getClass().getName());
		Method accessorMethod1 = getAccessor(ifxObject, childElement1);
		Object retValObj1 = accessorMethod1.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.SignonRq"", retValObj1.getClass().getName());
		Method accessorMethod2 = getAccessor(ifxObject, childElement2);
		Object retValObj2 = accessorMethod2.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.SignonRs"", retValObj2.getClass().getName());
		Method accessorMethod3 = getAccessor(ifxObject, childElement3);
		Object retValObj3 = accessorMethod3.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.BankingRq"", retValObj3.getClass().getName());
		Method accessorMethod4 = getAccessor(ifxObject, childElement4);
		Object retValObj4 = accessorMethod4.invoke(ifxObject, null);
		assertEquals(""org.sourceforge.ifx.framework.BankingRs"", retValObj4.getClass().getName());
	}
	
	/**
	* Test case for {@link IFXDecoder#decode(Element)} method.
	* It tests the decoding of an element with five children.
	*/
	@Test
	void testDecodeElementWithFiveChildren() throws Exception {
		Element element = new Element(""IFX"");
		Element childElement1 = new Element(""SignonRq"");
		Element childElement2 = new Element(""SignonRs"");
		Element childElement3 = new Element(""BankingRq"");
		Element childElement4 = new Element(""BankingRs"");
		Element childElement5 = new Element(""BankingSvcRq"");
		element.addContent(childElement1);
		element.addContent(childElement2);
		element.addContent(childElement3);
		element.addContent(childElement4);
		element.addContent(childElement5);
		IFXDecoder decoder = new IFXDecoder();
		IFXObject ifxObject = decoder.decode(element);
		assertEquals(""org.sourceforge.ifx.framework.IFX"", ifxObject.getClass().getName());
"
cmpl-6uBUDyqLwCsux2hlvxx1lCg8UC5I7,/EvoSuiteBenchmark/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_0Test.java,40.46163892745972,length,"// IFXDocumentHandler.java
/*
 * $Id: IFXDocumentHandler.java,v 1.2 2004/02/26 17:50:30 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/utils/IFXDocumentHandler.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException {
        IFXEncoder encoder = null;
        if (namespaceURI != null) {
            encoder = new IFXEncoder(namespacePrefix, namespaceURI);
        } else {
            encoder = new IFXEncoder();
        }
        Element element = encoder.encode(obj);
        Document doc = new Document(element);
        return doc;
    }

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException {
        XMLOutputter outputter = new XMLOutputter();
        StringBuffer indent = new StringBuffer();
        for (int i = 0; i < indentSize; i++) {
            indent.append("" "");
        }
        outputter.setIndent(indent.toString());
        if (lineSeparator == null) {
            outputter.setNewlines(false);
        } else {
            outputter.setNewlines(true);
            outputter.setLineSeparator(lineSeparator);
        }
        try {
            outputter.output(doc, ostream);
        } catch (IOException e) {
            throw new IFXException(""Error writing Document"");
        }
    }

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException {
        Element element = doc.getRootElement();
        IFXDecoder decoder = new IFXDecoder();
        return decoder.decode(element);
    }

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException {
        SAXBuilder builder = null;
        if (validate) {
            builder = new SAXBuilder(""org.apache.xerces.parsers.SAXParser"", true);
            builder.setFeature(""http://apache.org/xml/features/validation/schema"", true);
            if (validationProperties != null) {
                Iterator propIter = validationProperties.keySet().iterator();
                StringBuffer buf = new StringBuffer();
                int i = 0;
                while (propIter.hasNext()) {
                    String key = (String) propIter.next();
                    String value = (String) validationProperties.get(key);
                    if (i > 0) {
                        buf.append("" "");
                    }
                    buf.append(key).append("" "").append(value);
                    i++;
                }
                builder.setProperty(""http://apache.org/xml/properties/schema/external-schemaLocation"", buf.toString());
            }
        } else {
            builder = new SAXBuilder();
        }
        Document doc = null;
        try {
            doc = builder.build(istream);
        } catch (Exception e) {
            throw new IFXException(""Error reading Document"", e);
        }
        return doc;
    }
}
","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {","// IFXDocumentHandler_0Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_0Test {

	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_0() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_1() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_2() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_3() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_4() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_5() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_6() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_7() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_8() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild_9() throws IFXException {
		IFXObject obj = new IFXObject();
		String namespacePrefix = """";
		String namespaceURI = """";
		Document result = IFXDocumentHandler.build(obj, namespacePrefix, namespaceURI);
		assertNotNull(result);
	}
	
}

// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
*/
class IFXDocumentHandler_1Test {
		
	/**
	* Test case for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite_0() throws IFXException {
		Document doc = new Document();
		int indentSize = 0;
		String lineSeparator = """";
		OutputStream ostream = new OutputStream() {
			public void write(int b) throws IOException {
			}
		};
		IFXDocumentHandler.write(doc, indentSize, lineSeparator, ostream);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite_1() throws IFXException {
		Document doc = new Document();
		int indentSize = 0;
		String lineSeparator = """";
		OutputStream ostream = new OutputStream() {
			public void write(int b) throws IOException {
			}
		};
		IFXDocumentHandler.write(doc, indentSize, lineSeparator, ostream);
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite_2() throws IFXException {
		Document doc = new Document"
cmpl-6uBVGLNI2donreDXE2WFk4KGNbaUq,/EvoSuiteBenchmark/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_1Test.java,46.18583679199219,length,"// IFXDocumentHandler.java
/*
 * $Id: IFXDocumentHandler.java,v 1.2 2004/02/26 17:50:30 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/utils/IFXDocumentHandler.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException {
        IFXEncoder encoder = null;
        if (namespaceURI != null) {
            encoder = new IFXEncoder(namespacePrefix, namespaceURI);
        } else {
            encoder = new IFXEncoder();
        }
        Element element = encoder.encode(obj);
        Document doc = new Document(element);
        return doc;
    }

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException {
        XMLOutputter outputter = new XMLOutputter();
        StringBuffer indent = new StringBuffer();
        for (int i = 0; i < indentSize; i++) {
            indent.append("" "");
        }
        outputter.setIndent(indent.toString());
        if (lineSeparator == null) {
            outputter.setNewlines(false);
        } else {
            outputter.setNewlines(true);
            outputter.setLineSeparator(lineSeparator);
        }
        try {
            outputter.output(doc, ostream);
        } catch (IOException e) {
            throw new IFXException(""Error writing Document"");
        }
    }

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException {
        Element element = doc.getRootElement();
        IFXDecoder decoder = new IFXDecoder();
        return decoder.decode(element);
    }

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException {
        SAXBuilder builder = null;
        if (validate) {
            builder = new SAXBuilder(""org.apache.xerces.parsers.SAXParser"", true);
            builder.setFeature(""http://apache.org/xml/features/validation/schema"", true);
            if (validationProperties != null) {
                Iterator propIter = validationProperties.keySet().iterator();
                StringBuffer buf = new StringBuffer();
                int i = 0;
                while (propIter.hasNext()) {
                    String key = (String) propIter.next();
                    String value = (String) validationProperties.get(key);
                    if (i > 0) {
                        buf.append("" "");
                    }
                    buf.append(key).append("" "").append(value);
                    i++;
                }
                builder.setProperty(""http://apache.org/xml/properties/schema/external-schemaLocation"", buf.toString());
            }
        } else {
            builder = new SAXBuilder();
        }
        Document doc = null;
        try {
            doc = builder.build(istream);
        } catch (Exception e) {
            throw new IFXException(""Error reading Document"", e);
        }
        return doc;
    }
}
","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {","// IFXDocumentHandler_1Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#parse(Document)} method.
*/
class IFXDocumentHandler_1Test {

	/**
	* Test case for {@link IFXDocumentHandler#parse(Document)} method.
	* @throws IFXException if any problems were encountered in parsing.
	*/
	@Test
	void testParse() throws IFXException {
		IFXDocumentHandler ifxDocumentHandler = new IFXDocumentHandler();
		IFXObject ifxObject = ifxDocumentHandler.parse(new Document());
		assertNotNull(ifxObject);
	}
}

// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
*/
class IFXDocumentHandler_2Test {
		
	/**
	* Test case for {@link IFXDocumentHandler#build(IFXObject, String, String)} method.
	* @throws IFXException if there was a problem building the document.
	*/
	@Test
	void testBuild() throws IFXException {
		IFXDocumentHandler ifxDocumentHandler = new IFXDocumentHandler();
		Document doc = ifxDocumentHandler.build(new IFXObject(), """", """");
		assertNotNull(doc);
	}
}

// IFXDocumentHandler_3Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
*/
class IFXDocumentHandler_3Test {
		
	/**
	* Test case for {@link IFXDocumentHandler#write(Document, int, String, OutputStream)} method.
	* @throws IFXException if there was a problem writing the Document.
	*/
	@Test
	void testWrite() throws IFXException {
		IFXDocumentHandler ifxDocumentHandler = new IFXDocumentHandler();
		ifxDocumentHandler.write(new Document(), 0, """", new OutputStream() {
			public void write(int b) throws IOException {
			}
		});
	}
}

// IFXDocumentHandler_4Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_4Test {
		
	/**
	* Test case for {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* @throws IFXException if there was a problem reading the document.
	*/
	@Test
	void testRead() throws IFXException {
		IFXDocumentHandler ifxDocumentHandler = new IFXDocumentHandler();
		Document doc = ifxDocumentHandler.read(new InputStream() {
			public int read() throws IOException {
				return 0;
			}
		}, false, new Map() {
			public int size() {
				return 0;
			}
			public boolean isEmpty() {
				return false;
			}
			public boolean containsKey(Object key) {
				return false;
			}
			public boolean containsValue(Object value) {
				return false;
			}
			public Object get(Object key) {
				return null;
			}
			public Object put(Object key, Object value) {
				return null;
			}
			public Object remove(Object key) {
				return null;
			}
			public void putAll(Map t) {
			}
			public void clear() {
			}
			public Set keySet() {
				return null;
			}
			public Collection values() {
				return null;
			}
			public Set entrySet() {
				return null;
			}
		});
		assertNotNull(doc);
	}
}

// IFXDecoder.java
/*
 * $Id: IFXDecoder.java,v 1.2 2004/02/26 17:50:30 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/utils/IFXDecoder.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.utils;

import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.StringTokenizer;
import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.Attribute;
import org.jdom.Text;
import org.jdom.Comment;
import org.jdom.CDATA;
import org.jdom.ProcessingInstruction;
import org.jdom.EntityRef;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org"
cmpl-6uBWJAzZjNWOzvR8vAegvPPwhWmQs,/EvoSuiteBenchmark/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXDocumentHandler_2Test.java,47.99309778213501,length,"// IFXDocumentHandler.java
/*
 * $Id: IFXDocumentHandler.java,v 1.2 2004/02/26 17:50:30 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/utils/IFXDocumentHandler.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;

/**
 * The IFXDocumentHandler provides methods for formatting and validating
 * IFX XML Documents.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXDocumentHandler {

    /**
     * System default Line separator string.
     */
    public static final String DEFAULT_LINE_SEPARATOR = System.getProperty(""line.separator"");

    /**
     * Builds a JDOM Document object from an IFXObject.
     * @param obj the IFXObject object to format.
     * @param namespacePrefix the namespace prefix to use in the output. A
     * value of null implies no prefix. If the namespaceURI is specified it
     * will be treated as the default namespace.
     * @param namespaceURI the namespace URI to use in the output. If specified
     * an xmlns declaration will be prepended to the output.
     * @return a JDOM Document object.
     * @exception IFXException if there was a problem building the document.
     */
    public static Document build(IFXObject obj, String namespacePrefix, String namespaceURI) throws IFXException {
        IFXEncoder encoder = null;
        if (namespaceURI != null) {
            encoder = new IFXEncoder(namespacePrefix, namespaceURI);
        } else {
            encoder = new IFXEncoder();
        }
        Element element = encoder.encode(obj);
        Document doc = new Document(element);
        return doc;
    }

    /**
     * Writes a Document object to the specified output stream.
     * @param doc a JDOM Document object.
     * @param indentSize the size of the indent in the output. A value of
     * zero implies no indentation.
     * @param lineSeparator the line separator for the output. A value of
     * null implies no line separators and no newlines in the output. To use
     * the system default, use DEFAULT_LINE_SEPARATOR.
     * @param ostream the OutputStream to write the formatted output to.
     * @exception IFXException if there was a problem writing the Document.
     */
    public static void write(Document doc, int indentSize, String lineSeparator, OutputStream ostream) throws IFXException {
        XMLOutputter outputter = new XMLOutputter();
        StringBuffer indent = new StringBuffer();
        for (int i = 0; i < indentSize; i++) {
            indent.append("" "");
        }
        outputter.setIndent(indent.toString());
        if (lineSeparator == null) {
            outputter.setNewlines(false);
        } else {
            outputter.setNewlines(true);
            outputter.setLineSeparator(lineSeparator);
        }
        try {
            outputter.output(doc, ostream);
        } catch (IOException e) {
            throw new IFXException(""Error writing Document"");
        }
    }

    /**
     * Parses a Document object into an IFXObject. This is a thin wrapper
     * over the IFXDecoder.decode() method.
     * @param doc the JDOM Document object to parse.
     * @exception IFXException if any problems were encountered in parsing.
     */
    public static IFXObject parse(Document doc) throws IFXException {
        Element element = doc.getRootElement();
        IFXDecoder decoder = new IFXDecoder();
        return decoder.decode(element);
    }

    /**
     * Reads an XML stream from the specified InputStream and returns a
     * JDOM Document object. If validation is requested, then the XML is
     * validated while reading it into a Document.
     * @param istream the InputStream to read from.
     * @param validate XML is validated against schema if true.
     * @param validationProperties a Map of name value pairs specifying
     * the schema and the namespaces to validate against.
     * @exception IFXExveption if there was a problem reading the document.
     */
    public static Document read(InputStream istream, boolean validate, Map validationProperties) throws IFXException {
        SAXBuilder builder = null;
        if (validate) {
            builder = new SAXBuilder(""org.apache.xerces.parsers.SAXParser"", true);
            builder.setFeature(""http://apache.org/xml/features/validation/schema"", true);
            if (validationProperties != null) {
                Iterator propIter = validationProperties.keySet().iterator();
                StringBuffer buf = new StringBuffer();
                int i = 0;
                while (propIter.hasNext()) {
                    String key = (String) propIter.next();
                    String value = (String) validationProperties.get(key);
                    if (i > 0) {
                        buf.append("" "");
                    }
                    buf.append(key).append("" "").append(value);
                    i++;
                }
                builder.setProperty(""http://apache.org/xml/properties/schema/external-schemaLocation"", buf.toString());
            }
        } else {
            builder = new SAXBuilder();
        }
        Document doc = null;
        try {
            doc = builder.build(istream);
        } catch (Exception e) {
            throw new IFXException(""Error reading Document"", e);
        }
        return doc;
    }
}
","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {","// IFXDocumentHandler_2Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.input.SAXBuilder;
import org.jdom.output.XMLOutputter;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXDocumentHandler}.
* It contains ten unit test cases for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
*/
class IFXDocumentHandler_2Test {

	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is null.
	*/
	@Test
	void testRead_1() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_2() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_3() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_4() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_5() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_6() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_7() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_8() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_9() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
	
	/**
	* Test case for the {@link IFXDocumentHandler#read(InputStream, boolean, Map)} method.
	* It tests the case when the input stream is not null.
	*/
	@Test
	void testRead_10() {
		InputStream istream = null;
		boolean validate = false;
		Map validationProperties = null;
		try {
			IFXDocumentHandler.read(istream, validate, validationProperties);
			fail(""Expected an IOException to be thrown"");
		} catch (IOException e) {
			assertEquals(""Error reading Document"", e.getMessage());
		} catch (Exception e) {
			fail(""Expected an IOException to be thrown"");
		}
	}
}

// IFXDocumentHandler_3Test.java
package org.sourceforge.ifx.utils;

import java.io.OutputStream;
import java.io.InputStream;
import java.io.IOException;
import java.util.Map;
import java.util.Iterator;
import org.jdom.Document;
import org."
cmpl-6uBXMJpMy1mN2Od0wq0CKaBfWTp41,/EvoSuiteBenchmark/84_ifx-framework/src/main/java/org/sourceforge/ifx/utils/IFXEncoder.java,47.41305136680603,length,"// IFXEncoder.java
/*
 * $Id: IFXEncoder.java,v 1.2 2004/03/05 02:17:24 spal Exp $
 * $Source: /cvsroot/ifx-framework/code/src/org/sourceforge/ifx/utils/IFXEncoder.java,v $
 * IFX-Framework - IFX XML to JavaBean application framework.
 * Copyright (C) 2003  The IFX-Framework Team
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;

/**
 * Encodes an IFXObject to its equivalent IFX XML Element.
 * @author Sujit Pal (spal@users.sourceforge.net)
 * @version $Revision: 1.2 $
 */
public class IFXEncoder {

    private ResourceBundle bundle;

    private int xmlIndentSize = 2;

    private String lineSeparator = System.getProperty(""line.separator"");

    private Namespace namespace = Namespace.NO_NAMESPACE;

    /**
     * Creates an IFXEncoder object in the default namespace.
     */
    public IFXEncoder() {
        try {
            bundle = ResourceBundle.getBundle(""org.sourceforge.ifx.framework.beanmap"");
        } catch (MissingResourceException e) {
            e.printStackTrace();
            // :NOTE: should never happen
        }
    }

    /**
     * Creates an IFXEncoder in the specified namespace.
     * @param namespacePrefix the namespace prefix to use. If set to null,
     * then the element will be considered to be in the default namespace.
     * @param namespaceURI the URI of the namespace.
     */
    public IFXEncoder(String namespacePrefix, String namespaceURI) {
        this();
        this.setNamespace(namespacePrefix, namespaceURI);
    }

    /**
     * Builds a JDOM Element for the IFXObject supplied. No validation is
     * performed, regardless of the setting. To validate, use the encode()
     * methods instead.
     * @param obj an IFXObject.
     * @return a JDOM Element.
     * @exception IFXException if an exception was encountered in encoding.
     */
    public Element encode(IFXObject obj) throws IFXException {
        try {
            Element element = new Element(getElementName(obj), namespace);
            List accessorList = getAccessors(obj);
            Iterator accessorIter = accessorList.iterator();
            while (accessorIter.hasNext()) {
                Method accessorMethod = (Method) accessorIter.next();
                if (accessorMethod.getName().equals(""getClass"")) {
                    continue;
                }
                Object retValObj = accessorMethod.invoke(obj, null);
                if (retValObj == null) {
                    continue;
                }
                IFXObject[] retVals = new IFXObject[1];
                if (retValObj.getClass().isArray()) {
                    retVals = (IFXObject[]) retValObj;
                } else {
                    retVals[0] = (IFXObject) retValObj;
                }
                for (int i = 0; i < retVals.length; i++) {
                    IFXObject retVal = retVals[i];
                    if (retVal instanceof IBaseType) {
                        String value = ((IBaseType) retVal).getString();
                        if (accessorMethod.getName().equals(""getId"")) {
                            element.setAttribute(""Id"", value);
                        } else {
                            Element baseElement = new Element(getElementName(retVal), namespace);
                            baseElement.setText(value);
                            element.addContent(baseElement);
                        }
                    } else {
                        element.addContent(encode(retVal));
                    }
                }
            }
            return element;
        } catch (Exception e) {
            throw new IFXException(""Error encoding "" + obj.getClass().getName(), e);
        }
    }

    /**
     * Sets the name space for this Document.
     * @param prefix the namespace prefix to use. If null, this namespace
     * will be set to the default namespace.
     * @param nameSpaceURI the String URI of this namespace.
     */
    private void setNamespace(String prefix, String nameSpaceURI) {
        if (prefix == null) {
            this.namespace = Namespace.getNamespace(nameSpaceURI);
        } else {
            this.namespace = Namespace.getNamespace(prefix, nameSpaceURI);
        }
    }

    /**
     * Return a List of accessor methods for a given IFXObject. The
     * accessors will be ordered in the same order expected by the IFX
     * schema. This ordering is dictated by the ELEMENTS String[] variable.
     * @param obj an IFXObject.
     * @return a List of getXXX Method objects.
     * @exception IFXException wraps the original exception thrown.
     */
    private List getAccessors(IFXObject obj) throws IFXException {
        try {
            Class cl = obj.getClass();
            Method[] allMethods = cl.getMethods();
            Map getMethodsMap = new HashMap();
            for (int i = 0; i < allMethods.length; i++) {
                if (allMethods[i].getName().startsWith(""get"")) {
                    getMethodsMap.put(allMethods[i].getName(), allMethods[i]);
                }
            }
            Field elementsField = cl.getField(""ELEMENTS"");
            String[] elements = (String[]) elementsField.get(obj);
            List getMethods = new ArrayList();
            for (int i = 0; i < elements.length; i++) {
                String elementName = elements[i];
                Method getMethod = (Method) getMethodsMap.get(""get"" + elementName);
                getMethods.add(getMethod);
            }
            return getMethods;
        } catch (Exception e) {
            throw new IFXException(""Exception getting Accessor"", e);
        }
    }

    /**
     * Gets the element name from the object class name. It retrieves the
     * class name portion from the fully qualified class name for the bean,
     * then applies transformations to convert back to dotted form for
     * certain elements.
     * @param obj an IFXObject.
     * @return the name of the element that is represented by this object.
     * @exception IFXException if element name was not found.
     */
    private String getElementName(IFXObject obj) throws IFXException {
        String elementName = bundle.getString(obj.getClass().getName());
        if (elementName == null) {
            throw new IFXException(""No element found for "" + obj.getClass().getName());
        }
        return elementName;
    }
}
","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains ten unit test cases for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {","// IFXEncoderTest.java
package org.sourceforge.ifx.utils;

import java.lang.reflect.Array;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.io.Writer;
import java.io.OutputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.ResourceBundle;
import java.util.MissingResourceException;
import org.sourceforge.ifx.basetypes.IFXObject;
import org.sourceforge.ifx.basetypes.IBaseType;
import org.jdom.Element;
import org.jdom.Namespace;
import org.jdom.output.XMLOutputter;
import org.jdom.input.SAXBuilder;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link IFXEncoder}.
* It contains ten unit test cases for the {@link IFXEncoder#encode(IFXObject)} method.
*/
class IFXEncoderTest {

	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject.
	*/
	@Test
	void testEncodeSimpleIFXObject() throws Exception {
		IFXEncoder encoder = new IFXEncoder();
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithNamespace() throws Exception {
		IFXEncoder encoder = new IFXEncoder(""ifx"", ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals(""ifx"", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace2() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace3() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace4() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace5() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace6() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace7() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace8() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		assertEquals("""", element.getNamespacePrefix());
		assertEquals(""http://www.ifxforum.org/ifx"", element.getNamespaceURI());
	}
	
	/**
	* Test case for {@link IFXEncoder#encode(IFXObject)} method.
	* It tests the encoding of a simple IFXObject with a namespace.
	*/
	@Test
	void testEncodeSimpleIFXObjectWithDefaultNamespace9() throws Exception {
		IFXEncoder encoder = new IFXEncoder(null, ""http://www.ifxforum.org/ifx"");
		IFXObject obj = new IFXObject();
		Element element = encoder.encode(obj);
		assertEquals(""IFXObject"", element.getName());
		"
