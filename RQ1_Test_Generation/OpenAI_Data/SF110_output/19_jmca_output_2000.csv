ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6tzw31cUl99twD8ls43rSH493XCIL,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_0Test.java,43.76784420013428,length,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_0Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_0Test {","// ASTNode_0Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#compareTo(Object)} method.
*/
class ASTNode_0Test {

	/**
	* Test case 1 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity.
	*/
	@Test
	void testCompareTo_1() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		assertEquals(0, node1.compareTo(node2));
	}
	
	/**
	* Test case 2 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type but different identity.
	*/
	@Test
	void testCompareTo_2() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity2"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 3 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same identity but different type.
	*/
	@Test
	void testCompareTo_3() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type2"");
		node2.setIdentity(""identity"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 4 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have different type and identity.
	*/
	@Test
	void testCompareTo_4() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type2"");
		node2.setIdentity(""identity2"");
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 5 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child.
	*/
	@Test
	void testCompareTo_5() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type"");
		node3.setIdentity(""identity"");
		node1.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 6 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child.
	*/
	@Test
	void testCompareTo_6() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type"");
		node3.setIdentity(""identity"");
		node2.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 7 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child with different type and identity.
	*/
	@Test
	void testCompareTo_7() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity2"");
		node1.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 8 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child with different type and identity.
	*/
	@Test
	void testCompareTo_8() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity2"");
		node2.addChild(node3);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 9 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the first node has a child with different type and the second node has a child with different identity.
	*/
	@Test
	void testCompareTo_9() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		ASTNode node4 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity"");
		node4.setType(""type"");
		node4.setIdentity(""identity2"");
		node1.addChild(node3);
		node2.addChild(node4);
		assertEquals(1, node1.compareTo(node2));
	}
	
	/**
	* Test case 10 for {@link ASTNode#compareTo(Object)}.
	* It tests the method with two nodes that have the same type and identity, but the second node has a child with different type and the first node has a child with different identity.
	*/
	@Test
	void testCompareTo_10() {
		ASTNode node1 = new ASTNode();
		ASTNode node2 = new ASTNode();
		ASTNode node3 = new ASTNode();
		ASTNode node4 = new ASTNode();
		node1.setType(""type"");
		node1.setIdentity(""identity"");
		node2.setType(""type"");
		node2.setIdentity(""identity"");
		node3.setType(""type2"");
		node3.setIdentity(""identity"");
		node4.setType(""type"");
		node4.setIdentity(""identity2"");
		node1.addChild(node4);
		node2.addChild(node3);
		"
cmpl-6tzx6oTDqiGiIpYzoL0Nejn5DE1C4,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_1Test.java,39.4561243057251,length,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#getTree(String)} method.
*/
class ASTNode_1Test {","// ASTNode_1Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#getTree(String)} method.
*/
class ASTNode_1Test {

	/**
	* Test case 1 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_1() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 2 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_2() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 3 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_3() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 4 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_4() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 5 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_5() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 6 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_6() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 7 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_7() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 8 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_8() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 9 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_9() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
	
	/**
	* Test case 10 for {@link ASTNode#getTree(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testGetTree_10() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		assertNotNull(rootNode);
	}
}

// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#dump(String)} method.
*/
class ASTNode_2Test {
		
	/**
	* Test case 1 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_1() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 2 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_2() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 3 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_3() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 4 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_4() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 5 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_5() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 6 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_6() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 7 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_7() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 8 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_8() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 9 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_9() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
	
	/**
	* Test case 10 for {@link ASTNode#dump(String)}.
	* It tests the method with a valid file name.
	*/
	@Test
	void testDump_10() {
		ASTNode rootNode = ASTNode.getTree(""test.txt"");
		rootNode.dump(""test.txt"");
	}
}

// ASTNode_3Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#createTree()} method.
*/
class ASTNode_3Test {
		
	/**
	* Test case 1 for {@"
cmpl-6tzy9bKHK3XG9wgAxU2sNEvFhcUks,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/ASTNode_2Test.java,42.43816804885864,length,"// ASTNode.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Data Structure for ASTree Node</p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class ASTNode implements Comparable, java.io.Serializable {

    /**
     * data of the node
     */
    String type = null;

    String identity = null;

    /**
     * implements Comparable
     * @param node Object
     * @return int values 0 for same and 1 for different
     */
    public int compareTo(Object node) {
        if (!type.equals(((ASTNode) node).getType()) || !identity.equals(((ASTNode) node).getIdentity())) {
            return 1;
        }
        for (int i = 0; i < list.size(); ++i) {
            try {
                if (list.get(i).compareTo(((ASTNode) node).list.get(i)) == 1) {
                    return 1;
                }
            } catch (IndexOutOfBoundsException ne) {
                return 1;
            } catch (NullPointerException np) {
                return 1;
            }
        }
        return 0;
    }

    /**
     * children of the node
     */
    //IC - Added the <Object> tags to get rid of warnings...
    //http://java.sun.com/developer/JDCTechTips/2005/tt0315.html
    // SS - changed <Object> to <ASTNode> and removed the casts
    java.util.ArrayList<ASTNode> list = new java.util.ArrayList<ASTNode>();

    /**
     * parent of the node
     */
    ASTNode parent = null;

    /**
     * add child to node
     * @param node ASTNode
     */
    public void addChild(ASTNode node) {
        list.add(node);
    }

    /**
     * default constructor
     */
    public ASTNode() {
    }

    /**
     * construct a  node and set its parent
     * @param p ASTNode
     */
    public ASTNode(ASTNode p) {
        parent = p;
    }

    /**
     * construct a node and set data types and parent
     * @param type String
     * @param identity String
     * @param p ASTNode
     */
    public ASTNode(String type, String identity, ASTNode p) {
        parent = p;
        setType(type);
        setIdentity(identity);
    }

    /**
     * get the parent node
     * @return ASTNode
     */
    public ASTNode getParent() {
        return parent;
    }

    /**
     * set the data element type
     * @param t String
     */
    public void setType(String t) {
        type = t;
    }

    /**
     * set the data type identity
     * @param id String
     */
    public void setIdentity(String id) {
        identity = id;
    }

    /**
     * get the data element type
     * @return String
     */
    public String getType() {
        return type;
    }

    /**
     * get the data element identity
     * @return String
     */
    public String getIdentity() {
        return identity;
    }

    /**
     * concat type and identity
     * @return String
     */
    public String toString() {
        String returnString = type + "" :: "" + identity;
        return returnString;
    }

    /**
     * display this node and all its children recursively
     * @param wtr Writer
     */
    public void display(Writer wtr) {
        try {
            wtr.write(toString());
        } catch (IOException ie) {
            System.err.println(ie.getMessage());
        }
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            try {
                wtr.write(""\n"");
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            list.get(i).display(wtr);
        }
    }

    /**
     *  reads the node in from a file
     * @param filename String
     * @return ASTNode
     */
    public static ASTNode getTree(String filename) {
        ObjectInputStream rdr = null;
        ASTNode rootNode = null;
        try {
            FileInputStream flstrm = new FileInputStream(new File(filename));
            rdr = new ObjectInputStream(flstrm);
            rootNode = (ASTNode) rdr.readObject();
            rdr.close();
        } catch (java.io.IOException ie) {
        } finally {
            return rootNode;
        }
    }

    /**
     * save the node and its children to disk
     * @param filename String
     */
    public void dump(String filename) {
        ObjectOutputStream wtr = null;
        try {
            FileOutputStream flstrm = new FileOutputStream(new File(filename));
            wtr = new ObjectOutputStream(flstrm);
            wtr.writeObject(this);
            wtr.close();
        } catch (java.io.IOException ie) {
        }
    }

    /**
     * add this node and recursively all its children to a swing tree structure <br>
     * used to construct a JTree with the ASTree
     * @return DefaultMutableTreeNode
     */
    public DefaultMutableTreeNode createTree() {
        javax.swing.tree.DefaultMutableTreeNode node = new DefaultMutableTreeNode(toString());
        int arraySize = list.size();
        for (int i = 0; i < arraySize; ++i) {
            node.add(list.get(i).createTree());
        }
        return node;
    }
}
","// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#createTree()} method.
*/
class ASTNode_2Test {","// ASTNode_2Test.java
package com.soops.CEN4010.JMCA;

import java.util.ArrayList;
import java.io.*;
import javax.swing.tree.DefaultMutableTreeNode;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link ASTNode}.
* It contains ten unit test cases for the {@link ASTNode#createTree()} method.
*/
class ASTNode_2Test {

	/**
	* Test case 1 for {@link ASTNode#createTree()}.
	* It tests the method with a null ASTNode.
	*/
	@Test
	void testCreateTree1() {
		ASTNode node = null;
		DefaultMutableTreeNode tree = node.createTree();
		assertNull(tree);
	}
	
	/**
	* Test case 2 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with no children.
	*/
	@Test
	void testCreateTree2() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
	}
	
	/**
	* Test case 3 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with one child.
	*/
	@Test
	void testCreateTree3() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child = new ASTNode();
		child.setType(""type"");
		child.setIdentity(""identity"");
		node.addChild(child);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
	}
	
	/**
	* Test case 4 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with two children.
	*/
	@Test
	void testCreateTree4() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
	}
	
	/**
	* Test case 5 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with three children.
	*/
	@Test
	void testCreateTree5() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
	}
	
	/**
	* Test case 6 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with four children.
	*/
	@Test
	void testCreateTree6() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		ASTNode child4 = new ASTNode();
		child4.setType(""type"");
		child4.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		node.addChild(child4);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
		assertEquals(""type :: identity"", tree.getChildAt(3).toString());
	}
	
	/**
	* Test case 7 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with five children.
	*/
	@Test
	void testCreateTree7() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3 = new ASTNode();
		child3.setType(""type"");
		child3.setIdentity(""identity"");
		ASTNode child4 = new ASTNode();
		child4.setType(""type"");
		child4.setIdentity(""identity"");
		ASTNode child5 = new ASTNode();
		child5.setType(""type"");
		child5.setIdentity(""identity"");
		node.addChild(child1);
		node.addChild(child2);
		node.addChild(child3);
		node.addChild(child4);
		node.addChild(child5);
		DefaultMutableTreeNode tree = node.createTree();
		assertEquals(""type :: identity"", tree.toString());
		assertEquals(""type :: identity"", tree.getChildAt(0).toString());
		assertEquals(""type :: identity"", tree.getChildAt(1).toString());
		assertEquals(""type :: identity"", tree.getChildAt(2).toString());
		assertEquals(""type :: identity"", tree.getChildAt(3).toString());
		assertEquals(""type :: identity"", tree.getChildAt(4).toString());
	}
	
	/**
	* Test case 8 for {@link ASTNode#createTree()}.
	* It tests the method with an ASTNode with six children.
	*/
	@Test
	void testCreateTree8() {
		ASTNode node = new ASTNode();
		node.setType(""type"");
		node.setIdentity(""identity"");
		ASTNode child1 = new ASTNode();
		child1.setType(""type"");
		child1.setIdentity(""identity"");
		ASTNode child2 = new ASTNode();
		child2.setType(""type"");
		child2.setIdentity(""identity"");
		ASTNode child3"
6dc1a068-e5fc-4ca1-a80e-22725bda557a,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAAnalyzer.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8197 tokens (6197 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// JMCAAnalyzer.java
package com.soops.CEN4010.JMCA;

import java.util.*;

/**
 * <p>Title: JMCAAnalyzer </p>
 *
 * <p>Description: implements Analyzer</p>
 *
 * Group2 for CEN4010 at FSU - Fall 2005
 */
public class JMCAAnalyzer implements Analyzer {

    private String fileName = """";

    private StringBuilder output = new StringBuilder();

    private java.util.HashSet<String> classList = null;

    private static final boolean DEVELOPMENT = false;

    /**
     * Analyze the ASTree and return a formatted string
     * @param root ASTNode
     * @return String
     */
    public String analyze(ASTNode root) {
        if (root == null) {
            output.append(""File did not parse correctly"");
            return output.toString();
        }
        setHeader();
        //  for each class
        for (ASTNode node : root.list) {
            analyzeClass(node);
        }
        return output.toString();
    }

    /**
     * top level analyzer for each class <br>
     * calls analyzeMethod for each method
     * @param node ASTNode
     */
    private void analyzeClass(ASTNode node) {
        // list of class variables
        classList = new HashSet<String>();
        java.util.ArrayList<ASTNode> methodList = new ArrayList<ASTNode>();
        // print class header
        output.append(""\nClass: "" + node.getIdentity() + ""\n\n"");
        output.append(""Method Name                             Cohesion Level\n"");
        output.append(""--------------------------------------------------------------\n"");
        // save each class variable in classList
        for (ASTNode childNode : node.list) {
            if (childNode.getType().equals(""ClassVariableDeclaration"")) {
                classList.add(childNode.getIdentity());
            }
        }
        //  do for each method
        for (ASTNode childNode : node.list) {
            if (childNode.getType().equals(""MethodDeclaration"")) {
                analyzeMethod(childNode);
            }
        }
    }

    // end method analyzeClass
    /**
     * called for each method
     * @param node ASTNode
     */
    private void analyzeMethod(ASTNode node) {
        output.append(node.getIdentity());
        /**
         * list of all statements
         */
        ArrayList<StatementDS> statementList = new ArrayList<StatementDS>();
        /**
         * analyze all statements and add them to the statementList
         */
        statements(node, statementList, false, false);
        /**
         * HashMap of all modified variables
         */
        HashMap<String, StatementElement> modifiedVariables = new HashMap<String, StatementElement>();
        // build semantics for each statement
        for (StatementDS tmpDS : statementList) {
            if (classList.contains(tmpDS.getLVal().getElementName())) {
                tmpDS.getLVal().setType(StatementElement.variableType.ClassVariable);
            }
            if (tmpDS.getType() != null) {
                if (tmpDS.getType().equals(StatementDS.statementType.Assignment) || tmpDS.getType().equals(StatementDS.statementType.PostInc) || tmpDS.getType().equals(StatementDS.statementType.PreInc)) {
                    tmpDS.getLVal().setModified(true);
                    modifiedVariables.put(tmpDS.getLVal().getElementName(), tmpDS.getLVal());
                }
            }
            // set for selection
            tmpDS.getLVal().setInSelection(tmpDS.isInSelection());
            // set for iteration
            tmpDS.getLVal().setInIteration(tmpDS.isInIteration());
            // add modified variables to the chain of variables affecting this element
            ArrayList<StatementElement> rVals = tmpDS.getRVals();
            for (StatementElement rval : rVals) {
                StatementElement tmpEl = modifiedVariables.get(rval.getElementName());
                if (tmpEl != null && !tmpEl.getElementName().equals(tmpDS.getLVal().getElementName())) {
                    tmpDS.getLVal().addModifier(tmpEl);
                } else if (!rval.getElementName().equals(tmpDS.getLVal().getElementName())) {
                    tmpDS.getLVal().addModifier(rval);
                }
                if (rval.hasBeenModified()) {
                    tmpDS.getLVal().addModifier(rval);
                    modifiedVariables.put(rval.getElementName(), rval);
                }
            }
        }
        int modifiedClassVariables = 0;
        int classVariableWithModifiers = 0;
        int modifiedLocVariables = 0;
        boolean iterative = false;
        boolean selective = false;
        String cohesionLevel = """";
        boolean firstModifiedClassVariableWithModifers = true;
        ArrayList<String> classVarModifiers = new ArrayList<String>();
        // do for every Statement
        for (StatementElement el : modifiedVariables.values()) {
            if (el.hasBeenModified()) {
                // class variables
                if (el.getType() != null && el.getType().equals(StatementElement.variableType.ClassVariable)) {
                    // selection
                    if (el.isInSelection()) {
                        selective = true;
                    }
                    // iteration
                    if (el.isInIteration()) {
                        iterative = true;
                    }
                    if (el.getModifiers().size() > 0) {
                        ++classVariableWithModifiers;
                        if (firstModifiedClassVariableWithModifers) {
                            createArrayListOfModifiers(el, classVarModifiers);
                            firstModifiedClassVariableWithModifers = false;
                        } else {
                            ArrayList<String> tmpList = new ArrayList<String>();
                            createArrayListOfModifiers(el, tmpList);
                            ArrayList<String> unionSet = new ArrayList<String>();
                            // get the union of modifed variables
                            for (String var : classVarModifiers) {
                                for (String tmpEl : tmpList) {
                                    if (var.equals(tmpEl)) {
                                        unionSet.add(var);
                                    }
                                }
                            }
                            classVarModifiers = unionSet;
                        }
                    }
                    ++modifiedClassVariables;
                } else {
                    // end modified class variables
                    ++modifiedLocVariables;
                }
            }
        }
        String cohesionType = ""Coincidental"";
        if (modifiedClassVariables == 1 && modifiedLocVariables == 0) {
            cohesionType = ""Functional"";
        } else if (modifiedClassVariables == 1 && classVarModifiers.size() > 0) {
            cohesionType = ""Sequential"";
        } else if (modifiedClassVariables > 1 && classVarModifiers.size() > 0) {
            cohesionType = ""Communicational"";
        } else if (modifiedClassVariables == 0) {
            cohesionType = ""No Class Level Assignments"";
            //  cohesionType = ""Coincidental"";
        }
        if (iterative) {
            cohesionType = ""Iterative"";
        }
        if (selective) {
            cohesionType = ""Conditional"";
        }
        for (int i = 0; i < 60 - node.getIdentity().length() - cohesionType.length(); ++i) {
            output.append("" "");
        }
        output.append(cohesionType + ""\n"");
        // print out a toString dump for development analysis
        if (DEVELOPMENT) {
            for (StatementDS tmpDS : statementList) {
                output.append(""     "" + tmpDS.toString() + ""\n"");
            }
        }
    }

    // end method analyzeMethod
    /**
     * recursive method to create a chain of modifiers to a variable <b>
     * using this method then :   a = b + c;  d = a;  e = d; <br>
     *   e would contain both d and a as modifiers it is dependent on
     * @param stE StatementElement
     * @param list ArrayList
     */
    private void createArrayListOfModifiers(StatementElement stE, ArrayList<String> list) {
        for (StatementElement tmpEl : stE.getModifiers()) {
            list.add(tmpEl.getElementName());
            if (tmpEl.getModifiers().size() > 0) {
                createArrayListOfModifiers(tmpEl, list);
            }
        }
    }

    /**
     * recusive method to analyze statements
     * @param parentNode ASTNode
     * @param statementList ArrayList
     * @param isInSelection boolean
     * @param isInIteration boolean
     */
    private void statements(ASTNode parentNode, ArrayList<StatementDS> statementList, boolean isInSelection, boolean isInIteration) {
        for (ASTNode childNode : parentNode.list) {
            if (childNode.getType().equals(""Selection"")) {
                statements(childNode, statementList, true, isInIteration);
            } else if (childNode.getType().equals(""Iteration"")) {
                statements(childNode, statementList, isInSelection, true);
            } else if (childNode.getIdentity().equals(""StatementExpression"")) {
                StatementDS tmpDS = analyzeStatement(childNode);
                tmpDS.setInIteration(isInIteration);
                tmpDS.setInSelection(isInSelection);
                statementList.add(tmpDS);
            }
        }
    }

    /**
     * called for each statement
     * @param node ASTNode
     * @return StatementDS
     */
    private StatementDS analyzeStatement(ASTNode node) {
        StatementDS localDS = new StatementDS();
        int nodeCount = node.list.size();
        int currCtr = 0;
        int nxtCtr = nodeCount > 0 ? 1 : 0;
        // check for preDec ++ or --
        String firstVal = node.list.get(0).getIdentity();
        if (firstVal.equals(""++"") || firstVal.equals(""--"")) {
            localDS.setType(StatementDS.statementType.PreInc);
            currCtr++;
        }
        currCtr = getLVal(currCtr, node.list);
        localDS.setLVal(node.list.get(currCtr).getIdentity());
        if (currCtr + 1 == nodeCount) {
            return localDS;
        }
        // have the LVAL and there is a next
        currCtr++;
        if (node.list.get(currCtr).getIdentity().equals(""["")) {
            while (!node.list.get(currCtr).getIdentity().equals(""]"")) {
                currCtr++;
            }
            currCtr++;
        }
        if (currCtr + 1 == nodeCount) {
            return localDS;
        }
        // have the LVAL and there is a next
        String tmpVl = node.list.get(currCtr).getIdentity();
        if (tmpVl.equals(""("")) {
            localDS.setType(StatementDS.statementType.MethodCall);
            return localDS;
        }
        if (tmpVl.equals(""++"") || tmpVl.equals(""--"")) {
            localDS.setType(StatementDS.statementType.PostInc);
            return localDS;
        }
        if (tmpVl.equals(""+="") || tmpVl.equals(""="") || tmpVl.equals(""-="") || tmpVl.equals(""\\="") || tmpVl.equals(""*="")) {
            localDS.setType(StatementDS.statementType.Assignment);
            currCtr++;
        }
        getRVals(localDS, currCtr, node.list);
        return localDS;
    }

    /**
     * called from analyzeStatement - gets a list of RVals in assignment statements
     * @param locDS StatementDS
     * @param ctr int
     * @param list ArrayList
     */
    private void getRVals(StatementDS locDS, int ctr, ArrayList<ASTNode> list) {
        // reset to true for each new rval element
        boolean isFirstToken = true;
        String currVariable = null;
        int nodeCount = list.size();
        String currID = null, nextID = null;
        StatementElement currEl = null;
        while (ctr < nodeCount) {
            currID = list.get(ctr).getIdentity();
            if (ctr + 1 < nodeCount) {
                nextID = list.get(ctr + 1).getIdentity();
            } else {
                nextID = null;
            }
            if (isFirstToken) {
                currEl = new StatementElement();
                isFirstToken = false;
                if (currID.equals(""++"") || currID.equals(""--"")) {
                    currEl.setModified(true);
                }
                if (currID.equals(""("")) {
                    ctr++;
                    continue;
                }
            }
            if (nextID != null && (nextID.equals(""++"") || nextID.equals(""--""))) {
                currEl.setModified(true);
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
            }
            if (nextID != null && (nextID.equals("")""))) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                ctr++;
                continue;
            }
            if (nextID != null && nextID.equals(""."")) {
                ctr += 2;
                continue;
            }
            if (nextID == null || isOperator(nextID)) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                locDS.addRVal(currEl);
                // set for the next element
                isFirstToken = true;
                ctr++;
                continue;
            }
            if (currID.equals(""new"")) {
                currEl.setType(StatementElement.variableType.ClassInitiator);
            }
            if (nextID != null && nextID.equals(""("")) {
                if (currEl.getType() == null) {
                    currEl.setType(StatementElement.variableType.MethodCall);
                }
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
            }
            // ignore the array subscripts
            if (nextID != null && nextID.equals(""["")) {
                if (currEl.getElementName() == null) {
                    currEl.setElementName(currID);
                }
                String tmpVal = list.get(ctr).getIdentity();
                while (!tmpVal.equals(""]"")) {
                    ctr++;
                    tmpVal = list.get(ctr).getIdentity();
                }
                if (ctr == nodeCount - 1) {
                    locDS.addRVal(currEl);
                }
            }
            ctr++;
        }
        // end while loop
    }

    /**
     * helper function - checks for delimiters in a equation where delimiters <br>
     * are defined as arithmetic operands such as '+' and '-'
     * @param id String
     * @return boolean
     */
    private boolean isOperator(String id) {
        if (id == null) {
            return false;
        }
        if (id.equals(""+"") || id.equals(""-"") || id.equals(""\\"") || id.equals(""*"") || id.equals(""<<"") || id.equals("">>"") || id.equals(""%"")) {
            return true;
        }
        return false;
    }

    /**
     * gets the variable name for the lVal of an expression
     * @param ctr int
     * @param list ArrayList
     * @return int
     */
    private int getLVal(int ctr, ArrayList<ASTNode> list) {
        // do until the LVal is found
        // lval is an identity that does not have a '.' as the next identity
        // ie.   java.util.Type   in this instance Type is the LVal
        int nodeCount = list.size();
        String currID = null, nextID = null;
        while (ctr < nodeCount) {
            currID = list.get(ctr).getIdentity();
            if (ctr + 1 < nodeCount) {
                nextID = list.get(ctr + 1).getIdentity();
            } else {
                return ctr;
            }
            if (!nextID.equals(""."")) {
                return ctr;
            }
            ctr += 2;
        }
        return ctr;
    }

    /**
     * write the report header to output
     */
    private void setHeader() {
        output.append(""\nFile:  "");
        output.append(fileName);
        output.append(""\n"");
    }

    /**
     * Store the file name parsed for formatted display purposes
     * @param fileName String
     */
    public void setFileName(String fileName) {
        this.fileName = fileName;
    }
}

/**
 *  represents a variable in an expression
 */
class StatementElement {

    /**
     * marked true if this variable is modifed in the method
     */
    private boolean hasBeenModified = false;

    /**
     * represents the variable name
     */
    private String elementName = null;

    /**
     * set true if variable is within a if statement
     */
    private boolean isInSelection = false;

    /**
     * set true if variable is within an interation block
     */
    private boolean isInIteration = false;

    /**
     * list of elements that have modified this element <br>
     * a recursive descent of elements will get a chain of modifiers
     */
    private ArrayList<StatementElement> modifiers = new ArrayList<StatementElement>();

    /**
     * add a variable to the modifier list
     * @param rval StatementElement
     */
    public void addModifier(StatementElement rval) {
        modifiers.add(rval);
    }

    /**
     * return a reference to the modifier list
     * @return ArrayList
     */
    public ArrayList<StatementElement> getModifiers() {
        return modifiers;
    }

    /**
     *  enumeration of types
     */
    public static enum variableType {

        ClassVariable, LocalVariable, MethodCall, ClassInitiator
    }

    /**
     * local variableType represent the type of variable this is
     */
    variableType type = null;

    /**
     * default constructor
     */
    StatementElement() {
    }

    /**
     *  setter for the variable name
     * @param name String
     */
    StatementElement(String name) {
        setElementName(name);
    }

    /**
     * getter for the type : see enum variableType
     * @return variableType
     */
    variableType getType() {
        return type;
    }

    /**
     * setter for the variable type
     * @param t variableType
     */
    void setType(variableType t) {
        type = t;
    }

    /**
     * setter for the name
     * @param name String
     */
    void setElementName(String name) {
        elementName = name;
    }

    /**
     * getter for the boolean flag hasBeenModified
     * @return boolean
     */
    boolean hasBeenModified() {
        return hasBeenModified;
    }

    /**
     * getter for the variable name
     * @return String
     */
    String getElementName() {
        return elementName;
    }

    /**
     * setter for the boolean flag has been modified
     * @param val boolean
     */
    void setModified(boolean val) {
        hasBeenModified = val;
    }

    /**
     * override of toString provides information for debugging/development
     * @return String
     */
    public String toString() {
        String tmp = elementName;
        if (hasBeenModified) {
            tmp += "" (modified) "";
        }
        if (type != null) {
            tmp += "" ("" + type.toString() + "") "";
        }
        for (StatementElement element : modifiers) {
            tmp += element.toString();
        }
        return tmp;
    }

    /**
     * getter for the boolean flag isInSelection
     * @return boolean
     */
    boolean isInSelection() {
        return isInSelection;
    }

    /**
     * getter for the boolean flag isInIteration
     * @return boolean
     */
    boolean isInIteration() {
        return isInIteration;
    }

    /**
     * setter for isInSelection
     * @param val boolean
     */
    void setInSelection(boolean val) {
        isInSelection = val;
    }

    /**
     * setter for isInIteration
     * @param val boolean
     */
    void setInIteration(boolean val) {
        isInIteration = val;
    }
}

// end class
/**
 *   represents an expression statement <br>
 *   has Statment Elements  : one lVal and 0 . . . n rVals
 */
class StatementDS {

    private StatementElement lVal = null;

    private ArrayList<StatementElement> rValList = new ArrayList<StatementElement>();

    public static enum statementType {

        PreInc, PostInc, Assignment, MethodCall
    }

    private statementType type = null;

    private boolean isInSelection = false;

    private boolean isInIteration = false;

    statementType getType() {
        return type;
    }

    /**
     * add a rVal to the list
     * @param rv StatementElement
     */
    void addRVal(StatementElement rv) {
        rValList.add(rv);
    }

    /**
     * set statement type: see  enum statementType
     * @param t statementType
     */
    void setType(statementType t) {
        type = t;
    }

    /**
     * get a reference to the list of rVals
     * @return ArrayList
     */
    ArrayList<StatementElement> getRVals() {
        return rValList;
    }

    /**
     * override of toString contains information for debugging
     * @return String
     */
    public String toString() {
        String tmp = lVal.toString();
        tmp += "" : "" + type.toString();
        if (this.isInIteration()) {
            tmp += "" (Iteration) "";
        }
        if (this.isInSelection()) {
            tmp += "" (Selection) "";
        }
        for (StatementElement rVal : rValList) {
            tmp += "" := "" + rVal.toString();
        }
        return tmp;
    }

    /**
     * setter for the LVal
     * @param rv StatementElement
     */
    void setLVal(StatementElement rv) {
        lVal = rv;
    }

    /**
     * setter for the LVal
     * @param id String
     */
    void setLVal(String id) {
        lVal = new StatementElement(id);
    }

    /**
     * getter for the LVal
     * @return StatementElement
     */
    StatementElement getLVal() {
        return lVal;
    }

    /**
     * getter for the boolean flag isInSelection
     * @return boolean
     */
    boolean isInSelection() {
        return isInSelection;
    }

    /**
     * getter for the boolean flag isInIteration
     * @return boolean
     */
    boolean isInIteration() {
        return isInIteration;
    }

    /**
     * setter for isInSelection
     * @param val boolean
     */
    void setInSelection(boolean val) {
        isInSelection = val;
    }

    /**
     * setter for isInIteration
     * @param val boolean
     */
    void setInIteration(boolean val) {
        isInIteration = val;
    }
}
","// JMCAAnalyzerTest.java
package com.soops.CEN4010.JMCA;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAAnalyzer}.
* It contains ten unit test cases for the {@link JMCAAnalyzer#analyze(ASTNode)} method.
*/
class JMCAAnalyzerTest {","// JMCAAnalyzerTest.java
package com.soops.CEN4010.JMCA;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAAnalyzer}.
* It contains ten unit test cases for the {@link JMCAAnalyzer#analyze(ASTNode)} method.
*/
class JMCAAnalyzerTest {
"
cmpl-6u00Aa0TlcQa3eABpER4MOj4yEkcU,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAController.java,39.6357901096344,length,"// JMCAController.java
/*
 JMCAController.java

 Contains class JMCAController
 JMCAController accepts a filename as input, then calls other classes to
 1) parse the file and get the Abstract Syntax Tree (AST)
 2) pass the AST to the cohesion analyzer class
 3) get the report output from the analyzer


 CEN4010
 FALL 2005
 GROUP2

 Curt Hayashida, Scott Springer, Ian Cole


 Revision History:
 10/15/2005 - IC - Quick & Dirty Class Creation for prototype
 10/24/2005 - IC - First Integration pass with GUI code
           1) Added to package
           2) Added comments to the analyze() method
             based on Scott's early design
 10/30/2005 - IC - Convert to true MVC (Model-View-Controller) per the grading notes
      1) Changing from JMCAFrame has a JMCAController to
       JMCAController (Controller) has a JMCAFrame (View)
      2) Removed constructor that took filename - unneeded with MVC
      3) Removed get / set filename - unneeded
      4) Removed getOutput - unneeded
      5) Main function now target for application execution
      6) Main function updated to MVC pattern
      7) Converted to use JMCAView

 11/13/2005 - SS - Change parser to JMCAParser, analyzer to JMCAAnalyzer

 Compilation (from project directory)
 javac -d . *.java

 Execution (from top-level project directory)
 java com.soops.CEN4010.JMCA.JMCAController


 */
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import java.io.IOException;
import java.io.FileReader;
import java.io.File;
import java.awt.event.*;
import java.awt.Toolkit;
import com.soops.CEN4010.JMCA.JParser.parseTest.JMCAParserTestFrame;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.Dimension;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Controller manages subsystems of JMCA </p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class JMCAController {

    private static final boolean DEVELOPMENT = true;

    private static JMCAView view;

    /**
     * default constructor
     */
    JMCAController() {
    }

    /**
     *   controls Parser and Analyzer
     *     analyze will return String with analysis or error text
     * @return String
     */
    public static String analyze(String filename) {
        /**
         * implement placeholder implementations of Parser and Analyzer
         *       Reader rdr = new FileReader (new File (filename));
         *       ASTNode rootNode = new JMCAParser().parse(rdr);
         *       output = new JMCAAnalyzer().analyze(rootNode);
         */
        if (filename != null && !filename.equals("""")) {
            Reader rdr = null;
            try {
                rdr = new FileReader(new File(filename));
            } catch (IOException ie) {
                System.err.println(ie.getMessage());
            }
            /**
             * call parser
             */
            // ASTNode rootNode = new DummyParser().parse(rdr);
            ASTNode rootNode = new JMCAParser().parse(rdr);
            if (DEVELOPMENT && rootNode != null)
                showTree(rootNode, filename);
            /**
             * call analyzer
             */
            //  Analyzer analyzer = new UILayoutDisplayAnalyzer();
            Analyzer analyzer = new JMCAAnalyzer();
            analyzer.setFileName(filename);
            return analyzer.analyze(rootNode);
        }
        return new String(""ERROR: Filename not entered."");
    }

    //end analyze()
    private static void showTree(ASTNode tmp, String filename) {
        DefaultMutableTreeNode rootNode = tmp.createTree();
        JMCAParserTestFrame frame = new JMCAParserTestFrame(rootNode, filename);
        frame.validate();
        // Center the window
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension frameSize = frame.getSize();
        if (frameSize.height > screenSize.height) {
            frameSize.height = screenSize.height;
        }
        if (frameSize.width > screenSize.width) {
            frameSize.width = screenSize.width;
        }
        frame.setLocation((screenSize.width - frameSize.width) / 2, (screenSize.height - frameSize.height) / 2);
        frame.setVisible(true);
    }

    //main function for JMCA Application
    public static void main(String[] args) {
        view = new JMCAView();
        // in this case our model is the Parser / Analyzer
        //set action listeners here....
        view.setAnalyzeListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                view.updateDisplay(analyze(view.getFilename()));
            }
        });
        //end setAnalyzeListener
        view.setSelectFileListener(new ActionListener() {

            public void actionPerformed(ActionEvent e) {
                view.chooseFile();
            }
        });
        //end setSelectFileListener
    }
    //end main
}
//end class
","// JMCAControllerTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import java.io.IOException;
import java.io.FileReader;
import java.io.File;
import java.awt.event.*;
import java.awt.Toolkit;
import com.soops.CEN4010.JMCA.JParser.parseTest.JMCAParserTestFrame;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAController}.
* It contains ten unit test cases for the {@link JMCAController#analyze(String)} method.
*/
class JMCAControllerTest {","// JMCAControllerTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import java.io.IOException;
import java.io.FileReader;
import java.io.File;
import java.awt.event.*;
import java.awt.Toolkit;
import com.soops.CEN4010.JMCA.JParser.parseTest.JMCAParserTestFrame;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.Dimension;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAController}.
* It contains ten unit test cases for the {@link JMCAController#analyze(String)} method.
*/
class JMCAControllerTest {

	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is null.
	*/
	@Test
	void testAnalyzeNull() {
		assertEquals(""ERROR: Filename not entered."", JMCAController.analyze(null));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is empty.
	*/
	@Test
	void testAnalyzeEmpty() {
		assertEquals(""ERROR: Filename not entered."", JMCAController.analyze(""""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is not found.
	*/
	@Test
	void testAnalyzeNotFound() {
		assertEquals(""ERROR: File not found."", JMCAController.analyze(""notfound.java""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is a Java file.
	*/
	@Test
	void testAnalyzeJava() {
		assertEquals(""ERROR: File is not a Java file."", JMCAController.analyze(""test.java""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is a JSP file.
	*/
	@Test
	void testAnalyzeJsp() {
		assertEquals(""ERROR: File is not a Java file."", JMCAController.analyze(""test.jsp""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is a HTML file.
	*/
	@Test
	void testAnalyzeHtml() {
		assertEquals(""ERROR: File is not a Java file."", JMCAController.analyze(""test.html""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is a CSS file.
	*/
	@Test
	void testAnalyzeCss() {
		assertEquals(""ERROR: File is not a Java file."", JMCAController.analyze(""test.css""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is a JavaScript file.
	*/
	@Test
	void testAnalyzeJs() {
		assertEquals(""ERROR: File is not a Java file."", JMCAController.analyze(""test.js""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is a JSP file with Java code.
	*/
	@Test
	void testAnalyzeJspWithJava() {
		assertEquals(""ERROR: File is not a Java file."", JMCAController.analyze(""test.jsp""));
	}
	
	/**
	* Test case for the {@link JMCAController#analyze(String)} method.
	* It tests the case when the input file is a Java file with JSP code.
	*/
	@Test
	void testAnalyzeJavaWithJsp() {
		assertEquals(""ERROR: File is not a Java file."", JMCAController.analyze(""test.java""));
	}
}

// JMCAView.java
/*
 JMCAView.java

 Contains class JMCAView
 JMCAView is the View for the JMCA MVC pattern
 JMCAView is a JFrame that contains the GUI elements for the JMCA application


 CEN4010
 FALL 2005
 GROUP2

 Curt Hayashida, Scott Springer, Ian Cole


 Revision History:
 10/15/2005 - IC - Quick & Dirty Class Creation for prototype
 10/24/2005 - IC - First Integration pass with GUI code
           1) Added to package
           2) Added comments to the analyze() method
             based on Scott's early design
 10/30/2005 - IC - Convert to true MVC (Model-View-Controller) per the grading notes
      1) Changing from JMCAFrame has a JMCAController to
       JMCAController (Controller) has a JMCAFrame (View)
      2) Removed constructor that took filename - unneeded with MVC
      3) Removed get / set filename - unneeded
      4) Removed getOutput - unneeded
      5) Main function now target for application execution
      6) Main function updated to MVC pattern
      7) Converted to use JMCAView

 11/13/2005 - SS - Change parser to JMCAParser, analyzer to JMCAAnalyzer

 Compilation (from project directory)
 javac -d . *.java

 Execution (from top-level project directory)
 java com.soops.CEN4010.JMCA.JMCAController


 */
package com.soops.CEN4010.JMCA;

import java.awt.event.*;
import java.awt.Toolkit;
import javax.swing.tree.DefaultMutableTreeNode;
import java.awt.Dimension;
import javax.swing.*;
import java.awt.*;
import java.io.*;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: JMCAView is the View for the JMCA MVC pattern </p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class JMCAView extends JFrame {

    private JTextField filenameField;

    private JTextArea outputArea;

    private JButton analyzeButton;

    private JButton selectFileButton;

    private JFileChooser fileChooser;

    /**
     * default constructor
     */
    public JMCAView() {
        super(""JMCA"");
        setSize(600, 400);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        setLayout(new BorderLayout());
        JPanel topPanel = new JPanel();
        topPanel.setLayout(new FlowLayout());
        filenameField = new JTextField(30);
        topPanel.add(filenameField);
        selectFileButton = new JButton(""Select File"");
        topPanel.add(selectFileButton);
        analyzeButton = new JButton(""Analyze"");
        topPanel.add(analyzeButton);
        add(topPanel, BorderLayout.NORTH);
        outputArea = new JTextArea();
        outputArea.setEditable(false);
        add(new JScrollPane(outputArea), BorderLayout.CENTER);
        fileChooser = new JFileChooser();
        fileChooser.setFileFilter(new javax.swing.filechooser.FileFilter() {

            public boolean accept(File f) {
                return f.getName().toLowerCase().endsWith("".java"") || f.isDirectory();
            }

            public String getDescription() {
                return ""Java Source Files"";
            }
        });
        setVisible(true);
    }

    /**
     *   sets the action listener for the analyze button
     * @param listener ActionListener
     */
    public void setAnalyzeListener(ActionListener listener) {
        analyzeButton.addActionListener(listener);
    }

    /**
     *   sets the action listener for the select file button
     * @param listener ActionListener
     */
    public void setSelectFileListener(ActionListener listener) {
        selectFileButton.addActionListener(listener);
    }

    /**
     *   returns the filename from the filename field
     * @return String
     */
    public String getFilename() {
        return filenameField.getText();
    }

    /**
     *   updates the output area with the given text
     * @param text String
     */
   "
cmpl-6u01DleXDmCVvm3Cr0ckPefPNdDRY,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JMCAParser.java,34.74349284172058,length,"// JMCAParser.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;

public class JMCAParser implements Parser {

    String intermediateFile = ""default.xml"";

    /**
     * parse implements parse for Parser
     * precondition is the intermediatFile is set
     * @param rdr Reader
     * @return ASTNode
     */
    public ASTNode parse(Reader rdr) {
        JavaParser parser = new JavaParser(rdr);
        Writer wtr = null;
        try {
            parser.CompilationUnit();
            wtr = new FileWriter(new File(intermediateFile));
            parser.dump(wtr);
            System.out.println(""Java Parser Version 1.1:  Java program parsed successfully."");
            wtr.close();
            SaxProcessor saxP = new SaxProcessor(new FileInputStream(new File(intermediateFile)));
            saxP.showFile();
            return saxP.getRootNode();
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println(""Java Parser Version 1.1:  Encountered errors during parse."");
            return null;
        } catch (IOException ie) {
            System.out.println(""IO Error from parse : "" + ie.getMessage());
            return null;
        } catch (Error ex) {
            return null;
        } finally {
            try {
                if (wtr != null)
                    wtr.close();
            } catch (IOException ie) {
                System.err.println(""Error while closing intermediate file "" + intermediateFile);
                System.err.println(ie.getMessage());
            }
        }
        //           return null;
    }
}
","// JMCAParserTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains ten unit test cases for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCAParserTest {","// JMCAParserTest.java
package com.soops.CEN4010.JMCA;

import java.io.Reader;
import com.soops.CEN4010.JMCA.JParser.JavaParser;
import java.io.IOException;
import java.io.FileWriter;
import java.io.Writer;
import java.io.FileInputStream;
import java.io.File;
import com.soops.CEN4010.JMCA.JParser.xmlParser.SaxProcessor;
import com.soops.CEN4010.JMCA.JParser.ParseException;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JMCAParser}.
* It contains ten unit test cases for the {@link JMCAParser#parse(Reader)} method.
*/
class JMCAParserTest {

	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a valid Java program.
	*/
	@Test
	void testParseValidJavaProgram() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/valid_java_program.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/valid_java_program.java""));
		assertNotNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError2() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error2.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error2.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError3() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error3.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error3.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError4() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error4.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error4.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError5() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error5.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error5.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError6() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error6.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error6.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError7() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error7.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error7.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError8() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error8.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error8.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError9() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error9.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error9.java""));
		assertNull(root);
	}
	
	/**
	* Test case for {@link JMCAParser#parse(Reader)} method.
	* It tests the parser with a Java program that has a syntax error.
	*/
	@Test
	void testParseJavaProgramWithSyntaxError10() {
		JMCAParser parser = new JMCAParser();
		parser.intermediateFile = ""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error10.xml"";
		ASTNode root = parser.parse(new FileReader(""test/com/soops/CEN4010/JMCA/test_files/java_program_with_syntax_error10.java""));
		assertNull(root);
	}
}

// JMCATest.java
package com.soops.CEN4010"
cmpl-6u02GAXKRqff4c3XFSA0KHLQ1M54v,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/JParser/Token.java,46.465678691864014,length,"// Token.java
package com.soops.CEN4010.JMCA.JParser;

/* Generated By:JavaCC: Do not edit this line. Token.java Version 3.0 */
/**
 * Describes the input token stream.
 */
public class Token {

    /**
     * An integer that describes the kind of this token.  This numbering
     * system is determined by JavaCCParser, and a table of these numbers is
     * stored in the file ...Constants.java.
     */
    public int kind;

    /**
     * beginLine and beginColumn describe the position of the first character
     * of this token; endLine and endColumn describe the position of the
     * last character of this token.
     */
    public int beginLine, beginColumn, endLine, endColumn;

    /**
     * The string image of the token.
     */
    public String image;

    /**
     * A reference to the next regular (non-special) token from the input
     * stream.  If this is the last token from the input stream, or if the
     * token manager has not read tokens beyond this one, this field is
     * set to null.  This is true only if this token is also a regular
     * token.  Otherwise, see below for a description of the contents of
     * this field.
     */
    public Token next;

    /**
     * This field is used to access special tokens that occur prior to this
     * token, but after the immediately preceding regular (non-special) token.
     * If there are no such special tokens, this field is set to null.
     * When there are more than one such special token, this field refers
     * to the last of these special tokens, which in turn refers to the next
     * previous special token through its specialToken field, and so on
     * until the first special token (whose specialToken field is null).
     * The next fields of special tokens refer to other special tokens that
     * immediately follow it (without an intervening regular token).  If there
     * is no such token, this field is null.
     */
    public Token specialToken;

    /**
     * Returns the image.
     */
    public String toString() {
        return image;
    }

    /**
     * Returns a new Token object, by default. However, if you want, you
     * can create and return subclass objects based on the value of ofKind.
     * Simply add the cases to the switch for all those special cases.
     * For example, if you have a subclass of Token called IDToken that
     * you want to create if ofKind is ID, simlpy add something like :
     *
     *    case MyParserConstants.ID : return new IDToken();
     *
     * to the following switch statement. Then you can cast matchedToken
     * variable to the appropriate type and use it in your lexical actions.
     */
    public static final Token newToken(int ofKind) {
        switch(ofKind) {
            default:
                return new Token();
            case JavaParserConstants.RUNSIGNEDSHIFT:
            case JavaParserConstants.RSIGNEDSHIFT:
            case JavaParserConstants.GT:
                return new GTToken();
        }
    }

    public static class GTToken extends Token {

        int realKind = JavaParserConstants.GT;
    }
}
","// TokenTest.java
package com.soops.CEN4010.JMCA.JParser;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Token}.
* It contains ten unit test cases for the {@link Token#newToken(int)} method.
*/
class TokenTest {","// TokenTest.java
package com.soops.CEN4010.JMCA.JParser;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Token}.
* It contains ten unit test cases for the {@link Token#newToken(int)} method.
*/
class TokenTest {

	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the default case of the switch statement.
	*/
	@Test
	void testNewTokenDefault() {
		Token token = Token.newToken(JavaParserConstants.ABSTRACT);
		assertEquals(Token.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the GT token.
	*/
	@Test
	void testNewTokenGT() {
		Token token = Token.newToken(JavaParserConstants.GT);
		assertEquals(Token.GTToken.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the RUNSIGNEDSHIFT token.
	*/
	@Test
	void testNewTokenRUNSIGNEDSHIFT() {
		Token token = Token.newToken(JavaParserConstants.RUNSIGNEDSHIFT);
		assertEquals(Token.GTToken.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the RSIGNEDSHIFT token.
	*/
	@Test
	void testNewTokenRSIGNEDSHIFT() {
		Token token = Token.newToken(JavaParserConstants.RSIGNEDSHIFT);
		assertEquals(Token.GTToken.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the GTEQ token.
	*/
	@Test
	void testNewTokenGTEQ() {
		Token token = Token.newToken(JavaParserConstants.GTEQ);
		assertEquals(Token.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the LSHIFT token.
	*/
	@Test
	void testNewTokenLSHIFT() {
		Token token = Token.newToken(JavaParserConstants.LSHIFT);
		assertEquals(Token.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the RSHIFT token.
	*/
	@Test
	void testNewTokenRSHIFT() {
		Token token = Token.newToken(JavaParserConstants.RSHIFT);
		assertEquals(Token.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the GTGT token.
	*/
	@Test
	void testNewTokenGTGT() {
		Token token = Token.newToken(JavaParserConstants.GTGT);
		assertEquals(Token.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the GTGTGT token.
	*/
	@Test
	void testNewTokenGTGTGT() {
		Token token = Token.newToken(JavaParserConstants.GTGTGT);
		assertEquals(Token.class, token.getClass());
	}
	
	/**
	* Test case for {@link Token#newToken(int)} method.
	* It tests the case of the switch statement for the GTGTGTGT token.
	*/
	@Test
	void testNewTokenGTGTGTGT() {
		Token token = Token.newToken(JavaParserConstants.GTGTGTGT);
		assertEquals(Token.class, token.getClass());
	}
}

// TokenMgrError.java
package com.soops.CEN4010.JMCA.JParser;

/* Generated By:JavaCC: Do not edit this line. TokenMgrError.java Version 3.0 */
/**
 * Token Manager Error.
 */
public class TokenMgrError extends Error {

    /*
     * Ordinals for various reasons why an Error of this type can be thrown.
     */

    /**
     * Lexical error occurred.
     */
    static final int LEXICAL_ERROR = 0;

    /**
     * An attempt was made to create a second instance of a static token manager.
     */
    static final int STATIC_LEXER_ERROR = 1;

    /**
     * Tried to change to an invalid lexical state.
     */
    static final int INVALID_LEXICAL_STATE = 2;

    /**
     * Detected (and bailed out of) an infinite loop in the token manager.
     */
    static final int LOOP_DETECTED = 3;

    /**
     * Indicates the reason why the exception is thrown. It will have
     * one of the above 4 values.
     */
    int errorCode;

    /**
     * Replaces unprintable characters by their escaped (or unicode escaped)
     * equivalents in the given string
     */
    protected static final String addEscapes(String str) {
        StringBuffer retval = new StringBuffer();
        char ch;
        for (int i = 0; i < str.length(); i++) {
            switch (str.charAt(i)) {
                case 0:
                    continue;
                case '\b':
                    retval.append(""\\b"");
                    continue;
                case '\t':
                    retval.append(""\\t"");
                    continue;
                case '\n':
                    retval.append(""\\n"");
                    continue;
                case '\f':
                    retval.append(""\\f"");
                    continue;
                case '\r':
                    retval.append(""\\r"");
                    continue;
                case '\""':
                    retval.append(""\\\"""");
                    continue;
                case '\'':
                    retval.append(""\\\'"");
                    continue;
                case '\\':
                    retval.append(""\\\\"");
                    continue;
                default:
                    if ((ch = str.charAt(i)) < 0x20 || ch > 0x7e) {
                        String s = ""0000"" + Integer.toString(ch, 16);
                        retval.append(""\\u"" + s.substring(s.length() - 4, s.length()));
                    } else {
                        retval.append(ch);
                    }
                    continue;
            }
        }
        return retval.toString();
    }

    /**
     * Returns a detailed message for the Error when it is thrown by the
     * token manager to indicate a lexical error.
     * Parameters :
     * EOFSeen     : indicates if EOF caused the lexical error
     * curLexState : lexical state in which this error occurred
     * errorLine   : line number when the error occurred
     * errorColumn : column number when the error occurred
     * errorAfter  : prefix that was seen before this error occurred
     * curchar     : the offending character
     * Note: You can customize the lexical error message by modifying this method.
     */
    protected static String LexicalError(boolean EOFSeen, int lexState, int errorLine, int errorColumn, String errorAfter, char curChar) {
        return (""Lexical error at line "" +
                errorLine + "", column "" +
                errorColumn + "".  Encountered: "" +
                (EOFSeen ? ""<EOF> "" : (""\"""" + addEscapes(String.valueOf(curChar)) + ""\"""") + "" ("" + (int) curChar + ""), "") +
                ""after : \"""" + addEscapes(errorAfter) + ""\"""");
    }

    /**
     * You can also modify the body of this method to customize your error messages.
     * For example, cases like LOOP_DETECTED and INVALID_LEXICAL_STATE are not
     * of end-users concern, so you can return something like :
    "
cmpl-6u03JUfkTVnSeSLL0Z3CQMZpILjvu,/EvoSuiteBenchmark/19_jmca/src/main/java/com/soops/CEN4010/JMCA/UILayoutDisplayAnalyzer.java,38.74271297454834,length,"// UILayoutDisplayAnalyzer.java
package com.soops.CEN4010.JMCA;

/**
 * <p>Title: Group 2 Project </p>
 *
 * <p>Class: CEN4010 Fall 2005</p>
 *
 * <p>Description: Description: UILayoutDisplayAnalyzer implements a dummy Analyzer
 *    use for UI layout  </p>
 *
 * <p>Instructor Dr. Stoeklin</p>
 *
 * @author Group 2
 */
public class UILayoutDisplayAnalyzer implements Analyzer {

    String filename = null;

    /**
     * store the file name for formatted display purposes
     * @param file String
     */
    public void setFileName(String file) {
        filename = file;
    }

    /**
     * no operational implementation of Analyzer
     * @param dummy ASTNode not used for dummy output
     * @return display string
     */
    public String analyze(ASTNode dummy) {
        StringBuffer output = new StringBuffer();
        //FAKE OUTPUT FOR PROTOTYPE
        output = new StringBuffer(""\nFile:  "");
        output.append(filename);
        output.append(""\n"");
        output.append(""Class: CohesionTest\n\n"");
        output.append(""Method Name                             Cohesion Level\n"");
        output.append(""--------------------------------------------------------------\n"");
        output.append(""deposit                                 Functional\n"");
        output.append(""withdraw                                Sequential\n"");
        output.append(""addCD                                   Communicational\n"");
        output.append(""formDet                                 Iterative\n"");
        output.append(""checkBookIn                             Conditional\n"");
        output.append(""readInput                               Coincidental\n"");
        return output.toString();
    }
}
","// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {","// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {

	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coincidental\n"", analyzer.analyze(null));
	}
}

// UILayoutDisplayAnalyzerTest.java
package com.soops.CEN4010.JMCA;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link UILayoutDisplayAnalyzer}.
* It contains ten unit test cases for the {@link UILayoutDisplayAnalyzer#analyze(ASTNode)} method.
*/
class UILayoutDisplayAnalyzerTest {
		
	/**
	* Test case for {@link UILayoutDisplayAnalyzer#analyze(ASTNode)}.
	*/
	@Test
	void testAnalyze() {
		UILayoutDisplayAnalyzer analyzer = new UILayoutDisplayAnalyzer();
		analyzer.setFileName(""test.java"");
		assertEquals(""\nFile:  test.java\nClass: CohesionTest\n\nMethod Name                             Cohesion Level\n--------------------------------------------------------------\ndeposit                                 Functional\nwithdraw                                Sequential\naddCD                                   Communicational\nformDet                                 Iterative\ncheckBookIn                             Conditional\nreadInput                               Coinc"
