ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
c09365b4-6f22-4c90-bf9a-2ecdf8a77cd9,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_0Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8060 tokens (6060 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {","// FTPClient_0Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String)} method.
*/
class FTPClient_0Test {
"
0de58afd-be7e-4a17-9cf7-efd47eeb2578,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_1Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8062 tokens (6062 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {","// FTPClient_1Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#store(String, boolean)} method.
*/
class FTPClient_1Test {
"
96d012b4-f00c-4588-bf2f-c7bcf8ec21f8,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_2Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8060 tokens (6060 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {","// FTPClient_2Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String)} method.
*/
class FTPClient_2Test {
"
dc509f36-6a8f-475c-9063-29c81bd174be,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_3Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8062 tokens (6062 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {","// FTPClient_3Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#append(String, boolean)} method.
*/
class FTPClient_3Test {
"
d11bef6c-786b-494b-b1d8-45437a5625d6,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_4Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8061 tokens (6061 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {","// FTPClient_4Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String)} method.
*/
class FTPClient_4Test {
"
294602fa-969b-4840-92d8-9e4f5737c64a,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_5Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8063 tokens (6063 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {","// FTPClient_5Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#storeUnique(String, boolean)} method.
*/
class FTPClient_5Test {
"
b721c468-253f-4ff1-ad6d-d907e2cac4bf,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/ftp/FTPClient_6Test.java,-1,"ERROR - This model's maximum context length is 8001 tokens, however you requested 8061 tokens (6061 in your prompt; 2000 for the completion). Please reduce your prompt; or completion length.","// FTPClient.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.ftp;

import java.io.*;
import java.net.*;

/**
 * An FTP client. See RFC-959.
 *
 * Pathnames must be specified using '/' for directory separator.
 * Passive mode will be used for all transfers.
 * <em>Not</em> thread-safe, i.e. you cannot start a new file while another one is in
 * progress.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPClient {

    private static final boolean DEBUG = false;

    private Socket control;

    private InputStream controlIn;

    private OutputStream controlOut;

    private String respString;

    private String lastPath = """";

    private int lastPathLen = 0;

    private void sendLine(String str) throws IOException {
        controlOut.write(str.getBytes(""US-ASCII""));
        controlOut.write('\r');
        controlOut.write('\n');
        controlOut.flush();
    }

    private String recvLine() throws EOFException, IOException {
        StringBuffer sb = new StringBuffer();
        while (true) {
            int i = controlIn.read();
            if (i < 0)
                throw new EOFException(""Unexpected EOF when reading socket"");
            byte b = (byte) i;
            if (b == '\n')
                break;
            if (b != '\r')
                sb.append((char) b);
        }
        return sb.toString();
    }

    private int recvResponse() throws EOFException, IOException {
        respString = recvLine();
        String code = respString.substring(0, 3);
        if (// multiline response
        respString.charAt(3) == '-') {
            String endMark = code + ' ';
            while (true) {
                respString = recvLine();
                if (respString.startsWith(endMark))
                    break;
            }
        }
        return Integer.parseInt(code);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param url  an URL specifying host, port, username and optionally
     *             an initial path to change to
     * @param password  the password to use for logging in
     *
     * @throws MalformedURLException  if there are any syntactic error in the URL
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String url, String password) throws MalformedURLException, UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (!url.startsWith(""ftp://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.indexOf('@', userPos + 1);
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String username;
        String host;
        int port;
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 21 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        connect(host, port, username, password);
        initialDir(path);
    }

    /**
     * Connect to an FTP server and login.
     *
     * @param host  the host to connect to, may be a domain name or IP address
     * @param port  the control channel port (default 21)
     * @param username  the username to use for logging in
     * @param password  the password to use for logging in
     * @param path  initial path, realtive to home directory unless starting with '/',
     *              may be <code>null</code> to use home directory
     *
     * @throws UnknownHostException  if the hostname specified doesn't exist
     * @throws FTPAuthenticationException  if the password is wrong
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public FTPClient(String host, int port, String username, String password, String path) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        connect(host, port, username, password);
        initialDir(path);
    }

    private void connect(String host, int port, String username, String password) throws UnknownHostException, FTPAuthenticationException, FTPException, IOException {
        if (port < 0 || port > 65535)
            port = 21;
        control = new Socket(host, port);
        controlIn = control.getInputStream();
        controlOut = control.getOutputStream();
        int resp;
        // Receive greeting message
        greeting: while (true) {
            resp = recvResponse();
            switch(resp) {
                case 120:
                    continue greeting;
                case 220:
                    break greeting;
                case 421:
                    throw new FTPException(""FTP server not avaliable (421)"");
                default:
                    throw new FTPException(""Unexpected response from FTP server: "" + respString);
            }
        }
        sendLine(""USER "" + username);
        resp = recvResponse();
        switch(resp) {
            case 230:
                break;
            case 331:
                sendLine(""PASS "" + password);
                resp = recvResponse();
                switch(resp) {
                    case 230:
                        break;
                    case 530:
                        throw new FTPAuthenticationException();
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            case 530:
                throw new FTPException(""Invalid username"");
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    private void initialDir(String path) throws FTPException, IOException {
        if (path == null)
            return;
        int pos, oldPos = 0;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            if (!chdir(comp))
                throw new FTPException(""Path not found: "" + path);
            oldPos = pos + 1;
        }
    }

    /**
     * Logout and disconnect from the FTP server.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        sendLine(""QUIT"");
        int resp = recvResponse();
        control.close();
        control = null;
    }

    /**
     * Change the current directory.
     *
     * @param dir  the directory to change into
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean chdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CWD "" + dir);
        sendLine(""CWD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Change the current directory to the parent directory.
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean cdup() throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""CDUP"");
        sendLine(""CDUP"");
        int resp = recvResponse();
        switch(resp) {
            case 200:
            case 250:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new directory.
     *
     * @param dir  the directory to create
     *
     * @return true if successful, false otherwise
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    private boolean mkdir(String dir) throws FTPException, IOException {
        if (DEBUG)
            System.out.println(""MKD "" + dir);
        sendLine(""MKD "" + dir);
        int resp = recvResponse();
        switch(resp) {
            case 257:
                return true;
            case 550:
                return false;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname) throws FTPException, IOException {
        return store(pathname, false);
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream store(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""STOR"", filename, last);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname) throws FTPException, IOException {
        return append(pathname, false);
    }

    /**
     * Create a new file, or append to an existing file.
     * Will create directories as nessesary.
     *
     * @param pathname  path to the file
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream append(String pathname, boolean last) throws FTPException, IOException {
        int pos = pathname.lastIndexOf('/');
        String path = pathname.substring(0, pos + 1);
        String filename = pathname.substring(pos + 1);
        changeDir(path);
        return upload(""APPE"", filename, last);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path) throws FTPException, IOException {
        return storeUnique(path, false);
    }

    /**
     * Create a new file with an unique name.
     * Will create directories as nessesary.
     *
     * @param path  path to the file, must end with '/' or be empty
     * @param last  close the FTPClient after transferring this file
     *
     * @return an OutputStream to write to, close() it when finished
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public OutputStream storeUnique(String path, boolean last) throws FTPException, IOException {
        changeDir(path);
        return upload(""STOU"", null, last);
    }

    private void changeDir(String path) throws FTPException, IOException {
        if (!path.equals(lastPath)) {
            if (path.length() > 0 && path.charAt(0) != '/')
                path = '/' + path;
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int pos, oldPos = 1;
            boolean mkd = false;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (mkd) {
                    if (!mkdir(comp))
                        throw new FTPException(""Unable to create directory: "" + comp);
                    if (!chdir(comp))
                        throw new FTPException(""Unable to change into newly created directory: "" + comp);
                } else {
                    if (!chdir(comp)) {
                        if (!mkdir(comp))
                            throw new FTPException(""Unable to create directory: "" + comp);
                        if (!chdir(comp))
                            throw new FTPException(""Unable to change into newly created directory: "" + comp);
                        mkd = true;
                    }
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
    }

    private OutputStream upload(String cmd, String filename, boolean last) throws FTPException, IOException {
        int resp;
        sendLine(""TYPE I"");
        resp = recvResponse();
        switch(resp) {
            case 200:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        sendLine(""PASV"");
        resp = recvResponse();
        switch(resp) {
            case 227:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        InetAddress addr;
        int port;
        String s = respString.replace(',', '.');
        int i = 3;
        while (i < s.length() && !Character.isDigit(s.charAt(i))) i++;
        if (i == s.length())
            throw new FTPException(""invalid response to PASV command"");
        int c1 = s.indexOf('.', i);
        if (c1 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c2 = s.indexOf('.', c1 + 2);
        if (c2 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c3 = s.indexOf('.', c2 + 1);
        if (c3 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c4 = s.indexOf('.', c3 + 1);
        if (c4 < 0)
            throw new FTPException(""invalid response to PASV command"");
        int c5 = s.indexOf('.', c4 + 1);
        if (c5 < 0)
            throw new FTPException(""invalid response to PASV command"");
        try {
            addr = InetAddress.getByName(s.substring(i, c4));
            i = c5 + 1;
            while (i < s.length() && Character.isDigit(s.charAt(i))) i++;
            int portA = Integer.parseInt(s.substring(c4 + 1, c5));
            int portB = Integer.parseInt(s.substring(c5 + 1, i));
            port = (portA << 8) + portB;
        } catch (UnknownHostException e) {
            throw new FTPException(""invalid response to PASV command"");
        } catch (NumberFormatException e) {
            throw new FTPException(""invalid response to PASV command"");
        }
        if (cmd == null)
            sendLine(cmd);
        else
            sendLine(cmd + "" "" + filename);
        Socket data = new Socket(addr, port);
        resp = recvResponse();
        switch(resp) {
            case 125:
            case 150:
                break;
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
        return new FTPOutputStream(data.getOutputStream(), data, last ? this : null);
    }

    /**
     * Deletes a file.
     *
     * @param pathname  path to the file
     *
     * @return true if successful, false otherwise (file didn't exsist)
     * @throws FTPException if any FTP protocol error occurs
     * @throws IOException if any other IO error occurs
     */
    public boolean deleteFile(String pathname) throws FTPException, IOException {
        String path;
        String fn;
        int pos = pathname.lastIndexOf('/');
        path = pathname.substring(0, pos + 1);
        fn = pathname.substring(pos + 1);
        if (!path.equals(lastPath)) {
            // change directory
            for (int i = 0; i < lastPathLen; i++) if (!cdup())
                throw new FTPException(""Unable to change to parent directory"");
            lastPathLen = 0;
            int oldPos = 1;
            while (true) {
                pos = path.indexOf('/', oldPos);
                if (pos < 0)
                    break;
                lastPathLen++;
                String comp = path.substring(oldPos, pos);
                if (!chdir(comp)) {
                    // file doesn't exist
                    return false;
                }
                oldPos = pos + 1;
            }
        }
        lastPath = path;
        sendLine(""DELE "" + fn);
        int resp = recvResponse();
        switch(resp) {
            case 250:
                return true;
            case 550:
                return false;
            case 450:
                throw new FTPException(""Unable to delete file: "" + respString);
            case 421:
                throw new FTPException(""FTP server not avaliable (421)"");
            default:
                throw new FTPException(""Unexpected response from FTP server: "" + respString);
        }
    }

    class FTPOutputStream extends OutputStream {

        private Socket data;

        private OutputStream out;

        private FTPClient ftp;

        FTPOutputStream(OutputStream out, Socket data, FTPClient ftp) {
            this.out = out;
            this.data = data;
            this.ftp = ftp;
        }

        public void write(int b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b) throws IOException {
            out.write(b);
        }

        public void write(byte[] b, int off, int len) throws IOException {
            out.write(b, off, len);
        }

        public void flush() throws IOException {
            out.flush();
        }

        public void close() throws IOException {
            out.close();
            if (data != null) {
                data.close();
                data = null;
            }
            theLoop: while (true) {
                int resp = recvResponse();
                switch(resp) {
                    case 226:
                    case 250:
                        break;
                    case 425:
                    case 426:
                    case 451:
                    case 551:
                    case 552:
                        throw new FTPException(""Error in file transfer ("" + resp + "")"");
                    case 421:
                        throw new FTPException(""FTP server not avaliable (421)"");
                    default:
                        throw new FTPException(""Unexpected response from FTP server: "" + respString);
                }
                break;
            }
            if (ftp != null)
                ftp.close();
        }
    }
}
","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {","// FTPClient_6Test.java
package nu.staldal.ftp;

import java.io.*;
import java.net.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPClient}.
* It contains ten unit test cases for the {@link FTPClient#deleteFile(String)} method.
*/
class FTPClient_6Test {
"
29629dae-33e7-4616-bf3d-8d6aa75059c1,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/core/LagoonProcessor_0Test.java,-1,"ERROR - Error communicating with OpenAI: ('Connection aborted.', ConnectionResetError(104, 'Connection reset by peer'))","// LagoonProcessor.java
/*
 * Copyright (c) 2001-2004, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;

/**
 * The main worker class of the Lagoon core.
 *
 * Initialized with the sitemap,
 * a source dir and a target storage URL.
 * Then building the website may be done several times,
 * until destroy() is invoked.
 *
 * This class is not thread-safe. The methods must not
 * be invoked concurrently from different threads.
 */
public class LagoonProcessor implements LagoonContext {

    private static final boolean DEBUG = false;

    private final String targetURL;

    private final FileStorage targetLocation;

    private File repositoryDir;

    private File tempDir;

    private File classDir;

    private File sourceRootDir;

    private java.net.URL[] classLoaderURLs;

    private ClassLoader repositoryClassLoader;

    private final Hashtable classDict;

    private final Hashtable paramDict;

    private final Hashtable filestorageDict;

    private Sitemap sitemap;

    PrintWriter log;

    PrintWriter err;

    /**
     * Constructs and initializes a LagoonProcessor.
     *
     * @param targetURL  where to put the generated files,
     *                   must be an absolute URL or a local file path
     * @param sitemapTree  the Sitemap as an XTree
     * @param sourceDir  where the source files are
     * @param password  password to access the target storage, or
     *                  <code>null</code> if not nessesary.
     * @param log  where to write progress messages.
     * @param err  where to write error messages.
     */
    public LagoonProcessor(String targetURL, Element sitemapTree, File sourceDir, String password, PrintWriter log, PrintWriter err) throws IOException, LagoonException, AuthenticationException, AuthenticationMissingException {
        this.targetURL = targetURL;
        this.log = log;
        this.err = err;
        classDict = new Hashtable();
        paramDict = new Hashtable();
        filestorageDict = new Hashtable();
        targetLocation = createFileStorage(targetURL);
        if (targetLocation == null)
            throw new LagoonException(""Cannot find FileStorage for URL "" + targetURL);
        if (targetLocation.needPassword() && (password == null)) {
            throw new AuthenticationMissingException();
        }
        String absPath = sourceDir.getAbsolutePath();
        this.sourceRootDir = new File(absPath);
        if (!this.sourceRootDir.isDirectory())
            throw new LagoonException(""sourceDir must be an existing directory: "" + sourceDir);
        sitemap = new Sitemap(this, sitemapTree, sourceRootDir);
        File workDir = new File(System.getProperty(""user.home""), "".lagoon"");
        if (!workDir.exists()) {
            if (!workDir.mkdir())
                throw new IOException(""Unable to create directory: "" + workDir);
        } else {
            if (!workDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + workDir);
            }
        }
        if (sitemap.getSiteName() != null) {
            repositoryDir = new File(workDir, sitemap.getSiteName());
            if (!repositoryDir.exists()) {
                if (!repositoryDir.mkdir())
                    throw new IOException(""Unable to create directory: "" + repositoryDir);
            } else {
                if (!repositoryDir.isDirectory()) {
                    throw new IOException(""Unable to create directory (a file with that name exists): "" + repositoryDir);
                }
            }
        } else {
            repositoryDir = null;
        }
        if (repositoryDir != null) {
            tempDir = new File(repositoryDir, ""temp"");
            classDir = new File(repositoryDir, ""classes"");
        } else {
            tempDir = new File(workDir, ""temp"");
        }
        if (!tempDir.exists()) {
            if (!tempDir.mkdir())
                throw new IOException(""Unable to create directory: "" + tempDir);
        } else {
            if (!tempDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + tempDir);
            }
        }
        if (classDir == null) {
            classDir = new File(tempDir, ""classes"");
        }
        if (!classDir.exists()) {
            if (!classDir.mkdir())
                throw new IOException(""Unable to create directory: "" + classDir);
        } else {
            if (!classDir.isDirectory()) {
                throw new IOException(""Unable to create directory (a file with that name exists): "" + classDir);
            }
        }
        classLoaderURLs = new java.net.URL[] { classDir.toURL() };
        reloadClasses();
        sitemap.init();
        targetLocation.open(targetURL, this, password);
    }

    /**
     * Get the Sitemap.
     *
     * @return the Sitemap.
     */
    Sitemap getSitemap() {
        return sitemap;
    }

    /**
     * Get the target location.
     *
     * @return the target location.
     */
    FileStorage getTargetLocation() {
        return targetLocation;
    }

    /**
     * Perform the building of the website.
     * May be invoked multiple times.
     * Synchronous, returns when the building is complete.
     *
     * @param force force a rebuild of all files, otherwise dependency
     *        checking is used to check which files that needs rebuilding.
     *
     * @return true if successful, false if any non-fatal error occured
     * @throws IOException  if any fatal error occur
     */
    public boolean build(boolean force) throws IOException {
        boolean success = true;
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.beforeBuild(force);
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            if (!ent.build(force))
                success = false;
        }
        for (Enumeration e = sitemap.getEntries(); e.hasMoreElements(); ) {
            SitemapEntry ent = (SitemapEntry) e.nextElement();
            ent.afterBuild(force);
        }
        return success;
    }

    /**
     * Dispose this object and release any resources it holds.
     * This causes the FileStorage to be closed.
     */
    public void destroy() throws IOException {
        sitemap.destroy();
        targetLocation.close();
        repositoryClassLoader = null;
        if (repositoryDir == null) {
            File[] classFiles = classDir.listFiles();
            for (int i = 0; i < classFiles.length; i++) {
                classFiles[i].delete();
            }
        }
    }

    public File getTempDir() {
        return tempDir;
    }

    public InputStream readFileFromRepository(String key) {
        return readFileFromRepository(null, key);
    }

    InputStream readFileFromRepository(String dir, String key) {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""readFileFromRepository: "" + theFile);
        try {
            return new FileInputStream(theFile);
        } catch (FileNotFoundException e) {
            return null;
        }
    }

    public OutputStream storeFileInRepository(String key) throws IOException {
        return storeFileInRepository(null, key);
    }

    OutputStream storeFileInRepository(String dir, String key) throws IOException {
        if (repositoryDir == null)
            return null;
        File theDir = (dir == null) ? repositoryDir : new File(repositoryDir, dir);
        theDir.mkdir();
        File theFile = new File(theDir, key);
        if (DEBUG)
            System.out.println(""storeFileInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public Class loadClassFromRepository(String className) throws ClassNotFoundException {
        if (DEBUG)
            System.out.println(""loadClassFromRepository: "" + className);
        try {
            return Class.forName(className, true, repositoryClassLoader);
        } catch (ClassFormatError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" is malformed"");
        } catch (VerifyError e) {
            File classFile = new File(classDir, className + "".class"");
            classFile.delete();
            err.println(e.toString());
            throw new ClassNotFoundException(className + "" does not verify"");
        }
    }

    public OutputStream storeClassInRepository(String className) throws IOException {
        if (classDir == null)
            return null;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""storeClassInRepository: "" + theFile);
        return new FileOutputStream(theFile);
    }

    public void deleteClassInRepository(String className) throws IOException {
        if (classDir == null)
            return;
        File theFile = new File(classDir, className + "".class"");
        if (DEBUG)
            System.out.println(""deleteClassInRepository: "" + theFile);
        if (theFile.isFile() && !theFile.delete())
            throw new IOException(""Unable to delete file: "" + theFile);
    }

    public void reloadClasses() {
        repositoryClassLoader = new java.net.URLClassLoader(classLoaderURLs);
    }

    public Object getObjectFromRepository(String key) throws IOException {
        return getObjectFromRepository(null, key);
    }

    Object getObjectFromRepository(String dir, String key) throws IOException {
        InputStream is = readFileFromRepository(dir, key);
        if (is == null)
            return null;
        ObjectInputStream ois = new ObjectInputStream(is);
        try {
            return ois.readObject();
        } catch (ClassNotFoundException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ObjectStreamException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (ClassCastException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } catch (EOFException e) {
            if (DEBUG)
                System.out.println(e);
            return null;
        } finally {
            is.close();
        }
    }

    public boolean putObjectIntoRepository(String key, Object obj) throws IOException {
        return putObjectIntoRepository(null, key, obj);
    }

    boolean putObjectIntoRepository(String dir, String key, Object obj) throws IOException {
        OutputStream os = storeFileInRepository(dir, key);
        if (os == null)
            return false;
        ObjectOutputStream oos = new ObjectOutputStream(os);
        try {
            oos.writeObject(obj);
            return true;
        } finally {
            oos.close();
        }
    }

    /**
     * Create a new producer.
     *
     * @param cat  the producer category (format, transform, source,
     *             read, parse or process).
     * @param type the producer type, use """" for default.
     *
     * @return  a new Producer
     *          or <code>null</code> if it cannot be found.
     */
    Producer createProducer(String cat, String type) throws LagoonException {
        Class cls = (Class) classDict.get(cat + "":"" + type);
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/producer/"" + cat + ((type == """") ? """" : (""-"" + type));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                if (className == null)
                    throw new LagoonException(""Illegal Producer config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core."" + Character.toUpperCase(cat.charAt(0)) + cat.substring(1);
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(cat + "" class must derive from "" + baseClassName);
                    classDict.put(cat + "":"" + type, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""Producer class cannot be found:"" + e.getMessage());
                }
                Hashtable params = new Hashtable();
                for (; ; ) {
                    String s = br.readLine();
                    if (s == null)
                        break;
                    int colon = s.indexOf(':');
                    if (colon < 1)
                        throw new LagoonException(""Illegal producer config file: "" + fileName);
                    String paramName = s.substring(0, colon).trim();
                    String paramValue = s.substring(colon + 1).trim();
                    params.put(paramName, paramValue);
                }
                br.close();
                paramDict.put(cat + "":"" + type, params);
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            Producer prod = (Producer) cls.newInstance();
            Hashtable params = (Hashtable) paramDict.get(cat + "":"" + type);
            for (Enumeration e = params.keys(); e.hasMoreElements(); ) {
                String name = (String) e.nextElement();
                String value = (String) params.get(name);
                prod.addParam(name, value);
            }
            return prod;
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate producer class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate producer class (instantiation failed): "" + e.getMessage());
        }
    }

    /**
     * Create a new file storage
     *
     * @param url  the URL
     *
     * @return  a new FileStorage
     *          or <code>null</code> if it cannot be found.
     */
    FileStorage createFileStorage(String url) throws LagoonException {
        Class cls = null;
        String prefix;
        int colon = url.indexOf(':');
        if (colon < 1) {
            prefix = """";
            cls = (Class) filestorageDict.get("""");
        } else {
            prefix = url.substring(0, colon);
            cls = (Class) filestorageDict.get(prefix);
            if (cls == null) {
                cls = (Class) filestorageDict.get("""");
            }
        }
        if (cls == null)
            try {
                String fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"" + ((prefix == """") ? """" : (""-"" + prefix));
                InputStream is = getClass().getResourceAsStream(fileName);
                if (is == null) {
                    fileName = ""/nu/staldal/lagoon/filestorage/FileStorage"";
                    is = getClass().getResourceAsStream(fileName);
                    prefix = """";
                }
                if (is == null)
                    return null;
                BufferedReader br = new BufferedReader(new InputStreamReader(is));
                String className = br.readLine();
                br.close();
                if (className == null)
                    throw new LagoonException(""Illegal FileStorage config file: "" + fileName);
                String baseClassName = ""nu.staldal.lagoon.core.FileStorage"";
                try {
                    cls = Class.forName(className);
                    if (!Class.forName(baseClassName).isAssignableFrom(cls))
                        throw new LagoonException(""file storage class must derive from "" + baseClassName);
                    filestorageDict.put(prefix, cls);
                } catch (ClassNotFoundException e) {
                    throw new LagoonException(""FileStorage class cannot be found:"" + e.getMessage());
                }
            } catch (IOException e) {
                throw new LagoonException(""Unable to read producer config file: "" + e.toString());
            }
        try {
            return (FileStorage) cls.newInstance();
        } catch (IllegalAccessException e) {
            throw new LagoonException(""Unable to instantiate file storage class (illegal access): "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new LagoonException(""Unable to instantiate file storage class (instantiation failed): "" + e.getMessage());
        }
    }

    public boolean canCheckFileHasBeenUpdated(String url) {
        return !Utils.absoluteURL(url) || url.startsWith(""part:"") || url.startsWith(""file:"") || url.startsWith(""res:"");
    }

    public File getSourceRootDir() {
        return sourceRootDir;
    }

    public String getFileURLRelativeTo(String url, String base) {
        if (Utils.absoluteURL(url) || Utils.pseudoAbsoluteURL(url)) {
            return url;
        } else {
            if (!Utils.pseudoAbsoluteURL(base))
                throw new IllegalArgumentException(""base must be a pseudo-absolute URL"");
            int slash = base.lastIndexOf('/');
            String baseDir = base.substring(0, slash + 1);
            return baseDir + url;
        }
    }

    public String getProperty(String key) {
        return sitemap.getProperty(key);
    }
}
","// LagoonProcessor_0Test.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains ten unit test cases for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessor_0Test {","// LagoonProcessor_0Test.java
package nu.staldal.lagoon.core;

import java.io.*;
import java.util.*;
import nu.staldal.xtree.*;
import nu.staldal.util.Utils;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LagoonProcessor}.
* It contains ten unit test cases for the {@link LagoonProcessor#build(boolean)} method.
*/
class LagoonProcessor_0Test {
"
7fb1788a-2fc0-487b-8d1e-ff7ef2c513d9,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/FTPFileStorage_1Test.java,-1,"ERROR - Request timed out: HTTPSConnectionPool(host='api.openai.com', port=443): Read timed out. (read timeout=600)","// FTPFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;

/**
 * A FileStorage which transfers files to a remote site using FTP.
 *
 * <strong>Note:</strong> This class will transmit password in clear text over
 * the network.
 */
public class FTPFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private FTPClient ftp;

    private String url;

    private String password;

    /**
     * Default constructor.
     */
    public FTPFileStorage() {
    }

    public boolean needPassword() {
        return true;
    }

    public boolean isReentrant() {
        return false;
    }

    public void open(String url, LagoonContext context, String password) throws MalformedURLException, UnknownHostException, FTPException, IOException, AuthenticationException {
        this.url = url;
        this.password = password;
        ftp = new FTPClient(url, password);
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
        ftp.close();
        ftp = null;
    }

    /**
     * Create a new file, or overwrite an existing file.
     *
     * @param pathname  path to the file
     */
    public OutputHandler createFile(String pathname) throws IOException {
        OutputStream os;
        try {
            os = ftp.store(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            os = ftp.store(pathname);
        }
        return new FTPOutputHandler(pathname, os);
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param pathname  path to the file
     */
    public void deleteFile(String pathname) throws java.io.IOException {
        try {
            ftp.deleteFile(pathname);
        } catch (IOException e) {
            if (DEBUG)
                System.out.println(""FTP reconnecting: "" + e.toString());
            try {
                ftp.close();
            } catch (IOException ignore) {
            }
            ftp = new FTPClient(url, password);
            ftp.deleteFile(pathname);
        }
    }

    class FTPOutputHandler extends OutputHandler {

        private String currentPathname;

        FTPOutputHandler(String currentPathname, OutputStream out) {
            super(out);
            this.currentPathname = currentPathname;
        }

        public void commit() throws java.io.IOException {
            out.close();
            fileModified(currentPathname);
        }

        public void discard() throws java.io.IOException {
            try {
                commit();
            } catch (FTPException e) {
                // ignore exception
            }
            ftp.deleteFile(currentPathname);
        }
    }
}
","// FTPFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains ten unit test cases for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorage_1Test {","// FTPFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.*;
import nu.staldal.lagoon.core.*;
import nu.staldal.ftp.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link FTPFileStorage}.
* It contains ten unit test cases for the {@link FTPFileStorage#createFile(String)} method.
*/
class FTPFileStorage_1Test {
"
6a594c6f-fd41-40df-aa63-4603b9a7248e,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage_1Test.java,-1,"ERROR - Request timed out: HTTPSConnectionPool(host='api.openai.com', port=443): Read timed out. (read timeout=600)","// LocalFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    private File root;

    /**
     * Default constructor.
     */
    public LocalFileStorage() {
        root = null;
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {
        root = new File(loc);
        if (root.exists()) {
            if (!root.isDirectory())
                throw new IOException(""Location exists but is not a directory"");
        } else {
            if (!root.mkdir())
                throw new IOException(""Location didn't exist and couldn't be created"");
        }
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() // throws java.io.IOException;
    {
        root = null;
    }

    /**
     * Check if a file exists and when it was last modified.
     *
     * @param path  path to the file
     *
     * @return  the time when the file was last modified,
     * or -1 if that information is not avaliable,
     * or 0 if the file doesn't exists.
     */
    public long fileLastModified(String path) // throws java.io.IOException
    {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                return 0;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        return file.lastModified();
    }

    /**
     * Create a new file, or overwrite an existing file.
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                if (!file.mkdir())
                    throw new IOException(""Unable to create directory: "" + file);
            oldPos = pos + 1;
        }
        File currentFile = new File(file, path.substring(oldPos));
        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            // file doesn't exist
            if (!file.exists())
                return;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        if (!file.exists())
            return;
        if (file.delete()) {
            return;
        } else {
            throw new IOException(""Unable to delete file: "" + file);
        }
    }

    static class LocalOutputHandler extends OutputHandler {

        private File currentFile;

        LocalOutputHandler(File currentFile, OutputStream out) {
            super(out);
            this.currentFile = currentFile;
        }

        public void commit() throws java.io.IOException {
            out.close();
        }

        public void discard() throws java.io.IOException {
            out.close();
            if (!currentFile.exists())
                return;
            if (currentFile.delete()) {
                return;
            } else {
                throw new IOException(""Unable to delete file: "" + currentFile);
            }
        }
    }
}
","// LocalFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorage_1Test {","// LocalFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#fileLastModified(String)} method.
*/
class LocalFileStorage_1Test {
"
cmpl-6tvIeJpG7Z3m1hRtWmxTRdT8Wqxch,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/LocalFileStorage_2Test.java,45.7941517829895,length,"// LocalFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;

/**
 * A FileStorage using the local file system.
 */
public class LocalFileStorage implements FileStorage {

    private File root;

    /**
     * Default constructor.
     */
    public LocalFileStorage() {
        root = null;
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String loc, LagoonContext context, String password) throws java.io.IOException {
        root = new File(loc);
        if (root.exists()) {
            if (!root.isDirectory())
                throw new IOException(""Location exists but is not a directory"");
        } else {
            if (!root.mkdir())
                throw new IOException(""Location didn't exist and couldn't be created"");
        }
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() // throws java.io.IOException;
    {
        root = null;
    }

    /**
     * Check if a file exists and when it was last modified.
     *
     * @param path  path to the file
     *
     * @return  the time when the file was last modified,
     * or -1 if that information is not avaliable,
     * or 0 if the file doesn't exists.
     */
    public long fileLastModified(String path) // throws java.io.IOException
    {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                return 0;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        return file.lastModified();
    }

    /**
     * Create a new file, or overwrite an existing file.
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            if (!file.exists())
                if (!file.mkdir())
                    throw new IOException(""Unable to create directory: "" + file);
            oldPos = pos + 1;
        }
        File currentFile = new File(file, path.substring(oldPos));
        return new LocalOutputHandler(currentFile, new FileOutputStream(currentFile));
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        File file = root;
        int oldPos = 1;
        int pos;
        while (true) {
            pos = path.indexOf('/', oldPos);
            if (pos < 0)
                break;
            String comp = path.substring(oldPos, pos);
            file = new File(file, comp);
            // file doesn't exist
            if (!file.exists())
                return;
            oldPos = pos + 1;
        }
        file = new File(file, path.substring(oldPos));
        if (!file.exists())
            return;
        if (file.delete()) {
            return;
        } else {
            throw new IOException(""Unable to delete file: "" + file);
        }
    }

    static class LocalOutputHandler extends OutputHandler {

        private File currentFile;

        LocalOutputHandler(File currentFile, OutputStream out) {
            super(out);
            this.currentFile = currentFile;
        }

        public void commit() throws java.io.IOException {
            out.close();
        }

        public void discard() throws java.io.IOException {
            out.close();
            if (!currentFile.exists())
                return;
            if (currentFile.delete()) {
                return;
            } else {
                throw new IOException(""Unable to delete file: "" + currentFile);
            }
        }
    }
}
","// LocalFileStorage_2Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#createFile(String)} method.
*/
class LocalFileStorage_2Test {","// LocalFileStorage_2Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#createFile(String)} method.
*/
class LocalFileStorage_2Test {

	/**
	* Test case 1 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_1() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 2 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_2() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 3 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_3() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 4 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_4() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 5 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_5() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 6 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_6() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 7 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_7() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 8 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_8() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 9 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_9() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
	
	/**
	* Test case 10 for {@link LocalFileStorage#createFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testCreateFile_10() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		OutputHandler outputHandler = localFileStorage.createFile(""testfile"");
		outputHandler.commit();
		localFileStorage.close();
		assertTrue(new File(""test/nu/staldal/lagoon/filestorage/testdir/testfile"").exists());
	}
}

// LocalFileStorage_3Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import nu.staldal.lagoon.core.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link LocalFileStorage}.
* It contains ten unit test cases for the {@link LocalFileStorage#deleteFile(String)} method.
*/
class LocalFileStorage_3Test {
		
	/**
	* Test case 1 for {@link LocalFileStorage#deleteFile(String)}
	*
	* @throws IOException
	*/
	@Test
	void testDeleteFile_1() throws IOException {
		LocalFileStorage localFileStorage = new LocalFileStorage();
		localFileStorage.open(""test/nu/staldal/lagoon/filestorage/testdir"", null, null);
		localFileStorage.deleteFile(""testfile"");
		localFileStorage.close();
		assertFalse(new File(""test/nu/staldal/lagoon/filestorage/testdir"
cmpl-6tvJhXoQ44QVmh3UWorNIlVq0YehI,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/filestorage/SSHFileStorage_1Test.java,33.15588092803955,stop,"// SSHFileStorage.java
/*
 * Copyright (c) 2001-2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;

/**
 * A FileStorage which transfers files to a remote site using SSH.
 */
public class SSHFileStorage extends RemoteFileStorage {

    private static final boolean DEBUG = false;

    private String host;

    private int port;

    private String username;

    private String rootPath;

    private Runtime rt;

    private Process runSSH(String[] command) throws IOException {
        String[] cmdline = new String[command.length + ((port > 0) ? 9 : 7)];
        cmdline[0] = ""ssh"";
        cmdline[1] = ""-q"";
        cmdline[2] = ""-e"";
        cmdline[3] = ""none"";
        cmdline[4] = ""-l"";
        cmdline[5] = username;
        if (port > 0) {
            cmdline[6] = ""-p"";
            cmdline[7] = Integer.toString(port);
        }
        cmdline[(port > 0) ? 8 : 6] = host;
        System.arraycopy(command, 0, cmdline, ((port > 0) ? 9 : 7), command.length);
        if (DEBUG) {
            System.out.println(""Executing: "");
            for (int i = 0; i < cmdline.length; i++) System.out.println(cmdline[i]);
            System.out.println();
        }
        return rt.exec(cmdline);
    }

    /**
     * Default constructor.
     */
    public SSHFileStorage() {
    }

    public boolean needPassword() {
        return false;
    }

    public boolean isReentrant() {
        return true;
    }

    public void open(String url, LagoonContext context, String passoword) throws MalformedURLException, IOException {
        if (!url.startsWith(""ssh://""))
            throw new MalformedURLException(url);
        int userPos = 5;
        int hostPos = url.lastIndexOf('@');
        if (hostPos < 0)
            throw new MalformedURLException(url);
        int portPos = url.indexOf(':', hostPos + 1);
        int pathPos = url.indexOf('/', ((portPos < 0) ? hostPos : portPos) + 1);
        String path;
        try {
            username = url.substring(userPos + 1, hostPos);
            host = url.substring(hostPos + 1, (portPos < 0) ? pathPos : portPos);
            port = (portPos < 0) ? 0 : Integer.parseInt(url.substring(portPos + 1, pathPos));
            path = url.substring(pathPos + 1);
        } catch (NumberFormatException e) {
            throw new MalformedURLException(url);
        }
        if (port < 0 || port > 65535 || username.length() < 1 || host.length() < 1 || (path.length() > 0 && path.charAt(path.length() - 1) != '/'))
            throw new MalformedURLException(url);
        if ((path.length() == 0) || (path.charAt(path.length() - 1) != '/')) {
            this.rootPath = path;
        } else {
            this.rootPath = path.substring(0, path.length() - 1);
        }
        this.rt = Runtime.getRuntime();
        openDateFile(context);
    }

    /**
     * Close the file system and release any resources it holds.
     *
     * After this method has been invoked, no other method may be invoked.
     */
    public void close() throws IOException {
        closeDateFile();
    }

    /**
     * Create a new file, or overwrite an existing file.
     * Use close() on the returned OutputStream when finished
     * writing to the file, and then commitFile() or discardFile()
     * on the FileStorage.
     *
     * @param path  path to the file
     *
     * @return an OutputStream to write to
     *
     * @see #commitFile
     * @see #discardFile
     */
    public OutputHandler createFile(String path) throws java.io.IOException {
        String currentPath = path;
        String s = rootPath + path;
        int i = s.lastIndexOf('/');
        String dir = (i < 0) ? ""."" : s.substring(0, i);
        if (DEBUG)
            System.out.println(""dir: "" + dir);
        Process currentProc = runSSH(new String[] { ""mkdir"", ""-p"", dir, ""&&"", ""rm"", ""-f"", rootPath + path, ""&&"", ""cat"", "">"" + rootPath + path });
        return new SSHOutputHandler(currentPath, currentProc, currentProc.getOutputStream());
    }

    /**
     * Deletes a file.
     * Does not signal any error if the file doesn't exist.
     *
     * @param path  path to the file
     */
    public void deleteFile(String path) throws java.io.IOException {
        Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + path });
        proc.getOutputStream().close();
        try {
            proc.waitFor();
        } catch (InterruptedException e) {
        }
    }

    class SSHOutputHandler extends OutputHandler {

        private String currentPath;

        private Process currentProc;

        SSHOutputHandler(String currentPath, Process currentProc, OutputStream out) {
            super(out);
            this.currentPath = currentPath;
            this.currentProc = currentProc;
        }

        public void commit() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            fileModified(currentPath);
        }

        public void discard() throws java.io.IOException {
            out.close();
            try {
                currentProc.waitFor();
            } catch (InterruptedException e) {
            }
            Process proc = runSSH(new String[] { ""rm"", ""-f"", rootPath + currentPath });
            proc.getOutputStream().close();
            try {
                proc.waitFor();
            } catch (InterruptedException e) {
            }
        }
    }
}
","// SSHFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains ten unit test cases for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorage_1Test {","// SSHFileStorage_1Test.java
package nu.staldal.lagoon.filestorage;

import java.io.*;
import java.net.MalformedURLException;
import nu.staldal.lagoon.core.FileStorage;
import nu.staldal.lagoon.core.OutputHandler;
import nu.staldal.lagoon.core.RemoteFileStorage;
import nu.staldal.lagoon.core.LagoonContext;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SSHFileStorage}.
* It contains ten unit test cases for the {@link SSHFileStorage#createFile(String)} method.
*/
class SSHFileStorage_1Test {

		@Test
		void testCase1() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase2() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase3() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase4() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase5() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase6() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase7() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase8() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase9() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.commit();
				sshFileStorage0.close();
		}
		
		@Test
		void testCase10() throws MalformedURLException, IOException {
				SSHFileStorage sshFileStorage0 = new SSHFileStorage();
				sshFileStorage0.open(""ssh://user@host:80/path/"", (LagoonContext) null, """");
				OutputHandler outputHandler0 = sshFileStorage0.createFile("""");
				outputHandler0.discard();
				sshFileStorage0.close();
		}
}"
cmpl-6tvKkL7uaoR9qYAmDLebjASTbE1Vl,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_0Test.java,45.73508024215698,stop,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {","// Wildcard_0Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#isWildcard(String)} method.
*/
class Wildcard_0Test {

	@Test
	void testIsWildcard_0() {
		assertTrue(Wildcard.isWildcard(""*""));
	}
	
	@Test
	void testIsWildcard_1() {
		assertTrue(Wildcard.isWildcard(""*.html""));
	}
	
	@Test
	void testIsWildcard_2() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml""));
	}
	
	@Test
	void testIsWildcard_3() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt""));
	}
	
	@Test
	void testIsWildcard_4() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl""));
	}
	
	@Test
	void testIsWildcard_5() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css""));
	}
	
	@Test
	void testIsWildcard_6() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js""));
	}
	
	@Test
	void testIsWildcard_7() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg""));
	}
	
	@Test
	void testIsWildcard_8() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif""));
	}
	
	@Test
	void testIsWildcard_9() {
		assertTrue(Wildcard.isWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif;*.png""));
	}
}

// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {
		
	@Test
	void testMatchWildcard_0() {
		assertEquals("""", Wildcard.matchWildcard(""*"", """"));
	}
	
	@Test
	void testMatchWildcard_1() {
		assertEquals("""", Wildcard.matchWildcard(""*.html"", """"));
	}
	
	@Test
	void testMatchWildcard_2() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml"", """"));
	}
	
	@Test
	void testMatchWildcard_3() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt"", """"));
	}
	
	@Test
	void testMatchWildcard_4() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl"", """"));
	}
	
	@Test
	void testMatchWildcard_5() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css"", """"));
	}
	
	@Test
	void testMatchWildcard_6() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js"", """"));
	}
	
	@Test
	void testMatchWildcard_7() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg"", """"));
	}
	
	@Test
	void testMatchWildcard_8() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif"", """"));
	}
	
	@Test
	void testMatchWildcard_9() {
		assertEquals("""", Wildcard.matchWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif;*.png"", """"));
	}
}

// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {
		
	@Test
	void testInstantiateWildcard_0() {
		assertEquals("""", Wildcard.instantiateWildcard(""*"", """"));
	}
	
	@Test
	void testInstantiateWildcard_1() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html"", """"));
	}
	
	@Test
	void testInstantiateWildcard_2() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml"", """"));
	}
	
	@Test
	void testInstantiateWildcard_3() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt"", """"));
	}
	
	@Test
	void testInstantiateWildcard_4() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl"", """"));
	}
	
	@Test
	void testInstantiateWildcard_5() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css"", """"));
	}
	
	@Test
	void testInstantiateWildcard_6() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js"", """"));
	}
	
	@Test
	void testInstantiateWildcard_7() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg"", """"));
	}
	
	@Test
	void testInstantiateWildcard_8() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif"", """"));
	}
	
	@Test
	void testInstantiateWildcard_9() {
		assertEquals("""", Wildcard.instantiateWildcard(""*.html;*.xml;*.txt;*.xsl;*.css;*.js;*.jpg;*.gif;*.png"", """"));
	}
}"
cmpl-6tvLnbnjcXBUa13NkN8kmHintz3UB,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_1Test.java,49.95353722572327,length,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {","// Wildcard_1Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_1Test {

	/**
	 * Test case 1 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 1 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html"".
	 * The method should return the string ""index"".
	 */
	@Test
	void testMatchWildcard_1() {
		String pattern = ""*.html"";
		String filename = ""index.html"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals(""index"", result);
	}
	
	/**
	 * Test case 2 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 2 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.htm"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_2() {
		String pattern = ""*.html"";
		String filename = ""index.htm"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 3 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 3 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_3() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 4 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 4 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_4() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 5 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 5 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_5() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 6 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 6 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_6() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 7 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 7 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_7() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 8 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 8 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_8() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 9 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 9 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_9() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 10 for {@link Wildcard#matchWildcard(String, String)}.
	 * <p>
	 * Test case 10 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html.bak"".
	 * The method should return null.
	 */
	@Test
	void testMatchWildcard_10() {
		String pattern = ""*.html"";
		String filename = ""index.html.bak"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
}

// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {
		
	/**
	 * Test case 1 for {@link Wildcard#instantiateWildcard(String, String)}.
	 * <p>
	 * Test case 1 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.html"".
	 * The method should return the string ""index"".
	 */
	@Test
	void testInstantiateWildcard_1() {
		String pattern = ""*.html"";
		String filename = ""index.html"";
		String result = Wildcard.instantiateWildcard(pattern, filename);
		assertEquals(""index"", result);
	}
	
	/**
	 * Test case 2 for {@link Wildcard#instantiateWildcard(String, String)}.
	 * <p>
	 * Test case 2 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"" and the filename is ""index.htm"".
	 * The method should return null.
	 */
	@Test
	void testInstantiateWildcard_2() {
		String pattern = ""*.html"";
		String filename = ""index.htm"";
		String result = Wildcard.instantiateWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	 * Test case 3 for {@link Wildcard#instantiateWildcard(String, String)}.
	 * <p>
	 * Test case 3 tests the method with a pattern that contains a wildcard.
	 * The pattern is ""*.html"
cmpl-6tvMqwsaV32nrZpNKRkRhEZUPGchY,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/lagoon/util/Wildcard_2Test.java,39.04743242263794,length,"// Wildcard.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.lagoon.util;

import java.util.*;

/**
 * Wildcard processing methods. All methods in this class are static.
 *
 * A wildcard pattern consists of one or more simple patterns, separated by ';'.
 * A simple pattern may contain one '*' which match any string
 * (including the empty string).
 */
public final class Wildcard {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Wildcard() {
    }

    /**
     * Check if a wildcard pattern can possibly match more than one filename.
     *
     * @param pattern  the wildcard pattern to test
     */
    public static boolean isWildcard(String pattern) {
        return (pattern.indexOf('*') >= 0) || (pattern.indexOf(';') >= 0);
    }

    /**
     * Attempt to match a filename matches to wildcard pattern.
     *
     * @param pattern   the wildcard pattern
     * @param filename  the filename
     *
     * @return the string substituted into the pattern,
     *         or null if no match could be made
     */
    public static String matchWildcard(String pattern, String filename) {
        StringTokenizer st = new StringTokenizer(pattern, "";"");
        while (st.hasMoreTokens()) {
            String pat = st.nextToken();
            int star = pat.indexOf('*');
            if (star < 0) {
                if (pat.equals(filename))
                    return """";
            } else {
                if (!filename.startsWith(pat.substring(0, star)))
                    continue;
                if (!filename.endsWith(pat.substring(star + 1)))
                    continue;
                return filename.substring(star, star + filename.length() - pat.length() + 1);
            }
        }
        return null;
    }

    /**
     * Instantiate a wildcard pattern to a filename.
     *
     * @param pattern   the wildcard pattern
     * @param part      the string to substitue into the pattern
     *                  (returned from matchWildcard)
     *
     * @return  the filename
     *
     * @see #matchWildcard
     */
    public static String instantiateWildcard(String pattern, String part) {
        int star = pattern.indexOf('*');
        if (star < 0)
            return pattern;
        return pattern.substring(0, star) + part + pattern.substring(star + 1);
    }
}
","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {","// Wildcard_2Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#instantiateWildcard(String, String)} method.
*/
class Wildcard_2Test {

	/**
	* Test case 1 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_1() {
		String pattern = """";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals("""", result);
	}
	
	/**
	* Test case 2 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_2() {
		String pattern = ""*"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals("""", result);
	}
	
	/**
	* Test case 3 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_3() {
		String pattern = ""*"";
		String part = ""a"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 4 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_4() {
		String pattern = ""a*"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 5 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_5() {
		String pattern = ""a*"";
		String part = ""b"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""ab"", result);
	}
	
	/**
	* Test case 6 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_6() {
		String pattern = ""*a"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 7 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_7() {
		String pattern = ""*a"";
		String part = ""b"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""ba"", result);
	}
	
	/**
	* Test case 8 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_8() {
		String pattern = ""a*b"";
		String part = """";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""ab"", result);
	}
	
	/**
	* Test case 9 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_9() {
		String pattern = ""a*b"";
		String part = ""c"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""acb"", result);
	}
	
	/**
	* Test case 10 for {@link Wildcard#instantiateWildcard(String, String)}.
	*/
	@Test
	void testInstantiateWildcard_10() {
		String pattern = ""a*b*c"";
		String part = ""d"";
		String result = Wildcard.instantiateWildcard(pattern, part);
		assertEquals(""adb*c"", result);
	}
}

// Wildcard_3Test.java
package nu.staldal.lagoon.util;

import java.util.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Wildcard}.
* It contains ten unit test cases for the {@link Wildcard#matchWildcard(String, String)} method.
*/
class Wildcard_3Test {
		
	/**
	* Test case 1 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_1() {
		String pattern = """";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 2 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_2() {
		String pattern = """";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 3 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_3() {
		String pattern = ""a"";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 4 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_4() {
		String pattern = ""a"";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 5 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_5() {
		String pattern = ""a"";
		String filename = ""b"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 6 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_6() {
		String pattern = ""*"";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 7 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_7() {
		String pattern = ""*"";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals(""a"", result);
	}
	
	/**
	* Test case 8 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_8() {
		String pattern = ""a*"";
		String filename = """";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertNull(result);
	}
	
	/**
	* Test case 9 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_9() {
		String pattern = ""a*"";
		String filename = ""a"";
		String result = Wildcard.matchWildcard(pattern, filename);
		assertEquals("""", result);
	}
	
	/**
	* Test case 10 for {@link Wildcard#matchWildcard(String, String)}.
	*/
	@Test
	void testMatchWildcard_10() {
		String pattern = ""a*"";
		String filename = """
cmpl-6tvNtyPT5WfgERFrRbdnOMOW8jhTY,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/Utils_0Test.java,50.41788172721863,length,"// Utils.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.util;

/**
 * Some utility methods. All methods in this class are static.
 */
public final class Utils {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Utils() {
    }

    /**
     * Encode a path name or URL into a filename.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePath(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        for (int i = 0; i < path.length(); i++) {
            char c = path.charAt(i);
            switch(c) {
                case '-':
                    sb.append(""--"");
                    break;
                case '_':
                    sb.append(""__"");
                    break;
                case '$':
                    sb.append(""$$"");
                    break;
                case '~':
                    sb.append(""~~"");
                    break;
                case '/':
                    sb.append('-');
                    break;
                case '\\':
                    sb.append('-');
                    break;
                case '*':
                    sb.append('_');
                    break;
                case '?':
                    sb.append('$');
                    break;
                case ':':
                    sb.append('~');
                    break;
                default:
                    sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Encode a path name or URL into a Java identifier.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePathAsIdentifier(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        char c = path.charAt(0);
        if (Character.isJavaIdentifierStart(c))
            sb.append(c);
        else
            sb.append(""_"" + ((int) c) + ""_"");
        for (int i = 1; i < path.length(); i++) {
            c = path.charAt(i);
            if (Character.isJavaIdentifierPart(c))
                sb.append(c);
            else
                sb.append(""_"" + ((int) c) + ""_"");
        }
        return sb.toString();
    }

    /**
     * Check whether an URL is absolute.
     * Returns true if the URL contains at least one colon, and
     * the first colon is before the first slash (if any).
     */
    public static boolean absoluteURL(String url) {
        int colon = url.indexOf(':');
        if (colon < 0)
            return false;
        int slash = url.indexOf('/');
        if (slash < 0)
            return true;
        return colon < slash;
    }

    /**
     * Check whether an URL is pseudo-absolute.
     * Returns true if the URL start with a slash.
     */
    public static boolean pseudoAbsoluteURL(String url) {
        return (url.length() > 0) && (url.charAt(0) == '/');
    }

    /**
     * Generate a {@link java.lang.String} with a specified number
     * of a given character.
     */
    public static String nChars(int n, char c) {
        StringBuffer sb = new StringBuffer(n);
        for (int i = 0; i < n; i++) sb.append(c);
        return sb.toString();
    }
}
","// Utils_0Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePath(String)} method.
*/
class Utils_0Test {","// Utils_0Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePath(String)} method.
*/
class Utils_0Test {

	@Test
	void testEncodePath_0() {
		String path = """";
		String result = Utils.encodePath(path);
		assertEquals("""", result);
	}
	
	@Test
	void testEncodePath_1() {
		String path = ""a"";
		String result = Utils.encodePath(path);
		assertEquals(""a"", result);
	}
	
	@Test
	void testEncodePath_2() {
		String path = ""ab"";
		String result = Utils.encodePath(path);
		assertEquals(""ab"", result);
	}
	
	@Test
	void testEncodePath_3() {
		String path = ""abc"";
		String result = Utils.encodePath(path);
		assertEquals(""abc"", result);
	}
	
	@Test
	void testEncodePath_4() {
		String path = ""abcd"";
		String result = Utils.encodePath(path);
		assertEquals(""abcd"", result);
	}
	
	@Test
	void testEncodePath_5() {
		String path = ""abcde"";
		String result = Utils.encodePath(path);
		assertEquals(""abcde"", result);
	}
	
	@Test
	void testEncodePath_6() {
		String path = ""abcdef"";
		String result = Utils.encodePath(path);
		assertEquals(""abcdef"", result);
	}
	
	@Test
	void testEncodePath_7() {
		String path = ""abcdefg"";
		String result = Utils.encodePath(path);
		assertEquals(""abcdefg"", result);
	}
	
	@Test
	void testEncodePath_8() {
		String path = ""abcdefgh"";
		String result = Utils.encodePath(path);
		assertEquals(""abcdefgh"", result);
	}
	
	@Test
	void testEncodePath_9() {
		String path = ""abcdefghi"";
		String result = Utils.encodePath(path);
		assertEquals(""abcdefghi"", result);
	}
	
}

// Utils_1Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_1Test {
		
	@Test
	void testEncodePathAsIdentifier_0() {
		String path = """";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals("""", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_1() {
		String path = ""a"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""a"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_2() {
		String path = ""ab"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""ab"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_3() {
		String path = ""abc"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""abc"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_4() {
		String path = ""abcd"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""abcd"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_5() {
		String path = ""abcde"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""abcde"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_6() {
		String path = ""abcdef"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""abcdef"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_7() {
		String path = ""abcdefg"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""abcdefg"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_8() {
		String path = ""abcdefgh"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""abcdefgh"", result);
	}
	
	@Test
	void testEncodePathAsIdentifier_9() {
		String path = ""abcdefghi"";
		String result = Utils.encodePathAsIdentifier(path);
		assertEquals(""abcdefghi"", result);
	}
	
}

// Utils_2Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#absoluteURL(String)} method.
*/
class Utils_2Test {
		
	@Test
	void testAbsoluteURL_0() {
		String url = """";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_1() {
		String url = ""a"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_2() {
		String url = ""ab"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_3() {
		String url = ""abc"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_4() {
		String url = ""abcd"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_5() {
		String url = ""abcde"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_6() {
		String url = ""abcdef"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_7() {
		String url = ""abcdefg"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_8() {
		String url = ""abcdefgh"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
	@Test
	void testAbsoluteURL_9() {
		String url = ""abcdefghi"";
		boolean result = Utils.absoluteURL(url);
		assertEquals(false, result);
	}
	
}

// Utils_3Test.java
package nu.staldal.util;


import org.junit.j"
cmpl-6tvOwzpMkehxB7uipkAcv3wh1NReE,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/Utils_1Test.java,46.666935443878174,length,"// Utils.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.util;

/**
 * Some utility methods. All methods in this class are static.
 */
public final class Utils {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Utils() {
    }

    /**
     * Encode a path name or URL into a filename.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePath(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        for (int i = 0; i < path.length(); i++) {
            char c = path.charAt(i);
            switch(c) {
                case '-':
                    sb.append(""--"");
                    break;
                case '_':
                    sb.append(""__"");
                    break;
                case '$':
                    sb.append(""$$"");
                    break;
                case '~':
                    sb.append(""~~"");
                    break;
                case '/':
                    sb.append('-');
                    break;
                case '\\':
                    sb.append('-');
                    break;
                case '*':
                    sb.append('_');
                    break;
                case '?':
                    sb.append('$');
                    break;
                case ':':
                    sb.append('~');
                    break;
                default:
                    sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Encode a path name or URL into a Java identifier.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePathAsIdentifier(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        char c = path.charAt(0);
        if (Character.isJavaIdentifierStart(c))
            sb.append(c);
        else
            sb.append(""_"" + ((int) c) + ""_"");
        for (int i = 1; i < path.length(); i++) {
            c = path.charAt(i);
            if (Character.isJavaIdentifierPart(c))
                sb.append(c);
            else
                sb.append(""_"" + ((int) c) + ""_"");
        }
        return sb.toString();
    }

    /**
     * Check whether an URL is absolute.
     * Returns true if the URL contains at least one colon, and
     * the first colon is before the first slash (if any).
     */
    public static boolean absoluteURL(String url) {
        int colon = url.indexOf(':');
        if (colon < 0)
            return false;
        int slash = url.indexOf('/');
        if (slash < 0)
            return true;
        return colon < slash;
    }

    /**
     * Check whether an URL is pseudo-absolute.
     * Returns true if the URL start with a slash.
     */
    public static boolean pseudoAbsoluteURL(String url) {
        return (url.length() > 0) && (url.charAt(0) == '/');
    }

    /**
     * Generate a {@link java.lang.String} with a specified number
     * of a given character.
     */
    public static String nChars(int n, char c) {
        StringBuffer sb = new StringBuffer(n);
        for (int i = 0; i < n; i++) sb.append(c);
        return sb.toString();
    }
}
","// Utils_1Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_1Test {","// Utils_1Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_1Test {

	/**
	 * Test method for {@link Utils#encodePathAsIdentifier(String)}.
	 */
	@Test
	void testEncodePathAsIdentifier() {
		assertEquals(""a"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
	}
}

// Utils_2Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_2Test {
		
	/**
	 * Test method for {@link Utils#encodePathAsIdentifier(String)}.
	 */
	@Test
	void testEncodePathAsIdentifier() {
		assertEquals(""a"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
	}
}

// Utils_3Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_3Test {
		
	/**
	 * Test method for {@link Utils#encodePathAsIdentifier(String)}.
	 */
	@Test
	void testEncodePathAsIdentifier() {
		assertEquals(""a"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
	}
}

// Utils_4Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_4Test {
		
	/**
	 * Test method for {@link Utils#encodePathAsIdentifier(String)}.
	 */
	@Test
	void testEncodePathAsIdentifier() {
		assertEquals(""a"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
	}
}

// Utils_5Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_5Test {
		
	/**
	 * Test method for {@link Utils#encodePathAsIdentifier(String)}.
	 */
	@Test
	void testEncodePathAsIdentifier() {
		assertEquals(""a"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
		assertEquals(""_97_"", Utils.encodePathAsIdentifier(""a""));
	}
}

// Utils_6Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePathAsIdentifier(String)} method.
*/
class Utils_6Test {
		
	/**
	 * Test method for {@link Utils#encodePathAsIdentifier(String)}.
	 */
	"
cmpl-6tvPz0pwgzFQObHSuWHkP3caYMxVq,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/Utils_2Test.java,50.458717584609985,length,"// Utils.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.util;

/**
 * Some utility methods. All methods in this class are static.
 */
public final class Utils {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Utils() {
    }

    /**
     * Encode a path name or URL into a filename.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePath(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        for (int i = 0; i < path.length(); i++) {
            char c = path.charAt(i);
            switch(c) {
                case '-':
                    sb.append(""--"");
                    break;
                case '_':
                    sb.append(""__"");
                    break;
                case '$':
                    sb.append(""$$"");
                    break;
                case '~':
                    sb.append(""~~"");
                    break;
                case '/':
                    sb.append('-');
                    break;
                case '\\':
                    sb.append('-');
                    break;
                case '*':
                    sb.append('_');
                    break;
                case '?':
                    sb.append('$');
                    break;
                case ':':
                    sb.append('~');
                    break;
                default:
                    sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Encode a path name or URL into a Java identifier.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePathAsIdentifier(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        char c = path.charAt(0);
        if (Character.isJavaIdentifierStart(c))
            sb.append(c);
        else
            sb.append(""_"" + ((int) c) + ""_"");
        for (int i = 1; i < path.length(); i++) {
            c = path.charAt(i);
            if (Character.isJavaIdentifierPart(c))
                sb.append(c);
            else
                sb.append(""_"" + ((int) c) + ""_"");
        }
        return sb.toString();
    }

    /**
     * Check whether an URL is absolute.
     * Returns true if the URL contains at least one colon, and
     * the first colon is before the first slash (if any).
     */
    public static boolean absoluteURL(String url) {
        int colon = url.indexOf(':');
        if (colon < 0)
            return false;
        int slash = url.indexOf('/');
        if (slash < 0)
            return true;
        return colon < slash;
    }

    /**
     * Check whether an URL is pseudo-absolute.
     * Returns true if the URL start with a slash.
     */
    public static boolean pseudoAbsoluteURL(String url) {
        return (url.length() > 0) && (url.charAt(0) == '/');
    }

    /**
     * Generate a {@link java.lang.String} with a specified number
     * of a given character.
     */
    public static String nChars(int n, char c) {
        StringBuffer sb = new StringBuffer(n);
        for (int i = 0; i < n; i++) sb.append(c);
        return sb.toString();
    }
}
","// Utils_2Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#absoluteURL(String)} method.
*/
class Utils_2Test {","// Utils_2Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#absoluteURL(String)} method.
*/
class Utils_2Test {

	@Test
	void testAbsoluteURL_1() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/""));
	}
	
	@Test
	void testAbsoluteURL_2() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html""));
	}
	
	@Test
	void testAbsoluteURL_3() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html#fragment""));
	}
	
	@Test
	void testAbsoluteURL_4() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html?query""));
	}
	
	@Test
	void testAbsoluteURL_5() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html?query#fragment""));
	}
	
	@Test
	void testAbsoluteURL_6() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html?query#fragment?query""));
	}
	
	@Test
	void testAbsoluteURL_7() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html?query#fragment?query#fragment""));
	}
	
	@Test
	void testAbsoluteURL_8() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html?query#fragment?query#fragment?query""));
	}
	
	@Test
	void testAbsoluteURL_9() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html?query#fragment?query#fragment?query#fragment""));
	}
	
	@Test
	void testAbsoluteURL_10() {
		assertTrue(Utils.absoluteURL(""http://www.example.com/index.html?query#fragment?query#fragment?query#fragment?query""));
	}
}

// Utils_3Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#pseudoAbsoluteURL(String)} method.
*/
class Utils_3Test {
		
	@Test
	void testPseudoAbsoluteURL_1() {
		assertTrue(Utils.pseudoAbsoluteURL(""/""));
	}
	
	@Test
	void testPseudoAbsoluteURL_2() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html""));
	}
	
	@Test
	void testPseudoAbsoluteURL_3() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html#fragment""));
	}
	
	@Test
	void testPseudoAbsoluteURL_4() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html?query""));
	}
	
	@Test
	void testPseudoAbsoluteURL_5() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html?query#fragment""));
	}
	
	@Test
	void testPseudoAbsoluteURL_6() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html?query#fragment?query""));
	}
	
	@Test
	void testPseudoAbsoluteURL_7() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html?query#fragment?query#fragment""));
	}
	
	@Test
	void testPseudoAbsoluteURL_8() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html?query#fragment?query#fragment?query""));
	}
	
	@Test
	void testPseudoAbsoluteURL_9() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html?query#fragment?query#fragment?query#fragment""));
	}
	
	@Test
	void testPseudoAbsoluteURL_10() {
		assertTrue(Utils.pseudoAbsoluteURL(""/index.html?query#fragment?query#fragment?query#fragment?query""));
	}
}

// Utils_4Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#nChars(int, char)} method.
*/
class Utils_4Test {
		
	@Test
	void testNChars_1() {
		assertEquals("""", Utils.nChars(0, 'a'));
	}
	
	@Test
	void testNChars_2() {
		assertEquals(""a"", Utils.nChars(1, 'a'));
	}
	
	@Test
	void testNChars_3() {
		assertEquals(""aa"", Utils.nChars(2, 'a'));
	}
	
	@Test
	void testNChars_4() {
		assertEquals(""aaa"", Utils.nChars(3, 'a'));
	}
	
	@Test
	void testNChars_5() {
		assertEquals(""aaaa"", Utils.nChars(4, 'a'));
	}
	
	@Test
	void testNChars_6() {
		assertEquals(""aaaaa"", Utils.nChars(5, 'a'));
	}
	
	@Test
	void testNChars_7() {
		assertEquals(""aaaaaa"", Utils.nChars(6, 'a'));
	}
	
	@Test
	void testNChars_8() {
		assertEquals(""aaaaaaa"", Utils.nChars(7, 'a'));
	}
	
	@Test
	void testNChars_9() {
		assertEquals(""aaaaaaaa"", Utils.nChars(8, 'a'));
	}
	
	@Test
	void testNChars_10() {
		assertEquals(""aaaaaaaaa"", Utils.nChars(9, 'a'));
	}
}

// Utils_5Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#encodePath(String)} method.
*/
class Utils_5Test {
		
	@Test
	void testEncodePath_1() {
		assertEquals("""", Utils.encodePath(""""));
	}
	
	@Test
	void testEncodePath_2() {
		assertEquals(""a"", Utils.encodePath(""a""));
	}
	
	@Test
	void testEncodePath_3() {
		assertEquals(""aa"", Utils.encodePath(""aa""));
	}
	
	@Test
	void testEncodePath_4() {
		assertEquals(""aaa"", Utils.encodePath(""aaa""));
	}
	
	@Test
	void testEncodePath_5() {
		assertEquals(""aaaa"", Utils.encodePath(""aaaa""));
	}
	
	@Test
	void testEncodePath_6()"
cmpl-6tvR23gjj1LiV8YIB99EWXpvPg2js,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/Utils_3Test.java,42.31980514526367,length,"// Utils.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.util;

/**
 * Some utility methods. All methods in this class are static.
 */
public final class Utils {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Utils() {
    }

    /**
     * Encode a path name or URL into a filename.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePath(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        for (int i = 0; i < path.length(); i++) {
            char c = path.charAt(i);
            switch(c) {
                case '-':
                    sb.append(""--"");
                    break;
                case '_':
                    sb.append(""__"");
                    break;
                case '$':
                    sb.append(""$$"");
                    break;
                case '~':
                    sb.append(""~~"");
                    break;
                case '/':
                    sb.append('-');
                    break;
                case '\\':
                    sb.append('-');
                    break;
                case '*':
                    sb.append('_');
                    break;
                case '?':
                    sb.append('$');
                    break;
                case ':':
                    sb.append('~');
                    break;
                default:
                    sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Encode a path name or URL into a Java identifier.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePathAsIdentifier(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        char c = path.charAt(0);
        if (Character.isJavaIdentifierStart(c))
            sb.append(c);
        else
            sb.append(""_"" + ((int) c) + ""_"");
        for (int i = 1; i < path.length(); i++) {
            c = path.charAt(i);
            if (Character.isJavaIdentifierPart(c))
                sb.append(c);
            else
                sb.append(""_"" + ((int) c) + ""_"");
        }
        return sb.toString();
    }

    /**
     * Check whether an URL is absolute.
     * Returns true if the URL contains at least one colon, and
     * the first colon is before the first slash (if any).
     */
    public static boolean absoluteURL(String url) {
        int colon = url.indexOf(':');
        if (colon < 0)
            return false;
        int slash = url.indexOf('/');
        if (slash < 0)
            return true;
        return colon < slash;
    }

    /**
     * Check whether an URL is pseudo-absolute.
     * Returns true if the URL start with a slash.
     */
    public static boolean pseudoAbsoluteURL(String url) {
        return (url.length() > 0) && (url.charAt(0) == '/');
    }

    /**
     * Generate a {@link java.lang.String} with a specified number
     * of a given character.
     */
    public static String nChars(int n, char c) {
        StringBuffer sb = new StringBuffer(n);
        for (int i = 0; i < n; i++) sb.append(c);
        return sb.toString();
    }
}
","// Utils_3Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#pseudoAbsoluteURL(String)} method.
*/
class Utils_3Test {","// Utils_3Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#pseudoAbsoluteURL(String)} method.
*/
class Utils_3Test {

		/**
		 * Test case 1 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a null value.
		 */
		@Test
		void testPseudoAbsoluteURL_1() {
				assertFalse(Utils.pseudoAbsoluteURL(null));
		}
		
		/**
		 * Test case 2 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with an empty string.
		 */
		@Test
		void testPseudoAbsoluteURL_2() {
				assertFalse(Utils.pseudoAbsoluteURL(""""));
		}
		
		/**
		 * Test case 3 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash.
		 */
		@Test
		void testPseudoAbsoluteURL_3() {
				assertTrue(Utils.pseudoAbsoluteURL(""/""));
		}
		
		/**
		 * Test case 4 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a letter.
		 */
		@Test
		void testPseudoAbsoluteURL_4() {
				assertTrue(Utils.pseudoAbsoluteURL(""/a""));
		}
		
		/**
		 * Test case 5 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a number.
		 */
		@Test
		void testPseudoAbsoluteURL_5() {
				assertTrue(Utils.pseudoAbsoluteURL(""/1""));
		}
		
		/**
		 * Test case 6 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a special character.
		 */
		@Test
		void testPseudoAbsoluteURL_6() {
				assertTrue(Utils.pseudoAbsoluteURL(""/!""));
		}
		
		/**
		 * Test case 7 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a space.
		 */
		@Test
		void testPseudoAbsoluteURL_7() {
				assertTrue(Utils.pseudoAbsoluteURL(""/ ""));
		}
		
		/**
		 * Test case 8 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a tab.
		 */
		@Test
		void testPseudoAbsoluteURL_8() {
				assertTrue(Utils.pseudoAbsoluteURL(""/\t""));
		}
		
		/**
		 * Test case 9 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a newline.
		 */
		@Test
		void testPseudoAbsoluteURL_9() {
				assertTrue(Utils.pseudoAbsoluteURL(""/\n""));
		}
		
		/**
		 * Test case 10 for the {@link Utils#pseudoAbsoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a carriage return.
		 */
		@Test
		void testPseudoAbsoluteURL_10() {
				assertTrue(Utils.pseudoAbsoluteURL(""/\r""));
		}
}

// Utils_4Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#absoluteURL(String)} method.
*/
class Utils_4Test {
		
		/**
		 * Test case 1 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a null value.
		 */
		@Test
		void testAbsoluteURL_1() {
				assertFalse(Utils.absoluteURL(null));
		}
		
		/**
		 * Test case 2 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with an empty string.
		 */
		@Test
		void testAbsoluteURL_2() {
				assertFalse(Utils.absoluteURL(""""));
		}
		
		/**
		 * Test case 3 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash.
		 */
		@Test
		void testAbsoluteURL_3() {
				assertFalse(Utils.absoluteURL(""/""));
		}
		
		/**
		 * Test case 4 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a letter.
		 */
		@Test
		void testAbsoluteURL_4() {
				assertFalse(Utils.absoluteURL(""/a""));
		}
		
		/**
		 * Test case 5 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a number.
		 */
		@Test
		void testAbsoluteURL_5() {
				assertFalse(Utils.absoluteURL(""/1""));
		}
		
		/**
		 * Test case 6 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a special character.
		 */
		@Test
		void testAbsoluteURL_6() {
				assertFalse(Utils.absoluteURL(""/!""));
		}
		
		/**
		 * Test case 7 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a space.
		 */
		@Test
		void testAbsoluteURL_7() {
				assertFalse(Utils.absoluteURL(""/ ""));
		}
		
		/**
		 * Test case 8 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a tab.
		 */
		@Test
		void testAbsoluteURL_8() {
				assertFalse(Utils.absoluteURL(""/\t""));
		}
		
		/**
		 * Test case 9 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a newline.
		 */
		@Test
		void testAbsoluteURL_9() {
				assertFalse(Utils.absoluteURL(""/\n""));
		}
		
		/**
		 * Test case 10 for the {@link Utils#absoluteURL(String)} method.
		 * This test case tests the method with a string that starts with a slash and a carriage return.
		 */
		@Test
	"
cmpl-6tvS5Rt26kRaTlIMM1nAcDr3H4nJQ,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/util/Utils_4Test.java,12.470058679580688,stop,"// Utils.java
/*
 * Copyright (c) 2002, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.util;

/**
 * Some utility methods. All methods in this class are static.
 */
public final class Utils {

    /**
     * Private default constructor to prevent instantiation.
     */
    private Utils() {
    }

    /**
     * Encode a path name or URL into a filename.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePath(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        for (int i = 0; i < path.length(); i++) {
            char c = path.charAt(i);
            switch(c) {
                case '-':
                    sb.append(""--"");
                    break;
                case '_':
                    sb.append(""__"");
                    break;
                case '$':
                    sb.append(""$$"");
                    break;
                case '~':
                    sb.append(""~~"");
                    break;
                case '/':
                    sb.append('-');
                    break;
                case '\\':
                    sb.append('-');
                    break;
                case '*':
                    sb.append('_');
                    break;
                case '?':
                    sb.append('$');
                    break;
                case ':':
                    sb.append('~');
                    break;
                default:
                    sb.append(c);
            }
        }
        return sb.toString();
    }

    /**
     * Encode a path name or URL into a Java identifier.
     *
     * The encoding function is not intended to be inversible.
     */
    public static String encodePathAsIdentifier(String path) {
        StringBuffer sb = new StringBuffer(path.length());
        char c = path.charAt(0);
        if (Character.isJavaIdentifierStart(c))
            sb.append(c);
        else
            sb.append(""_"" + ((int) c) + ""_"");
        for (int i = 1; i < path.length(); i++) {
            c = path.charAt(i);
            if (Character.isJavaIdentifierPart(c))
                sb.append(c);
            else
                sb.append(""_"" + ((int) c) + ""_"");
        }
        return sb.toString();
    }

    /**
     * Check whether an URL is absolute.
     * Returns true if the URL contains at least one colon, and
     * the first colon is before the first slash (if any).
     */
    public static boolean absoluteURL(String url) {
        int colon = url.indexOf(':');
        if (colon < 0)
            return false;
        int slash = url.indexOf('/');
        if (slash < 0)
            return true;
        return colon < slash;
    }

    /**
     * Check whether an URL is pseudo-absolute.
     * Returns true if the URL start with a slash.
     */
    public static boolean pseudoAbsoluteURL(String url) {
        return (url.length() > 0) && (url.charAt(0) == '/');
    }

    /**
     * Generate a {@link java.lang.String} with a specified number
     * of a given character.
     */
    public static String nChars(int n, char c) {
        StringBuffer sb = new StringBuffer(n);
        for (int i = 0; i < n; i++) sb.append(c);
        return sb.toString();
    }
}
","// Utils_4Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#nChars(int, char)} method.
*/
class Utils_4Test {","// Utils_4Test.java
package nu.staldal.util;


import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Utils}.
* It contains ten unit test cases for the {@link Utils#nChars(int, char)} method.
*/
class Utils_4Test {

	@Test
	void test_nChars_1() {
		assertEquals("""", Utils.nChars(0, 'a'));
	}
	
	@Test
	void test_nChars_2() {
		assertEquals(""a"", Utils.nChars(1, 'a'));
	}
	
	@Test
	void test_nChars_3() {
		assertEquals(""aa"", Utils.nChars(2, 'a'));
	}
	
	@Test
	void test_nChars_4() {
		assertEquals(""aaa"", Utils.nChars(3, 'a'));
	}
	
	@Test
	void test_nChars_5() {
		assertEquals(""aaaa"", Utils.nChars(4, 'a'));
	}
	
	@Test
	void test_nChars_6() {
		assertEquals(""aaaaa"", Utils.nChars(5, 'a'));
	}
	
	@Test
	void test_nChars_7() {
		assertEquals(""aaaaaa"", Utils.nChars(6, 'a'));
	}
	
	@Test
	void test_nChars_8() {
		assertEquals(""aaaaaaa"", Utils.nChars(7, 'a'));
	}
	
	@Test
	void test_nChars_9() {
		assertEquals(""aaaaaaaa"", Utils.nChars(8, 'a'));
	}
	
	@Test
	void test_nChars_10() {
		assertEquals(""aaaaaaaaa"", Utils.nChars(9, 'a'));
	}
}"
cmpl-6tvT8Wa3csjvZEULvGCN8Rcl2b5Tm,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xodus/OutputConfig.java,51.36406207084656,length,"// OutputConfig.java
/*
 * Copyright (c) 2005, Mikael St�ldal
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without 
 * modification, are permitted provided that the following conditions 
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright 
 * notice, this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright 
 * notice, this list of conditions and the following disclaimer in the 
 * documentation and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the author nor the names of its contributors 
 * may be used to endorse or promote products derived from this software 
 * without specific prior written permission. 
 * 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR 
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, 
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY 
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * 
 * Note: This is known as ""the modified BSD license"". It's an approved 
 * Open Source and Free Software license, see 
 * http://www.opensource.org/licenses/ 
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xodus;

import java.util.*;
import javax.xml.transform.OutputKeys;

/**
 * Output config.
 */
public class OutputConfig {

    public String method;

    public boolean isXhtml = false;

    public boolean isText = false;

    public boolean isHtml = false;

    public String version;

    public String encoding;

    public int omit_xml_declaration;

    public boolean standalone;

    public String doctype_public;

    public String doctype_system;

    public Set cdata_section_elements;

    public boolean indent;

    public String media_type;

    /**
     * Factory method.
     */
    public static OutputConfig createOutputConfig(Properties outputProps) {
        return new OutputConfig(outputProps);
    }

    private OutputConfig(Properties outputProps) throws IllegalArgumentException {
        method = outputProps.getProperty(OutputKeys.METHOD);
        if (method == null)
            throw new IllegalArgumentException(""Output method must be specified"");
        else if (method.equals(""xml""))
            ;
        else if (method.equals(""xhtml""))
            isXhtml = true;
        else if (method.equals(""text""))
            isText = true;
        else if (method.equals(""html""))
            isHtml = true;
        else
            throw new IllegalArgumentException(""Unknown output method: "" + method);
        version = outputProps.getProperty(OutputKeys.VERSION);
        if (version == null)
            version = isHtml ? ""4.0"" : ""1.0"";
        encoding = outputProps.getProperty(OutputKeys.ENCODING);
        if (encoding == null)
            encoding = (isText || isHtml) ? ""iso-8859-1"" : ""UTF-8"";
        String omit = outputProps.getProperty(OutputKeys.OMIT_XML_DECLARATION);
        if (omit == null)
            omit_xml_declaration = 0;
        else if (omit.equals(""yes"") || omit.equals(""omit_xml_declaration""))
            omit_xml_declaration = 1;
        else if (omit.equals(""no""))
            omit_xml_declaration = -1;
        else
            throw new IllegalArgumentException(""Illegal omit_xml_declaration value: "" + omit);
        String _standalone = outputProps.getProperty(OutputKeys.STANDALONE);
        if (_standalone == null)
            standalone = false;
        else if (_standalone.equals(""yes"") || _standalone.equals(""standalone""))
            standalone = true;
        else if (_standalone.equals(""no""))
            standalone = false;
        else
            throw new IllegalArgumentException(""Illegal standalone value: "" + _standalone);
        String _doctype_public = outputProps.getProperty(OutputKeys.DOCTYPE_PUBLIC);
        if (_doctype_public != null)
            doctype_public = _doctype_public;
        String _doctype_system = outputProps.getProperty(OutputKeys.DOCTYPE_SYSTEM);
        if (_doctype_system != null)
            doctype_system = _doctype_system;
        String cdata = outputProps.getProperty(OutputKeys.CDATA_SECTION_ELEMENTS);
        if (cdata == null) {
            cdata_section_elements = Collections.EMPTY_SET;
        } else {
            cdata_section_elements = new HashSet();
            for (StringTokenizer st = new StringTokenizer(cdata); st.hasMoreTokens(); ) {
                cdata_section_elements.add(st.nextToken());
            }
        }
        String _indent = outputProps.getProperty(OutputKeys.INDENT);
        if (_indent == null)
            indent = false;
        else if (_indent.equals(""yes"") || _indent.equals(""indent""))
            indent = true;
        else if (_indent.equals(""no""))
            indent = false;
        else
            throw new IllegalArgumentException(""Illegal indent value: "" + _indent);
        media_type = outputProps.getProperty(OutputKeys.MEDIA_TYPE);
        if (media_type == null) {
            if (isHtml)
                media_type = ""text/html"";
            else if (isXhtml)
                media_type = ""text/html"";
            else if (isText)
                media_type = ""text/plain"";
            else
                media_type = ""text/xml"";
        }
    }
}
","// OutputConfigTest.java
package nu.staldal.xodus;

import java.util.*;
import javax.xml.transform.OutputKeys;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OutputConfig}.
* It contains ten unit test cases for the {@link OutputConfig#createOutputConfig(Properties)} method.
*/
class OutputConfigTest {","// OutputConfigTest.java
package nu.staldal.xodus;

import java.util.*;
import javax.xml.transform.OutputKeys;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link OutputConfig}.
* It contains ten unit test cases for the {@link OutputConfig#createOutputConfig(Properties)} method.
*/
class OutputConfigTest {

	/**
	* Test case 1.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code null}.
	* Expected result: {@code IllegalArgumentException}.
	*/
	@Test
	void testCreateOutputConfig_1() {
		Properties outputProps = null;
		assertThrows(IllegalArgumentException.class, () -> {
			OutputConfig.createOutputConfig(outputProps);
		});
	}
	
	/**
	* Test case 2.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code empty}.
	* Expected result: {@code IllegalArgumentException}.
	*/
	@Test
	void testCreateOutputConfig_2() {
		Properties outputProps = new Properties();
		assertThrows(IllegalArgumentException.class, () -> {
			OutputConfig.createOutputConfig(outputProps);
		});
	}
	
	/**
	* Test case 3.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code method=xml}.
	* Expected result: {@code OutputConfig}.
	*/
	@Test
	void testCreateOutputConfig_3() {
		Properties outputProps = new Properties();
		outputProps.setProperty(OutputKeys.METHOD, ""xml"");
		OutputConfig outputConfig = OutputConfig.createOutputConfig(outputProps);
		assertEquals(""xml"", outputConfig.method);
		assertFalse(outputConfig.isXhtml);
		assertFalse(outputConfig.isText);
		assertFalse(outputConfig.isHtml);
		assertEquals(""1.0"", outputConfig.version);
		assertEquals(""UTF-8"", outputConfig.encoding);
		assertEquals(0, outputConfig.omit_xml_declaration);
		assertFalse(outputConfig.standalone);
		assertNull(outputConfig.doctype_public);
		assertNull(outputConfig.doctype_system);
		assertEquals(Collections.EMPTY_SET, outputConfig.cdata_section_elements);
		assertFalse(outputConfig.indent);
		assertEquals(""text/xml"", outputConfig.media_type);
	}
	
	/**
	* Test case 4.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code method=xhtml}.
	* Expected result: {@code OutputConfig}.
	*/
	@Test
	void testCreateOutputConfig_4() {
		Properties outputProps = new Properties();
		outputProps.setProperty(OutputKeys.METHOD, ""xhtml"");
		OutputConfig outputConfig = OutputConfig.createOutputConfig(outputProps);
		assertEquals(""xhtml"", outputConfig.method);
		assertTrue(outputConfig.isXhtml);
		assertFalse(outputConfig.isText);
		assertFalse(outputConfig.isHtml);
		assertEquals(""1.0"", outputConfig.version);
		assertEquals(""UTF-8"", outputConfig.encoding);
		assertEquals(0, outputConfig.omit_xml_declaration);
		assertFalse(outputConfig.standalone);
		assertNull(outputConfig.doctype_public);
		assertNull(outputConfig.doctype_system);
		assertEquals(Collections.EMPTY_SET, outputConfig.cdata_section_elements);
		assertFalse(outputConfig.indent);
		assertEquals(""text/html"", outputConfig.media_type);
	}
	
	/**
	* Test case 5.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code method=text}.
	* Expected result: {@code OutputConfig}.
	*/
	@Test
	void testCreateOutputConfig_5() {
		Properties outputProps = new Properties();
		outputProps.setProperty(OutputKeys.METHOD, ""text"");
		OutputConfig outputConfig = OutputConfig.createOutputConfig(outputProps);
		assertEquals(""text"", outputConfig.method);
		assertFalse(outputConfig.isXhtml);
		assertTrue(outputConfig.isText);
		assertFalse(outputConfig.isHtml);
		assertEquals(""1.0"", outputConfig.version);
		assertEquals(""iso-8859-1"", outputConfig.encoding);
		assertEquals(0, outputConfig.omit_xml_declaration);
		assertFalse(outputConfig.standalone);
		assertNull(outputConfig.doctype_public);
		assertNull(outputConfig.doctype_system);
		assertEquals(Collections.EMPTY_SET, outputConfig.cdata_section_elements);
		assertFalse(outputConfig.indent);
		assertEquals(""text/plain"", outputConfig.media_type);
	}
	
	/**
	* Test case 6.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code method=html}.
	* Expected result: {@code OutputConfig}.
	*/
	@Test
	void testCreateOutputConfig_6() {
		Properties outputProps = new Properties();
		outputProps.setProperty(OutputKeys.METHOD, ""html"");
		OutputConfig outputConfig = OutputConfig.createOutputConfig(outputProps);
		assertEquals(""html"", outputConfig.method);
		assertFalse(outputConfig.isXhtml);
		assertFalse(outputConfig.isText);
		assertTrue(outputConfig.isHtml);
		assertEquals(""4.0"", outputConfig.version);
		assertEquals(""iso-8859-1"", outputConfig.encoding);
		assertEquals(0, outputConfig.omit_xml_declaration);
		assertFalse(outputConfig.standalone);
		assertNull(outputConfig.doctype_public);
		assertNull(outputConfig.doctype_system);
		assertEquals(Collections.EMPTY_SET, outputConfig.cdata_section_elements);
		assertFalse(outputConfig.indent);
		assertEquals(""text/html"", outputConfig.media_type);
	}
	
	/**
	* Test case 7.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code method=unknown}.
	* Expected result: {@code IllegalArgumentException}.
	*/
	@Test
	void testCreateOutputConfig_7() {
		Properties outputProps = new Properties();
		outputProps.setProperty(OutputKeys.METHOD, ""unknown"");
		assertThrows(IllegalArgumentException.class, () -> {
			OutputConfig.createOutputConfig(outputProps);
		});
	}
	
	/**
	* Test case 8.
	* Test method: {@link OutputConfig#createOutputConfig(Properties)}.
	* Test data: {@code method=xml, version=1.1}.
	* Expected result: {@code OutputConfig}.
	*/
	@Test
	void testCreateOutputConfig_8() {
		Properties outputProps = new Properties();
		outputProps.setProperty(OutputKeys.METHOD, ""xml"");
		outputProps.setProperty(OutputKeys.VERSION, ""1.1"");
		OutputConfig outputConfig = OutputConfig.createOutputConfig(outputProps);
		assertEquals(""xml"", outputConfig.method);
		assertFalse(outputConfig.isXhtml);
		assertFalse(outputConfig.isText);
		assertFalse(outputConfig.isHtml);
		assertEquals(""1.1"", outputConfig.version);
		assertEquals(""UTF-8"", outputConfig.encoding);
		assertEquals(0, outputConfig.omit_xml_declaration);
		assertFalse(outputConfig.stand"
cmpl-6tvUBNT8VmtbH1iYcLWM0npa3pVg2,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_0Test.java,55.1350200176239,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {","// Element_0Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#lookupAttribute(String, String)} method.
*/
class Element_0Test {

		@Test
		void test_lookupAttribute_0() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute("""", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_1() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_2() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute(""a"", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_3() {
			Element element = new Element("""", """", 0);
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_4() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute("""", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_5() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_6() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute(""a"", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_7() {
			Element element = new Element("""", """", 1);
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_8() {
			Element element = new Element("""", """", 1);
			element.addAttribute("""", """", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_9() {
			Element element = new Element("""", """", 1);
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_10() {
			Element element = new Element("""", """", 1);
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute(""a"", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_11() {
			Element element = new Element("""", """", 1);
			element.addAttribute(""a"", ""a"", """", """");
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_12() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_13() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(1, result);
		}
		
		@Test
		void test_lookupAttribute_14() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute(""a"", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_15() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_16() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(0, result);
		}
		
		@Test
		void test_lookupAttribute_17() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_18() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute(""a"", """");
			assertEquals(1, result);
		}
		
		@Test
		void test_lookupAttribute_19() {
			Element element = new Element("""", """", 2);
			element.addAttribute("""", """", """", """");
			element.addAttribute(""a"", """", """", """");
			int result = element.lookupAttribute(""a"", ""a"");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_20() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", """");
			assertEquals(-1, result);
		}
		
		@Test
		void test_lookupAttribute_21() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute("""", ""a"");
			assertEquals(1, result);
		}
		
		@Test
		void test_lookupAttribute_22() {
			Element element = new Element("""", """", 2);
			element.addAttribute(""a"", """", """", """");
			element.addAttribute("""", ""a"", """", """");
			int result = element.lookupAttribute(""a"
cmpl-6tvVEGjDmooI3lgjZRiQWVNvaasEe,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_11Test.java,54.60528206825256,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_11Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValueOrNull(String)} method.
*/
class Element_11Test {","// Element_11Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValueOrNull(String)} method.
*/
class Element_11Test {

		@Test
		public void test_getAttrValueOrNull_1() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value1"", element.getAttrValueOrNull(""attr1""));
		}
		
		@Test
		public void test_getAttrValueOrNull_2() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value2"", element.getAttrValueOrNull(""attr2""));
		}
		
		@Test
		public void test_getAttrValueOrNull_3() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value3"", element.getAttrValueOrNull(""attr3""));
		}
		
		@Test
		public void test_getAttrValueOrNull_4() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr4""));
		}
		
		@Test
		public void test_getAttrValueOrNull_5() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr5""));
		}
		
		@Test
		public void test_getAttrValueOrNull_6() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr6""));
		}
		
		@Test
		public void test_getAttrValueOrNull_7() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr7""));
		}
		
		@Test
		public void test_getAttrValueOrNull_8() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr8""));
		}
		
		@Test
		public void test_getAttrValueOrNull_9() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr9""));
		}
		
		@Test
		public void test_getAttrValueOrNull_10() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr10""));
		}
}

// Element_12Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String)} method.
*/
class Element_12Test {
		
		@Test
		public void test_getAttrValue_1() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value1"", element.getAttrValue(""attr1""));
		}
		
		@Test
		public void test_getAttrValue_2() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value2"", element.getAttrValue(""attr2""));
		}
		
		@Test
		public void test_getAttrValue_3() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value3"", element.getAttrValue(""attr3""));
		}
		
		@Test
		public void test_getAttrValue_4() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", """
cmpl-6tvWHpgcr9Xyo1vKGh3NhPBUiK3QT,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_12Test.java,51.64827370643616,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_12Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String)} method.
*/
class Element_12Test {","// Element_12Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String)} method.
*/
class Element_12Test {

	@Test
	void testGetAttrValue() throws Exception {
		Element e = new Element("""", ""test"");
		e.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		e.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		e.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		e.addAttribute("""", ""attr4"", ""CDATA"", ""value4"");
		e.addAttribute("""", ""attr5"", ""CDATA"", ""value5"");
		e.addAttribute("""", ""attr6"", ""CDATA"", ""value6"");
		e.addAttribute("""", ""attr7"", ""CDATA"", ""value7"");
		e.addAttribute("""", ""attr8"", ""CDATA"", ""value8"");
		e.addAttribute("""", ""attr9"", ""CDATA"", ""value9"");
		e.addAttribute("""", ""attr10"", ""CDATA"", ""value10"");
		e.addAttribute("""", ""attr11"", ""CDATA"", ""value11"");
		e.addAttribute("""", ""attr12"", ""CDATA"", ""value12"");
		assertEquals(""value1"", e.getAttrValue(""attr1""));
		assertEquals(""value2"", e.getAttrValue(""attr2""));
		assertEquals(""value3"", e.getAttrValue(""attr3""));
		assertEquals(""value4"", e.getAttrValue(""attr4""));
		assertEquals(""value5"", e.getAttrValue(""attr5""));
		assertEquals(""value6"", e.getAttrValue(""attr6""));
		assertEquals(""value7"", e.getAttrValue(""attr7""));
		assertEquals(""value8"", e.getAttrValue(""attr8""));
		assertEquals(""value9"", e.getAttrValue(""attr9""));
		assertEquals(""value10"", e.getAttrValue(""attr10""));
		assertEquals(""value11"", e.getAttrValue(""attr11""));
		assertEquals(""value12"", e.getAttrValue(""attr12""));
	}
}

// Element_13Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValueOrNull(String)} method.
*/
class Element_13Test {
		
	@Test
	void testGetAttrValueOrNull() throws Exception {
		Element e = new Element("""", ""test"");
		e.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		e.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		e.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		e.addAttribute("""", ""attr4"", ""CDATA"", ""value4"");
		e.addAttribute("""", ""attr5"", ""CDATA"", ""value5"");
		e.addAttribute("""", ""attr6"", ""CDATA"", ""value6"");
		e.addAttribute("""", ""attr7"", ""CDATA"", ""value7"");
		e.addAttribute("""", ""attr8"", ""CDATA"", ""value8"");
		e.addAttribute("""", ""attr9"", ""CDATA"", ""value9"");
		e.addAttribute("""", ""attr10"", ""CDATA"", ""value10"");
		e.addAttribute("""", ""attr11"", ""CDATA"", ""value11"");
		e.addAttribute("""", ""attr12"", ""CDATA"", ""value12"");
		assertEquals(""value1"", e.getAttrValueOrNull(""attr1""));
		assertEquals(""value2"", e.getAttrValueOrNull(""attr2""));
		assertEquals(""value3"", e.getAttrValueOrNull(""attr3""));
		assertEquals(""value4"", e.getAttrValueOrNull(""attr4""));
		assertEquals(""value5"", e.getAttrValueOrNull(""attr5""));
		assertEquals(""value6"", e.getAttrValueOrNull(""attr6""));
		assertEquals(""value7"", e.getAttrValueOrNull(""attr7""));
		assertEquals(""value8"", e.getAttrValueOrNull(""attr8""));
		assertEquals(""value9"", e.getAttrValueOrNull(""attr9""));
		assertEquals(""value10"", e.getAttrValueOrNull(""attr10""));
		assertEquals(""value11"", e.getAttrValueOrNull(""attr11""));
		assertEquals(""value12"", e.getAttrValueOrNull(""attr12""));
	}
}

// Element_14Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String,String)} method.
*/
class Element_14Test {
		
	@Test
	void testGetAttrValue() throws Exception {
		Element e = new Element("""", ""test"");
		e.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		e.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		e.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		e.addAttribute("""", ""attr4"", ""CDATA"", ""value4"");
		e.addAttribute("""", ""attr5"", ""CDATA"", ""value5"");
		e.addAttribute("""", ""attr6"", ""CDATA"", ""value6"");
		e.addAttribute("""", ""attr7"", ""CDATA"", ""value7"");
		e.addAttribute("""", ""attr8"", ""CDATA"", ""value8"");
		e.addAttribute("""", ""attr9"", ""CDATA"", ""value9"");
		e.addAttribute("""", ""attr10"", ""CDATA"", ""value10"");
		e.addAttribute("""", ""attr11"", ""CDATA"", ""value11"");
		e.addAttribute("""", ""attr12"", ""CDATA"", ""value12"");
		assertEquals(""value1"", e.getAttrValue("""", ""attr1""));
		assertEquals(""value2"", e.getAttrValue("""", ""attr2""));
		assertEquals(""value3"", e.getAttrValue("""", ""attr3""));
		assertEquals(""value4"", e.getAttrValue("""", ""attr4""));
		assertEquals(""value5"", e.getAttrValue("""", ""attr5""));
		assertEquals(""value6"", e.getAttrValue("""", ""attr6""));
		assertEquals(""value7"", e.getAttrValue("""", ""attr7""));
		assertEquals(""value8"", e.getAttrValue("""", ""attr8""));
		assertEquals(""value9"", e.getAttrValue("""", ""attr9""));
		assertEquals(""value10"", e.getAttrValue("""", ""attr10""));
		assertEquals(""value11"", e.getAttrValue("""", ""attr11""));
		assertEquals(""value12"", e.getAttrValue("""", ""attr12""));
	}
}

// Element_15Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*"
cmpl-6tvXKlVG4u1AVjOJaUQnjeoBkTPco,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_13Test.java,52.34191417694092,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_13Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValueOrNull(String, String)} method.
*/
class Element_13Test {","// Element_13Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValueOrNull(String, String)} method.
*/
class Element_13Test {

		@Test
		public void test_getAttrValueOrNull_1() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value1"", element.getAttrValueOrNull(""attr1""));
		}
		
		@Test
		public void test_getAttrValueOrNull_2() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value2"", element.getAttrValueOrNull(""attr2""));
		}
		
		@Test
		public void test_getAttrValueOrNull_3() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value3"", element.getAttrValueOrNull(""attr3""));
		}
		
		@Test
		public void test_getAttrValueOrNull_4() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr4""));
		}
		
		@Test
		public void test_getAttrValueOrNull_5() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr5""));
		}
		
		@Test
		public void test_getAttrValueOrNull_6() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr6""));
		}
		
		@Test
		public void test_getAttrValueOrNull_7() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr7""));
		}
		
		@Test
		public void test_getAttrValueOrNull_8() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr8""));
		}
		
		@Test
		public void test_getAttrValueOrNull_9() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr9""));
		}
		
		@Test
		public void test_getAttrValueOrNull_10() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(null, element.getAttrValueOrNull(""attr10""));
		}
}

// Element_14Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String, String)} method.
*/
class Element_14Test {
		
		@Test
		public void test_getAttrValue_1() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value1"", element.getAttrValue(""attr1""));
		}
		
		@Test
		public void test_getAttrValue_2() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value2"", element.getAttrValue(""attr2""));
		}
		
		@Test
		public void test_getAttrValue_3() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
				element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
				element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
				assertEquals(""value3"", element.getAttrValue(""attr3""));
		}
		
		@Test
		public void test_getAttrValue_4() throws Exception {
				Element element = new Element("""", ""test"");
				element.addAttribute("""", ""attr1"", ""CDATA"
cmpl-6tvYN7xDjp5Teh3L7eiYrAJ42Bnyd,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_14Test.java,56.310938596725464,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_14Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String, String)} method.
*/
class Element_14Test {","// Element_14Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String, String)} method.
*/
class Element_14Test {

	@Test
	void test_getAttrValue_1() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value2"", element.getAttrValue("""", ""attr2""));
	}
	
	@Test
	void test_getAttrValue_2() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value3"", element.getAttrValue("""", ""attr3""));
	}
	
	@Test
	void test_getAttrValue_3() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value1"", element.getAttrValue("""", ""attr1""));
	}
	
	@Test
	void test_getAttrValue_4() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value1"", element.getAttrValue("""", ""attr1""));
	}
	
	@Test
	void test_getAttrValue_5() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value2"", element.getAttrValue("""", ""attr2""));
	}
	
	@Test
	void test_getAttrValue_6() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value3"", element.getAttrValue("""", ""attr3""));
	}
	
	@Test
	void test_getAttrValue_7() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value1"", element.getAttrValue("""", ""attr1""));
	}
	
	@Test
	void test_getAttrValue_8() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value2"", element.getAttrValue("""", ""attr2""));
	}
	
	@Test
	void test_getAttrValue_9() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value3"", element.getAttrValue("""", ""attr3""));
	}
	
	@Test
	void test_getAttrValue_10() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value1"", element.getAttrValue("""", ""attr1""));
	}
}

// Element_15Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttrValue(String)} method.
*/
class Element_15Test {
		
	@Test
	void test_getAttrValue_1() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value2"", element.getAttrValue(""attr2""));
	}
	
	@Test
	void test_getAttrValue_2() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value3"", element.getAttrValue(""attr3""));
	}
	
	@Test
	void test_getAttrValue_3() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value1"", element.getAttrValue(""attr1""));
	}
	
	@Test
	void test_getAttrValue_4() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value2"", element.getAttrValue(""attr2""));
	}
	
	@Test
	void test_getAttrValue_5() throws Exception {
		Element element = new Element("""", ""test"");
		element.addAttribute("""", ""attr1"", ""CDATA"", ""value1"");
		element.addAttribute("""", ""attr2"", ""CDATA"", ""value2"");
		element.addAttribute("""", ""attr3"", ""CDATA"", ""value3"");
		assertEquals(""value3"", element.getAttrValue(""attr3""));
	}
	
	@Test
	void test_getAttrValue_6() throws Exception {
		"
cmpl-6tvZQnX3KVbSRl7rxQRlYCSAVFmLB,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_15Test.java,59.12122631072998,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_15Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getFirstChildElementOrNull(String, String)} method.
*/
class Element_15Test {","// Element_15Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getFirstChildElementOrNull(String, String)} method.
*/
class Element_15Test {

	@Test
	void test_getFirstChildElementOrNull_01() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull("""", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_02() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull("""", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_03() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull(""a"", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_04() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull(""a"", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_05() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull("""", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_06() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull(""a"", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_07() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull(""a"", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_08() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull("""", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_09() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull(""a"", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_10() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull(""a"", ""a"");
		assertNull(result);
	}
}

// Element_16Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getFirstChildElement(String, String)} method.
*/
class Element_16Test {
		
	@Test
	void test_getFirstChildElement_01() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement("""", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_02() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement("""", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_03() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement(""a"", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_04() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement(""a"", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_05() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement("""", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_06() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement(""a"", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_07() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement(""a"", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_08() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement("""", ""a"");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_09() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement(""a"", """");
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElement_10() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElement(""a"", ""a"");
		assertNull(result);
	}
}

// Element_17Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getFirstChildElementOrNull()} method.
*/
class Element_17Test {
		
	@Test
	void test_getFirstChildElementOrNull_01() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull();
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_02() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull();
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_03() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull();
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_04() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull();
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_05() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull();
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_06() {
		Element element = new Element("""", """", 0, 0);
		Element result = element.getFirstChildElementOrNull();
		assertNull(result);
	}
	
	@Test
	void test_getFirstChildElementOrNull_07() {
		Element element = new Element("""","
cmpl-6tvaTNR1iVRL8OPYiXfAa1zdIS1fk,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_16Test.java,53.09503531455994,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_16Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getFirstChildElement(String, String)} method.
*/
class Element_16Test {","// Element_16Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getFirstChildElement(String, String)} method.
*/
class Element_16Test {

		@Test
		public void test_getFirstChildElement_01() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child"");
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_02() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child2"");
				assertNull(result);
		}
		
		@Test
		public void test_getFirstChildElement_03() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child"");
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_04() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child2"");
				assertNull(result);
		}
		
		@Test
		public void test_getFirstChildElement_05() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child"");
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_06() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child2"");
				assertNull(result);
		}
		
		@Test
		public void test_getFirstChildElement_07() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child"");
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_08() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child2"");
				assertNull(result);
		}
		
		@Test
		public void test_getFirstChildElement_09() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child"");
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_10() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement("""", ""child2"");
				assertNull(result);
		}
}

// Element_17Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getFirstChildElement()} method.
*/
class Element_17Test {
		
		@Test
		public void test_getFirstChildElement_01() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_02() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_03() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_04() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_05() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_06() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_07() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_08() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element("""", ""child"");
				element.addChild(child);
				Element result = element.getFirstChildElement();
				assertEquals(child, result);
		}
		
		@Test
		public void test_getFirstChildElement_09() throws Exception {
				Element element = new Element("""", ""element"");
				Element child = new Element"
cmpl-6tvbWv4Ojyd7Hxj30552HGO7sd10M,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_1Test.java,53.835516691207886,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {","// Element_1Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfAttributes()} method.
*/
class Element_1Test {

	@Test
	void test_numberOfAttributes_1() {
		Element element = new Element("""", """", 0);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_2() {
		Element element = new Element("""", """", 1);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_3() {
		Element element = new Element("""", """", 2);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_4() {
		Element element = new Element("""", """", 3);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_5() {
		Element element = new Element("""", """", 4);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_6() {
		Element element = new Element("""", """", 5);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_7() {
		Element element = new Element("""", """", 6);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_8() {
		Element element = new Element("""", """", 7);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_9() {
		Element element = new Element("""", """", 8);
		assertEquals(0, element.numberOfAttributes());
	}
	
	@Test
	void test_numberOfAttributes_10() {
		Element element = new Element("""", """", 9);
		assertEquals(0, element.numberOfAttributes());
	}
}

// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#addAttribute(String, String, String, String)} method.
*/
class Element_2Test {
		
	@Test
	void test_addAttribute_1() {
		Element element = new Element("""", """", 0);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_2() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_3() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_4() {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_5() {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_6() {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_7() {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_8() {
		Element element = new Element("""", """", 7);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_9() {
		Element element = new Element("""", """", 8);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_10() {
		Element element = new Element("""", """", 9);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
}

// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#addAttribute(String, String, String, String)} method.
*/
class Element_3Test {
		
	@Test
	void test_addAttribute_1() {
		Element element = new Element("""", """", 0);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_2() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_3() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_4() {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_5() {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_6() {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_7() {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_8() {
		Element element = new Element("""", """", 7);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element.numberOfAttributes());
	}
	
	@Test
	void test_addAttribute_9() {
		Element element = new Element("""", """", 8);
		element.addAttribute("""", """", """", """");
		assertEquals(1, element"
cmpl-6tvcZ3r6S4vaxUEgmbNWEjMrpChcZ,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_2Test.java,52.15369391441345,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {","// Element_2Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_2Test {

	@Test
	void testGetAttributeNamespaceURI_0() throws Exception {
		Element element = new Element("""", """", 0);
		assertEquals(null, element.getAttributeNamespaceURI(-1));
	}
	
	@Test
	void testGetAttributeNamespaceURI_1() throws Exception {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(0));
	}
	
	@Test
	void testGetAttributeNamespaceURI_2() throws Exception {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(1));
	}
	
	@Test
	void testGetAttributeNamespaceURI_3() throws Exception {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(2));
	}
	
	@Test
	void testGetAttributeNamespaceURI_4() throws Exception {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(3));
	}
	
	@Test
	void testGetAttributeNamespaceURI_5() throws Exception {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(4));
	}
	
	@Test
	void testGetAttributeNamespaceURI_6() throws Exception {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(5));
	}
	
	@Test
	void testGetAttributeNamespaceURI_7() throws Exception {
		Element element = new Element("""", """", 7);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(6));
	}
	
	@Test
	void testGetAttributeNamespaceURI_8() throws Exception {
		Element element = new Element("""", """", 8);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(7));
	}
	
	@Test
	void testGetAttributeNamespaceURI_9() throws Exception {
		Element element = new Element("""", """", 9);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeNamespaceURI(8));
	}
	
}

// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {
		
	@Test
	void testGetAttributeLocalName_0() throws Exception {
		Element element = new Element("""", """", 0);
		assertEquals(null, element.getAttributeLocalName(-1));
	}
	
	@Test
	void testGetAttributeLocalName_1() throws Exception {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(0));
	}
	
	@Test
	void testGetAttributeLocalName_2() throws Exception {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(1));
	}
	
	@Test
	void testGetAttributeLocalName_3() throws Exception {
		Element element = new Element("""", """", 3);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(2));
	}
	
	@Test
	void testGetAttributeLocalName_4() throws Exception {
		Element element = new Element("""", """", 4);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(3));
	}
	
	@Test
	void testGetAttributeLocalName_5() throws Exception {
		Element element = new Element("""", """", 5);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeLocalName(4));
	}
	
	@Test
	void testGetAttributeLocalName_6() throws Exception {
		Element element = new Element("""", """", 6);
		element.addAttribute("""", """", """", """");
		element.addAttribute("""", """", """", """");
		element.addAttribute"
cmpl-6tvdcAlLCnbiGZWRfa9O46HCMfP2o,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_3Test.java,50.38846826553345,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {","// Element_3Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeLocalName(int)} method.
*/
class Element_3Test {

	@Test
	void testGetAttributeLocalName_0() throws Exception {
		Element element = new Element("""", """", 0);
		int index = -1;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_1() throws Exception {
		Element element = new Element("""", """", 1);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_2() throws Exception {
		Element element = new Element("""", """", 2);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_3() throws Exception {
		Element element = new Element("""", """", 3);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_4() throws Exception {
		Element element = new Element("""", """", 4);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_5() throws Exception {
		Element element = new Element("""", """", 5);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_6() throws Exception {
		Element element = new Element("""", """", 6);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_7() throws Exception {
		Element element = new Element("""", """", 7);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_8() throws Exception {
		Element element = new Element("""", """", 8);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeLocalName_9() throws Exception {
		Element element = new Element("""", """", 9);
		int index = 0;
		String result = element.getAttributeLocalName(index);
		assertNull(result);
	}
	
}

// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_4Test {
		
	@Test
	void testGetAttributeNamespaceURI_0() throws Exception {
		Element element = new Element("""", """", 0);
		int index = -1;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_1() throws Exception {
		Element element = new Element("""", """", 1);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_2() throws Exception {
		Element element = new Element("""", """", 2);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_3() throws Exception {
		Element element = new Element("""", """", 3);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_4() throws Exception {
		Element element = new Element("""", """", 4);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_5() throws Exception {
		Element element = new Element("""", """", 5);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_6() throws Exception {
		Element element = new Element("""", """", 6);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_7() throws Exception {
		Element element = new Element("""", """", 7);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_8() throws Exception {
		Element element = new Element("""", """", 8);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeNamespaceURI_9() throws Exception {
		Element element = new Element("""", """", 9);
		int index = 0;
		String result = element.getAttributeNamespaceURI(index);
		assertNull(result);
	}
	
}

// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_5Test {
		
	@Test
	void testGetAttributeType_0() throws Exception {
		Element element = new Element("""", """", 0);
		int index = -1;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_1() throws Exception {
		Element element = new Element("""", """", 1);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_2() throws Exception {
		Element element = new Element("""", """", 2);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_3() throws Exception {
		Element element = new Element("""", """", 3);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	}
	
	@Test
	void testGetAttributeType_4() throws Exception {
		Element element = new Element("""", """", 4);
		int index = 0;
		String result = element.getAttributeType(index);
		assertNull(result);
	"
cmpl-6tvefmTYoQbrmbv5j37VhcQCA9ypp,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_4Test.java,48.442681074142456,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {","// Element_4Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_4Test {

		@Test
		void test_getAttributeType_1() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeType(-1));
		}
		
		@Test
		void test_getAttributeType_2() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_3() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", """", """");
				assertEquals("""", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_4() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""CDATA"", """");
				assertEquals(""CDATA"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_5() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ID"", """");
				assertEquals(""ID"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_6() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREF"", """");
				assertEquals(""IDREF"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_7() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREFS"", """");
				assertEquals(""IDREFS"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_8() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKEN"", """");
				assertEquals(""NMTOKEN"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_9() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKENS"", """");
				assertEquals(""NMTOKENS"", element.getAttributeType(0));
		}
		
		@Test
		void test_getAttributeType_10() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ENTITY"", """");
				assertEquals(""ENTITY"", element.getAttributeType(0));
		}
		
}

// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {
		
		@Test
		void test_getAttributeValue_1() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeValue(-1));
		}
		
		@Test
		void test_getAttributeValue_2() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_3() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", """", """");
				assertEquals("""", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_4() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""CDATA"", ""a"");
				assertEquals(""a"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_5() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ID"", ""b"");
				assertEquals(""b"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_6() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREF"", ""c"");
				assertEquals(""c"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_7() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""IDREFS"", ""d"");
				assertEquals(""d"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_8() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKEN"", ""e"");
				assertEquals(""e"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_9() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""NMTOKENS"", ""f"");
				assertEquals(""f"", element.getAttributeValue(0));
		}
		
		@Test
		void test_getAttributeValue_10() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""ENTITY"", ""g"");
				assertEquals(""g"", element.getAttributeValue(0));
		}
		
}

// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(String)} method.
*/
class Element_6Test {
		
		@Test
		void test_getAttributeValue_1() {
				Element element = new Element("""", """", 0);
				assertEquals(null, element.getAttributeValue(""""));
		}
		
		@Test
		void test_getAttributeValue_2() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", """", """");
				assertEquals("""", element.getAttributeValue(""""));
		}
		
		@Test
		void test_getAttributeValue_3() {
				Element element = new Element("""", """", 1);
				element.addAttribute("""", """", ""CDATA"", ""a"");
"
cmpl-6tvfiA718VUUA7Y8wujElAKw1qXv1,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_5Test.java,54.27690124511719,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {","// Element_5Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeValue(int)} method.
*/
class Element_5Test {

	@Test
	void test_getAttributeValue_1() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(0);
		});
	}
	
	@Test
	void test_getAttributeValue_2() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(-1);
		});
	}
	
	@Test
	void test_getAttributeValue_3() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeValue(0));
	}
	
	@Test
	void test_getAttributeValue_4() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", ""a"");
		assertEquals(""a"", element.getAttributeValue(0));
	}
	
	@Test
	void test_getAttributeValue_5() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", ""a"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(1);
		});
	}
	
	@Test
	void test_getAttributeValue_6() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", ""a"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(-1);
		});
	}
	
	@Test
	void test_getAttributeValue_7() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertEquals(""a"", element.getAttributeValue(0));
	}
	
	@Test
	void test_getAttributeValue_8() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertEquals(""b"", element.getAttributeValue(1));
	}
	
	@Test
	void test_getAttributeValue_9() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(2);
		});
	}
	
	@Test
	void test_getAttributeValue_10() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", """", ""a"");
		element.addAttribute("""", """", """", ""b"");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeValue(-1);
		});
	}
}

// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeType(int)} method.
*/
class Element_6Test {
		
	@Test
	void test_getAttributeType_1() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(0);
		});
	}
	
	@Test
	void test_getAttributeType_2() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(-1);
		});
	}
	
	@Test
	void test_getAttributeType_3() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", """", """");
		assertEquals("""", element.getAttributeType(0));
	}
	
	@Test
	void test_getAttributeType_4() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", ""a"", """");
		assertEquals(""a"", element.getAttributeType(0));
	}
	
	@Test
	void test_getAttributeType_5() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", ""a"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(1);
		});
	}
	
	@Test
	void test_getAttributeType_6() {
		Element element = new Element("""", """", 1);
		element.addAttribute("""", """", ""a"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(-1);
		});
	}
	
	@Test
	void test_getAttributeType_7() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertEquals(""a"", element.getAttributeType(0));
	}
	
	@Test
	void test_getAttributeType_8() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertEquals(""b"", element.getAttributeType(1));
	}
	
	@Test
	void test_getAttributeType_9() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(2);
		});
	}
	
	@Test
	void test_getAttributeType_10() {
		Element element = new Element("""", """", 2);
		element.addAttribute("""", """", ""a"", """");
		element.addAttribute("""", """", ""b"", """");
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeType(-1);
		});
	}
}

// Element_7Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getAttributeNamespaceURI(int)} method.
*/
class Element_7Test {
		
	@Test
	void test_getAttributeNamespaceURI_1() {
		Element element = new Element("""", """", 0);
		assertThrows(IndexOutOfBoundsException.class, () -> {
			element.getAttributeNamespaceURI(0);
		});
	}
	
	@Test"
cmpl-6tvgllU0PXkk3BWRjlspELkRWi0o9,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_6Test.java,55.206809520721436,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {","// Element_6Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#numberOfNamespaceMappings()} method.
*/
class Element_6Test {

	@Test
	void test_numberOfNamespaceMappings_0() {
		Element element = new Element("""", """", -1, -1);
		assertEquals(0, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_1() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		assertEquals(1, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_2() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(2, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_3() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(3, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_4() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(4, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_5() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(5, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_6() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(6, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_7() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(7, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_8() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(8, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_9() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(9, element.numberOfNamespaceMappings());
	}
	
	@Test
	void test_numberOfNamespaceMappings_10() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertEquals(10, element.numberOfNamespaceMappings());
	}
	
}

// Element_7Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getNamespaceMapping(int)} method.
*/
class Element_7Test {
		
	@Test
	void test_getNamespaceMapping_0() {
		Element element = new Element("""", """", -1, -1);
		assertArrayEquals(new String[] { """", """" }, element.getNamespaceMapping(0));
	}
	
	@Test
	void test_getNamespaceMapping_1() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		assertArrayEquals(new String[] { """", """" }, element.getNamespaceMapping(1));
	}
	
	@Test
	void test_getNamespaceMapping_2() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertArrayEquals(new String[] { """", """" }, element.getNamespaceMapping(2));
	}
	
	@Test
	void test_getNamespaceMapping_3() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		assertArrayEquals(new String[] { """", """" }, element.getNamespaceMapping(3));
	}
	
	@Test
	void test_getNamespaceMapping_4() {
		Element element = new Element("""", """", -1, -1);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespace"
cmpl-6tvhoncMRnibj9z84pAFDoCwamSW7,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Element_7Test.java,55.60019254684448,length,"// Element.java
/*
 * Copyright (c) 2001, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;

/**
 * An XML Element.
 */
public class Element extends NodeWithChildren {

    static final long serialVersionUID = -1804355746259349573L;

    final String namespaceURI;

    final String localName;

    URL baseURI = null;

    Vector attrName;

    Vector attrValue;

    Vector attrType;

    Vector namespacePrefixes;

    Vector namespaceURIs;

    char xmlSpaceAttribute = ' ';

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     */
    public Element(String namespaceURI, String localName) {
        this(namespaceURI, localName, -1, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the element name
     * @param numberOfAttributes  the number of attributes this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes) {
        this(namespaceURI, localName, numberOfAttributes, -1);
    }

    /**
     * Construct an element.
     *
     * @param namespaceURI  the namespace URI for this element,
     *                      may be the empty string
     * @param localName	the name of this element (no namespace)
     * @param numberOfAttributes  the number of attributes this element should have
     * @param numberOfChildren  the number of children this element should have
     */
    public Element(String namespaceURI, String localName, int numberOfAttributes, int numberOfChildren) {
        super(numberOfChildren);
        if (namespaceURI == null)
            namespaceURI = """";
        if (localName == null)
            throw new NullPointerException(""LocalName may not be null"");
        if (numberOfAttributes >= 0) {
            attrName = new Vector(numberOfAttributes);
            attrValue = new Vector(numberOfAttributes);
            attrType = new Vector(numberOfAttributes);
        } else {
            attrName = new Vector();
            attrValue = new Vector();
            attrType = new Vector();
        }
        namespaceURIs = new Vector();
        namespacePrefixes = new Vector();
        this.namespaceURI = namespaceURI;
        this.localName = localName;
    }

    /**
     * Get the namespace URI for this element. May be the empty string.
     */
    public String getNamespaceURI() {
        return namespaceURI;
    }

    /**
     * Get the name of this element.
     * The name does not include namespace URI or prefix.
     */
    public String getLocalName() {
        return localName;
    }

    /**
     * Lookup the index of an attribute to this element. The returned index
     * may be used as argument to other methods in this class.
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @return the index of the attribute, or -1 if no such attribute exists
     *
     * @see #getAttributeValue
     * @see #getAttributeType
     * @see #removeAttribute
     */
    public int lookupAttribute(String namespaceURI, String localName) {
        return attrName.indexOf(localName + '^' + namespaceURI);
    }

    /**
     * Add an attribute to this element.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @param namespaceURI  the namespace URI, may be the empty string
     * @param localName  the name
     * @param type  the type (use ""CDATA"" if the type is irrelevant)
     * @param value  the value
     */
    public void addAttribute(String namespaceURI, String localName, String type, String value) {
        attrName.addElement(localName + '^' + namespaceURI);
        attrType.addElement(type);
        attrValue.addElement(value);
        if (namespaceURI.equals(XML_NS) && localName.equals(""space"")) {
            if (value.equals(""preserve""))
                xmlSpaceAttribute = 'p';
            else if (value.equals(""default""))
                xmlSpaceAttribute = 'd';
        }
    }

    /**
     * Remove an attribute at the specified index.
     * This method is a bit inefficient.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundException  if no such attribute exist.
     */
    public void removeAttribute(int index) throws IndexOutOfBoundsException {
        attrName.removeElementAt(index);
        attrType.removeElementAt(index);
        attrValue.removeElementAt(index);
    }

    /**
     * Return the number of attributes this element have.
     */
    public int numberOfAttributes() {
        return attrName.size();
    }

    /**
     * Get the namespace URI for the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the namespace URI, may be (and is usually) the empty string,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeNamespaceURI(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(s.indexOf('^') + 1);
    }

    /**
     * Get the name of the attribute at the specified index.
     *
     * @param index  the index as returned from {@link #lookupAttribute}
     *
     * @return the localName,
     *         or <code>null</code> if index is -1
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeLocalName(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        String s = (String) attrName.elementAt(index);
        return s.substring(0, s.indexOf('^'));
    }

    /**
     * Get the type of the attribute at the specified index.
     *
     * The attribute type is one of the strings
     * ""CDATA"", ""ID"", ""IDREF"", ""IDREFS"", ""NMTOKEN"", ""NMTOKENS"",
     * ""ENTITY"", ""ENTITIES"", or ""NOTATION"" (always in upper case).
     *
     * @return the attribute type,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeType(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrType.elementAt(index);
    }

    /**
     * Get the value of the attribute at the specified index.
     *
     * @return the attribute value,
     *         or <code>null</code> if index is -1
     * @param index  the index as returned from {@link #lookupAttribute}
     * @throws IndexOutOfBoundsException  if no such attribute exist.
     */
    public String getAttributeValue(int index) throws IndexOutOfBoundsException {
        if (index == -1)
            return null;
        return (String) attrValue.elementAt(index);
    }

    void setNamespaceMappings(Vector prefixes, Vector URIs) {
        namespacePrefixes = prefixes;
        namespaceURIs = URIs;
    }

    /**
     * Add a namespace mapping to this element.
     *
     * @param prefix  the prefix
     * @param URI  the namespace URI
     */
    public void addNamespaceMapping(String prefix, String URI) {
        namespacePrefixes.addElement(prefix);
        namespaceURIs.addElement(URI);
    }

    /**
     * Return the number of namespace mapping for this element.
     */
    public int numberOfNamespaceMappings() {
        return namespacePrefixes.size();
    }

    /**
     * Return a namespace mapping at the specified index.
     *
     * @return a String[] with [0] = prefix, [1] = namespace URI
     * @throws IndexOutOfBoundsException  if no such mapping exist.
     */
    public String[] getNamespaceMapping(int index) throws IndexOutOfBoundsException {
        return new String[] { (String) namespacePrefixes.elementAt(index), (String) namespaceURIs.elementAt(index) };
    }

    public String lookupNamespaceURI(String prefix) {
        int index = namespacePrefixes.indexOf(prefix);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespaceURI(prefix);
            } else {
                if (prefix.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespaceURIs.elementAt(index);
        }
    }

    public String lookupNamespacePrefix(String URI) {
        int index = namespaceURI.indexOf(URI);
        if (index == -1) {
            if (parent != null) {
                return parent.lookupNamespacePrefix(URI);
            } else {
                if (URI.length() == 0) {
                    return """";
                } else {
                    return null;
                }
            }
        } else {
            return (String) namespacePrefixes.elementAt(index);
        }
    }

    /**
     * Set the baseURI property of this element.
     *
     * @param URI  the base URI, must be absolute
     */
    public void setBaseURI(URL URI) {
        baseURI = URI;
    }

    public URL getBaseURI() {
        if (baseURI != null) {
            return baseURI;
        } else {
            if (parent != null) {
                return parent.getBaseURI();
            } else {
                return null;
            }
        }
    }

    public boolean getPreserveSpace() {
        switch(xmlSpaceAttribute) {
            case 'p':
                return true;
            case 'd':
                return false;
            default:
                if (parent != null) {
                    return parent.getPreserveSpace();
                } else {
                    return false;
                }
        }
    }

    public String getInheritedAttribute(String namespaceURI, String localName) {
        String val = getAttrValueOrNull(namespaceURI, localName);
        if (val != null)
            return val;
        else if (parent == null)
            return null;
        else
            return parent.getInheritedAttribute(namespaceURI, localName);
    }

    /**
     * Fire the startElement event to the given SAX2 ContentHandler.
     * Will also fire startPrefixMapping events.
     */
    public void outputStartElement(ContentHandler sax) throws SAXException {
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.startPrefixMapping((String) namespacePrefixes.elementAt(i), (String) namespaceURIs.elementAt(i));
        }
        AttributesImpl atts = new AttributesImpl();
        for (int i = 0; i < attrName.size(); i++) {
            String s = (String) attrName.elementAt(i);
            String URI = s.substring(s.indexOf('^') + 1);
            String local = s.substring(0, s.indexOf('^'));
            atts.addAttribute(URI, local, """", (String) attrType.elementAt(i), (String) attrValue.elementAt(i));
        }
        sax.startElement(namespaceURI, localName, """", atts);
    }

    /**
     * Fire the endElement event to the given SAX2 ContentHandler.
     * Will also fire endPrefixMapping events.
     */
    public void outputEndElement(ContentHandler sax) throws SAXException {
        sax.endElement(namespaceURI, localName, """");
        for (int i = 0; i < namespacePrefixes.size(); i++) {
            sax.endPrefixMapping((String) namespacePrefixes.elementAt(i));
        }
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        outputStartElement(sax);
        for (int i = 0; i < numberOfChildren(); i++) {
            getChild(i).toSAX(sax);
        }
        outputEndElement(sax);
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String localName) {
        return getAttributeValue(lookupAttribute("""", localName));
    }

    /**
     * Shortcut method for getting the value of an attribute without
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String localName) throws SAXParseException {
        String v = getAttrValueOrNull(localName);
        if (v == null)
            throw new SAXParseException(""Attribute "" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, or <code>null</code>
     * 		if the attribute doesn't exist
     */
    public String getAttrValueOrNull(String namespaceURI, String localName) {
        return getAttributeValue(lookupAttribute(namespaceURI, localName));
    }

    /**
     * Shortcut method for getting the value of an attribute with
     * namespace.
     *
     * @return the attrubute value, never <code>null</code>
     * @throws SAXParseException if the attribute doesn't exist
     */
    public String getAttrValue(String namespaceURI, String localName) throws SAXParseException {
        String v = getAttrValueOrNull(namespaceURI, localName);
        if (v == null)
            throw new SAXParseException(""Attribute {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return v;
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         or <code>null</code>
     *         if there are more than one children or one non-Text child
     */
    public String getTextContentOrNull() {
        if (numberOfChildren() == 0) {
            return """";
        } else if (numberOfChildren() > 1) {
            return null;
        } else {
            Node node = getChild(0);
            if (!(node instanceof Text))
                return null;
            return ((Text) node).getValue();
        }
    }

    /**
     * Shortcut method for getting the text content of an Element.
     *
     * @return if there is a single Text child, return its value,
     *         if there is no children, return """",
     *         never <code>null</code>.
     * @throws SAXParseException
     *         if there are more than one children or one non-Text child
     */
    public String getTextContent() throws SAXParseException {
        String s = getTextContentOrNull();
        if (s == null)
            throw new SAXParseException(""No text content"", this);
        else
            return s;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          or <code>null</code> if there is no such child.
     */
    public Element getFirstChildElementOrNull(String namespaceURI, String localName) {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            Element e = (Element) getChild(i);
            if (e.getNamespaceURI().equals(namespaceURI) && e.getLocalName().equals(localName)) {
                return e;
            }
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element child with a
     * specified name.
     *
     * @return  the first child Element with the specified name,
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there is no such child.
     */
    public Element getFirstChildElement(String namespaceURI, String localName) throws SAXParseException {
        Element e = getFirstChildElementOrNull(namespaceURI, localName);
        if (e == null)
            throw new SAXParseException(""Element {"" + namespaceURI + ""}"" + localName + "" expected"", this);
        else
            return e;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          or <code>null</code> if there are no Element children.
     */
    public Element getFirstChildElementOrNull() {
        for (int i = 0; i < numberOfChildren(); i++) if (getChild(i) instanceof Element) {
            return (Element) getChild(i);
        }
        return null;
    }

    /**
     * Shortcut method for getting the first Element children with any name.
     *
     * @return  the first child Element
     *          never <code>null</code>.
     * @throws SAXParseException
     *         if there are no Element children.
     */
    public Element getFirstChildElement() throws SAXParseException {
        Element e = getFirstChildElementOrNull();
        if (e == null)
            throw new SAXParseException(""Element expected"", this);
        else
            return e;
    }
}
","// Element_7Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getNamespaceMapping(int)} method.
*/
class Element_7Test {","// Element_7Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getNamespaceMapping(int)} method.
*/
class Element_7Test {

	@Test
	void test_getNamespaceMapping_0() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(0);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_1() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(1);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_2() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(2);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_3() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(3);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_4() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(4);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_5() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(5);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_6() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(6);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_7() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(7);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_8() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(8);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_9() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(9);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
}

// Element_8Test.java
package nu.staldal.xtree;

import java.util.Vector;
import java.net.URL;
import org.xml.sax.*;
import org.xml.sax.helpers.AttributesImpl;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Element}.
* It contains ten unit test cases for the {@link Element#getNamespaceMapping(int)} method.
*/
class Element_8Test {
		
	@Test
	void test_getNamespaceMapping_0() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(0);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_1() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespaceMapping("""", """");
		String[] result = element.getNamespaceMapping(1);
		assertEquals("""", result[0]);
		assertEquals("""", result[1]);
	}
	
	@Test
	void test_getNamespaceMapping_2() throws Exception {
		Element element = new Element("""", """", 0, 0);
		element.addNamespaceMapping("""", """");
		element.addNamespace"
cmpl-6tvirqA1iZcBHDs98eGxOIJ8xbEow,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/SequentialTreeBuilder.java,35.804171323776245,stop,"// SequentialTreeBuilder.java
/*
 * Copyright (c) 2002-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build a list of XTree:s from a SAX2 event stream, or by parsing an XML document.
 * <p>
 * Useful to process a large document sequentially, without need to store the whole
 * document in memory at the same time.
 * <p>
 * The SequentialTreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class SequentialTreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private static final String XML_NS = ""http://www.w3.org/XML/1998/namespace"";

    private URL baseURI;

    private Locator locator = null;

    private ElementHandler handler;

    private Element rootElement;

    private TreeBuilder subTreeBuilder;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private int inSubTree = 0;

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     *
     * @param handler   handler to invoke for each element
     */
    public SequentialTreeBuilder(ElementHandler handler) {
        this(handler, null);
    }

    /**
     * Constructs a SequentialTreeBuilder, ready to receive SAX events.
     *
     * @param handler   handler to invoke for each element
     * @param base      base URL for the document, to support xml:base.
     */
    public SequentialTreeBuilder(ElementHandler handler, URL base) {
        this.handler = handler;
        baseURI = base;
        subTreeBuilder = new TreeBuilder();
    }

    /**
     * Obtain the root Element
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getRootElement() throws IllegalStateException {
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
        subTreeBuilder.setDocumentLocator(locator);
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (rootElement == null) {
            rootElement = new Element(namespaceURI, localName, atts.getLength());
            if (locator != null) {
                rootElement.setSystemId(locator.getSystemId());
                rootElement.setLine(locator.getLineNumber());
                rootElement.setColumn(locator.getColumnNumber());
            }
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
            for (int i = 0; i < atts.getLength(); i++) {
                rootElement.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
                if (atts.getURI(i).equals(XML_NS) && atts.getLocalName(i).equals(""base"")) {
                    try {
                        URL url = new URL(rootElement.getBaseURI(), atts.getValue(i));
                        rootElement.setBaseURI(url);
                    } catch (java.net.MalformedURLException e) {
                        throw new SAXException(e);
                    }
                }
            }
            if (nsPrefix != null) {
                rootElement.setNamespaceMappings(nsPrefix, nsURI);
            }
        } else {
            inSubTree++;
            subTreeBuilder.startElement(namespaceURI, localName, qName, atts);
        }
    }

    public void endElement(String namespaceURI, String localName, String qName) throws SAXException {
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qName + ')');
        if (inSubTree > 0) {
            subTreeBuilder.endElement(namespaceURI, localName, qName);
            if (inSubTree == 1) {
                Element el = subTreeBuilder.getTree();
                el.setParent(rootElement);
                handler.processElement(el);
                subTreeBuilder.reset();
            }
            inSubTree--;
        } else {
            // nothing to do
        }
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (rootElement == null) {
            if (nsPrefix == null) {
                nsPrefix = new Vector();
                nsURI = new Vector();
            }
            nsPrefix.addElement(prefix);
            nsURI.addElement(uri);
        } else {
            subTreeBuilder.startPrefixMapping(prefix, uri);
        }
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.characters(ch, start, length);
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.ignorableWhitespace(ch, start, length);
    }

    public void processingInstruction(String target, String data) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.processingInstruction(target, data);
    }

    public void skippedEntity(String name) throws SAXException {
        if (inSubTree > 0)
            subTreeBuilder.skippedEntity(name);
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains ten unit test cases for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {","// SequentialTreeBuilderTest.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link SequentialTreeBuilder}.
* It contains ten unit test cases for the {@link SequentialTreeBuilder#parseXMLSequential(InputSource, boolean, ElementHandler)} method.
*/
class SequentialTreeBuilderTest {

	@Test
	void testParseXMLSequential() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential2() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential3() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential4() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential5() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential6() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential7() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential8() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential9() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
	
	@Test
	void testParseXMLSequential10() throws Exception {
		InputSource xmlInput = new InputSource(new StringReader(""<root><a/><b/><c/></root>""));
		ElementHandler handler = new ElementHandler() {
			public void processElement(Element el) {
				System.out.println(el.getLocalName());
			}
		};
		Element rootElement = SequentialTreeBuilder.parseXMLSequential(xmlInput, false, handler);
		assertEquals(""root"", rootElement.getLocalName());
	}
}"
cmpl-6tvjuATTFJx2axPaQ3JNUEeC9wjql,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/Text.java,12.077489376068115,stop,"// Text.java
/*
 * Copyright (c) 2001-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import org.xml.sax.*;

/**
 * Character content in an XML document. This class is immutible.
 */
public class Text extends Node {

    static final long serialVersionUID = -128692223369356277L;

    final String value;

    transient char[] charArrayCache;

    /**
     * Constructs a text node from a char[] buffer.
     *
     * @param data  a char[] buffer
     * @param start  the offset to read from in the buffer
     * @param length  the number of characters to read from the buffer
     * @param forceCopy  force copying of the data, if false a reference
     *                   to the buffer may be keept.
     */
    public Text(char[] data, int start, int length, boolean forceCopy) {
        value = new String(data, start, length);
        if (start == 0 && length == data.length && !forceCopy)
            charArrayCache = data;
    }

    /**
     * Constructs a text node from a String.
     *
     * @param value  the string
     */
    public Text(String value) {
        this.value = value;
    }

    /**
     * Get the charater content as a string
     */
    public String getValue() {
        return value;
    }

    private void obtainCharArray() {
        if (charArrayCache == null)
            charArrayCache = value.toCharArray();
    }

    /**
     * Get the charater content as a char[].
     */
    public char[] asCharArray() {
        obtainCharArray();
        return charArrayCache;
    }

    public void toSAX(ContentHandler sax) throws SAXException {
        obtainCharArray();
        sax.characters(charArrayCache, 0, charArrayCache.length);
    }

    public boolean isWhitespaceNode() {
        for (int i = 0; i < value.length(); i++) {
            if (value.charAt(i) > ' ')
                return false;
        }
        return true;
    }
}
","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains ten unit test cases for the {@link Text#asCharArray()} method.
*/
class TextTest {","// TextTest.java
package nu.staldal.xtree;

import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link Text}.
* It contains ten unit test cases for the {@link Text#asCharArray()} method.
*/
class TextTest {

	@Test
	void testAsCharArray() {
		char[] data = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
		Text text = new Text(data, 0, data.length, false);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 0, data.length, true);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 5, data.length - 5, false);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 5, data.length - 5, true);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 0, data.length - 5, false);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 0, data.length - 5, true);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 5, data.length - 10, false);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 5, data.length - 10, true);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 5, data.length - 5, false);
		assertArrayEquals(data, text.asCharArray());
		
		text = new Text(data, 5, data.length - 5, true);
		assertArrayEquals(data, text.asCharArray());
	}
}"
cmpl-6tvkxb7E3mOiS6pD4r1w3GeOH8ur8,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_0Test.java,55.899739503860474,length,"// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {","// TreeBuilder_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#fileToInputSource(File)} method.
*/
class TreeBuilder_0Test {

		@Test
		void test_0() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_1() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_2() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_3() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_4() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_5() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_6() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_7() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_8() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
		
		@Test
		void test_9() throws Exception {
				File file = new File(""src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"");
				InputSource inputSource = TreeBuilder.fileToInputSource(file);
				assertEquals(""file:/src/test/resources/nu/staldal/xtree/TreeBuilder_0Test.xml"", inputSource.getSystemId());
		}
}

// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {
		
		@Test
		void test_0() throws Exception {
				InputSource inputSource = new InputSource(""src/test/resources/nu/staldal/xtree/TreeBuilder_1Test.xml"");
				Element element = TreeBuilder.parseXML(inputSource, false);
				assertEquals(""http://www.staldal.nu/"", element.getNamespaceURI());
				assertEquals(""root"", element.getLocalName());
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(0));
				assertEquals(""attr"", element.getAttributeLocalName(0));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(1));
				assertEquals(""attr2"", element.getAttributeLocalName(1));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(2));
				assertEquals(""attr3"", element.getAttributeLocalName(2));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(3));
				assertEquals(""attr4"", element.getAttributeLocalName(3));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(4));
				assertEquals(""attr5"", element.getAttributeLocalName(4));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(5));
				assertEquals(""attr6"", element.getAttributeLocalName(5));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(6));
				assertEquals(""attr7"", element.getAttributeLocalName(6));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(7));
				assertEquals(""attr8"", element.getAttributeLocalName(7));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(8));
				assertEquals(""attr9"", element.getAttributeLocalName(8));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(9));
				assertEquals(""attr10"", element.getAttributeLocalName(9));
				assertEquals(""http://www.staldal.nu/"", element.getAttributeNamespaceURI(10));
				assertEquals(""attr11"","
cmpl-6tvm0vlHMpOPnqnm7ivp74IIHIsjq,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/TreeBuilder_1Test.java,53.05682706832886,length,"// TreeBuilder.java
/*
 * Copyright (c) 2001-2003, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;

/**
 * Build an XTree from a SAX2 event stream, or by parsing an XML document.
 *
 * The TreeBuilder ensures that the tree will not have two adjacent Text nodes.
 */
public class TreeBuilder implements ContentHandler, ErrorHandler {

    public static final boolean DEBUG = false;

    private Element rootElement = null;

    private Stack elementStack;

    private Vector nsPrefix = null;

    private Vector nsURI = null;

    private StringBuffer textBuffer = null;

    private String textSystemId = null;

    private int textLine = -1;

    private int textColumn = -1;

    private Locator locator = null;

    private URL baseURI;

    /**
     * Create an SAX InputSource from a File object.
     *
     * @param file  the file
     *
     * @return an InputSource
     * @throws FileNotFoundException  if the file doesn't exist
     * @throws FileNotFoundException  if some I/O error occurs
     */
    public static InputSource fileToInputSource(File file) throws FileNotFoundException, IOException {
        // we should use File.toURL() here, but it's Java2
        String absPath = file.getCanonicalPath().replace(File.separatorChar, '/');
        String systemId = ""file:"" + ((absPath.charAt(0) == '/') ? ""//"" : ""///"") + absPath;
        if (!file.isFile())
            throw new FileNotFoundException(systemId);
        return new InputSource(systemId);
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        }
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     * Will not support xml:base.
     */
    public TreeBuilder() {
        this(null);
    }

    /**
     * Constructs a TreeBuilder, ready to receive SAX events.
     *
     * @param base  base URL for the document, to support xml:base.
     */
    public TreeBuilder(URL base) {
        elementStack = new Stack();
        baseURI = base;
    }

    /**
     * Obtain the XTree built from SAX events.
     *
     * @throws IllegalStateException  if the SAX events received so far
     * doesn't constitues a well-formed XML document.
     */
    public Element getTree() throws IllegalStateException {
        if (!elementStack.isEmpty())
            throw new IllegalStateException(""All elements are not yet ended"");
        if (rootElement == null)
            throw new IllegalStateException(""No root element"");
        return rootElement;
    }

    void reset() {
        rootElement = null;
        elementStack = new Stack();
        nsPrefix = null;
        nsURI = null;
        textBuffer = null;
        textSystemId = null;
        textLine = -1;
        textColumn = -1;
    }

    private void addCharacters() {
        if ((textBuffer != null) && (textBuffer.length() > 0)) {
            Element parent = (Element) elementStack.peek();
            Node node = new Text(textBuffer.toString());
            node.setSystemId(textSystemId);
            node.setLine(textLine);
            node.setColumn(textColumn);
            parent.addChild(node);
        }
        textBuffer = null;
    }

    // ContentHandler implementation
    public void setDocumentLocator(Locator locator) {
        this.locator = locator;
    }

    public void startDocument() throws SAXException {
        // nothing to do
    }

    public void endDocument() throws SAXException {
        // nothing to do
    }

    public void startElement(String namespaceURI, String localName, String qname, Attributes atts) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""startElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        Element el = new Element(namespaceURI, localName, atts.getLength());
        if (locator != null) {
            el.setSystemId(locator.getSystemId());
            el.setLine(locator.getLineNumber());
            el.setColumn(locator.getColumnNumber());
        }
        if (rootElement == null) {
            rootElement = el;
            if (baseURI != null)
                rootElement.setBaseURI(baseURI);
        } else {
            Element parent = (Element) elementStack.peek();
            parent.addChild(el);
        }
        for (int i = 0; i < atts.getLength(); i++) {
            el.addAttribute(atts.getURI(i), atts.getLocalName(i), atts.getType(i), atts.getValue(i));
            if (atts.getURI(i).equals(Node.XML_NS) && atts.getLocalName(i).equals(""base"")) {
                try {
                    URL url = new URL(el.getBaseURI(), atts.getValue(i));
                    el.setBaseURI(url);
                } catch (java.net.MalformedURLException e) {
                    throw new SAXException(e);
                }
            }
        }
        if (nsPrefix != null) {
            el.setNamespaceMappings(nsPrefix, nsURI);
        }
        elementStack.push(el);
        nsPrefix = null;
        nsURI = null;
    }

    public void endElement(String namespaceURI, String localName, String qname) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""endElement("" + namespaceURI + ',' + localName + ',' + qname + ')');
        elementStack.pop();
    }

    public void startPrefixMapping(String prefix, String uri) throws SAXException {
        if (DEBUG)
            System.out.println(""startPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ',' + uri + ')');
        if (nsPrefix == null) {
            nsPrefix = new Vector();
            nsURI = new Vector();
        }
        nsPrefix.addElement(prefix);
        nsURI.addElement(uri);
    }

    public void endPrefixMapping(String prefix) throws SAXException {
        if (DEBUG)
            System.out.println(""endPrefixMapping("" + ((prefix.length() == 0) ? ""<default>"" : prefix) + ')');
        // nothing to do
    }

    public void characters(char[] ch, int start, int length) throws SAXException {
        if (textBuffer == null) {
            textBuffer = new StringBuffer(length);
        }
        textBuffer.append(ch, start, length);
        if (locator != null) {
            textSystemId = locator.getSystemId();
            textLine = locator.getLineNumber();
            textColumn = locator.getColumnNumber();
        }
    }

    public void ignorableWhitespace(char[] ch, int start, int length) throws SAXException {
        // nothing to do
    }

    public void processingInstruction(String target, String data) throws SAXException {
        addCharacters();
        if (DEBUG)
            System.out.println(""processingInstruction("" + target + ',' + data + ')');
        Element parent = (Element) elementStack.peek();
        Node node = new ProcessingInstruction(target, data);
        if (locator != null) {
            node.setSystemId(locator.getSystemId());
            node.setLine(locator.getLineNumber());
            node.setColumn(locator.getColumnNumber());
        }
        parent.addChild(node);
    }

    public void skippedEntity(String name) throws SAXException {
        // nothing to do
    }

    // ErrorHandler implementation
    public void fatalError(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void error(SAXParseException e) throws SAXParseException {
        throw e;
    }

    public void warning(SAXParseException e) {
        // do nothing
    }
}
","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {","// TreeBuilder_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import org.xml.sax.*;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link TreeBuilder}.
* It contains ten unit test cases for the {@link TreeBuilder#parseXML(InputSource, boolean)} method.
*/
class TreeBuilder_1Test {

		@Test
		public void test1() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root/>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		public void test2() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root attr=\""value\""/>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(1, root.getAttributeCount());
				assertEquals(""attr"", root.getAttributeName(0));
				assertEquals(""value"", root.getAttributeValue(0));
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		public void test3() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child/></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(1, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(0, ((Element)child).getChildCount());
		}
		
		@Test
		public void test4() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text</child></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(1, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(1, ((Element)child).getChildCount());
				Node text = ((Element)child).getChild(0);
				assertTrue(text instanceof Text);
				assertEquals(""text"", text.getText());
		}
		
		@Test
		public void test5() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text1<child2/>text2</child></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(1, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(3, ((Element)child).getChildCount());
				Node text1 = ((Element)child).getChild(0);
				assertTrue(text1 instanceof Text);
				assertEquals(""text1"", text1.getText());
				Node child2 = ((Element)child).getChild(1);
				assertTrue(child2 instanceof Element);
				assertEquals(""child2"", child2.getLocalName());
				assertEquals(0, ((Element)child2).getAttributeCount());
				assertEquals(0, ((Element)child2).getChildCount());
				Node text2 = ((Element)child).getChild(2);
				assertTrue(text2 instanceof Text);
				assertEquals(""text2"", text2.getText());
		}
		
		@Test
		public void test6() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text1<child2/>text2</child>text3</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(2, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(3, ((Element)child).getChildCount());
				Node text1 = ((Element)child).getChild(0);
				assertTrue(text1 instanceof Text);
				assertEquals(""text1"", text1.getText());
				Node child2 = ((Element)child).getChild(1);
				assertTrue(child2 instanceof Element);
				assertEquals(""child2"", child2.getLocalName());
				assertEquals(0, ((Element)child2).getAttributeCount());
				assertEquals(0, ((Element)child2).getChildCount());
				Node text2 = ((Element)child).getChild(2);
				assertTrue(text2 instanceof Text);
				assertEquals(""text2"", text2.getText());
				Node text3 = root.getChild(1);
				assertTrue(text3 instanceof Text);
				assertEquals(""text3"", text3.getText());
		}
		
		@Test
		public void test7() throws Exception {
				String xml = ""<?xml version=\""1.0\""?><root><child>text1<child2/>text2</child>text3<child3/></root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				Element root = TreeBuilder.parseXML(xmlInput, false);
				assertEquals(""root"", root.getLocalName());
				assertEquals(0, root.getAttributeCount());
				assertEquals(3, root.getChildCount());
				Node child = root.getChild(0);
				assertTrue(child instanceof Element);
				assertEquals(""child"", child.getLocalName());
				assertEquals(0, ((Element)child).getAttributeCount());
				assertEquals(3, ((Element)child).getChildCount());
				Node text1 = ((Element)child).getChild(0);
				assertTrue(text1 instanceof Text"
cmpl-6tvn3GUSVpBql3IFk12DgDoONQJUK,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_0Test.java,53.9176459312439,length,"// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {","// XTreeUtil_0Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_0Test {

		@Test
		void test_0() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(""a"", result.getLocalName());
		}
		
		@Test
		void test_1() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals("""", result.getNamespaceURI());
		}
		
		@Test
		void test_2() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getAttributeCount());
		}
		
		@Test
		void test_3() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getChildCount());
		}
		
		@Test
		void test_4() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getLineNumber());
		}
		
		@Test
		void test_5() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getColumnNumber());
		}
		
		@Test
		void test_6() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getSystemId().length());
		}
		
		@Test
		void test_7() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getPublicId().length());
		}
		
		@Test
		void test_8() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getBaseURI().length());
		}
		
		@Test
		void test_9() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getPrefix().length());
		}
}

// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXML(InputSource, boolean, String, InputSource)} method.
*/
class XTreeUtil_1Test {
		
		@Test
		void test_0() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(""a"", result.getLocalName());
		}
		
		@Test
		void test_1() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals("""", result.getNamespaceURI());
		}
		
		@Test
		void test_2() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
				assertEquals(0, result.getAttributeCount());
		}
		
		@Test
		void test_3() throws Exception {
				InputSource xmlInput = new InputSource(new StringReader(""<a/>""));
				boolean validateDTD = false;
				String schemaType = null;
				InputSource schema = null;
				Element result = XTreeUtil.parseXML(xmlInput, validateDTD, schemaType, schema);
			"
cmpl-6tvo6dj10w2QHm5Po2p3stcpLa6dr,/EvoSuiteBenchmark/52_lagoon/src/main/java/nu/staldal/xtree/XTreeUtil_1Test.java,55.37627029418945,length,"// XTreeUtil.java
/*
 * Copyright (c) 2002-2004, Mikael St�ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as ""the modified BSD license"". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;

/**
 * Some utility methods for XTree. All methods in this class are static.
 */
public final class XTreeUtil {

    /**
     * Private default constructor to prevent instantiation.
     */
    private XTreeUtil() {
    }

    /**
     * Parse an XML document into an XTree.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     *
     * @return an XTree representation of the XML data
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXML(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            parserFactory.setFeature(""http://xml.org/sax/features/namespaces"", true);
            parserFactory.setFeature(""http://xml.org/sax/features/namespace-prefixes"", false);
            parserFactory.setFeature(""http://xml.org/sax/features/validation"", validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            TreeBuilder tb = new TreeBuilder();
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getTree();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Parse an XML document into a list of XTree:s, one for each element under the root.
     * Uses JAXP to find a parser and JARV to find a validator.
     * Will not support xml:base.
     *
     * @param xmlInput    the input to parse
     * @param validateDTD validate using DTD
     * @param schemaType  the type of schema to use, or <code>null</code>
     *                    for no schema validation
     * @param schema      the schema to use, or <code>null</code>
     *                    for no schema validation
     * @param handler     handler to invoke for each element
     *
     * @return the root element (without any children)
     *
     * @throws SAXParseException if the XML data is not valid
     * @throws SAXException if any other error occurs while parsing the XML data
     * @throws IOException  if there was some I/O error while reading the input.
     */
    public static Element parseXMLSequential(InputSource xmlInput, boolean validateDTD, String schemaType, InputSource schema, ElementHandler handler) throws SAXParseException, SAXException, IOException {
        try {
            SAXParserFactory parserFactory = SAXParserFactory.newInstance();
            parserFactory.setNamespaceAware(true);
            parserFactory.setValidating(validateDTD);
            XMLReader xmlReader = parserFactory.newSAXParser().getXMLReader();
            SequentialTreeBuilder tb = new SequentialTreeBuilder(handler);
            if (schema != null) {
                VerifierFactory vf = VerifierFactory.newInstance(schemaType);
                Verifier verifier = vf.newVerifier(schema);
                VerifierFilter filter = verifier.getVerifierFilter();
                filter.setParent(xmlReader);
                xmlReader = filter;
            }
            xmlReader.setContentHandler(tb);
            xmlReader.setErrorHandler(tb);
            xmlReader.parse(xmlInput);
            if ((schema != null) && !((VerifierFilter) xmlReader).isValid()) {
                throw new SAXParseException(""Invalid XML data"", null, null, -1, -1);
            }
            return tb.getRootElement();
        } catch (javax.xml.parsers.ParserConfigurationException e) {
            throw new Error(""XML parser configuration error: "" + e.getMessage());
        } catch (VerifierConfigurationException e) {
            throw new Error(""XML verifier configuration error: "" + e.getMessage());
        }
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os) throws IOException {
        Properties prop = new Properties();
        prop.setProperty(OutputKeys.METHOD, ""xml"");
        prop.setProperty(OutputKeys.ENCODING, ""utf-8"");
        prop.setProperty(OutputKeys.INDENT, ""no"");
        serialize(tree, os, prop);
    }

    /**
     * Serialize an XTree into an OutputStream.
     *
     * @param tree      the XTree to serialize
     * @param os        the OutputStream to write to
     * @param prop  	output properties
     *
     * @throws IOException if any error occurs
     */
    public static void serialize(Node tree, OutputStream os, Properties prop) throws IOException {
        try {
            TransformerFactory tf = TransformerFactory.newInstance();
            if (!(tf.getFeature(SAXTransformerFactory.FEATURE) && tf.getFeature(StreamResult.FEATURE))) {
                throw new Error(""The transformer factory "" + tf.getClass().getName() + "" doesn't support SAX"");
            }
            SAXTransformerFactory tfactory = (SAXTransformerFactory) tf;
            TransformerHandler th = tfactory.newTransformerHandler();
            th.setResult(new StreamResult(os));
            Transformer trans = th.getTransformer();
            trans.setOutputProperties(prop);
            ContentHandler ch = new ContentHandlerFixer(th, true);
            try {
                ch.startDocument();
                tree.toSAX(ch);
                ch.endDocument();
            } catch (SAXException e) {
                throw new IOException(e.toString());
            }
        } catch (TransformerConfigurationException e) {
            throw new Error(e.toString());
        }
    }
}
","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {","// XTreeUtil_1Test.java
package nu.staldal.xtree;

import java.util.*;
import java.io.*;
import java.net.URL;
import javax.xml.parsers.*;
import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.StreamResult;
import org.xml.sax.*;
import org.iso_relax.verifier.*;
import nu.staldal.xmlutil.ContentHandlerFixer;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link XTreeUtil}.
* It contains ten unit test cases for the {@link XTreeUtil#parseXMLSequential(InputSource, boolean, String, InputSource, ElementHandler)} method.
*/
class XTreeUtil_1Test {

		@Test
		void test_1() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void onElement(Element element) {
								System.out.println(element.getName());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_2() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void onElement(Element element) {
								System.out.println(element.getName());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_3() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void onElement(Element element) {
								System.out.println(element.getName());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_4() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void onElement(Element element) {
								System.out.println(element.getName());
						}
				};
				Element root = XTreeUtil.parseXMLSequential(xmlInput, true, null, null, handler);
				assertEquals(""root"", root.getName());
				assertEquals(0, root.getChildCount());
		}
		
		@Test
		void test_5() throws Exception {
				String xml = ""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>\n"" +
										 ""<!DOCTYPE root [\n"" +
										 ""<!ELEMENT root (child1, child2)>\n"" +
										 ""<!ELEMENT child1 (#PCDATA)>\n"" +
										 ""<!ELEMENT child2 (#PCDATA)>\n"" +
										 ""]>\n"" +
										 ""<root>\n"" +
										 ""  <child1>text1</child1>\n"" +
										 ""  <child2>text2</child2>\n"" +
										 ""</root>"";
				InputSource xmlInput = new InputSource(new StringReader(xml));
				ElementHandler handler = new ElementHandler() {
						public void onElement(Element element) {
								System.out.println(element.getName());
						}
				};
				Element root = XTreeUtil.parseX"
