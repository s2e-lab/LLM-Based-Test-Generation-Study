ID,PROMPT_ID,DURATION,FINISH_REASON,ORIGINAL_CODE,TEST_PROMPT,GENERATED_TEST
cmpl-6u25MtK8lOR7kl6yqrikVVeIaIKZq,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_0Test.java,59.8282573223114,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_0Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getValue(String)} method.
*/
class JCLO_0Test {","// JCLO_0Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getValue(String)} method.
*/
class JCLO_0Test {

		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is null.
		*/
		@Test
		void testGetValue_0() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertNull(jclo.getValue(null));
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is empty.
		*/
		@Test
		void testGetValue_1() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertNull(jclo.getValue(""""));
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is not found.
		*/
		@Test
		void testGetValue_2() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertNull(jclo.getValue(""notFound""));
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_3() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""a""), ""a"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_4() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""b""), ""b"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_5() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""c""), ""c"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_6() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""d""), ""d"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_7() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""e""), ""e"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_8() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""f""), ""f"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_9() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""g""), ""g"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_10() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""h""), ""h"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_11() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""i""), ""i"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_12() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""j""), ""j"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_13() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""k""), ""k"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_14() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""l""), ""l"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_15() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""m""), ""m"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_16() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""n""), ""n"");
		}
		
		/**
		* Test case for {@link JCLO#getValue(String)} method.
		* It tests the case when the key is found.
		*/
		@Test
		void testGetValue_17() {
				JCLO jclo = new JCLO(new JCLO_0Test());
				assertEquals(jclo.getValue(""o""), ""o"");"
cmpl-6u26PJlqVuYYNM9x6w7ksguNItKih,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_10Test.java,60.77801752090454,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_10Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getString(String)} method.
*/
class JCLO_10Test {","// JCLO_10Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getString(String)} method.
*/
class JCLO_10Test {

		/**
		* Test case 1 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString1() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test""});
				assertEquals(""test"", jclo.getString(""string""));
		}
		
		/**
		* Test case 2 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString2() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2""});
				assertEquals(""test2"", jclo.getString(""string""));
		}
		
		/**
		* Test case 3 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString3() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3""});
				assertEquals(""test3"", jclo.getString(""string""));
		}
		
		/**
		* Test case 4 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString4() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3"", ""-string"", ""test4""});
				assertEquals(""test4"", jclo.getString(""string""));
		}
		
		/**
		* Test case 5 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString5() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3"", ""-string"", ""test4"", ""-string"", ""test5""});
				assertEquals(""test5"", jclo.getString(""string""));
		}
		
		/**
		* Test case 6 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString6() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3"", ""-string"", ""test4"", ""-string"", ""test5"", ""-string"", ""test6""});
				assertEquals(""test6"", jclo.getString(""string""));
		}
		
		/**
		* Test case 7 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString7() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3"", ""-string"", ""test4"", ""-string"", ""test5"", ""-string"", ""test6"", ""-string"", ""test7""});
				assertEquals(""test7"", jclo.getString(""string""));
		}
		
		/**
		* Test case 8 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString8() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3"", ""-string"", ""test4"", ""-string"", ""test5"", ""-string"", ""test6"", ""-string"", ""test7"", ""-string"", ""test8""});
				assertEquals(""test8"", jclo.getString(""string""));
		}
		
		/**
		* Test case 9 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString9() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3"", ""-string"", ""test4"", ""-string"", ""test5"", ""-string"", ""test6"", ""-string"", ""test7"", ""-string"", ""test8"", ""-string"", ""test9""});
				assertEquals(""test9"", jclo.getString(""string""));
		}
		
		/**
		* Test case 10 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString10() {
				JCLO jclo = new JCLO(new JCLO_10Test());
				jclo.parse(new String[] {""-string"", ""test"", ""-string"", ""test2"", ""-string"", ""test3"", ""-string"", ""test4"", ""-string"", ""test5"", ""-string"", ""test6"", ""-string"", ""test7"", ""-string"", ""test8"", ""-string"", ""test9"", ""-string"", ""test10""});
				assertEquals(""test10"", jclo.getString(""string""));
		}
}

// JCLO_11Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains eleven unit test cases for the {@link JCLO#getString(String)} method.
*/
class JCLO_11Test {
		
		/**
		* Test case 1 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString1() {
				JCLO jclo = new JCLO(new JCLO_11Test());
				jclo.parse(new String[] {""-string"", ""test""});
				assertEquals(""test"", jclo.getString(""string""));
		}
		
		/**
		* Test case 2 for {@link JCLO#getString(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetString2() {
				JCLO jclo = new J"
cmpl-6u27OQWtDyq7oQU2Mwjk7Tmvj3b2h,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_11Test.java,56.792696714401245,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_11Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getBytes(String)} method.
*/
class JCLO_11Test {","// JCLO_11Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getBytes(String)} method.
*/
class JCLO_11Test {

		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetBytes_Valid() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1""});
				byte[] expected = {1};
				byte[] actual = jclo.getBytes(""b"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with an invalid argument.
		*/
		@Test
		void testGetBytes_Invalid() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1""});
				byte[] expected = {1};
				byte[] actual = jclo.getBytes(""c"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with a null argument.
		*/
		@Test
		void testGetBytes_Null() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1""});
				byte[] expected = {1};
				byte[] actual = jclo.getBytes(null);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with an empty argument.
		*/
		@Test
		void testGetBytes_Empty() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1""});
				byte[] expected = {1};
				byte[] actual = jclo.getBytes("""");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetBytes_Valid_2() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2""});
				byte[] expected = {1, 2};
				byte[] actual = jclo.getBytes(""b"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with an invalid argument.
		*/
		@Test
		void testGetBytes_Invalid_2() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2""});
				byte[] expected = {1, 2};
				byte[] actual = jclo.getBytes(""c"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with a null argument.
		*/
		@Test
		void testGetBytes_Null_2() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2""});
				byte[] expected = {1, 2};
				byte[] actual = jclo.getBytes(null);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with an empty argument.
		*/
		@Test
		void testGetBytes_Empty_2() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2""});
				byte[] expected = {1, 2};
				byte[] actual = jclo.getBytes("""");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetBytes_Valid_3() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2"", ""3""});
				byte[] expected = {1, 2, 3};
				byte[] actual = jclo.getBytes(""b"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with an invalid argument.
		*/
		@Test
		void testGetBytes_Invalid_3() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2"", ""3""});
				byte[] expected = {1, 2, 3};
				byte[] actual = jclo.getBytes(""c"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with a null argument.
		*/
		@Test
		void testGetBytes_Null_3() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2"", ""3""});
				byte[] expected = {1, 2, 3};
				byte[] actual = jclo.getBytes(null);
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with an empty argument.
		*/
		@Test
		void testGetBytes_Empty_3() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", ""2"", ""3""});
				byte[] expected = {1, 2, 3};
				byte[] actual = jclo.getBytes("""");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getBytes(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetBytes_Valid_4() {
				JCLO_11 jclo = new JCLO_11();
				jclo.parse(new String[]{""-b"", ""1"", """
cmpl-6u28R8QcM0iYHmNnH9Sud23OHNrPS,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_12Test.java,53.13863921165466,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_12Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getChars(String)} method.
*/
class JCLO_12Test {","// JCLO_12Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getChars(String)} method.
*/
class JCLO_12Test {

		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetChars_ValidKey() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertEquals('a', jclo.getChars(""c""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with an invalid key.
		*/
		@Test
		void testGetChars_InvalidKey() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""a""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar2() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar3() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar4() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""e""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar5() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""f""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar6() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""g""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar7() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""h""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar8() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar9() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""j""));
		}
		
		/**
		* Test case for {@link JCLO#getChars(String)} method.
		* It tests the method with a key that is not a char.
		*/
		@Test
		void testGetChars_KeyNotChar10() {
				JCLO_12 jclo = new JCLO_12();
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChars(""k""));
		}
}

// JCLO_12.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
* This class is used to parse command-line arguments based on a the
* variables with an object.  Each variable in the class specifies a
* command-line argument that can be accepted; the name of the variable
* becomes the name of the command-line argument.  As Java does not allow
* dashes '-' in variables, use two underscores '__' if you want a dash in
* an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
* start the variable name with a single underscore.  JCLO uses reflection
* to determine the type of each variable in the passed object and sets the
* values in the object passed to it via parsing the command line.  If you
* include a String array named ""additional"", all non-dashed arguments will
* be placed in it.
*
* @author		Steve Beaty ("
cmpl-6u29Ux5OlHVb8yVXlwfJDwpntaFb3,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_13Test.java,45.415143966674805,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_13Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getShorts(String)} method.
*/
class JCLO_13Test {","// JCLO_13Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getShorts(String)} method.
*/
class JCLO_13Test {

		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array.
		*/
		@Test
		void testGetShorts_ValidShortArray() {
				JCLO_13 jclo = new JCLO_13();
				jclo.parse(new String[]{""-short"", ""1"", ""-short"", ""2"", ""-short"", ""3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with double dashes.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithDoubleDashes() {
				JCLO_13 jclo = new JCLO_13();
				jclo.parse(new String[]{""--short"", ""1"", ""--short"", ""2"", ""--short"", ""3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with equals.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithEquals() {
				JCLO_13 jclo = new JCLO_13();
				jclo.parse(new String[]{""-short=1"", ""-short=2"", ""-short=3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with double dashes and equals.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithDoubleDashesAndEquals() {
				JCLO_13 jclo = new JCLO_13();
				jclo.parse(new String[]{""--short=1"", ""--short=2"", ""--short=3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with a prefix.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithPrefix() {
				JCLO_13 jclo = new JCLO_13(""prefix"");
				jclo.parse(new String[]{""-prefixshort"", ""1"", ""-prefixshort"", ""2"", ""-prefixshort"", ""3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with a prefix and double dashes.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithPrefixAndDoubleDashes() {
				JCLO_13 jclo = new JCLO_13(""prefix"");
				jclo.parse(new String[]{""--prefixshort"", ""1"", ""--prefixshort"", ""2"", ""--prefixshort"", ""3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with a prefix and equals.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithPrefixAndEquals() {
				JCLO_13 jclo = new JCLO_13(""prefix"");
				jclo.parse(new String[]{""-prefixshort=1"", ""-prefixshort=2"", ""-prefixshort=3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with a prefix, double dashes, and equals.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithPrefixAndDoubleDashesAndEquals() {
				JCLO_13 jclo = new JCLO_13(""prefix"");
				jclo.parse(new String[]{""--prefixshort=1"", ""--prefixshort=2"", ""--prefixshort=3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with an alias.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithAlias() {
				JCLO_13 jclo = new JCLO_13(null, null, new String[][]{{""alias"", ""short""}});
				jclo.parse(new String[]{""-alias"", ""1"", ""-alias"", ""2"", ""-alias"", ""3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with an alias and double dashes.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithAliasAndDoubleDashes() {
				JCLO_13 jclo = new JCLO_13(null, null, new String[][]{{""alias"", ""short""}});
				jclo.parse(new String[]{""--alias"", ""1"", ""--alias"", ""2"", ""--alias"", ""3""});
				short[] expected = {1, 2, 3};
				short[] actual = jclo.getShorts(""short"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getShorts(String)} method.
		* It tests the method with a valid short array with an alias and equals.
		*/
		@Test
		void testGetShorts_ValidShortArrayWithAliasAndEquals() {
				JCLO_13 jclo = new JCLO_13(null, null, new String[][]{{""alias"", ""short""}}"
cmpl-6u2AXWdo2uXWYtTWtEC3zf8xcCvs9,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_14Test.java,54.355621576309204,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_14Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getInts(String)} method.
*/
class JCLO_14Test {","// JCLO_14Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getInts(String)} method.
*/
class JCLO_14Test {

		/**
		* Test case for {@link JCLO#getInts(String)} method.
		* It tests the case when the value of the variable is an array of integers.
		*/
		@Test
		void testGetInts_1() {
				JCLO_14 jclo = new JCLO_14();
				jclo.parse(new String[]{""-i"", ""1"", ""-i"", ""2"", ""-i"", ""3""});
				int[] expected = {1, 2, 3};
				int[] actual = jclo.getInts(""i"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getInts(String)} method.
		* It tests the case when the value of the variable is an array of integers.
		*/
		@Test
		void testGetInts_2() {
				JCLO_14 jclo = new JCLO_14();
				jclo.parse(new String[]{""-i"", ""1"", ""-i"", ""2"", ""-i"", ""3"", ""-i"", ""4"", ""-i"", ""5""});
				int[] expected = {1, 2, 3, 4, 5};
				int[] actual = jclo.getInts(""i"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getInts(String)} method.
		* It tests the case when the value of the variable is an array of integers.
		*/
		@Test
		void testGetInts_3() {
				JCLO_14 jclo = new JCLO_14();
				jclo.parse(new String[]{""-i"", ""1"", ""-i"", ""2"", ""-i"", ""3"", ""-i"", ""4"", ""-i"", ""5"", ""-i"", ""6"", ""-i"", ""7"", ""-i"", ""8"", ""-i"", ""9"", ""-i"", ""10""});
				int[] expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
				int[] actual = jclo.getInts(""i"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getInts(String)} method.
		* It tests the case when the value of the variable is an array of integers.
		*/
		@Test
		void testGetInts_4() {
				JCLO_14 jclo = new JCLO_14();
				jclo.parse(new String[]{""-i"", ""1"", ""-i"", ""2"", ""-i"", ""3"", ""-i"", ""4"", ""-i"", ""5"", ""-i"", ""6"", ""-i"", ""7"", ""-i"", ""8"", ""-i"", ""9"", ""-i"", ""10"", ""-i"", ""11"", ""-i"", ""12"", ""-i"", ""13"", ""-i"", ""14"", ""-i"", ""15"", ""-i"", ""16"", ""-i"", ""17"", ""-i"", ""18"", ""-i"", ""19"", ""-i"", ""20""});
				int[] expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20};
				int[] actual = jclo.getInts(""i"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getInts(String)} method.
		* It tests the case when the value of the variable is an array of integers.
		*/
		@Test
		void testGetInts_5() {
				JCLO_14 jclo = new JCLO_14();
				jclo.parse(new String[]{""-i"", ""1"", ""-i"", ""2"", ""-i"", ""3"", ""-i"", ""4"", ""-i"", ""5"", ""-i"", ""6"", ""-i"", ""7"", ""-i"", ""8"", ""-i"", ""9"", ""-i"", ""10"", ""-i"", ""11"", ""-i"", ""12"", ""-i"", ""13"", ""-i"", ""14"", ""-i"", ""15"", ""-i"", ""16"", ""-i"", ""17"", ""-i"", ""18"", ""-i"", ""19"", ""-i"", ""20"", ""-i"", ""21"", ""-i"", ""22"", ""-i"", ""23"", ""-i"", ""24"", ""-i"", ""25"", ""-i"", ""26"", ""-i"", ""27"", ""-i"", ""28"", ""-i"", ""29"", ""-i"", ""30""});
				int[] expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};
				int[] actual = jclo.getInts(""i"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getInts(String)} method.
		* It tests the case when the value of the variable is an array of integers.
		*/
		@Test
		void testGetInts_6() {
				JCLO_14 jclo = new JCLO_14();
				jclo.parse(new String[]{""-i"", ""1"", ""-i"", ""2"", ""-i"", ""3"", ""-i"", ""4"", ""-i"", ""5"", ""-i"", ""6"", ""-i"", ""7"", ""-i"", ""8"", ""-i"", ""9"", ""-i"", ""10"", ""-i"", ""11"", ""-i"", ""12"", ""-i"", ""13"", ""-i"", ""14"", ""-i"", ""15"", ""-i"", ""16"", ""-i"", ""17"", ""-i"", ""18"", ""-i"", ""19"", ""-i"", ""20"", ""-i"", ""21"", ""-i"", ""22"", ""-i"", ""23"", ""-i"", ""24"", ""-i"", ""25"", ""-i"", ""26"", ""-i"", ""27"", ""-i"", ""28"", ""-i"", ""29"", ""-i"", ""30"", ""-i"", ""31"", ""-i"", ""32"", ""-i"", ""33"", ""-i"", ""34"", ""-i"", ""35"", ""-i"", ""36"", ""-i"", ""37"", ""-i"", ""38"", ""-i"", ""39"", ""-i"", ""40""});
				int[] expected = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40};
				int[] actual = jclo.getInts(""i"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getInts(String)} method.
		* It tests the case when the value of the variable is an array of integers.
		*/
		@Test
		void testGetInts_7() {
				JCLO_14 jclo = new JCLO_14();
				jclo.parse(new String[]{""-i"", ""1"", ""-i"", ""2"", ""-i"", ""3"", ""-i"", ""4"", ""-i"", ""5"", ""-i"", ""6"", ""-i"", ""7"", ""-i"", ""8"", ""-i"", ""9"", ""-i"", ""10"", ""-i"", ""11"", ""-i"", ""12"", ""-i"", ""13"", ""-i"", ""14"", ""-i"", ""15"", ""-i"", ""16"", ""-i"", ""17"", ""-i"", ""18"", ""-"
cmpl-6u2BaeRepWgGADxMmkRWjOh0TJQ9v,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_15Test.java,59.377758502960205,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_15Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getFloats(String)} method.
*/
class JCLO_15Test {","// JCLO_15Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getFloats(String)} method.
*/
class JCLO_15Test {

		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloats_Valid() {
				JCLO_15 jclo = new JCLO_15();
				jclo.parse(new String[]{""-f"", ""1.0"", ""-f"", ""2.0"", ""-f"", ""3.0""});
				float[] expected = {1.0f, 2.0f, 3.0f};
				float[] actual = jclo.getFloats(""f"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with an invalid argument.
		*/
		@Test
		void testGetFloats_Invalid() {
				JCLO_15 jclo = new JCLO_15();
				jclo.parse(new String[]{""-f"", ""1.0"", ""-f"", ""2.0"", ""-f"", ""3.0""});
				float[] actual = jclo.getFloats(""g"");
				assertNull(actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with a valid argument and a prefix.
		*/
		@Test
		void testGetFloats_Valid_Prefix() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""-pf"", ""1.0"", ""-pf"", ""2.0"", ""-pf"", ""3.0""});
				float[] expected = {1.0f, 2.0f, 3.0f};
				float[] actual = jclo.getFloats(""f"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with an invalid argument and a prefix.
		*/
		@Test
		void testGetFloats_Invalid_Prefix() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""-pf"", ""1.0"", ""-pf"", ""2.0"", ""-pf"", ""3.0""});
				float[] actual = jclo.getFloats(""g"");
				assertNull(actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with a valid argument and a prefix.
		*/
		@Test
		void testGetFloats_Valid_Prefix_DoubleDash() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""--pf"", ""1.0"", ""--pf"", ""2.0"", ""--pf"", ""3.0""});
				float[] expected = {1.0f, 2.0f, 3.0f};
				float[] actual = jclo.getFloats(""f"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with an invalid argument and a prefix.
		*/
		@Test
		void testGetFloats_Invalid_Prefix_DoubleDash() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""--pf"", ""1.0"", ""--pf"", ""2.0"", ""--pf"", ""3.0""});
				float[] actual = jclo.getFloats(""g"");
				assertNull(actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with a valid argument and a prefix.
		*/
		@Test
		void testGetFloats_Valid_Prefix_Equals() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""-pf=1.0"", ""-pf=2.0"", ""-pf=3.0""});
				float[] expected = {1.0f, 2.0f, 3.0f};
				float[] actual = jclo.getFloats(""f"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with an invalid argument and a prefix.
		*/
		@Test
		void testGetFloats_Invalid_Prefix_Equals() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""-pf=1.0"", ""-pf=2.0"", ""-pf=3.0""});
				float[] actual = jclo.getFloats(""g"");
				assertNull(actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with a valid argument and a prefix.
		*/
		@Test
		void testGetFloats_Valid_Prefix_DoubleDash_Equals() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""--pf=1.0"", ""--pf=2.0"", ""--pf=3.0""});
				float[] expected = {1.0f, 2.0f, 3.0f};
				float[] actual = jclo.getFloats(""f"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with an invalid argument and a prefix.
		*/
		@Test
		void testGetFloats_Invalid_Prefix_DoubleDash_Equals() {
				JCLO_15 jclo = new JCLO_15(""p"");
				jclo.parse(new String[]{""--pf=1.0"", ""--pf=2.0"", ""--pf=3.0""});
				float[] actual = jclo.getFloats(""g"");
				assertNull(actual);
		}
		
		/**
		* Test case for {@link JCLO#getFloats(String)} method.
		* It tests the method with a valid argument and a prefix.
		*/
		@Test
		void testGetFloats_Valid_Prefix_DoubleDash_Equals_Alias() {
				JCLO_15 jclo = new JCLO_15(""p"", null, new String[][]{{""f"", ""g""}});
				jclo.parse(new String[]{""--pg=1.0"", ""--pg=2.0"", ""--pg=3.0""});
				float[] expected = {1.0f, 2.0f, 3.0f};"
cmpl-6u2Cd6kUUHwgrNTsi2X5Yo55UKzQA,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_16Test.java,50.97408866882324,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_16Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getDoubles(String)} method.
*/
class JCLO_16Test {","// JCLO_16Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getDoubles(String)} method.
*/
class JCLO_16Test {

		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array.
		*/
		@Test
		void testGetDoubles_ValidDoubleArray() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0,2.0,3.0""});
				double[] expected = {1.0, 2.0, 3.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValue() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpaces() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray= 1.0 ""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndComma() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray= 1.0 , ""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndCommaAndEquals() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndCommaAndEqualsAndDoubleDashes() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndCommaAndEqualsAndDoubleDashesAndPrefix() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndCommaAndEqualsAndDoubleDashesAndPrefixAndAliases() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndCommaAndEqualsAndDoubleDashesAndPrefixAndAliasesAndObject() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndCommaAndEqualsAndDoubleDashesAndPrefixAndAliasesAndObjectAndFields() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getDoubles(String)} method.
		* It tests the method with a valid double array with a single value.
		*/
		@Test
		void testGetDoubles_ValidDoubleArrayWithSingleValueAndSpacesAndCommaAndEqualsAndDoubleDashesAndPrefixAndAliasesAndObjectAndFieldsAndGetObject() {
				JCLO_16 jclo = new JCLO_16();
				jclo.parse(new String[]{""--doubleArray=1.0""});
				double[] expected = {1.0};
				double[] actual = jclo.getDoubles(""doubleArray"");
		"
cmpl-6u2Dgqto4NbE9vLLFBWeZM40CxrR5,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_17Test.java,53.17920732498169,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_17Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getLongs(String)} method.
*/
class JCLO_17Test {","// JCLO_17Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getLongs(String)} method.
*/
class JCLO_17Test {

		/**
		* Test case 1 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_1() {
				JCLO jclo = new JCLO(new JCLO_17Test_1());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 2 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_2() {
				JCLO jclo = new JCLO(new JCLO_17Test_2());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 3 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_3() {
				JCLO jclo = new JCLO(new JCLO_17Test_3());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 4 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_4() {
				JCLO jclo = new JCLO(new JCLO_17Test_4());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 5 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_5() {
				JCLO jclo = new JCLO(new JCLO_17Test_5());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 6 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_6() {
				JCLO jclo = new JCLO(new JCLO_17Test_6());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 7 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_7() {
				JCLO jclo = new JCLO(new JCLO_17Test_7());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 8 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_8() {
				JCLO jclo = new JCLO(new JCLO_17Test_8());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 9 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_9() {
				JCLO jclo = new JCLO(new JCLO_17Test_9());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case 10 for {@link JCLO#getLongs(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetLongs_10() {
				JCLO jclo = new JCLO(new JCLO_17Test_10());
				jclo.parse(new String[]{""-longs"", ""1"", ""2"", ""3""});
				long[] expected = {1, 2, 3};
				long[] actual = jclo.getLongs(""longs"");
				assertArrayEquals(expected, actual);
		}
}

class JCLO_17Test_1 {
		public long[] longs;
}

class JCLO_17Test_2 {
		public long longs[];
}

class JCLO_17Test_3 {
		public long[] longs[];
}

class JCLO_17Test_4 {
		public long longs[][];
}

class JCLO_17Test_5 {
		public long[] longs[][];
}

class JCLO_17Test_6 {
		public long longs[][][];
}

class JCLO_17Test_7 {
		public long[] longs[][][];
}

class JCLO_17Test_8 {
		public long longs[][][][];
}

class JCLO_17Test_9 {
		public long[] longs[][][][];
}

class JCLO_17Test_10 {
		public long longs[][][][][];
}

// JCLO_18Test.java"
cmpl-6u2EjOkUnmgKzkyHepyDt339drgaf,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_18Test.java,57.4685595035553,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_18Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getStrings(String)} method.
*/
class JCLO_18Test {","// JCLO_18Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getStrings(String)} method.
*/
class JCLO_18Test {

		/**
		* Test case for {@link JCLO#getStrings(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetStrings_ValidKey() {
				JCLO jclo = new JCLO(new JCLO_18Test_Object());
				jclo.parse(new String[]{""-s"", ""a"", ""-s"", ""b"", ""-s"", ""c""});
				String[] expected = {""a"", ""b"", ""c""};
				String[] actual = jclo.getStrings(""s"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getStrings(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetStrings_ValidKey_2() {
				JCLO jclo = new JCLO(new JCLO_18Test_Object());
				jclo.parse(new String[]{""-s"", ""a"", ""-s"", ""b"", ""-s"", ""c"", ""-s"", ""d"", ""-s"", ""e"", ""-s"", ""f""});
				String[] expected = {""a"", ""b"", ""c"", ""d"", ""e"", ""f""};
				String[] actual = jclo.getStrings(""s"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getStrings(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetStrings_ValidKey_3() {
				JCLO jclo = new JCLO(new JCLO_18Test_Object());
				jclo.parse(new String[]{""-s"", ""a"", ""-s"", ""b"", ""-s"", ""c"", ""-s"", ""d"", ""-s"", ""e"", ""-s"", ""f"", ""-s"", ""g"", ""-s"", ""h"", ""-s"", ""i"", ""-s"", ""j"", ""-s"", ""k"", ""-s"", ""l"", ""-s"", ""m"", ""-s"", ""n"", ""-s"", ""o"", ""-s"", ""p"", ""-s"", ""q"", ""-s"", ""r"", ""-s"", ""s"", ""-s"", ""t"", ""-s"", ""u"", ""-s"", ""v"", ""-s"", ""w"", ""-s"", ""x"", ""-s"", ""y"", ""-s"", ""z""});
				String[] expected = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z""};
				String[] actual = jclo.getStrings(""s"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getStrings(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetStrings_ValidKey_4() {
				JCLO jclo = new JCLO(new JCLO_18Test_Object());
				jclo.parse(new String[]{""-s"", ""a"", ""-s"", ""b"", ""-s"", ""c"", ""-s"", ""d"", ""-s"", ""e"", ""-s"", ""f"", ""-s"", ""g"", ""-s"", ""h"", ""-s"", ""i"", ""-s"", ""j"", ""-s"", ""k"", ""-s"", ""l"", ""-s"", ""m"", ""-s"", ""n"", ""-s"", ""o"", ""-s"", ""p"", ""-s"", ""q"", ""-s"", ""r"", ""-s"", ""s"", ""-s"", ""t"", ""-s"", ""u"", ""-s"", ""v"", ""-s"", ""w"", ""-s"", ""x"", ""-s"", ""y"", ""-s"", ""z"", ""-s"", ""A"", ""-s"", ""B"", ""-s"", ""C"", ""-s"", ""D"", ""-s"", ""E"", ""-s"", ""F"", ""-s"", ""G"", ""-s"", ""H"", ""-s"", ""I"", ""-s"", ""J"", ""-s"", ""K"", ""-s"", ""L"", ""-s"", ""M"", ""-s"", ""N"", ""-s"", ""O"", ""-s"", ""P"", ""-s"", ""Q"", ""-s"", ""R"", ""-s"", ""S"", ""-s"", ""T"", ""-s"", ""U"", ""-s"", ""V"", ""-s"", ""W"", ""-s"", ""X"", ""-s"", ""Y"", ""-s"", ""Z""});
				String[] expected = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"", ""K"", ""L"", ""M"", ""N"", ""O"", ""P"", ""Q"", ""R"", ""S"", ""T"", ""U"", ""V"", ""W"", ""X"", ""Y"", ""Z""};
				String[] actual = jclo.getStrings(""s"");
				assertArrayEquals(expected, actual);
		}
		
		/**
		* Test case for {@link JCLO#getStrings(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetStrings_ValidKey_5() {
				JCLO jclo = new JCLO(new JCLO_18Test_Object());
				jclo.parse(new String[]{""-s"", ""a"", ""-s"", ""b"", ""-s"", ""c"", ""-s"", ""d"", ""-s"", ""e"", ""-s"", ""f"", ""-s"", ""g"", ""-s"", ""h"", ""-s"", ""i"", ""-s"", ""j"", ""-s"", ""k"", ""-s"", ""l"", ""-s"", ""m"", ""-s"", ""n"", ""-s"", ""o"", ""-s"", ""p"", ""-s"", ""q"", ""-s"", ""r"", ""-s"", ""s"", ""-s"", ""t"", ""-s"", ""u"", ""-s"", ""v"", ""-s"", ""w"", ""-s"", ""x"", ""-s"", ""y"", ""-s"", ""z"", ""-s"", ""A"", ""-s"", ""B"", ""-s"", ""C"", ""-s"", ""D"", ""-s"", ""E"", ""-s"", ""F"", ""-s"", ""G"", ""-s"", ""H"", ""-s"", ""I"", ""-s"", ""J"", ""-s"", ""K"", ""-s"", ""L"", ""-s"", ""M"", ""-s"", ""N"", ""-s"", ""O"", ""-s"", ""P"", ""-s"", ""Q"", ""-s"", ""R"", ""-s"", ""S"", ""-s"", ""T"", ""-s"", ""U"", ""-s"", ""V"", ""-s"", ""W"", ""-s"", ""X"", ""-s"", ""Y"", ""-s"", ""Z"", ""-s"", ""0"", ""-s"", ""1"", ""-s"", ""2"", ""-s"", ""3"", ""-s"", ""4"", ""-s"", ""5"", ""-s"", ""6"", ""-s"", ""7"", ""-s"", ""8"", ""-s"", ""9""});
				String[] expected = {""a"", ""b"", ""c"", ""d"", ""e"", ""f"", ""g"", ""h"", ""i"", ""j"", ""k"", ""l"", ""m"", ""n"", ""o"", ""p"", ""q"", ""r"", ""s"", ""t"", ""u"", ""v"", ""w"", ""x"", ""y"", ""z"", ""A"", ""B"", ""C"", ""D"", ""E"", ""F"", ""G"", ""H"", ""I"", ""J"","
cmpl-6u2FmXJaHhcRfmFxvENsRCbEf2NHF,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_1Test.java,53.08442449569702,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_1Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#usage()} method.
*/
class JCLO_1Test {","// JCLO_1Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#usage()} method.
*/
class JCLO_1Test {

		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has no variables.
		*/
		@Test
		void testUsage_1() {
				JCLO jclo = new JCLO(new Object());
				assertEquals("""", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has one variable.
		*/
		@Test
		void testUsage_2() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
				});
				assertEquals(""-a\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables.
		*/
		@Test
		void testUsage_3() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean b;
				});
				assertEquals(""-a\n-b\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables, one of which is an array.
		*/
		@Test
		void testUsage_4() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean[] b;
				});
				assertEquals(""-a\n-b boolean...\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables, one of which is an array.
		*/
		@Test
		void testUsage_5() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean[] b;
						public boolean c;
				});
				assertEquals(""-a\n-b boolean...\n-c\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables, one of which is an array.
		*/
		@Test
		void testUsage_6() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean[] b;
						public boolean c;
						public boolean d;
				});
				assertEquals(""-a\n-b boolean...\n-c\n-d\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables, one of which is an array.
		*/
		@Test
		void testUsage_7() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean[] b;
						public boolean c;
						public boolean d;
						public boolean e;
				});
				assertEquals(""-a\n-b boolean...\n-c\n-d\n-e\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables, one of which is an array.
		*/
		@Test
		void testUsage_8() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean[] b;
						public boolean c;
						public boolean d;
						public boolean e;
						public boolean f;
				});
				assertEquals(""-a\n-b boolean...\n-c\n-d\n-e\n-f\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables, one of which is an array.
		*/
		@Test
		void testUsage_9() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean[] b;
						public boolean c;
						public boolean d;
						public boolean e;
						public boolean f;
						public boolean g;
				});
				assertEquals(""-a\n-b boolean...\n-c\n-d\n-e\n-f\n-g\n"", jclo.usage());
		}
		
		/**
		* Test case for {@link JCLO#usage()} method.
		* It tests the usage method with a class that has two variables, one of which is an array.
		*/
		@Test
		void testUsage_10() {
				JCLO jclo = new JCLO(new Object() {
						public boolean a;
						public boolean[] b;
						public boolean c;
						public boolean d;
						public boolean e;
						public boolean f;
						public boolean g;
						public boolean h;
				});
				assertEquals(""-a\n-b boolean...\n-c\n-d\n-e\n-f\n-g\n-h\n"", jclo.usage());
		}
}

// JCLO_2Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#parse(String[])} method.
*/
class JCLO_2Test {
		
		/**
		* Test case for {@link JCLO#parse(String[])} method.
		* It tests the parse method with a class that has no variables.
		*/
		@Test
		void testParse_1() {
				JCLO jclo = new JCLO(new Object());
				jclo.parse(new String[] {});
		}
		
		/**
		* Test case for {@link JCLO#parse(String[])} method.
		"
cmpl-6u2GpwdPqHL7pWAWYs8wZAMkUM2qd,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_2Test.java,50.936004877090454,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_2Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getBoolean(String)} method.
*/
class JCLO_2Test {","// JCLO_2Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getBoolean(String)} method.
*/
class JCLO_2Test {

		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_1() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-a""});
				assertTrue(jclo.getBoolean(""a""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_2() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-b""});
				assertTrue(jclo.getBoolean(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_3() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-c""});
				assertTrue(jclo.getBoolean(""c""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_4() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-d""});
				assertTrue(jclo.getBoolean(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_5() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-e""});
				assertTrue(jclo.getBoolean(""e""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_6() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-f""});
				assertTrue(jclo.getBoolean(""f""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_7() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-g""});
				assertTrue(jclo.getBoolean(""g""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_8() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-h""});
				assertTrue(jclo.getBoolean(""h""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_9() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-i""});
				assertTrue(jclo.getBoolean(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getBoolean(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetBoolean_10() {
				JCLO jclo = new JCLO(new JCLO_2Test_1());
				jclo.parse(new String[] {""-j""});
				assertTrue(jclo.getBoolean(""j""));
		}
}

// JCLO_2Test_1.java
package edu.mscd.cs.jclo;

/**
* Test class of {@link JCLO}.
* It contains ten boolean variables.
*/
class JCLO_2Test_1 {
		
		/**
		* A boolean variable.
		*/
		public boolean a;
		
		/**
		* A boolean variable.
		*/
		public boolean b;
		
		/**
		* A boolean variable.
		*/
		public boolean c;
		
		/**
		* A boolean variable.
		*/
		public boolean d;
		
		/**
		* A boolean variable.
		*/
		public boolean e;
		
		/**
		* A boolean variable.
		*/
		public boolean f;
		
		/**
		* A boolean variable.
		*/
		public boolean g;
		
		/**
		* A boolean variable.
		*/
		public boolean h;
		
		/**
		* A boolean variable.
		*/
		public boolean i;
		
		/**
		* A boolean variable.
		*/
		public boolean j;
}

// JCLO_3Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getByte(String)} method.
*/
class JCLO_3Test {
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetByte_1() {
				JCLO jclo = new JCLO(new JCLO_3Test_1());
				jclo.parse(new String[] {""-a"", ""1""});
				assertEquals(1, jclo.getByte(""a""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the method with a valid key.
		*/
		@Test
		void testGetByte_2() {
				JCLO jclo = new JCLO(new JCLO"
cmpl-6u2Hsqm4xT0M50VkgHr6N1Z2O6vII,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_3Test.java,53.65487766265869,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_3Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getByte(String)} method.
*/
class JCLO_3Test {","// JCLO_3Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getByte(String)} method.
*/
class JCLO_3Test {

		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is positive.
		*/
		@Test
		void testGetByte_Positive() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""-b"", ""127""});
				assertEquals(127, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is negative.
		*/
		@Test
		void testGetByte_Negative() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""-b"", ""-128""});
				assertEquals(-128, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is zero.
		*/
		@Test
		void testGetByte_Zero() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""-b"", ""0""});
				assertEquals(0, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is positive and
		* the value is specified using the equals sign.
		*/
		@Test
		void testGetByte_Positive_Equals() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""-b=127""});
				assertEquals(127, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is negative and
		* the value is specified using the equals sign.
		*/
		@Test
		void testGetByte_Negative_Equals() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""-b=-128""});
				assertEquals(-128, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is zero and
		* the value is specified using the equals sign.
		*/
		@Test
		void testGetByte_Zero_Equals() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""-b=0""});
				assertEquals(0, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is positive and
		* the value is specified using the double dash.
		*/
		@Test
		void testGetByte_Positive_DoubleDash() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""--b"", ""127""});
				assertEquals(127, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is negative and
		* the value is specified using the double dash.
		*/
		@Test
		void testGetByte_Negative_DoubleDash() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""--b"", ""-128""});
				assertEquals(-128, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is zero and
		* the value is specified using the double dash.
		*/
		@Test
		void testGetByte_Zero_DoubleDash() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""--b"", ""0""});
				assertEquals(0, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is positive and
		* the value is specified using the double dash and the equals sign.
		*/
		@Test
		void testGetByte_Positive_DoubleDash_Equals() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""--b=127""});
				assertEquals(127, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is negative and
		* the value is specified using the double dash and the equals sign.
		*/
		@Test
		void testGetByte_Negative_DoubleDash_Equals() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""--b=-128""});
				assertEquals(-128, jclo.getByte(""b""));
		}
		
		/**
		* Test case for {@link JCLO#getByte(String)} method.
		* It tests the case when the value of the byte variable is zero and
		* the value is specified using the double dash and the equals sign.
		*/
		@Test
		void testGetByte_Zero_DoubleDash_Equals() {
				JCLO_3 jclo = new JCLO_3();
				jclo.parse(new String[]{""--b=0""});
				assertEquals(0, jclo.getByte(""b""));
		}
}

// JCLO_3.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String"
cmpl-6u2Iv8rwZCM7lIEyAzaGudNSkGCFh,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_4Test.java,49.209372997283936,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_4Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getChar(String)} method.
*/
class JCLO_4Test {","// JCLO_4Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getChar(String)} method.
*/
class JCLO_4Test {

		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetChar_ValidArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertEquals('a', jclo.getChar(""c""));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with an invalid argument.
		*/
		@Test
		void testGetChar_InvalidArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChar(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with a null argument.
		*/
		@Test
		void testGetChar_NullArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(NullPointerException.class, () -> jclo.getChar(null));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with an empty argument.
		*/
		@Test
		void testGetChar_EmptyArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChar(""""));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with a blank argument.
		*/
		@Test
		void testGetChar_BlankArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChar("" ""));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetChar_ValidArgument_2() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertEquals('a', jclo.getChar(""c""));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with an invalid argument.
		*/
		@Test
		void testGetChar_InvalidArgument_2() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChar(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with a null argument.
		*/
		@Test
		void testGetChar_NullArgument_2() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(NullPointerException.class, () -> jclo.getChar(null));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with an empty argument.
		*/
		@Test
		void testGetChar_EmptyArgument_2() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChar(""""));
		}
		
		/**
		* Test case for {@link JCLO#getChar(String)} method.
		* It tests the method with a blank argument.
		*/
		@Test
		void testGetChar_BlankArgument_2() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-c"", ""a""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getChar("" ""));
		}
}

// JCLO_5Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getShort(String)} method.
*/
class JCLO_5Test {
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetShort_ValidArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-s"", ""1""});
				assertEquals(1, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with an invalid argument.
		*/
		@Test
		void testGetShort_InvalidArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-s"", ""1""});
				assertThrows(IllegalArgumentException.class, () -> jclo.getShort(""t""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a null argument.
		*/
		@Test
		void testGetShort_NullArgument() {
				JCLO jclo = new JCLO(new TestClass());
				jclo.parse(new String[]{""-s"", ""1""});
				assertThrows(NullPointerException.class, () -> jclo.getShort(null));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with an empty argument.
		*/
		@Test
		void testGetShort_EmptyArgument() {
				JCLO jclo = new J"
cmpl-6u2JyBEt8xZv5WMhg3UlrgQBpNxnJ,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_5Test.java,55.55781865119934,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_5Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getShort(String)} method.
*/
class JCLO_5Test {","// JCLO_5Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getShort(String)} method.
*/
class JCLO_5Test {

		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""1""});
				assertEquals(1, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid2() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""2""});
				assertEquals(2, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid3() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""3""});
				assertEquals(3, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid4() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""4""});
				assertEquals(4, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid5() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""5""});
				assertEquals(5, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid6() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""6""});
				assertEquals(6, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid7() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""7""});
				assertEquals(7, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid8() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""8""});
				assertEquals(8, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid9() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""9""});
				assertEquals(9, jclo.getShort(""s""));
		}
		
		/**
		* Test case for {@link JCLO#getShort(String)} method.
		* It tests the method with a valid short value.
		*/
		@Test
		void testGetShort_Valid10() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-s"", ""10""});
				assertEquals(10, jclo.getShort(""s""));
		}
}

// JCLO_4Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getInt(String)} method.
*/
class JCLO_4Test {
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the method with a valid int value.
		*/
		@Test
		void testGetInt_Valid() {
				JCLO_4 jclo = new JCLO_4();
				jclo.parse(new String[]{""-i"", ""1""});
				assertEquals(1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the method with a valid int value.
		*/
		@Test
		void testGetInt_Valid2() {
				JCLO_4 jclo = new JCLO_4();
				jclo.parse(new String[]{""-i"", ""2""});
				assertEquals(2, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the method with a valid int value.
		*/
		@Test
		void testGetInt_Valid3() {
				JCLO_4 jclo = new JCLO_4();
				jclo.parse(new String[]{""-i"", ""3""});
				assertEquals(3, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the method with a valid int value.
		*/
		@Test
		void testGetInt_Valid4() {
				JCLO_4 jclo = new JCLO_4();
				jclo.parse(new String[]{""-i"", ""4""});
				assertEquals(4, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
	"
cmpl-6u2L1foZGo8uu0zVDnE5NhwZx2Lfm,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_6Test.java,53.11753249168396,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_6Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getInt(String)} method.
*/
class JCLO_6Test {","// JCLO_6Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getInt(String)} method.
*/
class JCLO_6Test {

		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is an integer.
		*/
		@Test
		void testGetInt_1() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""1""});
				assertEquals(1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a negative integer.
		*/
		@Test
		void testGetInt_2() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""-1""});
				assertEquals(-1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a float.
		*/
		@Test
		void testGetInt_3() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""1.0""});
				assertEquals(1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a negative float.
		*/
		@Test
		void testGetInt_4() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""-1.0""});
				assertEquals(-1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a double.
		*/
		@Test
		void testGetInt_5() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""1.0""});
				assertEquals(1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a negative double.
		*/
		@Test
		void testGetInt_6() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""-1.0""});
				assertEquals(-1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a long.
		*/
		@Test
		void testGetInt_7() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""1""});
				assertEquals(1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a negative long.
		*/
		@Test
		void testGetInt_8() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""-1""});
				assertEquals(-1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a String.
		*/
		@Test
		void testGetInt_9() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""1""});
				assertEquals(1, jclo.getInt(""i""));
		}
		
		/**
		* Test case for {@link JCLO#getInt(String)} method.
		* It tests the case when the value of the variable is a negative String.
		*/
		@Test
		void testGetInt_10() {
				JCLO_6 jclo = new JCLO_6();
				jclo.parse(new String[]{""-i"", ""-1""});
				assertEquals(-1, jclo.getInt(""i""));
		}
}

// JCLO_5Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getDouble(String)} method.
*/
class JCLO_5Test {
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the case when the value of the variable is an integer.
		*/
		@Test
		void testGetDouble_1() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-d"", ""1""});
				assertEquals(1.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the case when the value of the variable is a negative integer.
		*/
		@Test
		void testGetDouble_2() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-d"", ""-1""});
				assertEquals(-1.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the case when the value of the variable is a float.
		*/
		@Test
		void testGetDouble_3() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse(new String[]{""-d"", ""1.0""});
				assertEquals(1.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the case when the value of the variable is a negative float.
		*/
		@Test
		void testGetDouble_4() {
				JCLO_5 jclo = new JCLO_5();
				jclo.parse"
cmpl-6u2M45wmiomZtrwWx7lB0qmcPxLRM,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_7Test.java,53.489171266555786,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_7Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getFloat(String)} method.
*/
class JCLO_7Test {","// JCLO_7Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getFloat(String)} method.
*/
class JCLO_7Test {

		/**
		* Test case 1 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat1() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0""});
				assertEquals(1.0f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 2 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat2() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1""});
				assertEquals(1.0f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 3 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat3() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0f""});
				assertEquals(1.0f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 4 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat4() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0F""});
				assertEquals(1.0f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 5 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat5() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0e1""});
				assertEquals(10.0f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 6 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat6() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0E1""});
				assertEquals(10.0f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 7 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat7() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0e-1""});
				assertEquals(0.1f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 8 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat8() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0E-1""});
				assertEquals(0.1f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 9 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat9() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0e+1""});
				assertEquals(10.0f, jclo.getFloat(""float""));
		}
		
		/**
		* Test case 10 for {@link JCLO#getFloat(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetFloat10() {
				JCLO jclo = new JCLO(new JCLO_7Test());
				jclo.parse(new String[]{""-float"", ""1.0E+1""});
				assertEquals(10.0f, jclo.getFloat(""float""));
		}
}

// JCLO_8Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getDouble(String)} method.
*/
class JCLO_8Test {
		
		/**
		* Test case 1 for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble1() {
				JCLO jclo = new JCLO(new JCLO_8Test());
				jclo.parse(new String[]{""-double"", ""1.0""});
				assertEquals(1.0, jclo.getDouble(""double""));
		}
		
		/**
		* Test case 2 for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble2() {
				JCLO jclo = new JCLO(new JCLO_8Test());
				jclo.parse(new String[]{""-double"", ""1""});
				assertEquals(1.0, jclo.getDouble(""double""));
		}
		
		/**
		* Test case 3 for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble3() {
				JCLO jclo = new JCLO(new JCLO_8Test());
				jclo.parse(new String[]{""-double"", ""1.0d""});
				assertEquals(1.0, jclo.getDouble(""double""));
		}
		
		/**
		* Test case 4 for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void test"
cmpl-6u2N71CGlt5yClfhRucgcmNBnkSpL,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_8Test.java,49.312901973724365,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_8Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getDouble(String)} method.
*/
class JCLO_8Test {","// JCLO_8Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getDouble(String)} method.
*/
class JCLO_8Test {

		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_1() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0""});
				assertEquals(1.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_2() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0""});
				assertEquals(2.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_3() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0""});
				assertEquals(3.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_4() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0""});
				assertEquals(4.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_5() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0"", ""-d"", ""5.0""});
				assertEquals(5.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_6() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0"", ""-d"", ""5.0"", ""-d"", ""6.0""});
				assertEquals(6.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_7() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0"", ""-d"", ""5.0"", ""-d"", ""6.0"", ""-d"", ""7.0""});
				assertEquals(7.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_8() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0"", ""-d"", ""5.0"", ""-d"", ""6.0"", ""-d"", ""7.0"", ""-d"", ""8.0""});
				assertEquals(8.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_9() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0"", ""-d"", ""5.0"", ""-d"", ""6.0"", ""-d"", ""7.0"", ""-d"", ""8.0"", ""-d"", ""9.0""});
				assertEquals(9.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_10() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0"", ""-d"", ""5.0"", ""-d"", ""6.0"", ""-d"", ""7.0"", ""-d"", ""8.0"", ""-d"", ""9.0"", ""-d"", ""10.0""});
				assertEquals(10.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests the method with a valid argument.
		*/
		@Test
		void testGetDouble_11() {
				JCLO jclo = new JCLO(new JCLO_8Test_1());
				jclo.parse(new String[]{""-d"", ""1.0"", ""-d"", ""2.0"", ""-d"", ""3.0"", ""-d"", ""4.0"", ""-d"", ""5.0"", ""-d"", ""6.0"", ""-d"", ""7.0"", ""-d"", ""8.0"", ""-d"", ""9.0"", ""-d"", ""10.0"", ""-d"", ""11.0""});
				assertEquals(11.0, jclo.getDouble(""d""));
		}
		
		/**
		* Test case for {@link JCLO#getDouble(String)} method.
		* It tests"
cmpl-6u2OAii6uOZVNIDmP5huP8IwQ56Pu,/EvoSuiteBenchmark/94_jclo/src/main/java/edu/mscd/cs/jclo/JCLO_9Test.java,58.181464195251465,length,"// JCLO.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;

/**
 * This class is used to parse command-line arguments based on a the
 * variables with an object.  Each variable in the class specifies a
 * command-line argument that can be accepted; the name of the variable
 * becomes the name of the command-line argument.  As Java does not allow
 * dashes '-' in variables, use two underscores '__' if you want a dash in
 * an argument.  Also, if you want to have a numeric argument (e.g.: '-1'),
 * start the variable name with a single underscore.  JCLO uses reflection
 * to determine the type of each variable in the passed object and sets the
 * values in the object passed to it via parsing the command line.  If you
 * include a String array named ""additional"", all non-dashed arguments will
 * be placed in it.
 *
 * @author		Steve Beaty (beatys@mscd.edu) @version	$Id:
 * JCLO.java,v 1.5 2007/11/01 16:43:12 beaty Exp beaty $
 */
public class JCLO {

    private Field[] fields;

    private Object object;

    private boolean doubleDashes;

    private boolean hasEquals;

    private String prefix = """";

    private String[][] aliases;

    /**
     * 	A constructor that takes the Object that contains the variables
     * 	acceptable on a command line.  Call parse (String) to do the actual
     * 	parsing.
     *
     * 	@param	object	where the variables/arguments are
     */
    public JCLO(Object object) {
        this((String) null, object, null);
    }

    public JCLO(Object object, String[][] aliases) {
        this((String) null, object, aliases);
    }

    public JCLO(String prefix, Object object) {
        this(prefix, object, null);
    }

    /**
     * 	A constructor that takes an Object, a prefix, and a boolean that
     * 	specifies whether to accept single or double dashes; call parse
     * 	(String) to do the actual parsing.
     *
     * 	@param	object	where the variables/arguments are
     * 	@param	prefix	the String CLO's start with, if any
     */
    public JCLO(String prefix, Object object, String[][] aliases) {
        this.object = object;
        this.prefix = prefix;
        this.aliases = aliases;
        fields = object.getClass().getDeclaredFields();
        for (int i = 0; i < fields.length; i++) {
            fields[i].setAccessible(true);
        }
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to get the value of
     * 	@return		the Object with the value
     */
    private Object getObject(Field f) {
        try {
            return (f.get(object));
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
            System.exit(1);
        }
        return (null);
    }

    private Field getField(String key) {
        Field f = null;
        if (prefix != null)
            key = prefix + key;
        for (int i = 0; i < fields.length; i++) {
            String name = fields[i].getName();
            if (name.equals(key))
                return (fields[i]);
        }
        return (null);
    }

    /**
     * 	Get the current value of the variable in the object
     *
     * 	@param	key	the variable name
     * 	@return		an Object with the value
     */
    public Object getValue(String key) {
        Field f = getField(key);
        if (f == null) {
            System.out.println(""Field not found: "" + key);
            return (null);
        }
        return (getObject(f));
    }

    /**
     * 	Just a simple method to put the try/catch in one place.
     *
     * 	@param	f	the Field to set the value of
     * 	@param	o	the Object with the value
     */
    private void setObject(Field f, Object o) {
        try {
            f.set(object, o);
        } catch (java.lang.IllegalAccessException iae) {
            iae.printStackTrace();
        }
    }

    private String getArrayType(Class type) {
        return (type.getComponentType().toString().replaceFirst(""class.*\\."", """"));
    }

    /**
     * 	An external representation of the object
     *
     * 	@return		a formatted version of this object
     */
    public String toString() {
        String r = """";
        boolean first = true;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            Object object = getObject(field);
            if (!first)
                r += ""\n"";
            first = false;
            if (type.isArray()) {
                r += getArrayType(type) + ""[]"" + "": "" + key + "" = "";
                r += java.util.Arrays.toString((Object[]) object);
            } else {
                r += type.toString().replaceFirst(""class java.lang."", """") + "": "" + key + "" = "" + object;
            }
        }
        return (r);
    }

    private String getUsageType(Class type) {
        if (type.getName().equals(""boolean"")) {
            return (doubleDashes ? ""[=boolean]"" : """");
        } else if (type.isArray()) {
            return ((doubleDashes ? ""="" : "" "") + getArrayType(type) + ""..."");
        } else {
            return ((doubleDashes ? ""="" : "" "") + type.getName().replaceFirst(""java.lang."", """"));
        }
    }

    /**
     *  Create and usage message for the acceptable command line variables.
     *
     * 	@return		a String that specifies acceptable options
     */
    public String usage() {
        boolean additional = false;
        String[] a = new String[fields.length];
        int count = 0;
        for (int i = 0; i < fields.length; i++) {
            Field field = fields[i];
            String key = field.getName();
            Class type = field.getType();
            if (key.equals(""additional""))
                continue;
            if (prefix != null) {
                if (!key.startsWith(prefix))
                    continue;
                else
                    key = key.replaceFirst(""^"" + prefix, """");
            }
            if (Modifier.isFinal(field.getModifiers()))
                continue;
            key = key.replaceFirst(""^_([0-9])"", ""$1"");
            key = key.replaceAll(""__"", ""-"");
            key = key.replaceAll(""_\\$"", ""."");
            a[count++] = (doubleDashes ? ""--"" : ""-"") + key + getUsageType(type) + ""\n"";
        }
        String r = """";
        java.util.Arrays.sort(a, 0, count);
        for (int i = 0; i < a.length; i++) if (a[i] != null)
            r += a[i];
        return (r);
    }

    private void parseAdditional(String[] args, int i) {
        int number = args.length - i;
        String[] add = new String[number];
        for (int j = 0; j < number; j++, i++) {
            add[j] = args[i];
        }
        Field f = getField(""additional"");
        if (f != null) {
            setObject(f, add);
        } else {
            System.err.println(""No varible 'additional' found"");
        }
    }

    /**
     * 	Add to object o to the end of the array contained in field and
     * 	return the resulting array.
     *
     * 	@param	field	the field in the object
     * 	@param	o	the new object to be placed at the end
     * 	@return		a formatted version of this object
     */
    private Object addToArray(Field field, Object o) {
        Object ret;
        Object orig = getObject(field);
        Class componentType = field.getType().getComponentType();
        if (// the array is empty
        orig == null) {
            ret = Array.newInstance(componentType, 1);
            Array.set(ret, 0, o);
        } else {
            int length = Array.getLength(orig);
            ret = Array.newInstance(componentType, length + 1);
            int j;
            for (j = 0; j < length; j++) {
                Array.set(ret, j, Array.get(orig, j));
            }
            Array.set(ret, j, o);
        }
        return (ret);
    }

    private String getKey(String arg) {
        if (hasEquals)
            arg = arg.replaceFirst(""=.*"", """");
        if (doubleDashes)
            arg = arg.substring(2);
        else
            arg = arg.substring(1);
        // variables can't start with a number and can't have a dash
        arg = arg.replaceAll(""^([0-9])"", ""_$1"");
        arg = arg.replaceAll(""-"", ""__"");
        arg = arg.replaceAll(""\\."", ""_\\$"");
        if (aliases != null) {
            for (int i = 0; i < aliases.length; i++) {
                if (aliases[i][0].equals(arg))
                    arg = aliases[i][1];
            }
        }
        return (arg);
    }

    private String getBooleanValue(String arg) {
        if (hasEquals) {
            arg = arg.replaceFirst(""[^=]*="", """");
            if (arg.equalsIgnoreCase(""true"") || arg.equalsIgnoreCase(""yes""))
                return (""true"");
            else
                return (""false"");
        } else {
            return (""true"");
        }
    }

    /**
     * 	Make an Object of the correct type for the field, using a String
     * 	version of the value to create it.
     *
     * 	@param	type	a String representing the base (or String) type
     * 	@param	val	the value
     * 	@return		an Object of the correct type and value
     */
    private Object makeObject(String type, String val) {
        if (type.equals(""boolean"")) {
            return (new Boolean(val));
        }
        if (type.equals(""byte"")) {
            return (new Byte(val));
        }
        if (type.equals(""short"")) {
            return (new Short(val));
        }
        if (type.equals(""int"")) {
            return (new Integer(val));
        }
        if (type.equals(""float"")) {
            return (new Float(val));
        }
        if (type.equals(""double"")) {
            return (new Double(val));
        }
        if (type.equals(""long"")) {
            return (new Long(val));
        }
        if (type.equals(""java.lang.String"")) {
            return (val);
        }
        if (type.equals(""char"")) {
            return (new Character(val.charAt(0)));
        }
        return (null);
    }

    private String getEqualsValue(String arg) {
        if (arg.indexOf(""="") == -1) {
            throw (new IllegalArgumentException(""'"" + arg + ""' requires '=VALUE'""));
        } else {
            return (arg.replaceFirst(""[^=]*="", """"));
        }
    }

    /**
     * 	Parse a command line.
     *
     * 	@param	args	the arguments to be parsed
     */
    public void parse(String[] args) {
        for (int i = 0; i < args.length; i++) {
            if (!args[i].startsWith(""-"")) {
                parseAdditional(args, i);
                return;
            }
            doubleDashes = args[i].startsWith(""--"");
            hasEquals = args[i].indexOf(""="") != -1;
            String key = getKey(args[i]);
            Field field = getField(key);
            if (field == null) {
                throw (new IllegalArgumentException(""No such option: \"""" + key + ""\""""));
            }
            Class type = field.getType();
            String name = type.getName();
            if (type.isArray())
                name = type.getComponentType().getName();
            String value = null;
            if (name.equals(""boolean""))
                value = getBooleanValue(args[i]);
            else if (doubleDashes || hasEquals)
                value = getEqualsValue(args[i]);
            else
                value = args[++i];
            Object o = makeObject(name, value);
            if (o == null)
                continue;
            if (type.isArray())
                o = addToArray(field, o);
            setObject(field, o);
        }
    }

    /**
     * Get a boolean value from the object after parsing.
     */
    public boolean getBoolean(String key) {
        return (((Boolean) getValue(key)).booleanValue());
    }

    /**
     * Get a byte value from the object after parsing.
     */
    public byte getByte(String key) {
        return (((Byte) getValue(key)).byteValue());
    }

    /**
     * Get a character value from the object after parsing.
     */
    public char getChar(String key) {
        return (((Character) getValue(key)).charValue());
    }

    /**
     * Get a short value from the object after parsing.
     */
    public short getShort(String key) {
        return (((Short) getValue(key)).shortValue());
    }

    /**
     * Get an integer value from the object after parsing.
     */
    public int getInt(String key) {
        return (((Integer) getValue(key)).intValue());
    }

    /**
     * Get a float value from the object after parsing.
     */
    public float getFloat(String key) {
        return (((Float) getValue(key)).floatValue());
    }

    /**
     * Get a double value from the object after parsing.
     */
    public double getDouble(String key) {
        return (((Double) getValue(key)).doubleValue());
    }

    /**
     * Get a long value from the object after parsing.
     */
    public long getLong(String key) {
        return (((Long) getValue(key)).longValue());
    }

    /**
     * Get a String from the object after parsing.
     */
    public String getString(String key) {
        return ((String) getValue(key));
    }

    /**
     * Get an array of bytes from the object after parsing.
     */
    public byte[] getBytes(String key) {
        return ((byte[]) getValue(key));
    }

    /**
     * Get an array of characaters from the object after parsing.
     */
    public char[] getChars(String key) {
        return ((char[]) getValue(key));
    }

    /**
     * Get an array of shorts from the object after parsing.
     */
    public short[] getShorts(String key) {
        return ((short[]) getValue(key));
    }

    /**
     * Get an array of integers from the object after parsing.
     */
    public int[] getInts(String key) {
        return ((int[]) getValue(key));
    }

    /**
     * Get an array of floats from the object after parsing.
     */
    public float[] getFloats(String key) {
        return ((float[]) getValue(key));
    }

    /**
     * Get an array of doubles from the object after parsing.
     */
    public double[] getDoubles(String key) {
        return ((double[]) getValue(key));
    }

    /**
     * Get an array of longs from the object after parsing.
     */
    public long[] getLongs(String key) {
        return ((long[]) getValue(key));
    }

    /**
     * Get an array of Strings from the object after parsing.
     */
    public String[] getStrings(String key) {
        return ((String[]) getValue(key));
    }

    public static void main(String[] args) {
        // cheesy, i know...
        if (args.length == 1 && args[0].equalsIgnoreCase(""--version"")) {
            System.out.println(""1.3.4"");
        }
    }
}
","// JCLO_9Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getLong(String)} method.
*/
class JCLO_9Test {","// JCLO_9Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getLong(String)} method.
*/
class JCLO_9Test {

		/**
		* Test case 1 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong1() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 2 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong2() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 3 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong3() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 4 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong4() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 5 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong5() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 6 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong6() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 7 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong7() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 8 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong8() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 9 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong9() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 10 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong10() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
}

// JCLO_9Test.java
package edu.mscd.cs.jclo;

import java.lang.reflect.Field;
import java.lang.reflect.Array;
import java.lang.reflect.Modifier;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

/**
* Test class of {@link JCLO}.
* It contains ten unit test cases for the {@link JCLO#getLong(String)} method.
*/
class JCLO_9Test {
		
		/**
		* Test case 1 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong1() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 2 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong2() throws Exception {
				JCLO jclo = new JCLO(new JCLO_9Test());
				jclo.parse(new String[] { ""--long"", ""1234567890123456789"" });
				assertEquals(1234567890123456789L, jclo.getLong(""long""));
		}
		
		/**
		* Test case 3 for {@link JCLO#getLong(String)}
		*
		* @throws Exception
		*/
		@Test
		void testGetLong3() throws Exception {
	"
