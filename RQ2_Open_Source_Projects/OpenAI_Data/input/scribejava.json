[
	{
		"original_code": "// StreamUtils.java\npackage org.scribe.utils;\n\nimport java.io.*;\n\n/**\n * Utils to deal with Streams.\n *\n * @author Pablo Fernandez\n */\npublic class StreamUtils {\n\n    private StreamUtils() {\n    }\n\n    /**\n     * Returns the stream contents as an UTF-8 encoded string\n     *\n     * @param is input stream\n     * @return string contents\n     */\n    public static String getStreamContents(InputStream is) {\n        Preconditions.checkNotNull(is, \"Cannot get String from a null object\");\n        try {\n            final char[] buffer = new char[0x10000];\n            StringBuilder out = new StringBuilder();\n            Reader in = new InputStreamReader(is, \"UTF-8\");\n            int read;\n            do {\n                read = in.read(buffer, 0, buffer.length);\n                if (read > 0) {\n                    out.append(buffer, 0, read);\n                }\n            } while (read >= 0);\n            in.close();\n            return out.toString();\n        } catch (IOException ioe) {\n            throw new IllegalStateException(\"Error while reading response body\", ioe);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/utils/StreamUtilsTest.java",
		"test_prompt": "// StreamUtilsTest.java\npackage org.scribe.utils;\n\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link StreamUtils}.\n* It contains ten unit test cases for the {@link StreamUtils#getStreamContents(InputStream)} method.\n*/\nclass StreamUtilsTest {"
	},
	{
		"original_code": "// OAuthEncoder.java\npackage org.scribe.utils;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class OAuthEncoder {\n\n    private static String CHARSET = \"UTF-8\";\n\n    private static final Map<String, String> ENCODING_RULES;\n\n    static {\n        Map<String, String> rules = new HashMap<String, String>();\n        rules.put(\"*\", \"%2A\");\n        rules.put(\"+\", \"%20\");\n        rules.put(\"%7E\", \"~\");\n        ENCODING_RULES = Collections.unmodifiableMap(rules);\n    }\n\n    private OAuthEncoder() {\n    }\n\n    public static String encode(String plain) {\n        Preconditions.checkNotNull(plain, \"Cannot encode null object\");\n        String encoded = \"\";\n        try {\n            encoded = URLEncoder.encode(plain, CHARSET);\n        } catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Charset not found while encoding string: \" + CHARSET, uee);\n        }\n        for (Map.Entry<String, String> rule : ENCODING_RULES.entrySet()) {\n            encoded = applyRule(encoded, rule.getKey(), rule.getValue());\n        }\n        return encoded;\n    }\n\n    private static String applyRule(String encoded, String toReplace, String replacement) {\n        return encoded.replaceAll(Pattern.quote(toReplace), replacement);\n    }\n\n    public static String decode(String encoded) {\n        Preconditions.checkNotNull(encoded, \"Cannot decode null object\");\n        try {\n            return URLDecoder.decode(encoded, CHARSET);\n        } catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Charset not found while decoding string: \" + CHARSET, uee);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/utils/OAuthEncoderTest0.java",
		"test_prompt": "// OAuthEncoderTest0.java\npackage org.scribe.utils;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAuthEncoder}.\n* It contains ten unit test cases for the {@link OAuthEncoder#encode(String)} method.\n*/\nclass OAuthEncoderTest0 {"
	},
	{
		"original_code": "// OAuthEncoder.java\npackage org.scribe.utils;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class OAuthEncoder {\n\n    private static String CHARSET = \"UTF-8\";\n\n    private static final Map<String, String> ENCODING_RULES;\n\n    static {\n        Map<String, String> rules = new HashMap<String, String>();\n        rules.put(\"*\", \"%2A\");\n        rules.put(\"+\", \"%20\");\n        rules.put(\"%7E\", \"~\");\n        ENCODING_RULES = Collections.unmodifiableMap(rules);\n    }\n\n    private OAuthEncoder() {\n    }\n\n    public static String encode(String plain) {\n        Preconditions.checkNotNull(plain, \"Cannot encode null object\");\n        String encoded = \"\";\n        try {\n            encoded = URLEncoder.encode(plain, CHARSET);\n        } catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Charset not found while encoding string: \" + CHARSET, uee);\n        }\n        for (Map.Entry<String, String> rule : ENCODING_RULES.entrySet()) {\n            encoded = applyRule(encoded, rule.getKey(), rule.getValue());\n        }\n        return encoded;\n    }\n\n    private static String applyRule(String encoded, String toReplace, String replacement) {\n        return encoded.replaceAll(Pattern.quote(toReplace), replacement);\n    }\n\n    public static String decode(String encoded) {\n        Preconditions.checkNotNull(encoded, \"Cannot decode null object\");\n        try {\n            return URLDecoder.decode(encoded, CHARSET);\n        } catch (UnsupportedEncodingException uee) {\n            throw new OAuthException(\"Charset not found while decoding string: \" + CHARSET, uee);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/utils/OAuthEncoderTest1.java",
		"test_prompt": "// OAuthEncoderTest1.java\npackage org.scribe.utils;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAuthEncoder}.\n* It contains ten unit test cases for the {@link OAuthEncoder#decode(String)} method.\n*/\nclass OAuthEncoderTest1 {"
	},
	{
		"original_code": "// ParameterList.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class ParameterList {\n\n    private static final char QUERY_STRING_SEPARATOR = '?';\n\n    private static final String PARAM_SEPARATOR = \"&\";\n\n    private static final String PAIR_SEPARATOR = \"=\";\n\n    private static final String EMPTY_STRING = \"\";\n\n    private final List<Parameter> params;\n\n    public ParameterList() {\n        params = new ArrayList<Parameter>();\n    }\n\n    ParameterList(List<Parameter> params) {\n        this.params = new ArrayList<Parameter>(params);\n    }\n\n    public ParameterList(Map<String, String> map) {\n        this();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            params.add(new Parameter(entry.getKey(), entry.getValue()));\n        }\n    }\n\n    public void add(String key, String value) {\n        params.add(new Parameter(key, value));\n    }\n\n    public String appendTo(String url) {\n        Preconditions.checkNotNull(url, \"Cannot append to null URL\");\n        String queryString = asFormUrlEncodedString();\n        if (queryString.equals(EMPTY_STRING)) {\n            return url;\n        } else {\n            url += url.indexOf(QUERY_STRING_SEPARATOR) != -1 ? PARAM_SEPARATOR : QUERY_STRING_SEPARATOR;\n            url += queryString;\n            return url;\n        }\n    }\n\n    public String asOauthBaseString() {\n        return OAuthEncoder.encode(asFormUrlEncodedString());\n    }\n\n    public String asFormUrlEncodedString() {\n        if (params.size() == 0)\n            return EMPTY_STRING;\n        StringBuilder builder = new StringBuilder();\n        for (Parameter p : params) {\n            builder.append('&').append(p.asUrlEncodedPair());\n        }\n        return builder.toString().substring(1);\n    }\n\n    public void addAll(ParameterList other) {\n        params.addAll(other.params);\n    }\n\n    public void addQuerystring(String queryString) {\n        if (queryString != null && queryString.length() > 0) {\n            for (String param : queryString.split(PARAM_SEPARATOR)) {\n                String[] pair = param.split(PAIR_SEPARATOR);\n                String key = OAuthEncoder.decode(pair[0]);\n                String value = pair.length > 1 ? OAuthEncoder.decode(pair[1]) : EMPTY_STRING;\n                params.add(new Parameter(key, value));\n            }\n        }\n    }\n\n    public boolean contains(Parameter param) {\n        return params.contains(param);\n    }\n\n    public int size() {\n        return params.size();\n    }\n\n    public ParameterList sort() {\n        ParameterList sorted = new ParameterList(params);\n        Collections.sort(sorted.params);\n        return sorted;\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterListTest0.java",
		"test_prompt": "// ParameterListTest0.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterList}.\n* It contains ten unit test cases for the {@link ParameterList#appendTo(String)} method.\n*/\nclass ParameterListTest0 {"
	},
	{
		"original_code": "// ParameterList.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class ParameterList {\n\n    private static final char QUERY_STRING_SEPARATOR = '?';\n\n    private static final String PARAM_SEPARATOR = \"&\";\n\n    private static final String PAIR_SEPARATOR = \"=\";\n\n    private static final String EMPTY_STRING = \"\";\n\n    private final List<Parameter> params;\n\n    public ParameterList() {\n        params = new ArrayList<Parameter>();\n    }\n\n    ParameterList(List<Parameter> params) {\n        this.params = new ArrayList<Parameter>(params);\n    }\n\n    public ParameterList(Map<String, String> map) {\n        this();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            params.add(new Parameter(entry.getKey(), entry.getValue()));\n        }\n    }\n\n    public void add(String key, String value) {\n        params.add(new Parameter(key, value));\n    }\n\n    public String appendTo(String url) {\n        Preconditions.checkNotNull(url, \"Cannot append to null URL\");\n        String queryString = asFormUrlEncodedString();\n        if (queryString.equals(EMPTY_STRING)) {\n            return url;\n        } else {\n            url += url.indexOf(QUERY_STRING_SEPARATOR) != -1 ? PARAM_SEPARATOR : QUERY_STRING_SEPARATOR;\n            url += queryString;\n            return url;\n        }\n    }\n\n    public String asOauthBaseString() {\n        return OAuthEncoder.encode(asFormUrlEncodedString());\n    }\n\n    public String asFormUrlEncodedString() {\n        if (params.size() == 0)\n            return EMPTY_STRING;\n        StringBuilder builder = new StringBuilder();\n        for (Parameter p : params) {\n            builder.append('&').append(p.asUrlEncodedPair());\n        }\n        return builder.toString().substring(1);\n    }\n\n    public void addAll(ParameterList other) {\n        params.addAll(other.params);\n    }\n\n    public void addQuerystring(String queryString) {\n        if (queryString != null && queryString.length() > 0) {\n            for (String param : queryString.split(PARAM_SEPARATOR)) {\n                String[] pair = param.split(PAIR_SEPARATOR);\n                String key = OAuthEncoder.decode(pair[0]);\n                String value = pair.length > 1 ? OAuthEncoder.decode(pair[1]) : EMPTY_STRING;\n                params.add(new Parameter(key, value));\n            }\n        }\n    }\n\n    public boolean contains(Parameter param) {\n        return params.contains(param);\n    }\n\n    public int size() {\n        return params.size();\n    }\n\n    public ParameterList sort() {\n        ParameterList sorted = new ParameterList(params);\n        Collections.sort(sorted.params);\n        return sorted;\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterListTest1.java",
		"test_prompt": "// ParameterListTest1.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterList}.\n* It contains ten unit test cases for the {@link ParameterList#asOauthBaseString()} method.\n*/\nclass ParameterListTest1 {"
	},
	{
		"original_code": "// ParameterList.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class ParameterList {\n\n    private static final char QUERY_STRING_SEPARATOR = '?';\n\n    private static final String PARAM_SEPARATOR = \"&\";\n\n    private static final String PAIR_SEPARATOR = \"=\";\n\n    private static final String EMPTY_STRING = \"\";\n\n    private final List<Parameter> params;\n\n    public ParameterList() {\n        params = new ArrayList<Parameter>();\n    }\n\n    ParameterList(List<Parameter> params) {\n        this.params = new ArrayList<Parameter>(params);\n    }\n\n    public ParameterList(Map<String, String> map) {\n        this();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            params.add(new Parameter(entry.getKey(), entry.getValue()));\n        }\n    }\n\n    public void add(String key, String value) {\n        params.add(new Parameter(key, value));\n    }\n\n    public String appendTo(String url) {\n        Preconditions.checkNotNull(url, \"Cannot append to null URL\");\n        String queryString = asFormUrlEncodedString();\n        if (queryString.equals(EMPTY_STRING)) {\n            return url;\n        } else {\n            url += url.indexOf(QUERY_STRING_SEPARATOR) != -1 ? PARAM_SEPARATOR : QUERY_STRING_SEPARATOR;\n            url += queryString;\n            return url;\n        }\n    }\n\n    public String asOauthBaseString() {\n        return OAuthEncoder.encode(asFormUrlEncodedString());\n    }\n\n    public String asFormUrlEncodedString() {\n        if (params.size() == 0)\n            return EMPTY_STRING;\n        StringBuilder builder = new StringBuilder();\n        for (Parameter p : params) {\n            builder.append('&').append(p.asUrlEncodedPair());\n        }\n        return builder.toString().substring(1);\n    }\n\n    public void addAll(ParameterList other) {\n        params.addAll(other.params);\n    }\n\n    public void addQuerystring(String queryString) {\n        if (queryString != null && queryString.length() > 0) {\n            for (String param : queryString.split(PARAM_SEPARATOR)) {\n                String[] pair = param.split(PAIR_SEPARATOR);\n                String key = OAuthEncoder.decode(pair[0]);\n                String value = pair.length > 1 ? OAuthEncoder.decode(pair[1]) : EMPTY_STRING;\n                params.add(new Parameter(key, value));\n            }\n        }\n    }\n\n    public boolean contains(Parameter param) {\n        return params.contains(param);\n    }\n\n    public int size() {\n        return params.size();\n    }\n\n    public ParameterList sort() {\n        ParameterList sorted = new ParameterList(params);\n        Collections.sort(sorted.params);\n        return sorted;\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterListTest2.java",
		"test_prompt": "// ParameterListTest2.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterList}.\n* It contains ten unit test cases for the {@link ParameterList#asFormUrlEncodedString()} method.\n*/\nclass ParameterListTest2 {"
	},
	{
		"original_code": "// ParameterList.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class ParameterList {\n\n    private static final char QUERY_STRING_SEPARATOR = '?';\n\n    private static final String PARAM_SEPARATOR = \"&\";\n\n    private static final String PAIR_SEPARATOR = \"=\";\n\n    private static final String EMPTY_STRING = \"\";\n\n    private final List<Parameter> params;\n\n    public ParameterList() {\n        params = new ArrayList<Parameter>();\n    }\n\n    ParameterList(List<Parameter> params) {\n        this.params = new ArrayList<Parameter>(params);\n    }\n\n    public ParameterList(Map<String, String> map) {\n        this();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            params.add(new Parameter(entry.getKey(), entry.getValue()));\n        }\n    }\n\n    public void add(String key, String value) {\n        params.add(new Parameter(key, value));\n    }\n\n    public String appendTo(String url) {\n        Preconditions.checkNotNull(url, \"Cannot append to null URL\");\n        String queryString = asFormUrlEncodedString();\n        if (queryString.equals(EMPTY_STRING)) {\n            return url;\n        } else {\n            url += url.indexOf(QUERY_STRING_SEPARATOR) != -1 ? PARAM_SEPARATOR : QUERY_STRING_SEPARATOR;\n            url += queryString;\n            return url;\n        }\n    }\n\n    public String asOauthBaseString() {\n        return OAuthEncoder.encode(asFormUrlEncodedString());\n    }\n\n    public String asFormUrlEncodedString() {\n        if (params.size() == 0)\n            return EMPTY_STRING;\n        StringBuilder builder = new StringBuilder();\n        for (Parameter p : params) {\n            builder.append('&').append(p.asUrlEncodedPair());\n        }\n        return builder.toString().substring(1);\n    }\n\n    public void addAll(ParameterList other) {\n        params.addAll(other.params);\n    }\n\n    public void addQuerystring(String queryString) {\n        if (queryString != null && queryString.length() > 0) {\n            for (String param : queryString.split(PARAM_SEPARATOR)) {\n                String[] pair = param.split(PAIR_SEPARATOR);\n                String key = OAuthEncoder.decode(pair[0]);\n                String value = pair.length > 1 ? OAuthEncoder.decode(pair[1]) : EMPTY_STRING;\n                params.add(new Parameter(key, value));\n            }\n        }\n    }\n\n    public boolean contains(Parameter param) {\n        return params.contains(param);\n    }\n\n    public int size() {\n        return params.size();\n    }\n\n    public ParameterList sort() {\n        ParameterList sorted = new ParameterList(params);\n        Collections.sort(sorted.params);\n        return sorted;\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterListTest3.java",
		"test_prompt": "// ParameterListTest3.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterList}.\n* It contains ten unit test cases for the {@link ParameterList#contains(Parameter)} method.\n*/\nclass ParameterListTest3 {"
	},
	{
		"original_code": "// ParameterList.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class ParameterList {\n\n    private static final char QUERY_STRING_SEPARATOR = '?';\n\n    private static final String PARAM_SEPARATOR = \"&\";\n\n    private static final String PAIR_SEPARATOR = \"=\";\n\n    private static final String EMPTY_STRING = \"\";\n\n    private final List<Parameter> params;\n\n    public ParameterList() {\n        params = new ArrayList<Parameter>();\n    }\n\n    ParameterList(List<Parameter> params) {\n        this.params = new ArrayList<Parameter>(params);\n    }\n\n    public ParameterList(Map<String, String> map) {\n        this();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            params.add(new Parameter(entry.getKey(), entry.getValue()));\n        }\n    }\n\n    public void add(String key, String value) {\n        params.add(new Parameter(key, value));\n    }\n\n    public String appendTo(String url) {\n        Preconditions.checkNotNull(url, \"Cannot append to null URL\");\n        String queryString = asFormUrlEncodedString();\n        if (queryString.equals(EMPTY_STRING)) {\n            return url;\n        } else {\n            url += url.indexOf(QUERY_STRING_SEPARATOR) != -1 ? PARAM_SEPARATOR : QUERY_STRING_SEPARATOR;\n            url += queryString;\n            return url;\n        }\n    }\n\n    public String asOauthBaseString() {\n        return OAuthEncoder.encode(asFormUrlEncodedString());\n    }\n\n    public String asFormUrlEncodedString() {\n        if (params.size() == 0)\n            return EMPTY_STRING;\n        StringBuilder builder = new StringBuilder();\n        for (Parameter p : params) {\n            builder.append('&').append(p.asUrlEncodedPair());\n        }\n        return builder.toString().substring(1);\n    }\n\n    public void addAll(ParameterList other) {\n        params.addAll(other.params);\n    }\n\n    public void addQuerystring(String queryString) {\n        if (queryString != null && queryString.length() > 0) {\n            for (String param : queryString.split(PARAM_SEPARATOR)) {\n                String[] pair = param.split(PAIR_SEPARATOR);\n                String key = OAuthEncoder.decode(pair[0]);\n                String value = pair.length > 1 ? OAuthEncoder.decode(pair[1]) : EMPTY_STRING;\n                params.add(new Parameter(key, value));\n            }\n        }\n    }\n\n    public boolean contains(Parameter param) {\n        return params.contains(param);\n    }\n\n    public int size() {\n        return params.size();\n    }\n\n    public ParameterList sort() {\n        ParameterList sorted = new ParameterList(params);\n        Collections.sort(sorted.params);\n        return sorted;\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterListTest4.java",
		"test_prompt": "// ParameterListTest4.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterList}.\n* It contains ten unit test cases for the {@link ParameterList#size()} method.\n*/\nclass ParameterListTest4 {"
	},
	{
		"original_code": "// ParameterList.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class ParameterList {\n\n    private static final char QUERY_STRING_SEPARATOR = '?';\n\n    private static final String PARAM_SEPARATOR = \"&\";\n\n    private static final String PAIR_SEPARATOR = \"=\";\n\n    private static final String EMPTY_STRING = \"\";\n\n    private final List<Parameter> params;\n\n    public ParameterList() {\n        params = new ArrayList<Parameter>();\n    }\n\n    ParameterList(List<Parameter> params) {\n        this.params = new ArrayList<Parameter>(params);\n    }\n\n    public ParameterList(Map<String, String> map) {\n        this();\n        for (Map.Entry<String, String> entry : map.entrySet()) {\n            params.add(new Parameter(entry.getKey(), entry.getValue()));\n        }\n    }\n\n    public void add(String key, String value) {\n        params.add(new Parameter(key, value));\n    }\n\n    public String appendTo(String url) {\n        Preconditions.checkNotNull(url, \"Cannot append to null URL\");\n        String queryString = asFormUrlEncodedString();\n        if (queryString.equals(EMPTY_STRING)) {\n            return url;\n        } else {\n            url += url.indexOf(QUERY_STRING_SEPARATOR) != -1 ? PARAM_SEPARATOR : QUERY_STRING_SEPARATOR;\n            url += queryString;\n            return url;\n        }\n    }\n\n    public String asOauthBaseString() {\n        return OAuthEncoder.encode(asFormUrlEncodedString());\n    }\n\n    public String asFormUrlEncodedString() {\n        if (params.size() == 0)\n            return EMPTY_STRING;\n        StringBuilder builder = new StringBuilder();\n        for (Parameter p : params) {\n            builder.append('&').append(p.asUrlEncodedPair());\n        }\n        return builder.toString().substring(1);\n    }\n\n    public void addAll(ParameterList other) {\n        params.addAll(other.params);\n    }\n\n    public void addQuerystring(String queryString) {\n        if (queryString != null && queryString.length() > 0) {\n            for (String param : queryString.split(PARAM_SEPARATOR)) {\n                String[] pair = param.split(PAIR_SEPARATOR);\n                String key = OAuthEncoder.decode(pair[0]);\n                String value = pair.length > 1 ? OAuthEncoder.decode(pair[1]) : EMPTY_STRING;\n                params.add(new Parameter(key, value));\n            }\n        }\n    }\n\n    public boolean contains(Parameter param) {\n        return params.contains(param);\n    }\n\n    public int size() {\n        return params.size();\n    }\n\n    public ParameterList sort() {\n        ParameterList sorted = new ParameterList(params);\n        Collections.sort(sorted.params);\n        return sorted;\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterListTest5.java",
		"test_prompt": "// ParameterListTest5.java\npackage org.scribe.model;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport org.scribe.utils.OAuthEncoder;\nimport org.scribe.utils.Preconditions;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ParameterList}.\n* It contains ten unit test cases for the {@link ParameterList#sort()} method.\n*/\nclass ParameterListTest5 {"
	},
	{
		"original_code": "// Response.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.utils.*;\n\n/**\n * Represents an HTTP Response.\n *\n * @author Pablo Fernandez\n */\npublic class Response {\n\n    private static final String EMPTY = \"\";\n\n    private int code;\n\n    private String message;\n\n    private String body;\n\n    private InputStream stream;\n\n    private Map<String, String> headers;\n\n    Response(HttpURLConnection connection) throws IOException {\n        try {\n            connection.connect();\n            code = connection.getResponseCode();\n            message = connection.getResponseMessage();\n            headers = parseHeaders(connection);\n            stream = isSuccessful() ? connection.getInputStream() : connection.getErrorStream();\n        } catch (UnknownHostException e) {\n            throw new OAuthException(\"The IP address of a host could not be determined.\", e);\n        }\n    }\n\n    private String parseBodyContents() {\n        body = StreamUtils.getStreamContents(getStream());\n        return body;\n    }\n\n    private Map<String, String> parseHeaders(HttpURLConnection conn) {\n        Map<String, String> headers = new HashMap<String, String>();\n        for (String key : conn.getHeaderFields().keySet()) {\n            headers.put(key, conn.getHeaderFields().get(key).get(0));\n        }\n        return headers;\n    }\n\n    public boolean isSuccessful() {\n        return getCode() >= 200 && getCode() < 400;\n    }\n\n    /**\n     * Obtains the HTTP Response body\n     *\n     * @return response body\n     */\n    public String getBody() {\n        return body != null ? body : parseBodyContents();\n    }\n\n    /**\n     * Obtains the meaningful stream of the HttpUrlConnection, either inputStream\n     * or errorInputStream, depending on the status code\n     *\n     * @return input stream / error stream\n     */\n    public InputStream getStream() {\n        return stream;\n    }\n\n    /**\n     * Obtains the HTTP status code\n     *\n     * @return the status code\n     */\n    public int getCode() {\n        return code;\n    }\n\n    /**\n     * Obtains the HTTP status message.\n     * Returns <code>null</code> if the message can not be discerned from the response (not valid HTTP)\n     *\n     * @return the status message\n     */\n    public String getMessage() {\n        return message;\n    }\n\n    /**\n     * Obtains a {@link Map} containing the HTTP Response Headers\n     *\n     * @return headers\n     */\n    public Map<String, String> getHeaders() {\n        return headers;\n    }\n\n    /**\n     * Obtains a single HTTP Header value, or null if undefined\n     *\n     * @param name the header name.\n     *\n     * @return header value or null.\n     */\n    public String getHeader(String name) {\n        return headers.get(name);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ResponseTest.java",
		"test_prompt": "// ResponseTest.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport java.net.*;\nimport java.util.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Response}.\n* It contains ten unit test cases for the {@link Response#isSuccessful()} method.\n*/\nclass ResponseTest {"
	},
	{
		"original_code": "// Parameter.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class Parameter implements Comparable<Parameter> {\n\n    private static final String UTF = \"UTF8\";\n\n    private final String key;\n\n    private final String value;\n\n    public Parameter(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public String asUrlEncodedPair() {\n        return OAuthEncoder.encode(key).concat(\"=\").concat(OAuthEncoder.encode(value));\n    }\n\n    public boolean equals(Object other) {\n        if (other == null)\n            return false;\n        if (other == this)\n            return true;\n        if (!(other instanceof Parameter))\n            return false;\n        Parameter otherParam = (Parameter) other;\n        return otherParam.key.equals(key) && otherParam.value.equals(value);\n    }\n\n    public int hashCode() {\n        return key.hashCode() + value.hashCode();\n    }\n\n    public int compareTo(Parameter parameter) {\n        int keyDiff = key.compareTo(parameter.key);\n        return keyDiff != 0 ? keyDiff : value.compareTo(parameter.value);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterTest0.java",
		"test_prompt": "// ParameterTest0.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Parameter}.\n* It contains ten unit test cases for the {@link Parameter#asUrlEncodedPair()} method.\n*/\nclass ParameterTest0 {"
	},
	{
		"original_code": "// Parameter.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class Parameter implements Comparable<Parameter> {\n\n    private static final String UTF = \"UTF8\";\n\n    private final String key;\n\n    private final String value;\n\n    public Parameter(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public String asUrlEncodedPair() {\n        return OAuthEncoder.encode(key).concat(\"=\").concat(OAuthEncoder.encode(value));\n    }\n\n    public boolean equals(Object other) {\n        if (other == null)\n            return false;\n        if (other == this)\n            return true;\n        if (!(other instanceof Parameter))\n            return false;\n        Parameter otherParam = (Parameter) other;\n        return otherParam.key.equals(key) && otherParam.value.equals(value);\n    }\n\n    public int hashCode() {\n        return key.hashCode() + value.hashCode();\n    }\n\n    public int compareTo(Parameter parameter) {\n        int keyDiff = key.compareTo(parameter.key);\n        return keyDiff != 0 ? keyDiff : value.compareTo(parameter.value);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterTest1.java",
		"test_prompt": "// ParameterTest1.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Parameter}.\n* It contains ten unit test cases for the {@link Parameter#equals(Object)} method.\n*/\nclass ParameterTest1 {"
	},
	{
		"original_code": "// Parameter.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class Parameter implements Comparable<Parameter> {\n\n    private static final String UTF = \"UTF8\";\n\n    private final String key;\n\n    private final String value;\n\n    public Parameter(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public String asUrlEncodedPair() {\n        return OAuthEncoder.encode(key).concat(\"=\").concat(OAuthEncoder.encode(value));\n    }\n\n    public boolean equals(Object other) {\n        if (other == null)\n            return false;\n        if (other == this)\n            return true;\n        if (!(other instanceof Parameter))\n            return false;\n        Parameter otherParam = (Parameter) other;\n        return otherParam.key.equals(key) && otherParam.value.equals(value);\n    }\n\n    public int hashCode() {\n        return key.hashCode() + value.hashCode();\n    }\n\n    public int compareTo(Parameter parameter) {\n        int keyDiff = key.compareTo(parameter.key);\n        return keyDiff != 0 ? keyDiff : value.compareTo(parameter.value);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterTest2.java",
		"test_prompt": "// ParameterTest2.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Parameter}.\n* It contains ten unit test cases for the {@link Parameter#hashCode()} method.\n*/\nclass ParameterTest2 {"
	},
	{
		"original_code": "// Parameter.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\n\n/**\n * @author: Pablo Fernandez\n */\npublic class Parameter implements Comparable<Parameter> {\n\n    private static final String UTF = \"UTF8\";\n\n    private final String key;\n\n    private final String value;\n\n    public Parameter(String key, String value) {\n        this.key = key;\n        this.value = value;\n    }\n\n    public String asUrlEncodedPair() {\n        return OAuthEncoder.encode(key).concat(\"=\").concat(OAuthEncoder.encode(value));\n    }\n\n    public boolean equals(Object other) {\n        if (other == null)\n            return false;\n        if (other == this)\n            return true;\n        if (!(other instanceof Parameter))\n            return false;\n        Parameter otherParam = (Parameter) other;\n        return otherParam.key.equals(key) && otherParam.value.equals(value);\n    }\n\n    public int hashCode() {\n        return key.hashCode() + value.hashCode();\n    }\n\n    public int compareTo(Parameter parameter) {\n        int keyDiff = key.compareTo(parameter.key);\n        return keyDiff != 0 ? keyDiff : value.compareTo(parameter.value);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/ParameterTest3.java",
		"test_prompt": "// ParameterTest3.java\npackage org.scribe.model;\n\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Parameter}.\n* It contains ten unit test cases for the {@link Parameter#compareTo(Parameter)} method.\n*/\nclass ParameterTest3 {"
	},
	{
		"original_code": "// Token.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\n\n/**\n * Represents an OAuth token (either request or access token) and its secret\n *\n * @author Pablo Fernandez\n */\npublic class Token implements Serializable {\n\n    private static final long serialVersionUID = 715000866082812683L;\n\n    private final String token;\n\n    private final String secret;\n\n    private final String rawResponse;\n\n    /**\n     * Default constructor\n     *\n     * @param token token value. Can't be null.\n     * @param secret token secret. Can't be null.\n     */\n    public Token(String token, String secret) {\n        this(token, secret, null);\n    }\n\n    public Token(String token, String secret, String rawResponse) {\n        Preconditions.checkNotNull(token, \"Token can't be null\");\n        Preconditions.checkNotNull(secret, \"Secret can't be null\");\n        this.token = token;\n        this.secret = secret;\n        this.rawResponse = rawResponse;\n    }\n\n    public String getToken() {\n        return token;\n    }\n\n    public String getSecret() {\n        return secret;\n    }\n\n    public String getRawResponse() {\n        if (rawResponse == null) {\n            throw new IllegalStateException(\"This token object was not constructed by scribe and does not have a rawResponse\");\n        }\n        return rawResponse;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Token[%s , %s]\", token, secret);\n    }\n\n    /**\n     * Returns true if the token is empty (token = \"\", secret = \"\")\n     */\n    public boolean isEmpty() {\n        return \"\".equals(this.token) && \"\".equals(this.secret);\n    }\n\n    /**\n     * Factory method that returns an empty token (token = \"\", secret = \"\").\n     *\n     * Useful for two legged OAuth.\n     */\n    public static Token empty() {\n        return new Token(\"\", \"\");\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        Token that = (Token) o;\n        return token.equals(that.token) && secret.equals(that.secret);\n    }\n\n    @Override\n    public int hashCode() {\n        return 31 * token.hashCode() + secret.hashCode();\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/TokenTest0.java",
		"test_prompt": "// TokenTest0.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#isEmpty()} method.\n*/\nclass TokenTest0 {"
	},
	{
		"original_code": "// Token.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\n\n/**\n * Represents an OAuth token (either request or access token) and its secret\n *\n * @author Pablo Fernandez\n */\npublic class Token implements Serializable {\n\n    private static final long serialVersionUID = 715000866082812683L;\n\n    private final String token;\n\n    private final String secret;\n\n    private final String rawResponse;\n\n    /**\n     * Default constructor\n     *\n     * @param token token value. Can't be null.\n     * @param secret token secret. Can't be null.\n     */\n    public Token(String token, String secret) {\n        this(token, secret, null);\n    }\n\n    public Token(String token, String secret, String rawResponse) {\n        Preconditions.checkNotNull(token, \"Token can't be null\");\n        Preconditions.checkNotNull(secret, \"Secret can't be null\");\n        this.token = token;\n        this.secret = secret;\n        this.rawResponse = rawResponse;\n    }\n\n    public String getToken() {\n        return token;\n    }\n\n    public String getSecret() {\n        return secret;\n    }\n\n    public String getRawResponse() {\n        if (rawResponse == null) {\n            throw new IllegalStateException(\"This token object was not constructed by scribe and does not have a rawResponse\");\n        }\n        return rawResponse;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Token[%s , %s]\", token, secret);\n    }\n\n    /**\n     * Returns true if the token is empty (token = \"\", secret = \"\")\n     */\n    public boolean isEmpty() {\n        return \"\".equals(this.token) && \"\".equals(this.secret);\n    }\n\n    /**\n     * Factory method that returns an empty token (token = \"\", secret = \"\").\n     *\n     * Useful for two legged OAuth.\n     */\n    public static Token empty() {\n        return new Token(\"\", \"\");\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        Token that = (Token) o;\n        return token.equals(that.token) && secret.equals(that.secret);\n    }\n\n    @Override\n    public int hashCode() {\n        return 31 * token.hashCode() + secret.hashCode();\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/TokenTest1.java",
		"test_prompt": "// TokenTest1.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#empty()} method.\n*/\nclass TokenTest1 {"
	},
	{
		"original_code": "// Token.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\n\n/**\n * Represents an OAuth token (either request or access token) and its secret\n *\n * @author Pablo Fernandez\n */\npublic class Token implements Serializable {\n\n    private static final long serialVersionUID = 715000866082812683L;\n\n    private final String token;\n\n    private final String secret;\n\n    private final String rawResponse;\n\n    /**\n     * Default constructor\n     *\n     * @param token token value. Can't be null.\n     * @param secret token secret. Can't be null.\n     */\n    public Token(String token, String secret) {\n        this(token, secret, null);\n    }\n\n    public Token(String token, String secret, String rawResponse) {\n        Preconditions.checkNotNull(token, \"Token can't be null\");\n        Preconditions.checkNotNull(secret, \"Secret can't be null\");\n        this.token = token;\n        this.secret = secret;\n        this.rawResponse = rawResponse;\n    }\n\n    public String getToken() {\n        return token;\n    }\n\n    public String getSecret() {\n        return secret;\n    }\n\n    public String getRawResponse() {\n        if (rawResponse == null) {\n            throw new IllegalStateException(\"This token object was not constructed by scribe and does not have a rawResponse\");\n        }\n        return rawResponse;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Token[%s , %s]\", token, secret);\n    }\n\n    /**\n     * Returns true if the token is empty (token = \"\", secret = \"\")\n     */\n    public boolean isEmpty() {\n        return \"\".equals(this.token) && \"\".equals(this.secret);\n    }\n\n    /**\n     * Factory method that returns an empty token (token = \"\", secret = \"\").\n     *\n     * Useful for two legged OAuth.\n     */\n    public static Token empty() {\n        return new Token(\"\", \"\");\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        Token that = (Token) o;\n        return token.equals(that.token) && secret.equals(that.secret);\n    }\n\n    @Override\n    public int hashCode() {\n        return 31 * token.hashCode() + secret.hashCode();\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/TokenTest2.java",
		"test_prompt": "// TokenTest2.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#equals(Object)} method.\n*/\nclass TokenTest2 {"
	},
	{
		"original_code": "// Token.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\n\n/**\n * Represents an OAuth token (either request or access token) and its secret\n *\n * @author Pablo Fernandez\n */\npublic class Token implements Serializable {\n\n    private static final long serialVersionUID = 715000866082812683L;\n\n    private final String token;\n\n    private final String secret;\n\n    private final String rawResponse;\n\n    /**\n     * Default constructor\n     *\n     * @param token token value. Can't be null.\n     * @param secret token secret. Can't be null.\n     */\n    public Token(String token, String secret) {\n        this(token, secret, null);\n    }\n\n    public Token(String token, String secret, String rawResponse) {\n        Preconditions.checkNotNull(token, \"Token can't be null\");\n        Preconditions.checkNotNull(secret, \"Secret can't be null\");\n        this.token = token;\n        this.secret = secret;\n        this.rawResponse = rawResponse;\n    }\n\n    public String getToken() {\n        return token;\n    }\n\n    public String getSecret() {\n        return secret;\n    }\n\n    public String getRawResponse() {\n        if (rawResponse == null) {\n            throw new IllegalStateException(\"This token object was not constructed by scribe and does not have a rawResponse\");\n        }\n        return rawResponse;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"Token[%s , %s]\", token, secret);\n    }\n\n    /**\n     * Returns true if the token is empty (token = \"\", secret = \"\")\n     */\n    public boolean isEmpty() {\n        return \"\".equals(this.token) && \"\".equals(this.secret);\n    }\n\n    /**\n     * Factory method that returns an empty token (token = \"\", secret = \"\").\n     *\n     * Useful for two legged OAuth.\n     */\n    public static Token empty() {\n        return new Token(\"\", \"\");\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o)\n            return true;\n        if (o == null || getClass() != o.getClass())\n            return false;\n        Token that = (Token) o;\n        return token.equals(that.token) && secret.equals(that.secret);\n    }\n\n    @Override\n    public int hashCode() {\n        return 31 * token.hashCode() + secret.hashCode();\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/TokenTest3.java",
		"test_prompt": "// TokenTest3.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Token}.\n* It contains ten unit test cases for the {@link Token#hashCode()} method.\n*/\nclass TokenTest3 {"
	},
	{
		"original_code": "// OAuthConfig.java\npackage org.scribe.model;\n\nimport java.io.*;\n\n/**\n * Parameter object that groups OAuth config values\n *\n * @author Pablo Fernandez\n */\npublic class OAuthConfig {\n\n    private final String apiKey;\n\n    private final String apiSecret;\n\n    private final String callback;\n\n    private final SignatureType signatureType;\n\n    private final String scope;\n\n    private final OutputStream debugStream;\n\n    public OAuthConfig(String key, String secret) {\n        this(key, secret, null, null, null, null);\n    }\n\n    public OAuthConfig(String key, String secret, String callback, SignatureType type, String scope, OutputStream stream) {\n        this.apiKey = key;\n        this.apiSecret = secret;\n        this.callback = callback;\n        this.signatureType = type;\n        this.scope = scope;\n        this.debugStream = stream;\n    }\n\n    public String getApiKey() {\n        return apiKey;\n    }\n\n    public String getApiSecret() {\n        return apiSecret;\n    }\n\n    public String getCallback() {\n        return callback;\n    }\n\n    public SignatureType getSignatureType() {\n        return signatureType;\n    }\n\n    public String getScope() {\n        return scope;\n    }\n\n    public boolean hasScope() {\n        return scope != null;\n    }\n\n    public void log(String message) {\n        if (debugStream != null) {\n            message = message + \"\\n\";\n            try {\n                debugStream.write(message.getBytes(\"UTF8\"));\n            } catch (Exception e) {\n                throw new RuntimeException(\"there were problems while writting to the debug stream\", e);\n            }\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/model/OAuthConfigTest.java",
		"test_prompt": "// OAuthConfigTest.java\npackage org.scribe.model;\n\nimport java.io.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link OAuthConfig}.\n* It contains ten unit test cases for the {@link OAuthConfig#hasScope()} method.\n*/\nclass OAuthConfigTest {"
	},
	{
		"original_code": "// BaseStringExtractorImpl.java\npackage org.scribe.extractors;\n\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\n\n/**\n * Default implementation of {@link BaseStringExtractor}. Conforms to OAuth 1.0a\n *\n * @author Pablo Fernandez\n */\npublic class BaseStringExtractorImpl implements BaseStringExtractor {\n\n    private static final String AMPERSAND_SEPARATED_STRING = \"%s&%s&%s\";\n\n    /**\n     * {@inheritDoc}\n     */\n    public String extract(OAuthRequest request) {\n        checkPreconditions(request);\n        String verb = OAuthEncoder.encode(request.getVerb().name());\n        String url = OAuthEncoder.encode(request.getSanitizedUrl());\n        String params = getSortedAndEncodedParams(request);\n        return String.format(AMPERSAND_SEPARATED_STRING, verb, url, params);\n    }\n\n    private String getSortedAndEncodedParams(OAuthRequest request) {\n        ParameterList params = new ParameterList();\n        params.addAll(request.getQueryStringParams());\n        params.addAll(request.getBodyParams());\n        params.addAll(new ParameterList(request.getOauthParameters()));\n        return params.sort().asOauthBaseString();\n    }\n\n    private void checkPreconditions(OAuthRequest request) {\n        Preconditions.checkNotNull(request, \"Cannot extract base string from null object\");\n        if (request.getOauthParameters() == null || request.getOauthParameters().size() <= 0) {\n            throw new OAuthParametersMissingException(request);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/extractors/BaseStringExtractorImplTest.java",
		"test_prompt": "// BaseStringExtractorImplTest.java\npackage org.scribe.extractors;\n\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link BaseStringExtractorImpl}.\n* It contains ten unit test cases for the {@link BaseStringExtractorImpl#extract(OAuthRequest)} method.\n*/\nclass BaseStringExtractorImplTest {"
	},
	{
		"original_code": "// TokenExtractor20Impl.java\npackage org.scribe.extractors;\n\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\n\n/**\n * Default implementation of {@AccessTokenExtractor}. Conforms to OAuth 2.0\n */\npublic class TokenExtractor20Impl implements AccessTokenExtractor {\n\n    private static final String TOKEN_REGEX = \"access_token=([^&]+)\";\n\n    private static final String EMPTY_SECRET = \"\";\n\n    /**\n     * {@inheritDoc}\n     */\n    public Token extract(String response) {\n        Preconditions.checkEmptyString(response, \"Response body is incorrect. Can't extract a token from an empty string\");\n        Matcher matcher = Pattern.compile(TOKEN_REGEX).matcher(response);\n        if (matcher.find()) {\n            String token = OAuthEncoder.decode(matcher.group(1));\n            return new Token(token, EMPTY_SECRET, response);\n        } else {\n            throw new OAuthException(\"Response body is incorrect. Can't extract a token from this: '\" + response + \"'\", null);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/extractors/TokenExtractor20ImplTest.java",
		"test_prompt": "// TokenExtractor20ImplTest.java\npackage org.scribe.extractors;\n\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TokenExtractor20Impl}.\n* It contains ten unit test cases for the {@link TokenExtractor20Impl#extract(String)} method.\n*/\nclass TokenExtractor20ImplTest {"
	},
	{
		"original_code": "// TokenExtractorImpl.java\npackage org.scribe.extractors;\n\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\n\n/**\n * Default implementation of {@RequestTokenExtractor} and {@AccessTokenExtractor}. Conforms to OAuth 1.0a\n *\n * The process for extracting access and request tokens is similar so this class can do both things.\n *\n * @author Pablo Fernandez\n */\npublic class TokenExtractorImpl implements RequestTokenExtractor, AccessTokenExtractor {\n\n    private static final Pattern TOKEN_REGEX = Pattern.compile(\"oauth_token=([^&]+)\");\n\n    private static final Pattern SECRET_REGEX = Pattern.compile(\"oauth_token_secret=([^&]*)\");\n\n    /**\n     * {@inheritDoc}\n     */\n    public Token extract(String response) {\n        Preconditions.checkEmptyString(response, \"Response body is incorrect. Can't extract a token from an empty string\");\n        String token = extract(response, TOKEN_REGEX);\n        String secret = extract(response, SECRET_REGEX);\n        return new Token(token, secret, response);\n    }\n\n    private String extract(String response, Pattern p) {\n        Matcher matcher = p.matcher(response);\n        if (matcher.find() && matcher.groupCount() >= 1) {\n            return OAuthEncoder.decode(matcher.group(1));\n        } else {\n            throw new OAuthException(\"Response body is incorrect. Can't extract token and secret from this: '\" + response + \"'\", null);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/extractors/TokenExtractorImplTest.java",
		"test_prompt": "// TokenExtractorImplTest.java\npackage org.scribe.extractors;\n\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link TokenExtractorImpl}.\n* It contains ten unit test cases for the {@link TokenExtractorImpl#extract(String)} method.\n*/\nclass TokenExtractorImplTest {"
	},
	{
		"original_code": "// HeaderExtractorImpl.java\npackage org.scribe.extractors;\n\nimport java.util.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\n\n/**\n * Default implementation of {@link HeaderExtractor}. Conforms to OAuth 1.0a\n *\n * @author Pablo Fernandez\n */\npublic class HeaderExtractorImpl implements HeaderExtractor {\n\n    private static final String PARAM_SEPARATOR = \", \";\n\n    private static final String PREAMBLE = \"OAuth \";\n\n    public static final int ESTIMATED_PARAM_LENGTH = 20;\n\n    /**\n     * {@inheritDoc}\n     */\n    public String extract(OAuthRequest request) {\n        checkPreconditions(request);\n        Map<String, String> parameters = request.getOauthParameters();\n        StringBuilder header = new StringBuilder(parameters.size() * ESTIMATED_PARAM_LENGTH);\n        header.append(PREAMBLE);\n        for (Map.Entry<String, String> entry : parameters.entrySet()) {\n            if (header.length() > PREAMBLE.length()) {\n                header.append(PARAM_SEPARATOR);\n            }\n            header.append(String.format(\"%s=\\\"%s\\\"\", entry.getKey(), OAuthEncoder.encode(entry.getValue())));\n        }\n        if (request.getRealm() != null && !request.getRealm().isEmpty()) {\n            header.append(PARAM_SEPARATOR);\n            header.append(String.format(\"%s=\\\"%s\\\"\", OAuthConstants.REALM, request.getRealm()));\n        }\n        return header.toString();\n    }\n\n    private void checkPreconditions(OAuthRequest request) {\n        Preconditions.checkNotNull(request, \"Cannot extract a header from a null object\");\n        if (request.getOauthParameters() == null || request.getOauthParameters().size() <= 0) {\n            throw new OAuthParametersMissingException(request);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/extractors/HeaderExtractorImplTest.java",
		"test_prompt": "// HeaderExtractorImplTest.java\npackage org.scribe.extractors;\n\nimport java.util.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link HeaderExtractorImpl}.\n* It contains ten unit test cases for the {@link HeaderExtractorImpl#extract(OAuthRequest)} method.\n*/\nclass HeaderExtractorImplTest {"
	},
	{
		"original_code": "// JsonTokenExtractor.java\npackage org.scribe.extractors;\n\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\n\npublic class JsonTokenExtractor implements AccessTokenExtractor {\n\n    private Pattern accessTokenPattern = Pattern.compile(\"\\\"access_token\\\":\\\\s*\\\"(\\\\S*?)\\\"\");\n\n    public Token extract(String response) {\n        Preconditions.checkEmptyString(response, \"Cannot extract a token from a null or empty String\");\n        Matcher matcher = accessTokenPattern.matcher(response);\n        if (matcher.find()) {\n            return new Token(matcher.group(1), \"\", response);\n        } else {\n            throw new OAuthException(\"Cannot extract an access token. Response was: \" + response);\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/extractors/JsonTokenExtractorTest.java",
		"test_prompt": "// JsonTokenExtractorTest.java\npackage org.scribe.extractors;\n\nimport java.util.regex.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link JsonTokenExtractor}.\n* It contains ten unit test cases for the {@link JsonTokenExtractor#extract(String)} method.\n*/\nclass JsonTokenExtractorTest {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest0.java",
		"test_prompt": "// ServiceBuilderTest0.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#provider(Class)} method.\n*/\nclass ServiceBuilderTest0 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest1.java",
		"test_prompt": "// ServiceBuilderTest1.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#provider(Api)} method.\n*/\nclass ServiceBuilderTest1 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest2.java",
		"test_prompt": "// ServiceBuilderTest2.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#callback(String)} method.\n*/\nclass ServiceBuilderTest2 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest3.java",
		"test_prompt": "// ServiceBuilderTest3.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#apiKey(String)} method.\n*/\nclass ServiceBuilderTest3 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest4.java",
		"test_prompt": "// ServiceBuilderTest4.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#apiSecret(String)} method.\n*/\nclass ServiceBuilderTest4 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest5.java",
		"test_prompt": "// ServiceBuilderTest5.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#scope(String)} method.\n*/\nclass ServiceBuilderTest5 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest6.java",
		"test_prompt": "// ServiceBuilderTest6.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#signatureType(SignatureType)} method.\n*/\nclass ServiceBuilderTest6 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest7.java",
		"test_prompt": "// ServiceBuilderTest7.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#debugStream(OutputStream)} method.\n*/\nclass ServiceBuilderTest7 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest8.java",
		"test_prompt": "// ServiceBuilderTest8.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#debug()} method.\n*/\nclass ServiceBuilderTest8 {"
	},
	{
		"original_code": "// ServiceBuilder.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\n\n/**\n * Implementation of the Builder pattern, with a fluent interface that creates a\n * {@link OAuthService}\n *\n * @author Pablo Fernandez\n */\npublic class ServiceBuilder {\n\n    private String apiKey;\n\n    private String apiSecret;\n\n    private String callback;\n\n    private Api api;\n\n    private String scope;\n\n    private SignatureType signatureType;\n\n    private OutputStream debugStream;\n\n    /**\n     * Default constructor\n     */\n    public ServiceBuilder() {\n        this.callback = OAuthConstants.OUT_OF_BAND;\n        this.signatureType = SignatureType.Header;\n        this.debugStream = null;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * @param apiClass the class of one of the existent {@link Api}s on org.scribe.api package\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Class<? extends Api> apiClass) {\n        this.api = createApi(apiClass);\n        return this;\n    }\n\n    private Api createApi(Class<? extends Api> apiClass) {\n        Preconditions.checkNotNull(apiClass, \"Api class cannot be null\");\n        Api api;\n        try {\n            api = apiClass.newInstance();\n        } catch (Exception e) {\n            throw new OAuthException(\"Error while creating the Api object\", e);\n        }\n        return api;\n    }\n\n    /**\n     * Configures the {@link Api}\n     *\n     * Overloaded version. Let's you use an instance instead of a class.\n     *\n     * @param api instance of {@link Api}s\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder provider(Api api) {\n        Preconditions.checkNotNull(api, \"Api cannot be null\");\n        this.api = api;\n        return this;\n    }\n\n    /**\n     * Adds an OAuth callback url\n     *\n     * @param callback callback url. Must be a valid url or 'oob' for out of band OAuth\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder callback(String callback) {\n        Preconditions.checkNotNull(callback, \"Callback can't be null\");\n        this.callback = callback;\n        return this;\n    }\n\n    /**\n     * Configures the api key\n     *\n     * @param apiKey The api key for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiKey(String apiKey) {\n        Preconditions.checkEmptyString(apiKey, \"Invalid Api key\");\n        this.apiKey = apiKey;\n        return this;\n    }\n\n    /**\n     * Configures the api secret\n     *\n     * @param apiSecret The api secret for your application\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder apiSecret(String apiSecret) {\n        Preconditions.checkEmptyString(apiSecret, \"Invalid Api secret\");\n        this.apiSecret = apiSecret;\n        return this;\n    }\n\n    /**\n     * Configures the OAuth scope. This is only necessary in some APIs (like Google's).\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder scope(String scope) {\n        Preconditions.checkEmptyString(scope, \"Invalid OAuth scope\");\n        this.scope = scope;\n        return this;\n    }\n\n    /**\n     * Configures the signature type, choose between header, querystring, etc. Defaults to Header\n     *\n     * @param scope The OAuth scope\n     * @return the {@link ServiceBuilder} instance for method chaining\n     */\n    public ServiceBuilder signatureType(SignatureType type) {\n        Preconditions.checkNotNull(type, \"Signature type can't be null\");\n        this.signatureType = type;\n        return this;\n    }\n\n    public ServiceBuilder debugStream(OutputStream stream) {\n        Preconditions.checkNotNull(stream, \"debug stream can't be null\");\n        this.debugStream = stream;\n        return this;\n    }\n\n    public ServiceBuilder debug() {\n        this.debugStream(System.out);\n        return this;\n    }\n\n    /**\n     * Returns the fully configured {@link OAuthService}\n     *\n     * @return fully configured {@link OAuthService}\n     */\n    public OAuthService build() {\n        Preconditions.checkNotNull(api, \"You must specify a valid api through the provider() method\");\n        Preconditions.checkEmptyString(apiKey, \"You must provide an api key\");\n        Preconditions.checkEmptyString(apiSecret, \"You must provide an api secret\");\n        return api.createService(new OAuthConfig(apiKey, apiSecret, callback, signatureType, scope, debugStream));\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/ServiceBuilderTest9.java",
		"test_prompt": "// ServiceBuilderTest9.java\npackage org.scribe.builder;\n\nimport java.io.*;\nimport org.scribe.builder.api.*;\nimport org.scribe.exceptions.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.utils.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link ServiceBuilder}.\n* It contains ten unit test cases for the {@link ServiceBuilder#build()} method.\n*/\nclass ServiceBuilderTest9 {"
	},
	{
		"original_code": "// DefaultApi20.java\npackage org.scribe.builder.api;\n\nimport org.scribe.extractors.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\n\n/**\n * Default implementation of the OAuth protocol, version 2.0 (draft 11)\n *\n * This class is meant to be extended by concrete implementations of the API,\n * providing the endpoints and endpoint-http-verbs.\n *\n * If your Api adheres to the 2.0 (draft 11) protocol correctly, you just need to extend\n * this class and define the getters for your endpoints.\n *\n * If your Api does something a bit different, you can override the different\n * extractors or services, in order to fine-tune the process. Please read the\n * javadocs of the interfaces to get an idea of what to do.\n *\n * @author Diego Silveira\n */\npublic abstract class DefaultApi20 implements Api {\n\n    /**\n     * Returns the access token extractor.\n     *\n     * @return access token extractor\n     */\n    public AccessTokenExtractor getAccessTokenExtractor() {\n        return new TokenExtractor20Impl();\n    }\n\n    /**\n     * Returns the verb for the access token endpoint (defaults to GET)\n     *\n     * @return access token endpoint verb\n     */\n    public Verb getAccessTokenVerb() {\n        return Verb.GET;\n    }\n\n    /**\n     * Returns the URL that receives the access token requests.\n     *\n     * @return access token URL\n     */\n    public abstract String getAccessTokenEndpoint();\n\n    /**\n     * Returns the URL where you should redirect your users to authenticate\n     * your application.\n     *\n     * @param config OAuth 2.0 configuration param object\n     * @return the URL where you should redirect your users\n     */\n    public abstract String getAuthorizationUrl(OAuthConfig config);\n\n    /**\n     * {@inheritDoc}\n     */\n    public OAuthService createService(OAuthConfig config) {\n        return new OAuth20ServiceImpl(this, config);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/api/DefaultApi20Test.java",
		"test_prompt": "// DefaultApi20Test.java\npackage org.scribe.builder.api;\n\nimport org.scribe.extractors.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultApi20}.\n* It contains ten unit test cases for the {@link DefaultApi20#createService(OAuthConfig)} method.\n*/\nclass DefaultApi20Test {"
	},
	{
		"original_code": "// DefaultApi10a.java\npackage org.scribe.builder.api;\n\nimport org.scribe.extractors.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.services.*;\n\n/**\n * Default implementation of the OAuth protocol, version 1.0a\n *\n * This class is meant to be extended by concrete implementations of the API,\n * providing the endpoints and endpoint-http-verbs.\n *\n * If your Api adheres to the 1.0a protocol correctly, you just need to extend\n * this class and define the getters for your endpoints.\n *\n * If your Api does something a bit different, you can override the different\n * extractors or services, in order to fine-tune the process. Please read the\n * javadocs of the interfaces to get an idea of what to do.\n *\n * @author Pablo Fernandez\n */\npublic abstract class DefaultApi10a implements Api {\n\n    /**\n     * Returns the access token extractor.\n     *\n     * @return access token extractor\n     */\n    public AccessTokenExtractor getAccessTokenExtractor() {\n        return new TokenExtractorImpl();\n    }\n\n    /**\n     * Returns the base string extractor.\n     *\n     * @return base string extractor\n     */\n    public BaseStringExtractor getBaseStringExtractor() {\n        return new BaseStringExtractorImpl();\n    }\n\n    /**\n     * Returns the header extractor.\n     *\n     * @return header extractor\n     */\n    public HeaderExtractor getHeaderExtractor() {\n        return new HeaderExtractorImpl();\n    }\n\n    /**\n     * Returns the request token extractor.\n     *\n     * @return request token extractor\n     */\n    public RequestTokenExtractor getRequestTokenExtractor() {\n        return new TokenExtractorImpl();\n    }\n\n    /**\n     * Returns the signature service.\n     *\n     * @return signature service\n     */\n    public SignatureService getSignatureService() {\n        return new HMACSha1SignatureService();\n    }\n\n    /**\n     * Returns the timestamp service.\n     *\n     * @return timestamp service\n     */\n    public TimestampService getTimestampService() {\n        return new TimestampServiceImpl();\n    }\n\n    /**\n     * Returns the verb for the access token endpoint (defaults to POST)\n     *\n     * @return access token endpoint verb\n     */\n    public Verb getAccessTokenVerb() {\n        return Verb.POST;\n    }\n\n    /**\n     * Returns the verb for the request token endpoint (defaults to POST)\n     *\n     * @return request token endpoint verb\n     */\n    public Verb getRequestTokenVerb() {\n        return Verb.POST;\n    }\n\n    /**\n     * Returns the URL that receives the request token requests.\n     *\n     * @return request token URL\n     */\n    public abstract String getRequestTokenEndpoint();\n\n    /**\n     * Returns the URL that receives the access token requests.\n     *\n     * @return access token URL\n     */\n    public abstract String getAccessTokenEndpoint();\n\n    /**\n     * Returns the URL where you should redirect your users to authenticate\n     * your application.\n     *\n     * @param requestToken the request token you need to authorize\n     * @return the URL where you should redirect your users\n     */\n    public abstract String getAuthorizationUrl(Token requestToken);\n\n    /**\n     * Returns the {@link OAuthService} for this Api\n     *\n     * @param apiKey Key\n     * @param apiSecret Api Secret\n     * @param callback OAuth callback (either URL or 'oob')\n     * @param scope OAuth scope (optional)\n     */\n    public OAuthService createService(OAuthConfig config) {\n        return new OAuth10aServiceImpl(this, config);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/api/DefaultApi10aTest.java",
		"test_prompt": "// DefaultApi10aTest.java\npackage org.scribe.builder.api;\n\nimport org.scribe.extractors.*;\nimport org.scribe.model.*;\nimport org.scribe.oauth.*;\nimport org.scribe.services.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DefaultApi10a}.\n* It contains ten unit test cases for the {@link DefaultApi10a#createService(OAuthConfig)} method.\n*/\nclass DefaultApi10aTest {"
	},
	{
		"original_code": "// LinkedInApi.java\npackage org.scribe.builder.api;\n\nimport org.scribe.model.*;\nimport java.util.*;\n\npublic class LinkedInApi extends DefaultApi10a {\n\n    private static final String AUTHORIZE_URL = \"https://api.linkedin.com/uas/oauth/authenticate?oauth_token=%s\";\n\n    private static final String REQUEST_TOKEN_URL = \"https://api.linkedin.com/uas/oauth/requestToken\";\n\n    private final Set<String> scopes;\n\n    public LinkedInApi() {\n        scopes = Collections.emptySet();\n    }\n\n    public LinkedInApi(Set<String> scopes) {\n        this.scopes = Collections.unmodifiableSet(scopes);\n    }\n\n    @Override\n    public String getAccessTokenEndpoint() {\n        return \"https://api.linkedin.com/uas/oauth/accessToken\";\n    }\n\n    @Override\n    public String getRequestTokenEndpoint() {\n        return scopes.isEmpty() ? REQUEST_TOKEN_URL : REQUEST_TOKEN_URL + \"?scope=\" + scopesAsString();\n    }\n\n    private String scopesAsString() {\n        StringBuilder builder = new StringBuilder();\n        for (String scope : scopes) {\n            builder.append(\"+\" + scope);\n        }\n        return builder.substring(1);\n    }\n\n    @Override\n    public String getAuthorizationUrl(Token requestToken) {\n        return String.format(AUTHORIZE_URL, requestToken.getToken());\n    }\n\n    public static LinkedInApi withScopes(String... scopes) {\n        Set<String> scopeSet = new HashSet<String>(Arrays.asList(scopes));\n        return new LinkedInApi(scopeSet);\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/builder/api/LinkedInApiTest.java",
		"test_prompt": "// LinkedInApiTest.java\npackage org.scribe.builder.api;\n\nimport org.scribe.model.*;\nimport java.util.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link LinkedInApi}.\n* It contains ten unit test cases for the {@link LinkedInApi#withScopes(String[])} method.\n*/\nclass LinkedInApiTest {"
	},
	{
		"original_code": "// Base64Encoder.java\npackage org.scribe.services;\n\npublic abstract class Base64Encoder {\n\n    private static Base64Encoder instance;\n\n    public static synchronized Base64Encoder getInstance() {\n        if (instance == null) {\n            instance = createEncoderInstance();\n        }\n        return instance;\n    }\n\n    private static Base64Encoder createEncoderInstance() {\n        if (CommonsEncoder.isPresent()) {\n            return new CommonsEncoder();\n        } else {\n            return new DatatypeConverterEncoder();\n        }\n    }\n\n    public static String type() {\n        return getInstance().getType();\n    }\n\n    public abstract String encode(byte[] bytes);\n\n    public abstract String getType();\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/services/Base64EncoderTest0.java",
		"test_prompt": "// Base64EncoderTest0.java\npackage org.scribe.services;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Encoder}.\n* It contains ten unit test cases for the {@link Base64Encoder#getInstance()} method.\n*/\nclass Base64EncoderTest0 {"
	},
	{
		"original_code": "// Base64Encoder.java\npackage org.scribe.services;\n\npublic abstract class Base64Encoder {\n\n    private static Base64Encoder instance;\n\n    public static synchronized Base64Encoder getInstance() {\n        if (instance == null) {\n            instance = createEncoderInstance();\n        }\n        return instance;\n    }\n\n    private static Base64Encoder createEncoderInstance() {\n        if (CommonsEncoder.isPresent()) {\n            return new CommonsEncoder();\n        } else {\n            return new DatatypeConverterEncoder();\n        }\n    }\n\n    public static String type() {\n        return getInstance().getType();\n    }\n\n    public abstract String encode(byte[] bytes);\n\n    public abstract String getType();\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/services/Base64EncoderTest1.java",
		"test_prompt": "// Base64EncoderTest1.java\npackage org.scribe.services;\n\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link Base64Encoder}.\n* It contains ten unit test cases for the {@link Base64Encoder#type()} method.\n*/\nclass Base64EncoderTest1 {"
	},
	{
		"original_code": "// DatatypeConverterEncoder.java\npackage org.scribe.services;\n\nimport javax.xml.bind.*;\n\npublic class DatatypeConverterEncoder extends Base64Encoder {\n\n    @Override\n    public String encode(byte[] bytes) {\n        return DatatypeConverter.printBase64Binary(bytes);\n    }\n\n    @Override\n    public String getType() {\n        return \"DatatypeConverter\";\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/services/DatatypeConverterEncoderTest.java",
		"test_prompt": "// DatatypeConverterEncoderTest.java\npackage org.scribe.services;\n\nimport javax.xml.bind.*;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link DatatypeConverterEncoder}.\n* It contains ten unit test cases for the {@link DatatypeConverterEncoder#encode(byte[])} method.\n*/\nclass DatatypeConverterEncoderTest {"
	},
	{
		"original_code": "// CommonsEncoder.java\npackage org.scribe.services;\n\nimport org.apache.commons.codec.binary.*;\nimport org.scribe.exceptions.*;\nimport java.io.UnsupportedEncodingException;\n\npublic class CommonsEncoder extends Base64Encoder {\n\n    @Override\n    public String encode(byte[] bytes) {\n        try {\n            return new String(Base64.encodeBase64(bytes), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new OAuthSignatureException(\"Can't perform base64 encoding\", e);\n        }\n    }\n\n    @Override\n    public String getType() {\n        return \"CommonsCodec\";\n    }\n\n    public static boolean isPresent() {\n        try {\n            Class.forName(\"org.apache.commons.codec.binary.Base64\");\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/services/CommonsEncoderTest0.java",
		"test_prompt": "// CommonsEncoderTest0.java\npackage org.scribe.services;\n\nimport org.apache.commons.codec.binary.*;\nimport org.scribe.exceptions.*;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CommonsEncoder}.\n* It contains ten unit test cases for the {@link CommonsEncoder#encode(byte[])} method.\n*/\nclass CommonsEncoderTest0 {"
	},
	{
		"original_code": "// CommonsEncoder.java\npackage org.scribe.services;\n\nimport org.apache.commons.codec.binary.*;\nimport org.scribe.exceptions.*;\nimport java.io.UnsupportedEncodingException;\n\npublic class CommonsEncoder extends Base64Encoder {\n\n    @Override\n    public String encode(byte[] bytes) {\n        try {\n            return new String(Base64.encodeBase64(bytes), \"UTF-8\");\n        } catch (UnsupportedEncodingException e) {\n            throw new OAuthSignatureException(\"Can't perform base64 encoding\", e);\n        }\n    }\n\n    @Override\n    public String getType() {\n        return \"CommonsCodec\";\n    }\n\n    public static boolean isPresent() {\n        try {\n            Class.forName(\"org.apache.commons.codec.binary.Base64\");\n            return true;\n        } catch (ClassNotFoundException e) {\n            return false;\n        }\n    }\n}\n",
		"id": "GitHubDataBenchmark/Github_Data/scribejava/src/main/java/org/scribe/services/CommonsEncoderTest1.java",
		"test_prompt": "// CommonsEncoderTest1.java\npackage org.scribe.services;\n\nimport org.apache.commons.codec.binary.*;\nimport org.scribe.exceptions.*;\nimport java.io.UnsupportedEncodingException;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\n/**\n* Test class of {@link CommonsEncoder}.\n* It contains ten unit test cases for the {@link CommonsEncoder#isPresent()} method.\n*/\nclass CommonsEncoderTest1 {"
	}
]